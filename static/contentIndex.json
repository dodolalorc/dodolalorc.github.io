{"01-developer/index":{"slug":"01-developer/index","filePath":"01-developer/_index.md","title":"📔菜菜开发笔记","links":[],"tags":["intro","开发","Web前端","客户端","Electron","Chromium","Cpp"],"content":"目前在做的开发围绕前端Web网页、客户端开发、浏览器内核开发（Electron&amp;Chromium）。"},"01-developer/electronjs/index":{"slug":"01-developer/electronjs/index","filePath":"01-developer/electronjs/_index.md","title":"💡Electron学习笔记","links":[],"tags":["intro"],"content":"客户端开发、electron 及其上游学习记录"},"01-developer/electronjs/build_electron":{"slug":"01-developer/electronjs/build_electron","filePath":"01-developer/electronjs/build_electron.md","title":"Electron 构建记录 | 一条龙服务script","links":[],"tags":["Electron","Chromium"],"content":"\nSystem：Windows 11\nPython：Python 3.13.3\nnode：v22.14.0\nnpm：10.9.2\nyarn：1.22.22\n足够的磁盘空间和流量：源代码一套（chromium+electron）大约 70G，预留构建内核的内存空间，一共保留 200G 比较好\n\n初始化环境\nElectron  是嵌入  Chromium  和  Node.js  到 二进制进行开发，所以在构建Electron时显然也要准备这两者的开发环境。\nChromium 开发工具\n参考Chromium 此页拉取depot_tools。\n拉取完毕之后，将depot_tools的路径加入到系统变量path中，并将变量位置上移到至少git变量之前。\ndepot_tools需要本机安装了Git for Windows，以及python 3.8。\n识别不到安装的git\n报错信息：\n$ gclient --version\nUpdating depot_tools...\nWARNING:root:depot_tools will stop bundling Git for Windows on 2025-01-27.\nTo prepare for this change, please install Git directly. See\nchromium.googlesource.com/chromium/src/+/main/docs/windows_build_instructions.md#Install-git\n \nHaving issues and not ready for depot_tools to stop bundling\nGit for Windows? File a bug at:\nissues.chromium.org/issues/new\n \nERROR:root:Failed to bootstrap depot_tools.\nGit was not found in PATH. Have you installed it?\n本机使用Scoop安装大部分的软件，难过的是通过这样下载的git无法被depot_tools工具识别，只能卸载本机当前的git后在git重新下载一遍，之后gclient。\nElectron build-tools\n本篇使用的脚本是Electron build-tools，傻瓜一站式拉取不用管任何版本或分支。\n\n注意需要安装好 yarn 等工具：npm i -g yarn\n\n按照 readme 的提示安装：\nnpm i -g @electron/build-tools\n在本机找好存放源码的位置后，进行：\ne init --root=~/electron --bootstrap testing\n--root=~/electron是拉取的时候想要存源码的位置，如果留空则在当前路径下，建议选择合适的磁盘。\n识别不到命令\n在e init ...命令执行到一半，发现中断在某处，重新进行e sync -f后，出现找不到 npm 命令的反馈。\n$ e sync -f\nChecking for build-tools updates\n&#039;npm&#039; 不是内部或外部命令，也不是可运行的程序或批处理文件\n&#039;npx&#039; 不是内部或外部命令，也不是可运行的程序或批处理文件\n进行拉取时，脚本在执行到大约python script/lib/npx.py yarn@1.15.2 install --frozen-lockfile的时候发生了报错，称FileNotFoundError: [WinError 2]，导致ERROR gclient sync failed失败。\n仔细阅读日志之后，先在命令行直接执行上述脚本语句，发现运行是正常的，同时想的本机在平时开发使用 python、node.js 均没有出现找不到命令的问题，且实验当时在命令行测试node -v、yarn --version和npm -v都有版本返回，排错查看环境变量path也有正确设置。\n本机使用了 node.js 版本管理工具fnm，继而想到或许需要激活 node 环境，于是先运行了fnm use v22，发现继续的拉取依然有问题，想到或许是通过fnm设置的临时环境会不被识别，于是选择直接在 node.js 官网下载一个合适的版本，这样操作之后能成功运行完毕。\n不太确定nvm会不会也有这样的问题，但是插个眼，解决方法还是比较简单的。\n\nupdate：Mac 上没有这个问题捏\n\n构建\n附一张成功拉取的截图(嘻嘻)\n\n在进行e build之后，初次构建需要鉴权，点击命令行提示的网址操作一下就好啦~\n然后就是继续泡 n 杯咖啡等待构建。\n构建成功之后的结果会存在./src/out/..目录下，在命令行执行：\ne start\n可以在命令行看到当前构建出的Electron信息，以及弹出的窗口。\n\n根据提示的命令启动本地的 electron demo\n\n合影 😗"},"01-developer/electronjs/custom_electron_demo":{"slug":"01-developer/electronjs/custom_electron_demo","filePath":"01-developer/electronjs/custom_electron_demo.md","title":"自定义Electron.exe的使用","links":["posts/build_electron/"],"tags":["前端","Electron","Chromium"],"content":"初始化环境可以阅读这篇。\n上接之前的构建过程，经过第一次构建之后，后续修改源码添加 api 等都不会再构建那么久了。\n添加简单的 API\n当前目录在构建时相同的目录下，其下包含src、.gclient、node_modules等。\n找到src/electron目录，在lib/browser/api/app.ts添加：\napp.getElectronVersion = () =&gt; { // This is for test\n  return &#039;dodola test demo&#039; + process.versions.electron;\n};\n再到electron.d.ts中更新添加：\ndeclare namespace Electron {\n  const NodeEventEmitter: typeof import(&#039;events&#039;).EventEmitter;\n \n  type Accelerator = string;\n  type Event&lt;Params extends object = {}&gt; = {\n    preventDefault: () =&gt; void;\n    readonly defaultPrevented: boolean;\n  } &amp; Params;\n \n  interface App extends NodeJS.EventEmitter {\n    getElectronVersion(): string; // This is for test\n...\n然后在命令行重新构建一遍：\ne build\nINFO Auto-updates disabled - skipping update check\nRunning &quot;autoninja.bat -j 200 electron&quot; in D:\\playground\\Projects\\electron-coins\\electron\\src\\out\\Testing\nProxy started successfully.\n[4/4] LINK electron.exe electron.exe.pdb\nRBE Stats: down 0 B, up 0 B, 1 local fallback\n这样就准备好了测试用的自定义 electron 啦\n测试 demo\n找到一个测试用的小 electron demo，可以参考Electron 教程。\n修改启动命令\n在package.json中修改启动脚本start的部分，原来是electron .启动，将electron改为构建的electron.exe路径：\n{\n  &quot;name&quot;: &quot;electron-demo&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;main&quot;: &quot;main.js&quot;,\n  &quot;scripts&quot;: {\n    &quot;start&quot;: &quot;chcp 65001 &amp;&amp;  ..\\\\electron\\\\src\\\\out\\\\Testing\\\\electron.exe .&quot;,\n    &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;\n  },\n  &quot;author&quot;: &quot;dodola&quot;,\n  &quot;license&quot;: &quot;MIT&quot;,\n  &quot;devDependencies&quot;: {\n    &quot;electron&quot;: &quot;^35.2.0&quot;\n  }\n}\n\n\n                  \n                  不重要的小说明 \n                  \n                \n\n\nchcp 65001只是为了在命令行中能够正常显示中文字符用的\n\n\n\n调用 Api\n在main.js中添加 console.log 语句：\nconsole.log(`Custom Electron version: ${app.getElectronVersion()}`)\n之后正常启动测试的项目即可：\nnpm start\n可以看到命令行对应的输出：\n\n小 demo 的代码\nmain.js\nconst { app, BrowserWindow, ipcMain } = require(&#039;electron/main&#039;)\nconst path = require(&#039;node:path&#039;)\nconst { dialog } = require(&#039;electron/main&#039;)\n \nlet mainWindow;\nconst createWindow = () =&gt; {\n  mainWindow = new BrowserWindow({\n    width: 1000,\n    height: 800,\n    title: &#039;Just a little demo&#039;,\n    icon: path.join(__dirname, &#039;icon.png&#039;),\n    webPreferences: {\n      contextIsolation: true,\n      preload: path.join(__dirname, &#039;preload.js&#039;)\n    }\n  })\n  mainWindow.setMenu(null)\n  mainWindow.loadFile(&#039;index.html&#039;)\n \n  let wc = mainWindow.webContents;\n \n  // wc.openDevTools();\n \n  wc.on(&#039;dom-ready&#039;, (e) =&gt; {\n    dialog.showMessageBox(options = {\n      title: &#039;Hello&#039;,\n      message: &#039;This is a message box&#039;,\n    }).then((result) =&gt; {\n      console.log(result);\n    });\n  });\n}\n \n \napp.whenReady().then(() =&gt; {\n  ipcMain.handle(&#039;ping&#039;, () =&gt; &#039;pong&#039;);\n \n  createWindow();\n  mainWindow.maximize();\n \n  app.on(&#039;activate&#039;, () =&gt; {\n    if (BrowserWindow.getAllWindows().length === 0) createWindow()\n  })\n})\n \napp.on(&#039;window-all-closed&#039;, () =&gt; {\n  if (process.platform !== &#039;darwin&#039;) app.quit()\n});\n \nconsole.log(`Custom Electron version: ${app.getElectronVersion()}`)\npreload.js\nconst { contextBridge, ipcRenderer } = require(&#039;electron/renderer&#039;)\n \ncontextBridge.exposeInMainWorld(&#039;versions&#039;, {\n  node: () =&gt; process.versions.node,\n  chrome: () =&gt; process.versions.chrome,\n  electron: () =&gt; process.versions.electron,\n  ping: () =&gt; ipcRenderer.invoke(&#039;ping&#039;)\n})\nrenderer.js\nconst information = document.getElementById(&#039;info&#039;)\ninformation.innerText = `This app is using Chrome (v${window.versions.chrome()}), Node.js (v${window.versions.node()}), and Electron (v${window.versions.electron()})`;\n \nconst pingButton = document.getElementById(&#039;ping&#039;);\nconst pingMsg = document.getElementById(&#039;ping-msg&#039;);\npingButton.addEventListener(&#039;click&#039;, () =&gt; {\n  window.versions.ping().then((response) =&gt; {\n    console.log(response) // prints out &#039;pong&#039;\n    pingMsg.innerText = response\n  })\n})\nindex.html\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n \n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot; /&gt;\n  &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;default-src &#039;self&#039;; script-src &#039;self&#039;&quot; /&gt;\n  &lt;meta http-equiv=&quot;X-Content-Security-Policy&quot; content=&quot;default-src &#039;self&#039;; script-src &#039;self&#039;&quot; /&gt;\n&lt;/head&gt;\n \n&lt;body&gt;\n  &lt;h1&gt;Hello from Electron renderer!&lt;/h1&gt;\n  &lt;p&gt;👋&lt;/p&gt;\n  &lt;p id=&quot;info&quot;&gt;&lt;/p&gt;\n  &lt;button id=&quot;ping&quot;&gt;ping&lt;/button&gt;\n  &lt;p&gt;Message from ping is: &lt;span id=&quot;ping-msg&quot;&gt;&lt;/span&gt;&lt;/p&gt;\n&lt;/body&gt;\n&lt;script src=&quot;./renderer.js&quot;&gt;&lt;/script&gt;\n \n&lt;/html&gt;"},"01-developer/frontend/8part_essay":{"slug":"01-developer/frontend/8part_essay","filePath":"01-developer/frontend/8part_essay.md","title":"前端八股文小题集合","links":[],"tags":["前端八股文"],"content":"Vue2 和 Vue3 区别\n性能优化\n\n\nVue 3：通过重写虚拟 DOM 和优化编译器，性能显著提升，渲染速度更快，内存占用更少。\n\n\nVue 2：性能较好，但不如 Vue 3。\nComposition API\n\n\nVue 3：引入了 Composition API，允许开发者按逻辑组织代码，提升复杂组件的可维护性。\n\n\nVue 2：主要使用 Options API，代码组织方式相对固定。\n响应式系统\n\n\nVue 3：使用 Proxy 实现响应式系统，支持更多数据类型，性能更好。\n\n\nVue 2：使用 Object.defineProperty，存在一些局限性，如无法检测数组和对象的变化。\nTypeScript 支持\n\n\nVue 3：内置 TypeScript 支持，类型推断更完善。\n\n\nVue 2：对 TypeScript 的支持较弱，类型推断不够完善。\nFragment 和 Teleport\n\n\nVue 3：支持 Fragment（多根节点组件）和 Teleport（将组件渲染到 DOM 其他位置）。\n\n\nVue 2：不支持这些特性。\n\n\n全局 API 更改\n\nVue 3：全局 API 改为按需导入，减少打包体积。\nVue 2：全局 API 通过 Vue 对象访问。\n\n生命周期钩子\n\n\nVue 3：部分生命周期钩子更名（如 beforeDestroy 改为 beforeUnmount），并新增了 setup 函数。\n\n\nVue 2：使用传统的生命周期钩子。\n自定义渲染器\n\n\nVue 3：支持自定义渲染器，适用于非 DOM 环境（如小程序、Canvas）。\n\n\nVue 2：不支持自定义渲染器。\nSuspense\n\n\nVue 3：支持 Suspense，用于处理异步组件加载。\n\n\nVue 2：不支持 Suspense。\n\n\n打包体积\n\nVue 3：通过 Tree-shaking 优化，打包体积更小。\nVue 2：打包体积相对较大。\n\nVue 3 在性能、开发体验和灵活性上都有显著提升，尤其是 Composition API 和响应式系统的改进。对于新项目，推荐使用 Vue 3；对于现有 Vue 2 项目，可以根据需求逐步迁移。\nJavaScript 和 TypeScript\nTypeScript 和 JavaScript 是两种常用的编程语言，它们的主要区别和优点如下：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n对比项JavaScriptTypeScript类型系统动态类型语言，变量在运行时确定静态类型语言，支持类型注解，类型检查在编译时进行。编译直接由浏览器或 Node.js 执行，无需编译。需要编译为 JavaScript 后才能运行。工具支持工具支持较少，尤其在大型项目中。提供更好的开发工具支持，如代码补全、类型检查、重构等。兼容性所有 JavaScript 代码都可在 TypeScript 中运行。编译后的代码与 JavaScript 完全兼容。学习曲线学习曲线较平缓，适合初学者。需要掌握类型系统等额外概念，学习曲线稍陡。社区生态社区庞大，资源丰富。社区增长迅速，尤其在大型项目中应用广泛。适用场景适合小型项目或快速原型开发。适合大型项目，尤其是需要长期维护的复杂应用。优点无需编译，开发流程简单。学习门槛低，适合初学者。社区资源丰富，生态成熟。静态类型检查减少运行时错误。更好的工具支持提升开发效率。增强代码可读性和可维护性。支持最新的 JavaScript 特性。总结适合大型项目，提供更强的类型检查和工具支持。适合小型项目或快速开发，学习成本低。\n代码：千分位逗号\nlet num = 1234567.89;  \nlet formattedNum = num.toLocaleString(&#039;en-US&#039;);  \nconsole.log(formattedNum);  // 输出 &quot;1,234,567.89&quot;\n代码：手写深浅拷贝\n浅拷贝只会复制对象的顶层属性和值，如果属性值是对象或数组，那么它实际上只是复制了引用，而不是真正的对象。\n而深拷贝则会递归地复制对象的所有层级，确保所有的对象或数组都被真正复制，而不是仅复制引用。\n浅拷贝\nfunction shallowCopy(obj) {\n    if (typeof obj !== &#039;object&#039; || obj === null) {\n        return obj;\n    }\n    return Object.assign({}, obj);  // Object浅拷贝\n}\n \nconst original = { a: 1, b: { c: 2 } };\nconst copied = shallowCopy(original);\nconsole.log(copied);\n深拷贝\nfunction deepCopy(obj, hash = new WeakMap()) {\n\t// 使用了`WeakMap`来存储已经复制过的对象\n    if (typeof obj !== &#039;object&#039; || obj === null) {\n        return obj;\n    }\n \n    // 日期\n    if (obj instanceof Date) {\n        return new Date(obj);\n    }\n    // 正则\n    if (obj instanceof RegExp) {\n        return new RegExp(obj);\n    }\n \n    let newObj = Array.isArray(obj) ? [] : {};\n    hash.set(obj, newObj);\n \n    for (let key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            newObj[key] = deepCopy(obj[key], hash); // 递归进行拷贝\n        }\n    }\n \n    return newObj;\n}\n代码：手写 New 方法\nfunction myNew(constructor, ...args) {\n    const obj = {};\n    obj.__proto__ = constructor.prototype;\n    const result = constructor.apply(obj, args);\n    // 如果构造函数返回一个对象，则返回，否则返回新创建的对象\n    return result instanceof Object ? result : obj;\n}\n \nfunction Person(name, age) {\n    this.name = name;\n    this.age = age;\n}\n \nPerson.prototype.greet = function () {\n    console.log(`Hello, I&#039;m ${this.name} and I&#039;m ${this.age} years old.`);\n}\n \nconst person = myNew(Person, &#039;Alice&#039;, 12);\nconsole.log(person.name);\nconsole.log(person.age);\nperson.greet();\n代码：手写函数柯里化\nfunction curry(fn) {\n    if (typeof fn !== &#039;function&#039;) {\n        return new Error(&#039;Type Error&#039;);\n    }\n    return function curried(...args) {\n        if (args.length &gt;= fn.length) {    // 如果参数数量足够，则执行\n            return fn.apply(this, args);\n        }\n        return function (...args2) {\n            return curried.apply(this, args.concat(args2));\n        }\n    }\n}\n \nfunction sum(a, b, c) {\n    return a + b + c;\n}\n \nconst curriedSum = curry(sum);\n \nconsole.log(curriedSum(1)(2)(3));\nconsole.log(curriedSum(1, 2)(3));\n代码：实现 AJAX 请求，使用 Promise 封装 AJAX 请求\nfunction ajaxRequest(url, method = &#039;GET&#039;, data = null) {\n    return new Promise((resolve, reject) =&gt; {\n        const xhr = new XMLHttpRequest();\n        xhr.open(method, url, true);\n        if (method == &#039;POST&#039;) {\n            xhr.setRequestHeader(&#039;Content-Type&#039;, &#039;application/x-www-form-urlencoded&#039;);\n        }\n \n        xhr.onload = function () {\n            if (this.status === 200) {\n                resolve(this.responseText);\n            } else {\n                reject(new Error(this.statusText));\n            }\n        };\n \n        xhr.onerror = function () {\n            reject(new Error(&#039;Network Error&#039;));\n        }\n \n        if (data) {\n            xhr.send(data);\n        } else {\n            xhr.send();\n        }\n    })\n}\n \najaxRequest(\n    &#039;api.example.com/data&#039;, &#039;GET&#039;).then(response =&gt; {\n        console.log(response);\n    }).catch(error =&gt; {\n        console.error(&#039;Error:&#039;, error);\n    });"},"01-developer/frontend/index":{"slug":"01-developer/frontend/index","filePath":"01-developer/frontend/_index.md","title":"🍍Web前端菜菜笔记","links":[],"tags":["intro","开发","Web前端"],"content":"其实是预备面试时准备的许多八股文。"},"01-developer/frontend/cart_page_sample":{"slug":"01-developer/frontend/cart_page_sample","filePath":"01-developer/frontend/cart_page_sample.md","title":"购物车页面制作教程（包含分页设计）","links":[],"tags":["前端"],"content":"\n\n                  \n                  为什么有这篇低质量文章 \n                  \n                \n\n\n这篇文章用于2024年蓝旭暑期项目前的培训作业教学，目的是从零开始构建一个购物车页面，以此来熟悉原生前端三件套。o((&gt;ω&lt; ))o\n\n\n\n需求分析\n功能要求：\n\n\n全选、单选联动逻辑（包括依次选中所有物品时自动勾选全选按钮、勾选全选时勾选所\n有单选、取消全选后取消所有选中等）、结算小项总价以及整体总价。\n\n\n展示商品图片、名称、价格、数量等基础信息。\n\n\n体现分页展示购物车内商品内容。\n\n\n可以对购物车内商品进行增删改，即改变数量、结算商品、删除商品（结合分页显示数\n目合理调整）等。\n\n\n美观的页面效果。\n\n\n加分功能\n\n\n实现在购物车页面查找商品的功能。\n\n\n自己写一个弹出提示框，在删除商品、结算商品等行为后与用户进行确认交互。\n\n\n页面布局\n整体布局\n整个购物车页面有三个主要功能：列表、结算、分页。\n购物车页面的布局主要分为两部分：购物车列表和结算栏。\n购物车列表是购物车页面的主体部分，用于展示用户购物车中的商品信息，我们将整个列表设计在整个页面的中部，在顶部设计一个nav用于展示购物车的标题，以及作为之后的路由跳转的位置，这个nav设计成吸顶。\n中间主体部分是购物车列表，用于展示用户购物车中的商品信息。\n底部我设计为结算栏，用于展示用户当前选中的总价，以及结算按钮。\n分页的位置我设计在购物车列表之上，并且把它设计成向下滑动时吸顶的设计，这样用户在浏览商品时可以随时翻页。\n于是整体的设计如下：\n&lt;body&gt;\n  &lt;div class=&quot;shell&quot;&gt;\n    &lt;nav&gt;\n      {/* 用来设计路由栏 */}\n      &lt;img class=&quot;nav-item&quot; src=&quot;www.coca-cola.com/content/dam/onexp/cn/zh/logos/coke-header.png&quot; alt=&quot;&quot;&gt;\n      &lt;div class=&quot;nav-item&quot;&gt;购物车&lt;/div&gt;\n      &lt;div class=&quot;nav-item&quot;&gt;订单&lt;/div&gt;\n      &lt;div class=&quot;nav-item&quot;&gt;我的&lt;/div&gt;\n    &lt;/nav&gt;\n \n    &lt;main&gt;\n      &lt;div class=&quot;title-div&quot;&gt;\n        &lt;div class=&quot;title&quot;&gt;当前选中1样商品&lt;/div&gt;\n        &lt;div class=&quot;pagination&quot;&gt;\n          &lt;div class=&quot;page&quot;&gt;1&lt;/div&gt;\n          {/* 页码 */}\n          &lt;div class=&quot;page&quot;&gt;n&lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n      &lt;div class=&quot;container&quot;&gt;\n        &lt;div class=&quot;cart-item&quot;&gt;\n          {/* 详细的购物车内商品信息 */}\n        &lt;/div&gt;\n        &lt;div class=&quot;cart-item&quot;&gt;\n          {/* 详细的购物车内商品信息 */}\n        &lt;/div&gt;\n        {/* .... */}\n      &lt;/div&gt;\n    &lt;/main&gt;\n \n    &lt;footer&gt;\n      &lt;div class=&quot;sum-foot&quot;&gt;\n        {/* 展示全选按钮和结算信息 */}\n      &lt;/div&gt;\n    &lt;/footer&gt;\n  &lt;/div&gt;\n&lt;/body&gt;\n\n\n                  \n                  关于吸顶和吸底的设计 \n                  \n                \n\n\n设计吸顶和吸底的时候，我们可以使用position: sticky属性，这个属性可以让元素在滚动到特定位置时固定在页面上，这样可以让用户在浏览页面时更加方便。\n\n\n\n购物车列表设计\n购物车列表的设计主要是展示购物车内的商品信息，我们需要展示商品的图片、名称、价格、数量等基础信息，我们把每个商品信息设计成一个卡片，之后我们可以通过js动态生成这些卡片。\n这是我设计的一个商品卡片的结构：\n&lt;div class=&quot;cart-item&quot;&gt;\n  &lt;input type=&quot;radio&quot;&gt;  {/* 单选按钮 */}\n  &lt;img src=&quot;&quot; alt=&quot;&quot;&gt;   {/* 商品图片 */}\n  &lt;div class=&quot;item-info&quot;&gt;\n    &lt;h2&gt;{/* 商品名称 */}&lt;/h2&gt;\n    &lt;div class=&quot;info&quot;&gt;\n      &lt;div class=&quot;desp&quot;&gt;\n        {/* 商品描述 */}\n      &lt;/div&gt;\n      &lt;div class=&quot;detail&quot;&gt;\n        &lt;div class=&quot;price&quot;&gt;{/* 价格 */}&lt;/div&gt;\n        &lt;div class=&quot;quantity&quot;&gt;\n          {/* 数量 */}\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  &lt;/div&gt;\n  &lt;button class=&quot;del-btn&quot;&gt;删除&lt;/button&gt;\n&lt;/div&gt;\n这是我的CSS样式：\n.cart-item {\n    height: fit-content;\n    width: 80%;\n    margin-bottom: 1rem;\n    padding: 1rem;\n    background-color: rgba(255, 255, 255, 0.25);\n    backdrop-filter: blur(6px);\n    -webkit-backdrop-filter: blur(6px);\n    border: 0.666667px solid rgba(255, 255, 255, 0.18);\n    box-shadow: rgba(142, 142, 142, 0.19) 0px 6px 15px 0px;\n    -webkit-box-shadow: rgba(142, 142, 142, 0.19) 0px 6px 15px 0px;\n    border-radius: 12px;\n    -webkit-border-radius: 12px;\n \n    display: flex;\n    flex-direction: row;\n    justify-content: space-between;\n}\n \n.cart-item input[type=&quot;radio&quot;] {\n    margin-top: 1rem;\n    margin-right: 1rem;\n    cursor: pointer;\n    width: 1.5rem;\n}\n \n.cart-item img {\n    width: 160px;\n    height: 160px;\n    border-radius: 12px;\n    -webkit-border-radius: 12px;\n    box-shadow: rgba(142, 142, 142, 0.19) 0px 6px 15px 0px;\n}\n \n.cart-item .item-info {\n    flex: 1;\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n    /* align-items: center; */\n    margin-left: 1rem;\n}\n \n.cart-item .info {\n    display: flex;\n    flex-direction: row;\n    justify-content: space-between;\n \n    .desp {\n        flex: 3;\n    }\n \n    .detail {\n        flex: 1;\n        margin: 0 1rem;\n        background-color: #dddddd94;\n        border-radius: 12px;\n        backdrop-filter: blur(6px);\n        -webkit-backdrop-filter: blur(6px);\n        display: flex;\n        flex-direction: column;\n        justify-content: space-around;\n        padding: 0.5rem;\n \n        .price {\n            font-size: large;\n            font-weight: bold;\n            display: flex;\n \n            span {\n                flex: 1;\n                display: flex;\n                justify-content: space-around;\n                align-items: center;\n            }\n        }\n \n        .quantity {\n            font-size: medium;\n            font-weight: bold;\n            display: flex;\n \n            span {\n                flex: 1;\n                display: flex;\n                justify-content: space-around;\n                align-items: center;\n            }\n        }\n    }\n}\n \n \n.cart-item .del-btn {\n    background-color: #f8f9fa;\n    border: none;\n    color: red;\n    font-size: large;\n    font-weight: bold;\n    cursor: pointer;\n    margin-top: 1rem;\n}\n \n.cart-item .del-btn:hover {\n    color: #007bff;\n}\nCSS解释\n像上面这样直接甩出一堆代码，感觉会看起来有点懵，不过一条条的讲CSS会有点枯燥，这里稍微解释一下整体的设计想法。\n我比较习惯使用flex布局，所以整个卡片的设计都是基于flex布局的，首先整个卡片是一个flex容器，里面有四个部分：单选按钮、商品图片、商品信息、删除按钮。按照这个顺序，我将他们横向排列，分别占据不同的比例。\n\n\n                  \n                  在flex布局中让内部元素水平垂直居中，并且间隔合适的技巧 \n                  \n                \n\n\n在flex布局中，我们可以通过justify-content和align-items来控制元素的水平和垂直居中，通过margin来控制元素之间的间隔。\n其中justify-content用于控制元素在主轴上的排列方式，align-items用于控制元素在交叉轴上的排列方式。\n.div {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\njustify-content除了center之外还有flex-start、flex-end、space-between、space-around等属性，align-items除了center之外还有flex-start、flex-end、baseline、stretch等属性，是很方便的布局方式，可以节省大量之前需要通过不断调整margin来实现的布局。具体区别可以在justify-content和align-items在线演示。\n\n\n\n我固定了单选按钮、商品图片、删除按钮的大小，商品信息部分占据了剩下的空间。\n商品信息部分又分为两个部分：商品描述和商品价格，我将他们分别占据了不同的比例，使得整个卡片看起来比较美观。\n\n\n                  \n                  在flex布局中让内部元素占据不同的比例 \n                  \n                \n\n\n上面的justify-content和align-items更倾向于把元素均匀排列，有时候我们也需要让元素分别占据不同的比例，这时候我们可以试试通过flex属性来控制元素。\n例如上面的代码中，我通过flex: 3和flex: 1来控制商品描述和商品价格分别占据了3:1的比例。这样的写法相比较于width属性更加灵活，可以根据不同的屏幕大小自动调整。就像下面这样：\n.cart-item .info {\n    display: flex;\n    flex-direction: row;\n    justify-content: space-between;\n \n    .desp {\n        flex: 3;\n    }\n \n    .detail {\n        flex: 1;\n        display: flex;\n        flex-direction: column;\n        justify-content: space-around;\n \n        .price {\n            span {\n                flex: 1;\n            }\n        }\n \n        .quantity {\n            span {\n                flex: 1;\n            }\n        }\n    }\n}\n \n\n\n\n图标库\n相信大家看完图片之后发现，我在价格和数量的部分的加号减号按钮，以及￥符号看起来不像原生的按钮和字符，这里我使用了font-awesome图标库，这是一个很好用的图标库，在美化页面的时候我们其实会尝试使用很多图标，我比较喜欢的两个图标库是Font awesome和iconfont，大家可以尝试使用，使用方法大家可以自行学习，这里我就不再赘述了。\n在线工具推荐\n有些同学可能不太擅长调整出好看的盒子，这里我推荐一个好用的前端工具在线网站：{{&lt;link “lingdaima.com/”&gt;}} ，可以帮助你快速调整出好看的CSS样式。\n当然了，在线工具只是起到一个辅助作用，调整CSS的时候还是需要自己多尝试，多调整，多看看效果。大家不要过分依赖哦(‾◡◝)\n这里是整体设计完Html结构和CSS之后的效果：\n\n这个页面的效果是我自己设计的，大家可以根据自己的喜好进行调整，这里只是提供一个参考，相应的源码我也会公开放在我的gitee上，大家可以自行下载，仓库的地址在文末。\nJavaScript逻辑\n我比较习惯在设计完页面之后再写JavaScript逻辑，这样可以更好的理清思路，而且不需要总是再次调整Html和CSS。在设计完页面之后，我们通过让这个页面不再是一个静态的页面，而是一个可以动态交互的页面。\n\n\n                  \n                  通过本地json来获得数据和渲染数据&quot; \n                  \n                \n\n\n由于这个只是用于前端学习的小项目，我们没有接口，不过在生成应用中，页面的数据是来自后端传递而来的（往往是一个json），所以在这个项目中，我们可以通过本地的json文件来模拟后端返回的数据，这样可以更好的模拟真实的购物车页面，同时也可以更好的理解前后端的交互。\n引入json文件的方法是通过fetch方法，这是一个异步方法，我们可以通过这个方法来获取json文件，然后通过json()方法来解析json文件。\n就像这样：\nfetch(&#039;data.json&#039;)\n  .then(response =&gt; response.json())\n  .then(data =&gt; console.log(data));\n\n\n\nJS逻辑\n为了方便管理数据，我将数据保存在一个全局变量中，这样可以更好的操作数据，下文的代码中，我会使用这些全局变量来操作数据。\nvar goods = []; // 当前页的商品列表\nvar totItems = 0; // 总商品数\nvar curPage = 1; // 当前页码\nvar totPages = 1; // 总页数\n \nvar selectTotal = 0; // 选中商品总数\nvar curSelectGoods = [];  // 选中的商品列表\nvar selectAllStatus = false;  // 是否全选\n数据获取与渲染\n首先我们需要通过fetch方法来获取json文件，然后通过json()方法来解析json文件，这样我们就可以得到一个json对象，这个对象就是我们的商品信息。\n \nfetch(&#039;data.json&#039;)\n  .then(response =&gt; response.json())\n  .then(data =&gt; {\n    console.log(data);\n    render(data);\n  });\n \n获取数据之后，我们设置全局变量来保存当前的数据状态，然后将数据渲染到页面上，就像这样：\nconst renderCartList = () =&gt; {\n  const goodsContainer = document.querySelector(&#039;#container&#039;);\n  goodsContainer.innerHTML = &#039;&#039;;\n  if (goods.length === 0 &amp;&amp; totItems !== 0) {\n    // 如果购物车本页没有商品（通过删除删空的情况或意外情况），应该重新请求数据，初始化购物车\n    initGoods();\n  }\n  else if (totItems === 0) { \n    // 如果购物车没有商品，应该显示空购物车\n    goodsContainer.innerHTML = &#039;&lt;div class=&quot;empty-cart&quot;&gt;购物车为空`(*&gt;﹏&lt;*)′&lt;/div&gt;&#039;;\n    return;\n  }\n  for (let i = 0; i &lt; goods.length; i++) {\n    const good = goods[i];\n    const cartItem = document.createElement(&#039;div&#039;);\n    cartItem.classList.add(&#039;cart-item&#039;);\n    cartItem.setAttribute(&#039;id&#039;, &quot;item-&quot; + good[&quot;id&quot;]);\n    cartItem.innerHTML = `&lt;input type=&quot;checkbox&quot; onClick=&quot;selectGood(${good[&quot;id&quot;]})&quot;&gt;\n          &lt;img src=&quot;${good[&quot;image&quot;]}&quot; alt=&quot;&quot;&gt;\n          &lt;div class=&quot;item-info&quot;&gt;\n            &lt;h2&gt;商品名称：${good[&quot;name&quot;]}&lt;/h2&gt;\n            &lt;div class=&quot;info&quot;&gt;\n              &lt;div class=&quot;desp&quot;&gt;\n                商品描述：&lt;span&gt;${good[&quot;description&quot;]}&lt;/span&gt;\n              &lt;/div&gt;\n              &lt;div class=&quot;detail&quot;&gt;\n                &lt;div class=&quot;price&quot;&gt;单价：&lt;span&gt;&lt;i class=&quot;fa-solid fa-yen-sign&quot;&gt;&lt;/i&gt;\n                  &lt;span&gt;${good[&quot;price&quot;].toFixed(2)}&lt;/span&gt;\n                &lt;/span&gt;&lt;/div&gt;\n                &lt;div class=&quot;price&quot;&gt;小计：&lt;span&gt;&lt;i class=&quot;fa-solid fa-yen-sign&quot;&gt;&lt;/i&gt;\n                  &lt;span class=&quot;tot-price&quot;&gt;${(good[&quot;price&quot;] * good[&quot;quantity&quot;]).toFixed(2)}&lt;/span&gt;\n                &lt;/span&gt;&lt;/div&gt;\n                &lt;div class=&quot;quantity&quot;&gt;\n                  数量：\n                  &lt;span class=&quot;count&quot;&gt;\n                    &lt;i class=&quot;fa-solid fa-circle-minus&quot; onClick=&quot;changeQuantity(${good[&quot;id&quot;]}, -1)&quot;&gt;&lt;/i&gt;\n                    &lt;span&gt;${good[&quot;quantity&quot;]}&lt;/span&gt;\n                    &lt;i class=&quot;fa-solid fa-circle-plus&quot; onClick=&quot;changeQuantity(${good[&quot;id&quot;]}, 1)&quot;&gt;&lt;/i&gt;\n                  &lt;/span&gt;\n                &lt;/div&gt;\n              &lt;/div&gt;\n            &lt;/div&gt;\n          &lt;/div&gt;\n          &lt;button class=&quot;del-btn&quot; onClick=&quot;delItem(${good[&quot;id&quot;]})&quot;&gt;删除&lt;/button&gt;`;\n    goodsContainer.appendChild(cartItem);\n  }\n}\n注意到，在上述代码中，我为每一个cart-item添加了一个唯一的id属性，这个属性是用于标识每一个商品的，这样我们在之后的操作中可以通过这个id属性来找到对应的商品。\n\n\n                  \n                  关于唯一标识符 \n                  \n                \n\n\n在实际的项目中，我们往往需要为每一个商品添加一个唯一的标识符，这个标识符可以是商品的id，也可以是其他的唯一标识符，这样可以更好的操作商品，例如删除商品、修改商品数量等。\n\n\n\n\n\n                  \n                  过滤错误数据&quot; \n                  \n                \n\n\n在实际的项目中，我们往往会遇到一些错误的数据，例如商品数量为负数或者小数、商品价格为负数等，这些数据是不符合实际的，我们需要在获取数据之后对这些数据进行过滤，这样可以保证数据的正确性。\n如果数据量比较大，我们也会选择使用filter方法来过滤数据。\n\n\n\n\n\n                  \n                  图片加载失败时 \n                  \n                \n\n\n在实际的项目中，我们往往会遇到一些图片加载失败的情况，这时候我们可以通过onerror事件来监听图片加载失败的情况，然后通过一些方法来处理这种情况，例如显示一个默认图片、显示一个提示信息等。\n\n\n\n改变商品数量\n修改商品数量是通过点击+和-按钮来实现的，我们可以通过onClick事件来监听这两个按钮的点击事件，然后通过changeQuantity函数来改变商品的数量。\n在修改商品数量的时候，我们需要注意一些边界条件，例如商品数量不能为负数，商品数量不能超过库存（本篇的demo没有考虑这个库存上限）等，考虑到加操作和减操作的逻辑是一样的，我们可以通过传入一个参数来判断是加还是减，以减少代码的重复。\n以下是我的changeQuantity函数：\nconst changeQuantity = (id, cnt) =&gt; {\n  const item = document.querySelector(&#039;#item-&#039; + id);\n  const count = item.querySelector(&#039;.count span&#039;);\n  const price = item.querySelector(&#039;.tot-price&#039;);\n  const quantity = parseInt(count.innerHTML);\n  if (quantity + cnt &lt;= 0) {\n    delItem(id);\n    return;\n  }\n  count.innerHTML = quantity + cnt;\n  price.innerHTML = (parseFloat(price.innerHTML) + cnt * goods.find(good =&gt; good[&quot;id&quot;] === id)[&quot;price&quot;]).toFixed(2);\n  // 这里应该发送请求修改数据，这里只是模拟，直接修改\n  goods = goods.map(good =&gt; {\n    if (good[&quot;id&quot;] === id) {\n      good[&quot;quantity&quot;] = quantity + cnt;\n    }\n    return good;\n  });\n  if (curSelectGoods.find(good =&gt; good[&quot;id&quot;] === id)) {\n    selectTotal += cnt;\n    curSelectGoods = curSelectGoods.map(good =&gt; {\n      if (good[&quot;id&quot;] === id) {\n        good[&quot;price&quot;] = parseFloat(price.innerHTML);\n      }\n      return good;\n    });\n    updateTotalCount(); // 更新总价\n  }\n}\n删除商品\n删除商品是通过点击删除按钮来实现的，我们可以通过onClick事件来监听删除按钮的点击事件，然后通过delItem函数来删除商品。\n在删除商品的时候，我们需要注意一些边界条件，例如删除商品后本页购物车为空，或者删除商品后购物车的商品数量减少等。\n以下是我的delItem函数：\nconst delItem = (id) =&gt; {\n  const item = document.querySelector(&#039;#item-&#039; + id);\n  item.remove();\n  // 这里应该发送请求删除数据，这里只是模拟，直接删除\n  goods = goods.filter(good =&gt; good[&quot;id&quot;] !== id);\n  renderCartList();\n  if (curSelectGoods.find(good =&gt; good[&quot;id&quot;] === id)) {\n    selectTotal -= parseInt(item.querySelector(&#039;.count span&#039;).innerHTML);\n    curSelectGoods = curSelectGoods.filter(good =&gt; good[&quot;id&quot;] !== id);\n    updateTotalCount();\n  }\n}\n选中商品\n选中商品可以分为两种情况：全选和单选。全选的状态会影响到单选的状态，单选的状态也会影响到全选的状态，在考虑全选和单选的逻辑的时候，我们需要多角度考虑。\n在对单个商品进行选中的时候，我们可以通过onClick事件来监听单选按钮的点击事件，然后通过selectGood函数来选中商品，选中商品时，我们要考虑的有：选中商品的总价、选中商品的数量、全选按钮的状态等。\n以下是我的selectGood函数：\nconst selectGood = (id) =&gt; {\n  const item = document.querySelector(&#039;#item-&#039; + id);\n  const checkbox = item.querySelector(&#039;input[type=&quot;checkbox&quot;]&#039;);\n  const price = item.querySelector(&#039;.tot-price&#039;);\n  const quantity = item.querySelector(&#039;.count span&#039;);\n  if(checkbox.checked) {\n    selectTotal += parseInt(quantity.innerHTML);\n    curSelectGoods.push({ id: id, price: parseFloat(price.innerHTML) });\n    updateTotalCount();\n  } else {\n    selectTotal -= parseInt(quantity.innerHTML);\n    curSelectGoods = curSelectGoods.filter(good =&gt; good[&quot;id&quot;] !== id);\n    updateTotalCount();\n  }\n  if(curSelectGoods.length === goods.length) {\n    selectAllStatus = true;\n    const selectAll = document.querySelector(&#039;#select-all&#039;);\n    const icon = selectAll.querySelector(&#039;i&#039;);\n    icon.classList.remove(&#039;fa-regular&#039;);\n    icon.classList.add(&#039;fa-solid&#039;);\n  }\n  else {\n    selectAllStatus = false;\n    const selectAll = document.querySelector(&#039;#select-all&#039;);\n    const icon = selectAll.querySelector(&#039;i&#039;);\n    icon.classList.remove(&#039;fa-solid&#039;);\n    icon.classList.add(&#039;fa-regular&#039;);\n  }\n}\n在全选的时候，我们可以通过通过selectAll函数来全选商品，全选商品时，我们要考虑的有：选中商品的总价、选中商品的数量、单选按钮的状态等。\n以下是我的selectAll函数：\nconst setSelectAll = () =&gt; {\n  const selectAll = document.querySelector(&#039;#select-all&#039;);\n  selectAll.addEventListener(&#039;click&#039;, () =&gt; {\n    const items = document.querySelectorAll(&#039;.cart-item&#039;);\n    if (!selectAllStatus) {\n      selectTotal = 0;\n      curSelectGoods = [];\n      for (let i = 0; i &lt; items.length; i++) {\n        const item = items[i];\n        item.querySelector(&#039;input[type=&quot;checkbox&quot;]&#039;).checked = true;\n        selectTotal += parseInt(item.querySelector(&#039;.count span&#039;).innerHTML);\n        curSelectGoods.push({ id: parseInt(item.getAttribute(&#039;id&#039;).split(&#039;-&#039;)[1]), price: parseFloat(item.querySelector(&#039;.tot-price&#039;).innerHTML) });\n      }\n      const icon = selectAll.querySelector(&#039;i&#039;);\n      icon.classList.remove(&#039;fa-regular&#039;);\n      icon.classList.add(&#039;fa-solid&#039;);\n    }\n    else {\n      for (let i = 0; i &lt; items.length; i++) {\n        items[i].querySelector(&#039;input[type=&quot;checkbox&quot;]&#039;).checked = false;\n      }\n      selectTotal = 0;\n      curSelectGoods = [];\n      const icon = selectAll.querySelector(&#039;i&#039;);\n      icon.classList.remove(&#039;fa-solid&#039;);\n      icon.classList.add(&#039;fa-regular&#039;);\n    }\n    updateTotalCount();\n    selectAllStatus = !selectAllStatus;\n  });\n}\n更新总价\n我们在结算的时候需要计算当前选中的商品的总价，这个总价依赖于选中的商品数量和价格，我们可以通过updateTotalCount函数来更新总价，并在需要的时候调用这个函数。\n以下是我的updateTotalCount函数：\nconst updateTotalCount = () =&gt; {\n  const curSelectBox = document.querySelector(&#039;#cur-select&#039;);\n  if (selectTotal) {\n    curSelectBox.innerHTML = selectTotal;\n  }\n  else {\n    curSelectBox.innerHTML = 0;\n  }\n  const totPriceBox = document.querySelector(&#039;#sum&#039;);\n  if (curSelectGoods.length) {\n    totPriceBox.innerHTML = curSelectGoods.reduce((acc, cur) =&gt; acc + cur[&quot;price&quot;], 0).toFixed(2);\n  }\n  else {\n    totPriceBox.innerHTML = 0;\n  }\n}\n分页设计\n分页是通过点击页码来切换商品列表的，我们可以通过onClick事件来监听页码的点击事件，然后通过changePage函数来切换商品列表。\n标准的分页设计中，每次点击页码时，我们都会重新请求数据，然后重新渲染页面，这样可以保证数据的实时性，这里我只是模拟了这个过程，实际的项目中，我们会通过后端来获取数据。\n由于总页数是不确定的，所以我们依然是通过全局变量来保存当前的页码和总页数，并且在切换页码的时候，我们需要考虑一些边界条件，例如页码不能为负数，页码不能超过总页数等。\n以下是我的initPagnation和changePagnation函数：\nconst changePage = (e) =&gt; {\n  changePagnation(e.target.innerHTML);\n  // 按照正常的分页逻辑，这里应该重新请求数据，这里只是模拟，所以直接取数据\n  changeCartList();\n}\n \nconst initPagnation = () =&gt; {\n  const pagination = document.querySelector(&#039;#pagination&#039;);\n  pagination.innerHTML = &#039;&#039;;\n  for (let i = 0; i &lt;= totPages + 1; i++) {\n    if (i === 0) {\n      const prev = document.createElement(&#039;i&#039;);\n      prev.classList.add(&#039;fa-solid&#039;, &#039;fa-chevron-left&#039;, &#039;page-prev&#039;);\n      if (curPage === 1) {\n        prev.disabled = true;\n      }\n      prev.addEventListener(&#039;click&#039;, () =&gt; {\n        if (curPage &gt; 1) {\n          changePagnation(curPage - 1);\n        }\n      });\n      pagination.appendChild(prev);\n      continue;\n    }\n    else if (i === totPages + 1) {\n      const next = document.createElement(&#039;i&#039;);\n      next.classList.add(&#039;fa-solid&#039;, &#039;fa-chevron-right&#039;, &#039;page-next&#039;);\n      if (curPage === totPages) {\n        next.disabled = true;\n      }\n      next.addEventListener(&#039;click&#039;, () =&gt; {\n        if (curPage &lt; totPages) {\n          changePagnation(curPage + 1);\n        }\n      });\n      pagination.appendChild(next);\n      continue;\n    }\n    const page = document.createElement(&#039;div&#039;);\n    page.innerHTML = i;\n    page.classList.add(&#039;page&#039;);\n    if (i === curPage) {\n      page.classList.add(&#039;active-page&#039;);\n    }\n    page.addEventListener(&#039;click&#039;, changePage);\n    pagination.appendChild(page);\n  }\n}\n \nconst changePagnation = (pageNo) =&gt; {\n  const page = document.querySelector(&#039;.active-page&#039;);\n  page.classList.remove(&#039;active-page&#039;);\n  const pageArr = document.querySelectorAll(&#039;.page&#039;);\n  curPage = parseInt(pageNo);\n  pageArr[curPage - 1].classList.add(&#039;active-page&#039;);\n  changeCartList();\n}\n我这里的分页设计的比较简单，一共只根据json数据设计了5页，在实际项目中，分页的数目是不确定，而且有可能非常多，在设计分页功能的时候，最好的方法是增加一个...按钮，点击这个按钮可以展开更多的页码，以及增加一个跳转按钮，可以跳转到指定的页码，方便用户查找。\n结算\n结算逻辑比较简单，依然是考虑为空等边界条件。\n以下是我的setPay函数：\nconst setPay = () =&gt; {\n  const payBtn = document.querySelector(&#039;#pay&#039;);\n  payBtn.addEventListener(&#039;click&#039;, () =&gt; {\n    if (curSelectGoods.length === 0) {\n      alert(&#039;请选择商品后结算&#039;);\n      return;\n    }\n    // 这里应该发送请求支付，这里只是模拟，直接删除\n    goods = goods.filter(good =&gt; !curSelectGoods.find(select =&gt; select[&quot;id&quot;] === good[&quot;id&quot;]));\n    curSelectGoods = [];\n    selectTotal = 0;\n    updateTotalCount();\n    if (goods.length === 0) {\n      initGoods();\n    }\n    else {\n      renderCartList();\n    }\n    alert(&#039;支付成功&#039;);\n  });\n}\n消息提示框\n在删除商品、结算商品等行为后，我们可以通过一个弹出提示框来与用户进行确认交互，并且可以自定义消息弹出框的类型，这样可以提高用户体验。\n以下是我的alert函数：\nconst alert = (msg, type) =&gt; {\n  const alertBox = document.createElement(&#039;div&#039;);\n  alertBox.classList.add(&#039;alert-box&#039;);\n  alertBox.innerHTML = msg;\n  if (type === &#039;success&#039;) {\n    alertBox.classList.add(&#039;alert-success&#039;);\n  }\n  else if (type === &#039;error&#039;) {\n    alertBox.classList.add(&#039;alert-error&#039;);\n  }\n  document.body.appendChild(alertBox);\n  setTimeout(() =&gt; {\n    alertBox.style.display = &#039;none&#039;;\n  }, 2000);\n}\n \n{/* 结合上面的支付函数就可以写成下面这样 */}\nconst setPay = () =&gt; {\n  const payBtn = document.querySelector(&#039;#pay&#039;);\n  payBtn.addEventListener(&#039;click&#039;, () =&gt; {\n    if (curSelectGoods.length === 0) {\n      alert(&#039;请选择商品后结算&#039;, &#039;error&#039;);\n      return;\n    }\n    // 这里应该发送请求支付，这里只是模拟，直接删除\n    goods = goods.filter(good =&gt; !curSelectGoods.find(select =&gt; select[&quot;id&quot;] === good[&quot;id&quot;]));\n    curSelectGoods = [];\n    selectTotal = 0;\n    updateTotalCount();\n    if (goods.length === 0) {\n      initGoods();\n    }\n    else {\n      renderCartList();\n    }\n    alert(&#039;支付成功&#039;, &#039;success&#039;);\n  });\n}\n查找功能\n在本项目中，一页只有6个商品，感觉查找功能不是很必要，不过假如在一些项目中，一页有很多商品，比如不是基于分页获取数据，而是一次性获取所有数据或者是利用瀑布流加载数据，这时候查找功能就显得很重要了。\n查找功能的实现其实就是一个filter，我们设计一个简单的搜索功能：\nconst setSearch = () =&gt; {\n  // 回车搜索\n  const searchInput = document.querySelector(&#039;#search-input&#039;);\n  searchInput.addEventListener(&#039;keydown&#039;, (e) =&gt; {\n    if (e.keyCode === 13) {\n      search();\n    }\n  });\n}\n \nconst search = () =&gt; {\n  const searchInput = document.querySelector(&#039;#search-input&#039;);\n  const keyword = searchInput.value;\n  fetch(&#039;cart.json&#039;)\n    .then(response =&gt; response.json())\n    .then(data =&gt; {\n      console.log(data);\n      goods = data.pages[curPage - 1][&quot;items&quot;].filter(good =&gt; good[&quot;name&quot;].includes(keyword));\n      renderCartList();\n    }\n  );\n}\n搜索框的设计\n&lt;div class=&quot;search-bar&quot;&gt;\n  &lt;input type=&quot;text&quot; placeholder=&quot;Search&quot; id=&quot;search-input&quot;&gt;\n&lt;/div&gt;\n.search-bar {\n    height: 40px;\n    display: flex;\n    width: 100%;\n    max-width: 400px;\n    padding-left: 16px;\n \n    input {\n        width: 100%;\n        height: 100%;\n        border: none;\n        outline: none;\n        background-color: var(--search-bg);\n        border-radius: 4px;\n        font-family: var(--body-font);\n        font-size: 15px;\n        font-weight: 500;\n \n        &amp;::placeholder {\n            font-family: var(--body-font);\n            color: var(--inactive-color);\n            font-size: 15px;\n            font-weight: 500;\n        }\n    }\n}\n这样我们就可以通过输入关键字来查找商品了。"},"01-developer/frontend/flow_control":{"slug":"01-developer/frontend/flow_control","filePath":"01-developer/frontend/flow_control.md","title":"前端流量控制常用手段","links":[],"tags":["前端","JavaScript","前端八股文"],"content":"\n\n                  \n                  问题描述 \n                  \n                \n\n\n如何解决页面请求接口的大规模并发问题？\n\n\n\n在需要处理大规模请求的情境中，做好流量控制可以提升系统稳定性和性能。\n防抖/节流\n防抖（Debounce）\n在事件触发后，延迟执行函数，若在延迟期间再次出发，则重新计时，如在搜索框输入、调整窗口大小时。\n实现\nfunction debounce(fn, wait) {\n    let timeout;\n    return function () {\n        let context = this;\n        let args = arguments;\n        clearTimeout(timeout);\n        timeout = setTimeout(function () {\n            fn.apply(context, args);\n        }, wait);\n    }\n}\n \nconst sample = function () {\n    console.log(&quot;xxx&quot;);\n}\n \nwindow.addEventListener(&#039;resize&#039;, debounce(sample, 300));\n为什么在  debounce  函数中使用  let？\n在  debounce  函数中，timeout  变量需要满足以下条件：\n\n块级作用域：timeout  只需要在  debounce  函数内部有效，不需要泄漏到外部作用域。\n可重新赋值：每次调用返回的函数时，timeout  需要被重新赋值（通过  clearTimeout  和  setTimeout）。\n不需要提升：timeout  不需要在声明前访问，因此不需要  var  的提升行为。\n\nlet  完美符合这些需求：\n\n它提供了块级作用域，避免变量泄漏。\n它允许重新赋值，适合存储定时器 ID。\n它不会提升，避免了潜在的逻辑错误。\n\n如果使用  var：\n\ntimeout  会泄漏到外部作用域，可能导致意外行为。\n虽然可以重新赋值，但作用域规则不如  let  清晰。\n\n如果使用  const：\n\ntimeout  不能被重新赋值，无法满足  debounce  的逻辑需求。\n\n\n\n                  \n                  var、let和const \n                  \n                \n\n\n作用域区别：var是函数作用域，let和const是块级作用域。\n变量升级：var可以升级（初始值是undefined），let和const不能变量升级，是暂时性死区。\n变量提升指的是在代码执行前，js 引擎将变量和函数的声明提示到作用域的顶部，也就是说可以在声明之前使用变量或函数，但赋值操作会保留在原位置。\nExample：变量\nconsole.log(a); // 输出: undefined\nvar a = 10;\nconsole.log(a); // 输出: 10\n实际执行顺序：\nvar a;\nconsole.log(a); // 输出: undefined\na = 10;\nconsole.log(a); // 输出: 10\nExample：函数\nfoo(); // 输出: &quot;Hello&quot;\nfunction foo() {\n    console.log(&quot;Hello&quot;);\n}\n实际执行顺序：\nfunction foo() {\n    console.log(&quot;Hello&quot;);\n}\nfoo(); // 输出: &quot;Hello&quot;\n重新赋值：var和let可以重新赋值，const不可以。\n适用场景：\nvar：旧代码、全局变量\nlet：块级作用域、需要重新赋值\nconst：常量、不需要重新赋值\n\n\n\n节流（Throttle）\n在规定时间内，函数只执行一次，多余触发被忽略，适用于滚动事件、按钮点击等情景。\n实现\nfunction throttle(fn, limit) {\n    let inthrottle;\n    return function () {\n        let context = this;\n        let args = arguments;\n        if (!inthrottle) {\n            fn.apply(context, args);\n            inthrottle = true;\n            setTimeout(() =&gt; {\n                inthrottle = false;\n            }, limit);\n        }\n    }\n}\n \nconst sample = function () { };\n \nwindow.addEventListener(&#039;scroll&#039;, throttle(sample, 2000));\n注意事项\n\n这两个函数都返回一个新的函数，这个新函数会包装传入的原始函数，并根据防抖或节流的逻辑来调用它。\n防抖和节流的区别在于，防抖是在事件触发后等待一段时间再执行，而节流是确保事件触发后的一段时间内只执行一次。\n这两个函数都可以接受任意数量的参数，并将它们传递给原始函数。\n\n请求队列\n所用算法：滑动窗口\n每次只处理长度为maxConcurrent的窗口内的事件。\n实现\nclass RequestQueue {\n  constructor(maxConcurrent) {\n    this.maxConcurrent = maxConcurrent; // 最大并发数\n    this.queue = [];  // 请求队列\n    this.currentlyRunning = 0;  // 当前正在运行的请求数\n  }\n \n  add(request) {\n    return new Promise((resolve, reject) =&gt; {\n      this.queue.push({ request, resolve, reject });\n      this.processQueue();\n    });\n  };\n \n  processQueue() {\n    if (this.queue.length &gt; 0 &amp;&amp; this.currentlyRunning &lt; this.maxConcurrent) {\n      const { request, resolve, reject } = this.queue.shift();\n      this.currentlyRunning++;\n      request().then(resolve).catch(reject).finally(() =&gt; {\n        this.currentlyRunning--;\n        this.processQueue();\n      });\n    };\n  };\n}\n \n \nfunction fetchData(url) {\n  return new Promise((resolve, reject) =&gt; {\n    setTimeout(() =&gt; {\n      resolve(`Data from ${url}`);\n    }, 1000);\n  });\n}\n \nconst urls = [&#039;url1&#039;, &#039;url2&#039;, &#039;url3&#039;, &#039;url4&#039;, &#039;url5&#039;];\n \nconst requests = urls.map(url =&gt; () =&gt; fetchData(url));\nconst myRequestQueue = new RequestQueue(2);\n \nPromise.all(requests.map(request =&gt; myRequestQueue.add(request)))\n  .then(data =&gt; console.log(data))\n  .catch(err =&gt; console.error(err));\n \n// 1s 后输出\n// [ &#039;Data from url1&#039;, &#039;Data from url2&#039;, &#039;Data from url3&#039;, &#039;Data from url4&#039;, &#039;Data from url5&#039; ]\n分页加载\n分批加载数据，减少单次请求量，应用于长列表、分页数据。\n示例\nlet currentPage = 1;\nconst pageSize = 20;\nlet isLoading = false;\n \nfunction loadMoreData() {\n  if (isLoading) {\n    return;\n  }\n  isLoading = true;\n  fetch(`/aoi/items?page=${currentPage}&amp;limit=${pageSize}`)\n    .then((response) =&gt; response.json())\n    .then((data) =&gt; {\n      // 处理数据并更新页面\n      const container = document.getElementById(&#039;container&#039;);\n      data.forEach((item) =&gt; {\n        const div = document.createElement(&#039;div&#039;);\n        div.innerHTML = item.name;\n        container.appendChild(div);\n      });\n      currentPage++;\n      isLoading = false;\n    }).catch((error) =&gt; {\n      console.error(error);\n      isLoading = false;\n    });\n}\n \n// 监听滚动事件\nwindow.addEventListener(&#039;scroll&#039;, () =&gt; {\n  const { scrollTop, scrollHeight, clientHeight } = document.documentElement;\n  if (scrollTop + clientHeight &gt;= scrollHeight) {\n    loadMoreData();\n  }\n});\n \n// 初始化加载\nloadMoreData();\n懒加载（lazy Load）\n延迟加载非关键资源，减少初始负载，如图片、视频、长列表。\n实现\ndocument.addEventListener(&quot;DOMContentLoaded&quot;, function() {\n  const lazyImages = document.querySelectorAll(&quot;img.lazy&quot;);\n \n  const lazyLoad = function() {\n    lazyImages.forEach(img =&gt; {\n      if (img.getBoundingClientRect().top &lt; window.innerHeight &amp;&amp; img.getBoundingClientRect().bottom &gt; 0 &amp;&amp; getComputedStyle(img).display !== &quot;none&quot;) {\n        img.src = img.dataset.src;\n        img.classList.remove(&quot;lazy&quot;);\n      }\n    });\n  };\n \n  lazyLoad();\n  window.addEventListener(&quot;scroll&quot;, lazyLoad);\n});\n请求重试\n请求失败后，按策略重试，应用于网络不稳定、服务端错误等情景。\n实现\nfunction fetchWithRetry(url, options, retries = 3) {\n  return fetch(url, options)\n    .catch(err =&gt; retries &gt; 0 ? fetchWithRetry(url, options, retries - 1) : Promise.reject(err));\n}\n缓存\n缓存请求结果，减少重复请求，应用于静态资源、频繁请求的数据。\n实现\nconst cache = new Map();\n \nasync function fetchWithCache(url) {\n  if (cache.has(url)) {\n    return cache.get(url);\n  }\n  const response = await fetch(url);\n  cache.set(url, response);\n  return response;\n}\n限流\n限制单位时间内的请求次数，应用于 API 调用、资源加载等场景。\n实现\nclass RateLimiter {\n  constructor(limit, interval) {\n    this.limit = limit;\n    this.interval = interval;\n    this.queue = [];\n    this.times = [];\n  }\n \n  add(request) {\n    this.queue.push(request);\n    this.run();\n  }\n \n  run() {\n    const now = Date.now();\n    this.times = this.times.filter(time =&gt; now - time &lt; this.interval);\n \n    if (this.times.length &lt; this.limit &amp;&amp; this.queue.length) {\n      const request = this.queue.shift();\n      this.times.push(now);\n      request();\n    }\n \n    if (this.queue.length) {\n      setTimeout(() =&gt; this.run(), this.interval - (now - this.times[0]));\n    }\n  }\n}\n反思\n封装请求队列属于前端开发主导的限制请求行为。\n防抖、节流属于用户交互层面上的设计。可以查阅Lodash的实现思路。\n此外还有分页、滚动加载、可视区绘制等措施。\n再再此外还可以从服务器端有一些限制流量的措施，缓解高并发压力，如 Nginx 分流等。"},"01-developer/frontend/large_file_upload":{"slug":"01-developer/frontend/large_file_upload","filePath":"01-developer/frontend/large_file_upload.md","title":"大文件上传和下载问题","links":[],"tags":["前端","JavaScript","前端八股文"],"content":"\n\n                  \n                  问题预设 \n                  \n                \n\n\n网络断开之后，之前上传的部分没了？\n传着传着，网络波动了，结果没有了。\n关机后可不可以接着传，怎么做到？\n\n\n\n术语\n\n断点续传\n断开重连重传\n切片上传\n\n切片上传\n步骤\n\n前端切片 chunk 5MB\n将切片传递给后端，切片要去名：hash、index\n后端组合切片\n\n代码示例\n&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n \n&lt;head&gt;\n  &lt;meta charset=&quot;UTF-8&quot;&gt;\n  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n  &lt;title&gt;大文件上传&lt;/title&gt;\n&lt;/head&gt;\n \n&lt;body&gt;\n  &lt;input type=&quot;file&quot; id=&quot;file&quot; multiple&gt;\n  &lt;button id=&quot;upload&quot;&gt;上传&lt;/button&gt;\n&lt;/body&gt;\n \n&lt;script&gt;\n \n  const CHUNK_SIZE = 5 * 1024 * 1024; // 5MB\n \n \n  function uploadFile() {\n    const file = document.getElementById(&#039;file&#039;).files[0];\n    console.log(&#039;上传文件&#039;, file.name)\n    if (!file) {\n      return\n    }\n \n    const totalSize = file.size\n    const totalChunks = Math.ceil(totalSize / CHUNK_SIZE)\n    let currentChunk = 0\n    const chunks = []\n \n    function uploadChunk() {\n      console.log(&#039;上传第&#039;, currentChunk, &#039;块&#039;)\n      if (currentChunk &gt;= totalChunks) {\n        console.log(&#039;上传完成&#039;)\n        return\n      }\n      const start = currentChunk * CHUNK_SIZE\n      const end = Math.min(totalSize, start + CHUNK_SIZE)\n      const chunk = file.slice(start, end)\n \n      const formData = new FormData()\n      formData.append(&#039;file&#039;, chunk)\n      formData.append(&#039;index&#039;, currentChunk)\n      formData.append(&#039;totalChunks&#039;, totalChunks)\n      formData.append(&#039;filename&#039;, file.name)\n \n      // fetch(&#039;/api/upload&#039;, {\n      //   method: &#039;POST&#039;,\n      //   body: formData\n      // }).then(res =&gt; {\n      //   if (res.ok) {\n      //     currentChunk++;\n      //     uploadChunk() // 递归上传下一块\n      //   } else {\n      //     throw new Error(&#039;上传失败&#039;)\n      //   }\n      // }).catch(err =&gt; {\n      //   console.error(err)\n      // });\n \n      currentChunk++;\n      uploadChunk() // 递归上传下一块\n    };\n \n    // 开始上传\n    uploadChunk();\n  };\n \n  document.getElementById(&#039;upload&#039;).addEventListener(&#039;click&#039;, uploadFile);\n&lt;/script&gt;\n \n&lt;/html&gt;\n优化\n压缩文件\n上传前对文件进行压缩，减少传输的数据量。\ncanvas或第三方库压缩图片、pako压缩其他文件类型。\n并发上传\n使用Promise.all并发上传多个分片。\n注意控制并发数，避免请求过多。\nfunction uploadFile(file) {\n    const chunkSize = 5 * 1024 * 1024; // 5MB\n    const chunks = Math.ceil(file.size / chunkSize);\n    const concurrency = 3; // 并发数\n    let currentChunk = 0;\n \n    function uploadChunk(index) {\n        const offset = index * chunkSize;\n        const chunk = file.slice(offset, offset + chunkSize);\n        const formData = new FormData();\n        formData.append(&#039;file&#039;, chunk);\n        formData.append(&#039;offset&#039;, offset);\n        formData.append(&#039;totalSize&#039;, file.size);\n \n        return fetch(&#039;/upload&#039;, {\n            method: &#039;POST&#039;,\n            body: formData\n        });\n    }\n \n    function uploadNextChunk() {\n        if (currentChunk &gt;= chunks) {\n            console.log(&#039;Upload complete&#039;);\n            return;\n        }\n \n        const promises = [];\n        for (let i = 0; i &lt; concurrency &amp;&amp; currentChunk &lt; chunks; i++) {\n            promises.push(uploadChunk(currentChunk));\n            currentChunk++;\n        }\n \n        Promise.all(promises).then(() =&gt; {\n            uploadNextChunk();\n        });\n    }\n \n    uploadNextChunk();\n}\n显示上传进度\nwebsocket实时通知上传情况，以及请求序列的控制。\n通过XMLHttpRequest或fetch的 API 显示上传进度，提升用户体验。\nfunction uploadFile(file) {\n    const xhr = new XMLHttpRequest();\n    xhr.open(&#039;POST&#039;, &#039;/upload&#039;, true);\n \n    xhr.upload.onprogress = (event) =&gt; {\n        if (event.lengthComputable) {\n            const percentComplete = (event.loaded / event.total) * 100;\n            console.log(`Upload progress: ${percentComplete}%`);\n        }\n    };\n \n    xhr.onload = () =&gt; {\n        if (xhr.status === 200) {\n            console.log(&#039;Upload complete&#039;);\n        }\n    };\n \n    const formData = new FormData();\n    formData.append(&#039;file&#039;, file);\n    xhr.send(formData);\n}\n主进程卡顿？\n尝试使用web-worker，实现多线程切片，处理完之后交给主进程发送\n实现用户关闭浏览器后重新打开，继续上传\n将 Blob 存储到IndexedDB，下次打开浏览器后嗅探一下是否存在未完成的切片，如果有就尝试继续上传。\n记录已上传的分片信息。\n上传前检查服务器上已上传的分片，跳过已上传部分。\n下载\n合并分片的文件\n将大文件分成多个小块下载，减少单次请求的压力，并支持断点续传。\n步骤\n\n服务器将文件分片，前端通过多个请求下载分片。\n使用  Range  请求头指定下载范围。\n前端将分片合并为完整文件。\n\n代码示例\nasync function downloadFile(url, fileName, chunkSize = 5 * 1024 * 1024) {\n    let offset = 0;\n    const chunks = [];\n \n    while (true) {\n        const end = offset + chunkSize - 1;\n        const headers = { Range: `bytes=${offset}-${end}` };\n        const response = await fetch(url, { headers });\n \n        if (response.status === 206) { // 206 Partial Content\n            const blob = await response.blob();\n            chunks.push(blob);\n            offset += chunkSize;\n        } else if (response.status === 200) {\n            // 如果服务器不支持分片下载，直接下载整个文件\n            const blob = await response.blob();\n            chunks.push(blob);\n            break;\n        } else {\n            throw new Error(&#039;Failed to download file&#039;);\n        }\n    }\n \n    // 合并分片\n    const fullBlob = new Blob(chunks);\n    const link = document.createElement(&#039;a&#039;);\n    link.href = URL.createObjectURL(fullBlob);\n    link.download = fileName;\n    link.click();\n    URL.revokeObjectURL(link.href);\n}\n \n// 使用\ndownloadFile(&#039;example.com/large-file.zip&#039;, &#039;large-file.zip&#039;);\n流式下载\n使用流式 API（如  ReadableStream）逐步下载文件，避免内存占用过高。\n实现步骤：\n\n使用  fetch  获取响应流。\n通过  ReadableStream  逐步读取数据并写入文件。\n\n代码示例\nasync function streamDownload(url, fileName) {\n    const response = await fetch(url);\n    const reader = response.body.getReader();\n    const chunks = [];\n \n    while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n        chunks.push(value);\n    }\n \n    // 合并数据\n    const fullBlob = new Blob(chunks);\n    const link = document.createElement(&#039;a&#039;);\n    link.href = URL.createObjectURL(fullBlob);\n    link.download = fileName;\n    link.click();\n    URL.revokeObjectURL(link.href);\n}\n \n// 使用\nstreamDownload(&#039;example.com/large-file.zip&#039;, &#039;large-file.zip&#039;);\n断点续传（Resumable Download）\n在网络中断后，从中断处继续下载，避免重新下载。\n实现步骤：\n\n记录已下载的字节范围。\n使用  Range  请求头从断点处继续下载。\n\n代码示例\nasync function resumeDownload(url, fileName, chunkSize = 5 * 1024 * 1024) {\n    let offset = 0;\n    const chunks = [];\n \n    // 检查本地是否有部分下载的文件\n    const savedBlob = localStorage.getItem(fileName);\n    if (savedBlob) {\n        const blob = new Blob([savedBlob]);\n        offset = blob.size;\n        chunks.push(blob);\n    }\n \n    while (true) {\n        const end = offset + chunkSize - 1;\n        const headers = { Range: `bytes=${offset}-${end}` };\n        const response = await fetch(url, { headers });\n \n        if (response.status === 206) { // 206 Partial Content\n            const blob = await response.blob();\n            chunks.push(blob);\n            offset += chunkSize;\n \n            // 保存已下载的部分到本地\n            const fullBlob = new Blob(chunks);\n            localStorage.setItem(fileName, await fullBlob.text());\n        } else if (response.status === 200) {\n            // 如果服务器不支持分片下载，直接下载整个文件\n            const blob = await response.blob();\n            chunks.push(blob);\n            break;\n        } else {\n            throw new Error(&#039;Failed to download file&#039;);\n        }\n    }\n \n    // 合并分片\n    const fullBlob = new Blob(chunks);\n    const link = document.createElement(&#039;a&#039;);\n    link.href = URL.createObjectURL(fullBlob);\n    link.download = fileName;\n    link.click();\n    URL.revokeObjectURL(link.href);\n    localStorage.removeItem(fileName);\n}\n \n// 使用\nresumeDownload(&#039;example.com/large-file.zip&#039;, &#039;large-file.zip&#039;);\n其他优化\n\nService Worker 缓存：通过 Service Worker 缓存大文件，提升后续加载速度。。\n显示下载进度：提升用户体验。\n"},"01-developer/frontend/method_chaining":{"slug":"01-developer/frontend/method_chaining","filePath":"01-developer/frontend/method_chaining.md","title":"JavaScript 链式调用 | 设计模式 笔记","links":[],"tags":["前端","链式调用","JavaScript","前端八股文"],"content":"Vue :从 createApp 开始的链式调用\n代码示例\nimport { createApp } from &#039;vue&#039;;\n \n// 创建一个 Vue 应用实例\nconst app = createApp({\n  data() {\n    return {\n      message: &#039;Hello, Vue!&#039;\n    };\n  },\n  methods: {\n    handleClick() {\n      alert(&#039;Button clicked!&#039;);\n    }\n  }\n});\n \n// 链式调用：配置应用并绑定事件\napp\n  .component(&#039;MyButton&#039;, {\n    template: `&lt;button @click=&quot;handleClick&quot;&gt;Click Me&lt;/button&gt;`,\n    methods: {\n      handleClick() {\n        this.$emit(&#039;custom-click&#039;);\n      }\n    }\n  })\n  .directive(&#039;highlight&#039;, {\n    mounted(el) {\n      el.style.backgroundColor = &#039;yellow&#039;;\n    }\n  })\n  .mixin({\n    created() {\n      console.log(&#039;Mixin created hook&#039;);\n    }\n  })\n  .mount(&#039;#app&#039;); // 挂载到 DOM\n解释\ncreateApp:创建一个 Vue 应用实例。传入一个根组件配置对象，包含 data 和 methods。\n链式调用\n\n.component(): 注册一个全局组件 MyButton，组件中定义了一个按钮，点击按钮时会触发 custom-click 事件。\n.directive(): 注册一个全局指令 highlight，当元素挂载时，背景颜色会变为黄色。\n.mixin(): 添加一个全局混入，在组件的 created 生命周期钩子中输出日志。\n.mount(): 将应用挂载到 DOM 中，挂载点为 #app。\n\n事件绑定\n在 MyButton 组件中，通过 @click 绑定了一个点击事件，触发时会调用 handleClick 方法，并通过 $emit 触发 custom-click 事件。\n在父组件中，可以通过监听 custom-click 事件来处理按钮点击逻辑。\nuse 方法\nuse  方法是 Vue 应用实例的一个方法，用于安装插件。插件可以是一个对象（必须提供  install  方法），也可以是一个函数（会被直接调用）。Vue 会调用插件的  install  方法，并将 Vue 应用实例作为参数传递给它。\n语法\napp.use(plugin, options)\n\nplugin: 要安装的插件，可以是一个对象或函数。\noptions: 可选的配置对象，传递给插件的  install  方法。\n\n实现 use\n\nuse 的逻辑\n\nfunction use(plugin, options) {\n  if (typeof plugin.install === &#039;function&#039;) {\n    // 如果插件是一个对象，并且提供了 install 方法\n    plugin.install(this, options);\n  } else if (typeof plugin === &#039;function&#039;) {\n    // 如果插件是一个函数\n    plugin(this, options);\n  } else {\n    throw new Error(&#039;Plugin must be a function or an object with an install method.&#039;);\n  }\n  return this; // 返回应用实例，支持链式调用\n}\n\n使用\n\n// 自定义插件\nconst myPlugin = {\n  install(app, options) {\n    console.log(&#039;My plugin is installed with options:&#039;, options);\n    // 添加全局方法或属性\n    app.config.globalProperties.$myMethod = () =&gt; {\n      console.log(&#039;Hello from my plugin!&#039;);\n    };\n    // 注册全局组件\n    app.component(&#039;my-component&#039;, {\n      template: &#039;&lt;div&gt;My Custom Component&lt;/div&gt;&#039;\n    });\n  }\n};\n \n// 使用插件\ncreateApp(App)\n  .use(myPlugin, { someOption: true }) // 安装自定义插件\n  .mount(&#039;#app&#039;);\nPromise 中的链式调用\n手写 Promise 方法\nPromise A+规范\nPromiseA+规范详细描述了 JavaScript 中 Promise 的行为标准，确保不同的 Promise 实现可以相互兼容。\n术语\npromise：先是一个对象或函数，其具有，然后是方法，其行为符合本规范。\nthenable：先用一个具有，再用方法的对象或函数。\nvalue：任何合法的脚本值(包括未定义，一个已启用，或一个 Promise)。\nexception：一个使用抛出语句抛出的值。\nreason：一个表示 Promise 被拒绝的原因\n要求\nPromise 状态\n一个 promise 必须处于以下三种状态之一：pending(等待态），fulfilled(执行态)，或 rejected(拒绝态)。\npending：可以迁移到 fulfilled 或 rejected 状态。\nfulfilled：不可迁移到其他状态，必须有一个 value。\nrejected：不可迁移到其他状态，必须有一个 reason。\nthen 方法\n一个 promise 必须提供一个 then 方法来访问其当前或最终的 value 或 reason。\npromise.then(onFulfilled, onRejected)\n\nonFulfilled 和 onRejected 都是可选参数。\n如果 onFulfilled 不是函数，必须忽略它。\n如果 onRejected 不是函数，必须忽略它。\n\nonFulfilled 的执行\n\nonFulfilled 必须在 promise 完成后被调用，且 promise 的 value 作为其第一个参数。\nonFulfilled 不得在 promise 完成前被调用。\nonFulfilled 必须只被调用一次。\n\nonRejected 的执行\n\nonRejected 必须在 promise 被拒绝后被调用，且 promise 的 reason 作为其第一个参数。\nonRejected 不得在 promise 被拒绝前被调用。\nonRejected 必须只被调用一次。\n\nthen 方法必须返回一个 promise\npromise2 = promise1.then(onFulfilled, onRejected);\npromise2 必须是一个新的 promise。\n处理返回的值\n\n如果 onFulfilled 或 onRejected 返回一个值，则运行 Promise 解决程序Resolve(promise2, x)。\n如果 onFulfilled 或 onRejected 抛出一个异常，则 promise2 必须以作为拒绝原因。\n如果 onFulfilled 不是一个函数且 promise1 完成，promise2 必须以 promise1 的 value 作为其 value。\n如果 onRejected 不是一个函数且 promise1 被拒绝，promise2 必须以 promise1 的 reason 作为其 reason。\n\n代码示例\nconst PENDING = &#039;pending&#039;;\nconst FULFILLED = &#039;fulfilled&#039;;\nconst REJECTED = &#039;rejected&#039;;\n \nfunction isFunction(fn) {\n  return Object.prototype.toString.call(fn) === &#039;[object Function]&#039;;\n}\n \nfunction myPromise(fn) {\n  if (!this || this.constructor !== myPromise) {\n    throw new TypeError(&#039;Promise must be called with new&#039;);\n  }\n  if (!isFunction(fn)) {\n    throw new TypeError(&#039;Promise resolver undefined is not a function&#039;);\n  }\n \n  this.status = PENDING;\n  this.value = void 0;\n  this.reason = void 0;\n  this.onFulfilledCallbacks = [];\n  this.onRejectedCallbacks = [];\n \n  const resolve = value =&gt; {\n    if (this.status === PENDING) {\n      this.status = FULFILLED;\n      this.value = value;\n \n      // 发布\n      this.onFulfilledCallbacks.forEach(fn =&gt; fn());\n    }\n  };\n \n  const reject = reason =&gt; {\n    if (this.status === PENDING) {\n      this.status = REJECTED;\n      this.reason = reason;\n \n      // 发布\n      this.onRejectedCallbacks.forEach(fn =&gt; fn());\n    }\n  };\n \n  try {\n    fn(resolve, reject);\n  } catch (e) {\n    reject(e);\n  }\n}\n \n// 添加 then 原型方法\nmyPromise.prototype.then = function (onFulfilled, onRejected) {\n  // 处理边界\n  onFulfilled = isFunction(onFulfilled) ? onFulfilled : value =&gt; value;\n  onRejected = isFunction(onRejected) ? onRejected : reason =&gt; { throw reason };\n \n  // 返回一个新的 Promise\n  const promise2 = new myPromise((resolve, reject) =&gt; {\n    if (this.status === FULFILLED) {\n      setTimeout(() =&gt; {\n        try {\n          const x = onFulfilled(this.value);\n          resolve(x);\n        } catch (e) {\n          reject(e);\n        }\n      }, 0);\n    } else if (this.status === REJECTED) {\n      setTimeout(() =&gt; {\n        try {\n          const x = onRejected(this.reason);\n          resolve(x);\n        } catch (e) {\n          reject(e);\n        }\n      }, 0);\n    } else if (this.status === PENDING) {\n      // 订阅\n      this.onFulfilledCallbacks.push(() =&gt; {\n        setTimeout(() =&gt; {\n          try {\n            const x = onFulfilled(this.value);\n            resolve(x);\n          } catch (e) {\n            reject(e);\n          }\n        }, 0);\n      });\n \n      this.onRejectedCallbacks.push(() =&gt; {\n        setTimeout(() =&gt; {\n          try {\n            const x = onRejected(this.reason);\n            resolve(x);\n          } catch (e) {\n            reject(e);\n          }\n        }, 0);\n      });\n    }\n  });\n \n  return promise2;\n};\n \n \n// 测试\nconst promise = new myPromise((resolve, reject) =&gt; {\n  setTimeout(() =&gt; {\n    resolve(&#039;success&#039;);\n  }, 1000);\n \n});\n \npromise.then(value =&gt; {\n  console.log(value);\n  return &#039;msg from then1&#039;;\n}).then(value =&gt; {\n  console.log(value);\n  return &#039;msg from then2&#039;;\n}).then(value =&gt; {\n  console.log(value);\n});\n实现链式调用\n例题\n限制用 JavaScript 实现：\nStudent(&quot;Alice&quot;); // 输出 I am Alice\n \nStudent(&quot;Alice&quot;).rest(10).learn(&quot;computer&quot;);\n/* 输出\nI am Alice\n经过10秒后\nAfter 10 seconds\nLearning computer\n*/\n \nStudent(&quot;Alice&quot;).restFirst(5).learn(&quot;Math&quot;);\n/* 输出\nI am Alice\n经过5秒后\nAfter 5 seconds\nLearning Math\n*/\n代码\nclass Student {\n    constructor(name) {\n        this.name = name;\n        this.tasks = []; // 任务队列\n        this.tasks.push(() =&gt; {\n            console.log(`I am ${this.name}`);\n            this.next(); // 执行下一个任务\n        });\n        setTimeout(() =&gt; this.next(), 0); // 异步启动任务队列\n    }\n \n    next() {\n        const task = this.tasks.shift(); // 取出队列中的第一个任务\n        task &amp;&amp; task(); // 如果任务存在，则执行\n    }\n \n    rest(seconds) {\n        this.tasks.push(() =&gt; {\n            setTimeout(() =&gt; {\n                console.log(`After ${seconds} seconds`);\n                this.next(); // 执行下一个任务\n            }, seconds * 1000);\n        });\n        return this; // 返回this以支持链式调用\n    }\n \n    restFirst(seconds) {\n        this.tasks.unshift(() =&gt; {\n            setTimeout(() =&gt; {\n                console.log(`After ${seconds} seconds`);\n                this.next(); // 执行下一个任务\n            }, seconds * 1000);\n        });\n        return this; // 返回this以支持链式调用\n    }\n \n    learn(subject) {\n        this.tasks.push(() =&gt; {\n            console.log(`Learning ${subject}`);\n            this.next(); // 执行下一个任务\n        });\n        return this; // 返回this以支持链式调用\n    }\n}\n \n// 测试用例\nnew Student(&quot;Alice&quot;); // 输出 I am Alice\n \nnew Student(&quot;Alice&quot;).rest(10).learn(&quot;computer&quot;);\n/* 输出\nI am Alice\n经过10秒后\nAfter 10 seconds\nLearning computer\n*/\n \nnew Student(&quot;Alice&quot;).restFirst(5).learn(&quot;Math&quot;);\n/* 输出\nI am Alice\n经过5秒后\nAfter 5 seconds\nLearning Math\n*/\n发布订阅模式 vs 观察者模式\n发布-订阅模式（Pub-Sub）和观察者模式（Observer）是两种常见的设计模式，它们都用于处理对象之间的通信和事件处理。\n观察者模式（Observer Pattern）\n观察者模式定义了一种一对多的依赖关系，当一个对象（称为Subject，主题）的状态发生变化时，所有依赖于它的对象（称为Observers，观察者）都会收到通知并自动更新。\nSubject\n\n维护一个观察者列表。\n提供注册（attach）和注销（detach）观察者的方法。\n在状态变化时通知所有观察者（notify）。\n\nObserver（观察者）\n\n定义一个更新接口（update），用于接收主题的通知。\n\n代码示例\nclass Subject {\n    constructor() {\n        this.observers = [];\n    }\n \n    attach(observer) {\n        this.observers.push(observer);\n    }\n \n    detach(observer) {\n        this.observers = this.observers.filter(obs =&gt; obs !== observer);\n    }\n \n    notify() {\n        this.observers.forEach(observer =&gt; observer.update());\n    }\n}\n \nclass Observer {\n    constructor(name) {\n        this.name = name;\n    }\n \n    update() {\n        console.log(`${this.name} received an update!`);\n    }\n}\n \n// 使用\nconst subject = new Subject();\nconst observer1 = new Observer(&#039;Observer 1&#039;);\nconst observer2 = new Observer(&#039;Observer 2&#039;);\n \nsubject.attach(observer1);\nsubject.attach(observer2);\n \nsubject.notify(); // Observer 1 received an update! Observer 2 received an update!\n发布-订阅模式（Pub-Sub Pattern）\n发布-订阅模式通过一个事件中心（Event Bus）来解耦发布者和订阅者。发布者将消息发布到事件中心，订阅者从事件中心订阅感兴趣的消息。发布者和订阅者之间没有直接的依赖关系。\n关键角色\nPublisher（发布者）： 负责发布消息到事件中心。\nSubscriber（订阅者）： 向事件中心订阅感兴趣的消息。\nEvent Bus（事件中心）：维护一个消息队列和订阅者列表；负责将消息分发给订阅者。\n代码示例\nclass EventBus {\n  constructor() {\n    this.events = {};\n  }\n \n  subscribe(event, callback) {\n    if (!this.events[event]) {\n      this.events[event] = [];  // 初始化事件队列\n    }\n    this.events[event].push(callback);\n  }\n \n  publish(event, data) {\n    // 边界检查\n    if (!this.events[event]) {\n      return;\n    }\n    if (this.events[event]) {\n      this.events[event].forEach(callback =&gt; callback(data));\n    }\n  }\n}\n \n// 使用\nconst eventBus = new EventBus();\n \n// 订阅者\neventBus.subscribe(&#039;news&#039;, data =&gt; {\n  console.log(`Subscriber 1 received news: ${data}`);\n});\n \neventBus.subscribe(&#039;news&#039;, data =&gt; {\n  console.log(`Subscriber 2 received news: ${data}`);\n});\n \n// 发布者\neventBus.publish(&#039;news&#039;, &#039;Breaking news!&#039;);\n// 输出：\n// Subscriber 1 received news: Breaking news!\n// Subscriber 2 received news: Breaking news!\n主要区别\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n特性观察者模式发布-订阅模式通信方式直接通信（主题直接通知观察者）间接通信（通过事件中心）耦合度强耦合（观察者和主题直接关联）松耦合（发布者和订阅者解耦）角色主题（Subject）和观察者（Observer）发布者（Publisher）、订阅者（Subscriber）、事件中心（Event Bus）适用场景简单的对象间通信复杂的系统，需要解耦的场景实现复杂度简单相对复杂同步/异步通常是同步的可以是异步的\n应用\n观察者模式\n\nGUI 框架中的事件处理（如按钮点击事件）。\n数据模型和视图之间的绑定（如 MVC 模式）。\n简单的对象间通信场景。\n\n发布-订阅模式\n\n消息队列系统（如 RabbitMQ、Kafka）。\n事件驱动架构（如 Node.js 的 EventEmitter）。\n需要解耦的复杂系统（如微服务之间的通信）。\n"},"01-developer/frontend/mutationObserver":{"slug":"01-developer/frontend/mutationObserver","filePath":"01-developer/frontend/mutationObserver.md","title":"MutationObserver学习+实践","links":["links"],"tags":["前端","JavaScript"],"content":"\n一篇学习 MutationObserver 的文章\n\n背景\n今天调整新主题的时候，在重新设计友链样式的时候想保留原本的随机背景颜色，之前数量少的时候似乎不太明显，现在本地测试发觉加载太慢了。于是上网寻找解决思路，找到了 MutationObserver 这个 API，于是就学习了一下//此处记录一下学习过程。\n需求分析\n我有不知数量的div元素，每个div元素都有一个class名为friend-link-div，我需要在每个单个的div元素被加载完成的同时，对它设置一个随机的背景颜色。而不是等待整个页面或窗口加载完毕\n想法分析\nwindow.onload和&#039;DOMContentLoaded&#039;的问题\n原本的实现代码：\n  window.onload=function () {\n    const randomHex = () =&gt; `rgba(${Math.round(Math.random()*255)}, ${Math.round(Math.random()*255)}, ${Math.round(Math.random()*255)}, 0.5)`;\n    var friendArr=document.getElementsByClassName(&quot;friend-div&quot;),temp=[];\n    for(var i=0;i&lt;friendArr.length;i++){\n        friendArr[i].style.background=randomHex();\n    }\n  }\n原本的思路就是简单的在页面加载完成后，获取所有的友链元素，然后给每个元素设置一个随机的背景颜色。但是这样的实现方式有一个问题，就是当友链数量较多的时候，会导致页面加载变慢，因为每次都要重新计算随机颜色，并且在等待本页面加载的时候，友链的背景颜色是白色的，这样会导致页面的视觉体验不好。\n在网上询问得到的另一个思路是用document.addEventListener(&#039;DOMContentLoaded&#039;, function() {})，但是这个方法也是等待整个页面加载完毕后才会执行，观察发现还是挺慢的…所以也不适合。\n仅利用CSS实现随机色彩的思路\n还有一个仅利用CSS实现随机色彩的思路，该思路是在CSS中定义一个颜色数组，然后通过nth-child选择器来实现，但是这样的实现方式有一个问题，就是颜色的数量是固定的，而且颜色的选择是有规律的，不是真正的随机颜色。\n不过还是展示一下如何伪随机实现：\n  .friend-link-div:nth-child(1) {\n    background: #f00;\n  }\n  .friend-link-div:nth-child(2) {\n    background: #0f0;\n  }\n  .friend-link-div:nth-child(3) {\n    background: #00f;\n  }\n  .friend-link-div:nth-child(4) {\n    background: #ff0;\n  }\n  ...\n搭配scss的话可以这样写：\n  $colors: #f00, #0f0, #00f, #ff0, #f0f, #0ff, #000, #fff;\n  @for $i from 1 through length($colors) {\n    .friend-link-div:nth-child(#{$i}) {\n      background: nth($colors, $i);\n    }\n  }\n于是放弃window.onload和&#039;DOMContentLoaded&#039;，以及CSS的伪随机实现方法。改用 MutationObserver 来实现。\n解决思路\n使用MutationObserver API来观察DOM的变化，并在新的盒子被添加到DOM中时应用背景色更改。这样，每当有新的盒子被添加到页面上时，你就可以立即更改它的背景，而不需要等待其他内容加载完成。\n代码\n \n  // 定义一个生成随机背景色的函数\n  const randomHex = () =&gt; `rgba(${Math.round(Math.random() * 255)}, ${Math.round(Math.random() * 255)}, ${Math.round(Math.random() * 255)}, 0.5)`;\n \n  // 遍历所有已经存在的盒子，为每个盒子设置随机背景色\n  document.querySelectorAll(&#039;.friend-link-div&#039;).forEach(div =&gt; {\n    div.style.background = randomHex();\n  });\n \n  // 定义一个回调函数，用于处理每当DOM树中添加新节点时的操作\n  const callback = function (mutationsList, observer) {\n    for (const mutation of mutationsList) {\n      if (mutation.type === &#039;childList&#039; &amp;&amp; mutation.addedNodes.length &gt; 0) {\n        mutation.addedNodes.forEach(node =&gt; {\n          // 检查是否为目标盒子节点\n          if (node.nodeType === 1 &amp;&amp; node.classList.contains(&#039;friend-link-div&#039;)) {\n            // 更改背景色\n            node.style.background = randomHex();\n          }\n        });\n      }\n    }\n  };\n \n  // 创建MutationObserver实例\n  const observer = new MutationObserver(callback);\n \n  // 配置观察选项：观察子节点的添加\n  const config = { childList: true, subtree: true };\n \n  // 选择要观察变化的DOM节点（在这个例子中，是body，但你可以根据需要更改）\n  const targetNode = document.body;\n \n  // 启动观察\n  observer.observe(targetNode, config);\n关于用于hugo主题的一些Tips\n有的时候DOM初始化时已经存在一些盒子，因此我们需要在初始化时为这些盒子设置随机背景色。然后，我们创建一个MutationObserver实例，并配置它以观察DOM树中的子节点添加。最后，我们选择要观察变化的DOM节点（在这个例子中是body，但你可以根据需要更改），并启动观察。\n假如直接将js插入到friend.html中，打开控制台会发现该段js被渲染了好多次，这是因为hugo的模板渲染机制导致的，所以我们需要将js放在整个大页面的js中，这样就不会出现重复渲染的问题了。\n一个合适的地方是在layouts/partials/footer.html中，这样就可以保证在整个页面加载完毯后再执行这段js。\n不过直接放在footer.html中也会有一个问题，就是我们只需要在友链页面加载这段js，而不是每个页面都加载，所以我们可以在footer.html中加入一个判断条件，判断当前页面是否是友链页面，如果是则加载这段js。\n可以在content/links.md中加入一个isLink字段，然后在footer.html中判断是否为友链页面，如果是则加载这段js。\n  {{ if .Params.isLink }}\n    &lt;script&gt;\n      // 代码\n    &lt;/script&gt;\n  {{ end }}\n假如不想每次都把新增的js直接写在footer.html等地方中，可以在static/js/文件夹下新建一个js文件，然后在footer.html中引入这个js文件。\n  {{ if .Params.isLink }}\n    &lt;script src=&quot;/js/_extended/friend-link.js&quot;&gt;&lt;/script&gt;\n  {{ end }}\n另注：githubPage是jekyll模板似乎不能识别下划线开头的文件，所以有需要的话可以把_extended改成其他名字。\n完成！现在，每当新的friend-link-div盒子被添加到DOM中时，它的背景颜色将立即更改为随机颜色。\n可以在本站的友链页面查看效果：友链"},"02-experience/index":{"slug":"02-experience/index","filePath":"02-experience/_index.md","title":"🎨实验","links":[],"tags":["实验","intro"],"content":"记录一些笔记和实验记录"},"02-experience/datalab":{"slug":"02-experience/datalab","filePath":"02-experience/datalab.md","title":"🧪CS-APP Datalab","links":[],"tags":["CSAPP"],"content":"0. before start\n实验需要的材料在这里：CSAPP Datalab\nCSAPP原书在线阅读\n将datalab-handout.tar下载复制到计划用来实验的目录下，解压：\ntar xvf datalab-handout.tar\n解压之后，文件中bit.c是包含13个编程题中每个题的骨架。实验要求是使用没有任何循环或条件语句，以及有限的c算术和逻辑运算符来完成其中每个函数的内容，只能使用如下8个运算符：\n! ~ &amp; ^ | + &lt;&lt; &gt;&gt;\n测评\n在btest文件夹中，包含了一个测试程序，可以用来测试我们的实现是否正确。我们可以通过make命令编译btest，然后运行：\n# 编译并运行\nmake &amp;&amp; ./btest\n# 对某个函数进行单元测试\nmake &amp;&amp; ./btest -f bitXnor\n# 对某个函数进行单元测试，且指定测试用例，以 -1 指定第一个参数，依次类推\nmake &amp;&amp; ./btest -f bitXnor -1 7 -2 0xf\ndlc：用于检查我们的实现是否符合实验要求：\n./dlc bits.c\n接下来，按照难度从易到难，我们依次完成实验\n1. bitXor\n异或等价于不是同0且不是同1。\n代码\n//1\n/* \n * bitXor - x^y using only ~ and &amp; \n *   Example: bitXor(4, 5) = 1\n *   Legal ops: ~ &amp;\n *   Max ops: 14\n *   Rating: 1\n */\nint bitXor(int x, int y) {\n  return ~(~x&amp;~y)&amp;~(x&amp;y);\n}\n2. tmin\n获得对2补码的最小int值。在C中，int是32位的，所以补码的最小值就是符号位为1，其余位为0的值，对0x1左移31位即可。\n代码\n/* \n * tmin - return minimum two&#039;s complement integer \n *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;\n *   Max ops: 4\n *   Rating: 1\n */\nint tmin(void) {\n  return 1 &lt;&lt; 31;\n}\n3. isTmax\n判断x是否是int的最大整数。最大整数tmax应该为0x7fffffff。\n题目提示不允许使用移位操作。\n注意到：\n\\begin{aligned}\nTmax=0x7fffffff,Tmin=0x80000000\\\\\nso,that:Tmax=\\sim Tmin,Tmax+1 = Tmin\\\\\n-Tmin = \\sim Tmin + 1 = Tmax + 1 = Tmin\\\\\nso,that:\\\\\n-(\\sim Tmax) = Tmax + 1 = \\sim Tmax\\\\\n\\end{aligned}\n也就是说，假如~x的相反数与~x相等，则满足x=Tmax。\n注意除了Tmax拥有这个性质，当x=-1时：\n\\begin{aligned}\nx=0xffffffff\\\\ \n\\sim x=0x00000000\\\\\n-(\\sim x)=\\sim (\\sim x)+1 = x+1 = 0x00000000\n\\end{aligned}\n也满足这个上述特点，需要排除。\n代码\n/*\n * isTmax - returns 1 if x is the maximum, two&#039;s complement number,\n *     and 0 otherwise \n *   Legal ops: ! ~ &amp; ^ | +\n *   Max ops: 10\n *   Rating: 1\n */\nint isTmax(int x) {\n  return !!(~x)&amp;!((~x)^(x+1));\n}\n\n\n                  \n                  提示 \n                  \n                \n\n\n注意返回值是int型的，所以需要使用!!将结果转换为0或1。\n\n\n\n4. allOddBits\n当x中所有奇数位都为1时返回true。\n奇数位都为1的数形如：\nx=0b1x_{30}1x_{28}1...1x_{2}1x_{0}\n思路是构造偶数位都为1的掩码0x55555555，再与x按位取或，若能构造出0xffffffff则复合要求。\n由于实验要求不允许使用长度超过8位的常量，所以通过移位操作来构造掩码。\n代码\n/* \n * allOddBits - return 1 if all odd-numbered bits in word set to 1\n *   where bits are numbered from 0 (least significant) to 31 (most significant)\n *   Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1\n *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;\n *   Max ops: 12\n *   Rating: 2\n */\nint allOddBits(int x) {\n  int mask = 0x55 + (0x55 &lt;&lt; 8);\n  mask = mask + (mask &lt;&lt; 16);\n  return !(~(mask | x));\n}\n5. negate\n返回x的相反数。\n这个操作在第三个实验里其实已经使用过了。\n-x=\\sim x + 1\n代码\n/* \n * negate - return -x \n *   Example: negate(1) = -1.\n *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;\n *   Max ops: 5\n *   Rating: 2\n */\nint negate(int x) {\n  return ~x + 1;\n}\n6. isAsciDigit\n判断x是否是ASCII码0~9中的某一个，即判断0x30\\leq x\\leq 0x39。\n注意到0x30\\sim 0x39的低4位从0000\\sim 1001，低5~8位为0011，可以分别判断。\n在满足低5~8位为0011的前提下，若倒数第4位为0则符合要求，若倒数第4位为1则需判断是否为1000或1001，即中间2位是否是0。\n代码\n/* \n * isAsciiDigit - return 1 if 0x30 &lt;= x &lt;= 0x39 (ASCII codes for characters &#039;0&#039; to &#039;9&#039;)\n *   Example: isAsciiDigit(0x35) = 1.\n *            isAsciiDigit(0x3a) = 0.\n *            isAsciiDigit(0x05) = 0.\n *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;\n *   Max ops: 15\n *   Rating: 3\n */\nint isAsciiDigit(int x) {\n  int f3 = !((x &gt;&gt; 4) ^ 3);\n  int f0t9 =!! (!(x &amp; 8) + !(x &amp; 6));\n  return f3 &amp; f0t9;\n}\n7. conditional\n实现出w =( x ? y : z)的条件判断。\n感觉在上个题就实现了，上题相当于对一个二进制数x=x_4 x_3 x_2 x_1，是否满足(x_4 == 1)?(x \\&amp; 6 == 0):1。\n判断x通过!!x获得0/1，再通过按位取反+1分别获得0x00000000和0xffffffff，再与y和z按位或并相加，获得结果。\n代码\n/* \n * conditional - same as x ? y : z \n *   Example: conditional(2,4,5) = 4\n *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;\n *   Max ops: 16\n *   Rating: 3\n */\nint conditional(int x, int y, int z) {\n  int f = !!x;\n  int mask = ~f + 1;\n  return (y &amp; mask) + (z &amp; ~mask);\n}\n8. isLessOrEqual\n判断是否符合x\\leq y的关系。\n首先比较符号位，若符号位相同，则判断x-y\\leq 0是否成立。减号可以由按位取反+1获得相反数，再相加实现。\n代码\n/* \n * isLessOrEqual - if x &lt;= y  then return 1, else return 0 \n *   Example: isLessOrEqual(4,5) = 1.\n *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;\n *   Max ops: 24\n *   Rating: 3\n */\nint isLessOrEqual(int x, int y) {\n  int fx = x &gt;&gt; 31;\n  int fy = y &gt;&gt; 31;\n  int f = fx ^ fy;\n  int z = x + ~y + 1;\n  return !!((f &amp; fx) | ((!f) &amp; ((!z) | z &gt;&gt; 31)));\n}\n9. logicalNeg\n实现逻辑取反，x非0返回0，x为0返回1。\n通过取反+1获得相反数，如果x是0，其相反数与x拥有相同的符号位0，否则在x和其相反数两个数之间一定会有至少一个符号位为1。\n在Tmin = 0x80000000中也一致，-Tmin = ~Tmin + 1 = 0x7fffffff + 1 = 0x80000000。\n代码\n/* \n * logicalNeg - implement the ! operator, using all of \n *              the legal operators except !\n *   Examples: logicalNeg(3) = 0, logicalNeg(0) = 1\n *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;\n *   Max ops: 12\n *   Rating: 4 \n */\nint logicalNeg(int x) {\n  return (((~x + 1) | x) &gt;&gt; 31) + 1;\n}\n10. howManyBits\n计算出表示x​需要的最少补码位数。\n\\begin{aligned}\n0=0b0,1bit\\\\\n1=0b01,2bits\\\\\n-1=0b1,1bit\\\\\n2=0b010,3bits\\\\\n-2=0b10,2bits\\\\\n3=0b011,3bits\\\\\n-3=0b101,3bits\n\\end{aligned}\n如果是正数的话x补码形如：0x00001...，所需补码位数是从左向右第一个1的位置在+1（符号位），负数的话x补码形如：0x11110...，取反之后是0x00001...，所需位数是从左向右第一个1的位置+1。\n不能通过循环来从左向右找，尝试二分找第一个1的位置。\nint型有32位，逐渐二分为16、8、4、2、1位。\n\\begin{aligned}\n&amp;x = 0b0001,1...,....,....,....,....,....,....\\\\\nloop1:&amp; !!(x&gt;&gt;16)=1,b16=16\\\\\n&amp;\\text{高16位存在1，则可以舍去低16位，将x右移16位}\\\\\n&amp;x = x&gt;&gt;16=0b0001,1...,...,...\\\\\nloop2:&amp;...\n\\end{aligned}\n最后统计完毕之后要+1符号位。\n代码\n/* howManyBits - return the minimum number of bits required to represent x in\n *             two&#039;s complement\n *  Examples: howManyBits(12) = 5\n *            howManyBits(298) = 10\n *            howManyBits(-5) = 4\n *            howManyBits(0)  = 1\n *            howManyBits(-1) = 1\n *            howManyBits(0x80000000) = 32\n *  Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;\n *  Max ops: 90\n *  Rating: 4\n */\nint howManyBits(int x) {\n  int f = !!(x &gt;&gt; 31);\n  f = ~f + 1;\n  x = (x &amp; ~f) + (~x &amp; f);\n  int b16 = (!!(x &gt;&gt; 16)) &lt;&lt; 4;\n  x = x &gt;&gt; b16;\n  int b8 = (!!(x &gt;&gt; 8)) &lt;&lt; 3;\n  x = x &gt;&gt; b8;\n  int b4 = (!!(x &gt;&gt; 4)) &lt;&lt; 2;\n  x = x &gt;&gt; b4;\n  int b2 = (!!(x &gt;&gt; 2)) &lt;&lt; 1;\n  x = x &gt;&gt; b2;\n  int b1 = !!(x &gt;&gt; 1);\n  x = x &gt;&gt; b1;\n  return b16 + b8 + b4 + b2 + b1 + x + 1;\n}\n11. floatScale2\n求一个float浮点数乘2之后的值。\nfloat的各位：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n符号指数(exp)尾数18230/10x01111111+e小数部分\n通过定义先按指数是否为0x00000000或0x11111111、≠0 &amp; ≠255分类。\n\n\n对规格化数进行指数+1（若+1后为255则返回无穷大）\n\n\n非规格化数保持符号位不变，左移一位（注意：若尾数最左边一位为1时，乘2后恰好是规格化数，故保留符号位整体左移即可）\n\n\n无穷大保持不变\n\n\nNaN保持不变。\n\n\n代码\n/* \n * floatScale2 - Return bit-level equivalent of expression 2*f for\n *   floating point argument f.\n *   Both the argument and result are passed as unsigned int&#039;s, but\n *   they are to be interpreted as the bit-level representation of\n *   single-precision floating point values.\n *   When argument is NaN, return argument\n *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while\n *   Max ops: 30\n *   Rating: 4\n */\nunsigned floatScale2(unsigned uf) {\n  unsigned s = uf &amp; 0x80000000;\n  unsigned exp = uf &amp; 0x7f800000;\n  unsigned f = uf &amp; 0x007fffff;\n  if(!exp){\n    return s | (uf &lt;&lt; 1);\n  }\n  if(!(exp ^ 0x7f800000)){\n    return uf;\n  }\n  exp = exp + 0x00800000;\n  if(exp == 0x7f800000){\n    return 0x7f800000 | s;\n  }\n \n  return s | (exp &amp; 0x7f800000) | f;\n}\n12. floatFloat2Int\n将float浮点数转化为int类型。\n算出真实的Exp：Exp + 0b0111111 = e，\n再给尾数最左侧补一位1，整体右移|Exp-23|位（舍位），再通过正负性取补码。\n注意，若溢出或是NaN返回0x80000000u\n代码\n/* \n * floatFloat2Int - Return bit-level equivalent of expression (int) f\n *   for floating point argument f.\n *   Argument is passed as unsigned int, but\n *   it is to be interpreted as the bit-level representation of a\n *   single-precision floating point value.\n *   Anything out of range (including NaN and infinity) should return\n *   0x80000000u.\n *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while\n *   Max ops: 30\n *   Rating: 4\n */\nint floatFloat2Int(unsigned uf) {\n  unsigned s = uf &amp; 0x80000000,\n           e = uf &amp; 0x7f800000,\n           f = uf &amp; 0x007fffff;\n  int exp = (e &gt;&gt; 23) - 0x7f;\n  unsigned res = f | 0x00800000;\n  if(exp &lt; 0) return 0;\n  if(exp &gt;= 31) return 0x80000000;\n  if(exp &lt; 23)exp = 23 - exp;\n  else exp = exp - 23;\n  res = res &gt;&gt; exp;\n  if(s)return -res;\n  else return res;\n}\n13. floatPower2\n求浮点表示下的2.0的x次。\nemmm其实就是exp + x，那就处理好0b000000和0b11111111的情况就好了。\n代码\n/* \n * floatPower2 - Return bit-level equivalent of the expression 2.0^x\n *   (2.0 raised to the power x) for any 32-bit integer x.\n *\n *   The unsigned value that is returned should have the identical bit\n *   representation as the single-precision floating-point number 2.0^x.\n *   If the result is too small to be represented as a denorm, return\n *   0. If too large, return +INF.\n * \n *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. Also if, while \n *   Max ops: 30 \n *   Rating: 4\n */\nunsigned floatPower2(int x) {\n  int exp = 0x7f + x;\n  if(exp &lt; 0x00)return 0;\n  if(exp &gt;= 0xff)return 0x7f800000;\n  if(exp == 0x00)return 1;\n  return exp &lt;&lt; 23;\n}\n写完哩~最后一个样例似乎跑了好久（。\n总结碎碎念\n做完实验第一次感觉到!f和~f的区别（迫真。\n下个实验再见(∪.∪ )…zzz"},"03-algorithm/23HangZhouICPC":{"slug":"03-algorithm/23HangZhouICPC","filePath":"03-algorithm/23HangZhouICPC.md","title":"2023杭州ICPC区域赛","links":[],"tags":["算法"],"content":"G. Snake Move\n题意\nn\\times m的网格中有一条长度为k的贪吃蛇，贪吃蛇支持上下左右移动 1 格的操作，以及缩短 1 个身体长度的操作。\n设f(i,j)为从蛇头从初始位置到达网格中点(i,j)所需要的最少的操作数，网格中不可到达的格子操作数设为0，求解输出：\n\\sum_{i=1}^{i=n}\\sum_{j=1}^{j=m}f(i,j)\n思路\n初始时蛇身压住的格子有一个最早释放的时间，可以通过预处理获得。\n当蛇头开始移动时，蛇头经过的格子不会有更早的到达时刻，如果下一步可以到达蛇身压住的格子，绕行不可能优于直接缩短长度的操作数。\n正常从蛇头进行 BFS，如果遇到初始时不被蛇身压住的格子则正常加入队列，如果遇到被压住的格子，对释放时间和当前步数取max。\n代码\n#include &lt;bits/stdc++.h&gt;\n \n#define x first\n#define y second\n \nusing namespace std;\n \ntypedef double ld;\ntypedef unsigned long ul;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair&lt;ll, ll&gt; pll;\n \nconst int maxn = 2e5 + 50;\nconst ll inf = 0x3f3f3f3f3f3f;\nconst vector&lt;pll&gt; dxy = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}};\n \nll n, m, k;\nchar maz[3090][3090];\null dis[3090][3090];\nbool inq[3090][3090], vis[3090][3090];\nmap&lt;ll, pll&gt; snake;\nmap&lt;pll, ll&gt; body;\n \nbool check(pll &amp;p) {\n  return p.x &gt;= 1 &amp;&amp; p.x &lt;= n &amp;&amp; p.y &gt;= 1 &amp;&amp; p.y &lt;= m &amp;&amp; maz[p.x][p.y] != &#039;#&#039;;\n};\n \nvoid bfs(pll st) {\n  priority_queue&lt;pair&lt;ll, pll&gt;, vector&lt;pair&lt;ll, pll&gt;&gt;, greater&lt;&gt;&gt; q;\n  q.push({0ll, st});\n  dis[st.x][st.y] = 0ll;\n  inq[st.x][st.y] = true;\n  while (!q.empty()) {\n    auto [d, p] = q.top();\n    q.pop();\n    dis[p.x][p.y] = d;\n    for (auto [dx, dy] : dxy) {\n      pll pi = {p.x + dx, p.y + dy};\n      if (!check(pi))\n        continue;\n      if (inq[pi.x][pi.y])\n        continue;\n \n      if (body.count(pi)) {\n        ll di = max(d + 1, body[pi]);\n        q.push({di, pi});\n        inq[pi.x][pi.y] = true;\n      } else {\n        q.push({d + 1, pi});\n        inq[pi.x][pi.y] = true;\n      }\n    }\n  }\n}\n \nvoid solve() {\n  cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;\n \n  body.clear();\n \n  pll st;\n  for (ll i = k - 1; i &gt;= 0; i--) {\n    pll p;\n    cin &gt;&gt; p.x &gt;&gt; p.y;\n    snake[i] = p;\n    if (i == k - 1) {\n      st = p;\n      body[p] = 0;\n    } else {\n      body[p] = i + 1;\n    }\n  }\n \n  for (int i = 1; i &lt;= n; i++) {\n    for (int j = 1; j &lt;= m; j++) {\n      cin &gt;&gt; maz[i][j];\n      dis[i][j] = inf;\n    }\n  }\n \n  bfs(st);\n \n  ull ans = 0;\n  for (ll i = 1; i &lt;= n; i++) {\n    for (ll j = 1; j &lt;= m; j++) {\n      ull d = dis[i][j];\n      if (d == inf)\n        d = 0;\n      ans += d * d;\n    }\n  }\n  cout &lt;&lt; fixed &lt;&lt; setprecision(0) &lt;&lt; ans &lt;&lt; &#039;\\n&#039;;\n}\n \nvoid init() {\n}\nint main(void) {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  init();\n  int _t = 1;\n  // cin &gt;&gt; _t;\n  // cin.get();\n  while (_t--)\n    solve();\n \n  return 0;\n}\nJ. Mysterious Tree\n题意\n交互题。\n有一棵节点数n\\ge 4的树，树的形状是链状或者星状，每次询问两个点u和v，会返回(u,v)之间是否有边，需要在\\lceil \\frac{n}{2} \\rceil + 3的询问次数之内确定树的形状。\n思路\n每次询问2个没有问过的节点(1,2),(3,4),...如果到结束都没有问出边，此时节点数是偶数，则说明是链状，否则用三次询问确定节点n是否是星状的中心（询问中要有两个点之间是没有边的），若是则为星，否则为链。\n问出一条边后，抉择确定这条边的两个点是否是星的中心。\n代码\nvoid solve() {\n  ll n;\n  cin &gt;&gt; n;\n \n  ll t;\n  auto ask = [&amp;](ll p1, ll p2) {\n    cout &lt;&lt; &quot;? &quot; &lt;&lt; p1 &lt;&lt; &#039; &#039; &lt;&lt; p2 &lt;&lt; endl;\n    cin &gt;&gt; t;\n  };\n  auto conf = [&amp;](ll x) { cout &lt;&lt; &quot;! &quot; &lt;&lt; x &lt;&lt; endl; };\n \n  bool flag = false;\n  ll u = -1, v = -1;\n  for (ll i = 1; i + 1 &lt;= n; i += 2) {\n    ask(i, i + 1);\n    if (t == 1) {\n      flag = true;\n      u = i, v = i + 1;\n      break;\n    }\n  }\n \n  ll t1, t2, t3;\n  if (!flag) {\n    if (n &amp; 1) {\n      ask(n, 1), t1 = t;\n      ask(n, 2), t2 = t;\n      ask(n, 3), t3 = t;\n      if (t1 &amp;&amp; t2 &amp;&amp; t3) {\n        conf(2);\n      } else {\n        conf(1);\n      }\n    } else {\n      conf(1);\n    }\n    return;\n  }\n  if (u - 1 &gt;= 1) {\n    ask(u - 1, u);\n    t1 = t;\n    if (t1 != 1) {\n      ask(u - 1, v);\n      t2 = t;\n      if (t2 != 1) {\n        conf(1);\n      } else {\n        if (v + 1 &lt;= n)\n          ask(v, v + 1);\n        else\n          ask(u - 2, v);\n        t3 = t;\n        if (t3 != 1) {\n          conf(1);\n        } else {\n          conf(2);\n        }\n      }\n    } else {\n      if (u - 2 &gt;= 1) {\n        ask(u - 2, u);\n      } else {\n        ask(v + 1, u);\n      }\n      t2 = t;\n      if (t2 != 1) {\n        conf(1);\n      } else {\n        conf(2);\n      }\n    }\n  } else {\n    ask(v, v + 1);\n    t1 = t;\n    if (t1 != 1) {\n      ask(v + 1, u);\n      t2 = t;\n      if (t2 != 1) {\n        conf(1);\n      } else {\n        ask(v + 2, u);\n        t3 = t;\n        if (t3 != 1) {\n          conf(1);\n        } else {\n          conf(2);\n        }\n      }\n    } else {\n      ask(v, v + 2);\n      t2 = t;\n      if (t2 != 1) {\n        conf(1);\n      } else {\n        conf(2);\n      }\n    }\n  }\n}\nM. V-Diagram\n题意\n在 V 型数组，找一个平均值最大的连续子数组，要求子数组也成 V 型，输出平均值。\n思路\n从最低点（pi）分别向左向右找到平均值最大的位置（lp，rp），选择区间[lp,pi+1]、[pi-1,rp]、[lp,rp]之中平均值最大的一个。\n代码\nconst int maxn = 3e5 + 50;\nll a[maxn], pre[maxn];\n \nvoid solve() {\n  ll n;\n  cin &gt;&gt; n;\n  ll lp, rp, pi, mna = inf;\n  for (ll i = 1; i &lt;= n; i++) {\n    cin &gt;&gt; a[i];\n    pre[i] = pre[i - 1] + a[i];\n    if (mna &gt; a[i]) {\n      pi = lp = rp = i;\n      mna = a[i];\n    }\n  }\n  ll sum = 0, len = 0, llp = lp, rrp = rp;\n  ld rcur = 0.0, lcur = 0.0;\n  while (lp &gt;= 1) {\n    sum += a[lp];\n    len++;\n    if (1.0 * sum / len &gt; lcur) {\n      lcur = 1.0 * sum / len;\n      llp = lp;\n    }\n    lp -= 1;\n  }\n  sum = 0, len = 0;\n  while (rp &lt;= n) {\n    sum += a[rp];\n    len++;\n    if (1.0 * sum / len &gt; rcur) {\n      rcur = 1.0 * sum / len;\n      rrp = rp;\n    }\n    rp += 1;\n  }\n \n  auto getavl = [&amp;](ll r, ll l) {\n    return 1.0 * (pre[r] - pre[l - 1]) / (r - l + 1);\n  };\n \n  ld ans = max(getavl(rrp, pi - 1), getavl(pi + 1, llp));\n  ans = max(ans, getavl(rrp, llp));\n  cout &lt;&lt; fixed &lt;&lt; setprecision(12) &lt;&lt; ans &lt;&lt; &#039;\\n&#039;;\n}"},"03-algorithm/24JilinCCPC":{"slug":"03-algorithm/24JilinCCPC","filePath":"03-algorithm/24JilinCCPC.md","title":"2024吉林省赛补题记录","links":[],"tags":["算法"],"content":"GYM地址：2024吉林省赛\n题目顺序按照从易到难排序。\nI. The Easiest Problem\n题意\n数一数\n代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\n \nvoid solve() {\n    string s = &quot;Scan the QR code to sign in now.&quot;;\n    ll cnt = 0;\n    for (auto c : s) {\n        if (c &lt;= &#039;z&#039; &amp;&amp; c &gt;= &#039;a&#039;)cnt++;\n    }\n    cout &lt;&lt; cnt &lt;&lt; endl;\n}\n \nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int _ = 1;\n    // cin &gt;&gt; _;cin.get();\n    while(_--)\n        solve();\n \n    return 0;\n}\nL. Recharge\n题意\n有x次获得1格能量的机会，y次获得2格能量的机会，充满一个电池需要k格能量，溢出的能量会被浪费，问最多能充满多少电池。\n代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\n \nvoid solve() {\n    ll k, x, y;cin &gt;&gt; k &gt;&gt; x &gt;&gt; y;\n    if (k == 1) { cout &lt;&lt; x + y &lt;&lt; &quot;\\n&quot;;return; }\n    ll ans = 0;\n    if (k &amp; 1) {\n        ll yi = k / 2;\n        if (x &lt;= y / yi) {\n            ans += x;\n            y -= x * yi;\n            x = 0;\n            ans += y / (yi + 1);\n        }\n        else {\n            ans += y / yi;\n            x -= (y / yi);\n            y -= (y / yi) * yi;\n            if (y * 2 + x &gt;= k) {\n                ans += 1;x -= (k - 2 * y);y = 0;\n            }\n            ans += x / k;\n        }\n    }\n    else {\n        ll tot = x + 2 * y;\n        ans = tot / k;\n    }\n    cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;;\n}\n \nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int _ = 1;\n    cin &gt;&gt; _;cin.get();\n    while(_--)\n        solve();\n \n    return 0;\n}\nG. Platform Game\n题意\n在二维平面中有n个平台，每个平台有一个高度h_i，以及一个左端点l_i和右端点r_i。机器人从(x,y)出发，保持向右前进，如果遇到平台端点则会垂直下落，问机器人最终的落点。\n思路\n排序题，按照高度从高到低、左端点从小到大排序，遍历平台，如果机器人在平台上则更新机器人的位置。\n代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\n \nstruct PLAT {\n    ll l, r, y;\n    operator&lt;(const PLAT&amp; P)const {\n        if (y == P.y)return l &lt; P.l;\n        return y &gt; P.y;\n    }\n};\n \nvoid solve() {\n    ll n;cin &gt;&gt; n;\n    vector&lt;PLAT&gt;plats;\n    for (ll i = 0;i &lt; n;i++) {\n        ll l, r, y;cin &gt;&gt; l &gt;&gt; r &gt;&gt; y;\n        plats.push_back({ l,r,y });\n    }\n    sort(plats.begin(), plats.end());\n    ll sx, sy;cin &gt;&gt; sx &gt;&gt; sy;\n    for (auto p : plats) {\n        if (p.l &lt; sx &amp;&amp; p.r &gt;= sx &amp;&amp; p.y &lt; sy) {\n            sy = p.y;\n            sx = p.r;\n        }\n    }\n    cout &lt;&lt; sx &lt;&lt; &quot;\\n&quot;;\n}\n \nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int _ = 1;\n    cin &gt;&gt; _;cin.get();\n    while(_--)\n        solve();\n \n    return 0;\n}\nD. Parallel Lines\n题意\n二维平面上有k条平行线，这些直线上有n个点，已知每条直线上至少有2个点。现在给出n个点，找出这k条平行线（用点表示）。\n数据范围\n2 \\leq n \\leq 10^4\n1 \\leq k \\leq \\min(50, \\frac{n}{2})\n思路\n注意k的范围，k最多为50，可以枚举k来选择平行线的斜率，对于k条平行线，当我选择了k+1个点时，这k+1个点中必然至少有两个点之间的斜率是k条平行线的斜率。\n确定斜率k_i之后，我们分别计算过每个点斜率为k_i的直线在y轴上的截距，并计数相同截距的点的数目，注意垂直于x轴的情况。\n只有同时符产生截距数目恰好为k，且每个截距的点数目至少为2时，我们才找到了所要的k条平行线。\n代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\n \nstruct Point {\n    ll x, y;\n};\n \nvoid solve() {\n    ll n, k;cin &gt;&gt; n &gt;&gt; k;\n    vector&lt;Point&gt;points(n);\n    map&lt;ll, vector&lt;ll&gt;&gt;rx;\n    for (ll i = 0;i &lt; n;i++) {\n        cin &gt;&gt; points[i].x &gt;&gt; points[i].y;\n        rx[points[i].x].push_back(i + 1);\n    }\n    if (rx.size() == k) {\n        bool f = true;\n        for (auto i : rx) {\n            if (i.second.size() &lt; 2) { f = false;break; }\n        }\n        if (f) {\n            for (auto i : rx) {\n                cout &lt;&lt; i.second.size() &lt;&lt; &quot; &quot;;\n                for (auto j : i.second) {\n                    cout &lt;&lt; j &lt;&lt; &quot; &quot;;\n                }\n                cout &lt;&lt; &quot;\\n&quot;;\n            }\n            return;\n        }\n    }\n    ll b = 1000000;\n    map&lt;ll, bool&gt;mpk;\n    for (ll i = 0;i &lt; k + 1;i++) {\n        for (ll j = i + 1;j &lt; k + 1;j++) {\n            ll px = points[i].x, py = points[i].y, qx = points[j].x, qy = points[j].y;\n            if (px == qx) {\n                continue;\n            }\n            ld ki = 1.0 * (py - qy) / (px - qx);\n            ll kk = (ll)(ki * b);\n            if (mpk.count(kk) == 0)mpk[kk] = true;\n        }\n    }\n    for (auto kk : mpk) {\n        ld ki = 1.0 * kk.first / b;\n        map&lt;ll, vector&lt;ll&gt;&gt;cnt;\n        for (ll i = 0;i &lt; n;i++) {\n            ll x = points[i].x, y = points[i].y;\n            ld bi = y - ki * x;\n            ll bb = (ll)(bi * b);\n            cnt[bb].push_back(i + 1);\n            if (cnt.size() &gt; k)break;\n        }\n        if (cnt.size() == k) {\n            bool f = true;\n            for (auto i : cnt) {\n                if (i.second.size() &lt; 2) { f = false;break; }\n            }\n            if (!f)continue;\n            for (auto i : cnt) {\n                cout &lt;&lt; i.second.size() &lt;&lt; &quot; &quot;;\n                for (auto j : i.second) {\n                    cout &lt;&lt; j &lt;&lt; &quot; &quot;;\n                }\n                cout &lt;&lt; &quot;\\n&quot;;\n            }\n            return;\n        }\n    }\n}\n \nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int _ = 1;\n    // cin &gt;&gt; _;cin.get();\n    while (_--)\n        solve();\n \n    return 0;\n}\nE. Connected Components\n题意\n有n个王国，编号从1到n，每个王国有两个属性值a_i和b_i，如果两个王国的属性值满足a_i - a_j \\leq i - j \\leq b_i - b_j或a_j - a_i \\leq j - i \\leq b_j - b_i，则这两个王国是相连的。问有多少个连通块。\n数据范围\n1 \\leq n \\leq 10^6\n思路"},"03-algorithm/index":{"slug":"03-algorithm/index","filePath":"03-algorithm/_index.md","title":"⌨️chill打A的","links":[],"tags":["算法","intro"],"content":"Intro\n这个目录下记录了这两年来的写题不完全记录，多未填坑警告 ⚠。\n找工作中的很长一段时间不会更新了，但是期待找到满意工作之后可以继续 handle 自己的时间，可能那时候会继续打 codeforce！（谁知道呢\n那场大雨浇灭了我的 ACM 梦\n菜菜的算法生涯随着今年(2025.06)的蓝桥杯结束啦。\n虽然 ddl 退役了，但是 ddl 的队友还在奋斗，祝愿大家能拿到满意的成绩！\n流水账\n\n2023.11 CCPC 2023 年重庆站女生赛铜奖。\n2024.04 蓝桥杯吉林省一等奖、国优秀奖\n2024.04 CCPC 东北赛四省赛暨全国邀请赛铜奖、吉林省赛暨全国邀请赛银奖\n2024.05 天梯赛 CCCC 个人国三、团队二等奖\n2024.11 CCPC 2024 年重庆站女生赛银奖\n2025.05 天梯赛 CCCC 个人国三，团队二等奖\n2025.04 蓝桥杯吉林省一等奖\n"},"03-algorithm/cfedu162div2":{"slug":"03-algorithm/cfedu162div2","filePath":"03-algorithm/cfedu162div2.md","title":"💭Educational Codeforces Round 162(div2)","links":[],"tags":["算法"],"content":"A-Moving Chips\n题意\n每个单元格为空闲或有一个芯片，芯片可以向左移动到最近的空闲处（如果存在空闲格）。\n现在有一排单元格，求问进行多少次移动，才能使得所有芯片集中在一起（中间没有空格）。\n数据范围\nt(1≤t≤1000)\nn(2≤n≤50)​\na_i(a_i∈\\{1,0\\})\n思路\n统计数组中第一个1和最后一个1之间的0的数目。\n参考代码\nvoid solve() {\n    int n;cin &gt;&gt; n;\n    vector&lt;int&gt;a(n);\n    bool f = false;\n    int cnt = 0;\n    int ans = 0;\n    for (int i = 0;i &lt; n;i++) {\n        cin &gt;&gt; a[i];\n        if (a[i] == 1 &amp;&amp; !f) {\n            f = true;\n        }\n        if (f) {\n            if (a[i] == 0)\n                cnt++;\n            else {\n                ans += cnt;\n                cnt = 0;\n            }\n        }\n    }\n    cout &lt;&lt; ans &lt;&lt; endl;\n}\nB-Monsters Attack!\n题意\n玩家位于一维坐标0点处，开始游戏后，每一回合玩家可以向任意两个方向发射总共不多于k颗子弹，每个子弹可以造成怪物的血量a_i下降1点，降为0后怪物将倒下并从坐标上移除。之后，所有怪物超玩家移动一格。如果怪物到达了玩家的位置(即坐标0点)，则游戏失败。\n询问是否可能使玩家消灭所有n只怪物，不让任何一只怪物靠近玩家。\n数据范围\nt(1≤t≤3\\times 10^4)\nn,k(1≤n≤3\\times 10^5,1\\le k\\le 2\\times 10^9)​\na_i(1\\le a_i\\le 10^9)\nx_i(-n\\le x_1\\lt x_2\\lt\\dots\\lt x_n\\le n;x_i≠0)\n思路\n将所有怪物折合成同一个方向，每次玩家向怪物移动一格，每次都使用完所有的k颗子弹。遍历模拟，判断是否能在到达最远坐标之前消灭所有怪物。\n参考代码\nstruct monster {\n    ll a, x;\n    bool operator&lt;(const monster&amp; other) {\n        return x &lt; other.x;\n    }\n};\n \nvoid solve() {\n    ll n, k;cin &gt;&gt; n &gt;&gt; k;\n    vector&lt;ll&gt;a(n);\n    for (int i = 0;i &lt; n;i++)cin &gt;&gt; a[i];\n    vector&lt;ll&gt;x(n);\n    for(int i = 0;i &lt; n;i++) {\n        cin &gt;&gt; x[i];\n        if (x[i] &lt; 0)x[i] *= -1;\n    }\n    vector&lt;monster&gt;monsters;\n    for (int i = 0;i &lt; n;i++) {\n        monsters.push_back({a[i], x[i]});\n    }\n    sort(monsters.begin(), monsters.end());\n    map&lt;ll, ll&gt;turns;\n    for (int i = 0;i &lt; n;i++) {\n        ll t = monsters[i].a;\n        ll s = monsters[i].x;\n        turns[s] += t;\n    }\n    ll lk = 0;\t// 剩余子弹\n    ll ix = 0;\n    for (auto i = turns.begin();i != turns.end();i++) {\n        ll iy = i-&gt;first;   // 位置\n        ll t = i-&gt;second;\n        if ((iy - ix) * k + lk &lt; t) {\n            cout &lt;&lt; &quot;NO\\n&quot;;return;\n        }\n        else {\n            lk = (iy - ix) * k + lk - t;\n            ix = iy;\n        }\n    }\n    cout &lt;&lt; &quot;YES\\n&quot;;\n}\nC-Find B\n题意\n给一个数组a，每次截取一段[l,r]的子数组b，判断该数组是否可以变化成一个数组c，满足：\n\n\\sum_{i=1}^m b_i=\\sum_{i=1}^m c_i\n任意i∈[l,r]，都满足b_i≠c_i\n任意c_i\\gt 0​\n\n数据范围\nt(1≤t≤10^4)\nn,q(1≤n,q≤3\\times 10^5)​\na_i(1\\le a_i\\le 10^9)\nl_i,r_i(1\\le l_i\\le r_i\\le n)\n思路\n预处理数组a。\n对于子数组b，考虑：将所有不为1的数变成1，将所有的1至少再加1。\n这样生成的数组c是符合要求的。\n如果上述操作可以实现总和不变，则可行。\n参考代码\nvoid solve() {\n    ll n, q;cin &gt;&gt; n &gt;&gt; q;\n    vector&lt;ll&gt;c(n + 1);c[0] = 0;\n    vector&lt;ll&gt;pc(n + 1);pc[0] = 0;\n    vector&lt;ll&gt;ct(n + 1);ct[0] = 0;\n    for (int i = 1;i &lt;= n;i++) {\n        cin &gt;&gt; c[i];\n        pc[i] = c[i] + pc[i - 1];\n        if (c[i] == 1)ct[i] = ct[i - 1] + 1;\n        else ct[i] = ct[i - 1];\n    }\n    while (q--) {\n        ll l, r;cin &gt;&gt; l &gt;&gt; r;\n        if (l == r) {\n            cout &lt;&lt; &quot;NO\\n&quot;;continue;\n        }\n        ll sum = pc[r] - pc[l - 1];\n        ll lr = r - l + 1;\n        lr -= ct[r] - ct[l - 1];    // 非1的个数\n        if (sum - lr &gt;= 2 * (ct[r] - ct[l - 1])) {\n            cout &lt;&lt; &quot;YES\\n&quot;;\n        }\n        else cout &lt;&lt; &quot;NO\\n&quot;;\n    }\n}"},"03-algorithm/cfround927div3":{"slug":"03-algorithm/cfround927div3","filePath":"03-algorithm/cfround927div3.md","title":"💭Codeforces Round 927(div3)","links":[],"tags":["算法","CF"],"content":"A-Thorns and Coins\n题意\n长度为n的单元格路径，每个单元格有空、有金币、荆棘三种可能，人物从最左边开始向右移动，每次步长不多于2格，求能获得的最多金币数。\n数据范围\nt(1≤t≤1000)\nn(1≤n≤50)​\n.代表空，*代表荆棘，@代表金币\n思路\n从左往右，寻找第一个含有2个以上*的*连通块，其前的金币都可以达到。\n参考代码\nvoid solve() {\n    int n;cin &gt;&gt; n;\n    string s;cin &gt;&gt; s;\n    int cnt = 0;\n    bool f = true;\n    for (int i = 0;i &lt; n;i++) {\n        if (s[i] == &#039;@&#039;)cnt++;\n        if (i &gt; 0 &amp;&amp; s[i] == &#039;*&#039; &amp;&amp; s[i - 1] == &#039;*&#039;){\n            break;\n        }\n    }\n    cout &lt;&lt; cnt &lt;&lt; &#039;\\n&#039;;\n}\nB-Chaya Calendar\n题意\n查亚部落相信世界末日有n个征兆，第i个征兆每隔a_i年出现一次，当观测到第i-1个征兆后才会等待第i个征兆。给出每个征兆的出现间隔，询问观测到所有n个征兆所需要的年数。\nps:当第i个征兆在第x年被观测，部落会从第x+1年开始等待第i+1个征兆。\n数据范围\nt(1≤t≤1000)\nn(1≤n≤100)​\na_i(1\\le a_i\\le 10^6)\n思路\n第i个征兆间隔a_i年出现，若上一个征兆在第x年被观测，则下一个征兆将在第y=k\\times a_i年出现（x\\lt y\\le x+a_i）。等待的时间是y-x，也就是a_i-x\\text{ }mod\\text{ }a_i年。\n参考代码\nvoid solve() {\n    int n;cin &gt;&gt; n;\n    vector&lt;ll&gt;a(n);\n    ll sum = 0;\n    for (int i = 0;i &lt; n;i++) {\n        cin &gt;&gt; a[i];\n        ll lf = a[i] - sum % a[i];\n        sum += lf;\n    }\n    cout &lt;&lt; sum &lt;&lt; &#039;\\n&#039;;\n}\nC-LR-remainders\n题意\n有一个数组a，一个正整数m和长度为n的命令（由L和R组成的字符串），每次求数组中剩余数的积模m的余数并输出，然后按照命令删数（L删去最左边的数，R删去最右边的数）。\n数据范围\nt(1≤t≤10^4)\nn,m(1≤n≤2\\times 10^5,1\\le m\\le 10^4)​\na_i(1\\le a_i\\le 10^4)\n思路\n反过来考虑，从最后一个删去的数开始，每次对积乘上上一次被删去的数，记录模m的值，逆序输出。\n参考代码\nvoid solve() {\n    int n, m;cin &gt;&gt; n &gt;&gt; m;\n    vector&lt;int&gt;a(n);\n    for (int i = 0;i &lt; n;i++) { cin &gt;&gt; a[i]; }\n    string s;cin &gt;&gt; s;\n    vector&lt;int&gt;b;\n    int l = 0, r = n - 1;\n    for (int i = 0;i &lt; n;i++) {\n        if (s[i] == &#039;L&#039;)b.push_back(a[l++]);\n        else b.push_back(a[r--]);\n    }\n    ll ans = 1;\n    vector&lt;int&gt;res;\n    reverse(b.begin(), b.end());\n    for (int i = 0;i &lt; n;i++) {\n        ans *= b[i];\n        res.push_back(ans % m);\n        ans %= m;\n    }\n    reverse(res.begin(), res.end());\n    for (int i = 0;i &lt; n;i++) {\n        cout &lt;&lt; res[i] &lt;&lt; &quot; &quot;;\n    }cout &lt;&lt; &#039;\\n&#039;;\n}\nD-Card Game\n题意\n纸牌比大小游戏，有四种花色C、D、H、S，同一种花色之间比较数字，数字大的胜出。同时，每局有一个王牌花色，该花色的牌可以比剩余三种花色的牌都大，王牌花色和王牌花色之间比较数字大小。\n给出所有已经打出的牌，尝试复现对局情况（第二位玩家击败第一位玩家）；如果不能复现，输出IMPOSSIBLE。\n数据范围\nt(1≤t≤100)\nn(1\\le n \\le 16)​\n思路\n模拟。\n先对不同花色的牌分类，然后遍历同花色的牌，排序后，将非王牌花色放入一个序列，王牌花色单独一个序列。\n从非王牌花色序列开始遍历，如果当前牌和其后一牌是同一种花色，凑成一对局；如果不是，用一张王牌花色和它凑成一个对局。假如可以凑成所有的对局，输出这些对局，否则不能构成对局。\n参考代码\nvoid solve() {\n    int n;cin &gt;&gt; n;\n    string w;cin &gt;&gt; w;\n \n    int f = 0;\n    switch (w[0]) {\n    case &#039;S&#039;:f = 3;break;\n    case &#039;H&#039;:f = 2;break;\n    case &#039;D&#039;:f = 1;break;\n    case &#039;C&#039;:f = 0;break;\n    default:break;\n    }\n \n    vector&lt;vector&lt;string&gt;&gt;sp(4);\n    for (int i = 0;i &lt; 2 * n;i++) {\n        string s;cin &gt;&gt; s;\n        if (s[1] == &#039;C&#039;)sp[0].push_back(s);\n        else if (s[1] == &#039;D&#039;)sp[1].push_back(s);\n        else if (s[1] == &#039;H&#039;)sp[2].push_back(s);\n        else sp[3].push_back(s);\n    }\n    vector&lt;string&gt;rk;\n    for (int i = 0;i &lt; 4;i++) {\n        if (i == f)continue;\n        sort(sp[i].begin(), sp[i].end());\n        for (int j = 0;j &lt; sp[i].size();j++)\n            rk.push_back(sp[i][j]);\n    }\n    sort(sp[f].begin(), sp[f].end());\n    for (int j = 0;j &lt; sp[f].size();j++)\n        rk.push_back(sp[f][j]);\n \n    vector&lt;pair&lt;string, string&gt;&gt;ans;\n    int cnt = 0;int p = rk.size() - 1;\n    for (int i = 0;i &lt; p;i++) {\n        if (rk[i][1] == rk[i + 1][1]) {\n            ans.push_back({ rk[i],rk[i + 1] });i++;\n            cnt++;\n        }\n        else {\n            if (f == 0 &amp;&amp; rk[p][1] == &#039;C&#039;) {\n                ans.push_back({ rk[i],rk[p] });p--;\n            }\n            else if (f == 1 &amp;&amp; rk[p][1] == &#039;D&#039;) {\n                ans.push_back({ rk[i],rk[p] });p--;\n            }\n            else if (f == 2 &amp;&amp; rk[p][1] == &#039;H&#039;) {\n                ans.push_back({ rk[i],rk[p] });p--;\n            }\n            else if (f == 3 &amp;&amp; rk[p][1] == &#039;S&#039;) {\n                ans.push_back({ rk[i],rk[p] });p--;\n            }\n            else {\n                cout &lt;&lt; &quot;IMPOSSIBLE\\n&quot;;return;\n            }\n        }\n    }\n    for (int i = 0;i &lt; n;i++) {\n        cout &lt;&lt; ans[i].first &lt;&lt; &quot; &quot; &lt;&lt; ans[i].second &lt;&lt; &#039;\\n&#039;;\n    }\n}\nE-Final Countdown\n题意\n倒计时，但是每次变化数所需要的秒数等于要变化的数位的数量。\n求实际上需要多少秒完成倒计时。\n数据范围\nt(1≤t≤10^4)\nn(1≤n≤4\\times 10^5)​\na_i(1\\le a_i\\le 10^4)\n思路\n计数模拟：\n12345\n 1234\n  123\n   12\n    1\n-----+\n13715\n则对从第一位开始做前缀和，对(前缀和+进位)倒着取模，最后输出即可。\n参考代码\nvoid solve() {\n    int n;cin &gt;&gt; n;\n    string s;cin &gt;&gt; s;\n    int x = 0;\n    while (s[x] == &#039;0&#039;) {\n        x++;\n    }\n    s = s.substr(x);\n    vector&lt;ll&gt;v;\n    for (int i = 0;i &lt; s.size();i++) {\n        if (i != 0)\n            v.push_back(v.back() + s[i] - &#039;0&#039;);\n        else {\n            v.push_back(s[i] - &#039;0&#039;);\n        }\n    }\n    reverse(v.begin(), v.end());\n    ll k = 0;\n    vector&lt;int&gt;res;\n    for (int i = 0;i &lt; v.size();i++) {\n        res.emplace_back((v[i] + k) % 10);\n        k = (v[i] + k) / 10;\n    }\n    while(k &gt; 0) {\n        res.emplace_back(k % 10);\n        k /= 10;\n    }\n    reverse(res.begin(), res.end());\n    for (int i = 0;i &lt; res.size();i++) {\n        cout &lt;&lt; res[i];\n    }cout &lt;&lt; &#039;\\n&#039;;\n}"},"03-algorithm/cfround929div3":{"slug":"03-algorithm/cfround929div3","filePath":"03-algorithm/cfround929div3.md","title":"💭Codeforces Round 929(div3)","links":[],"tags":["算法","CF"],"content":"A-Turtle Puzzle: Rearrange and Negate\n题意\n对一个数组执行两个操作：\n\n对数组进行重新排序或保持元素顺序不变\n选择连续的一段，对该段中的元素取相反数，也可以不选择任何一段，即保持所有的元素符号不变。\n\n求进行上述操作之后数组的最大和是多少。\n数据范围\nt(1≤t≤1000)\nn(1≤n≤50)​\na_i(-100\\le a_i\\le 100)\n思路\n遍历数组，对所有的数取非负后相加。\n参考代码\nvoid solve() {\n    int n;cin &gt;&gt; n;\n    ll ans = 0ll;\n    for (int i = 0;i &lt; n;i++) {\n        ll x;cin &gt;&gt; x;\n        if (x &lt; 0)ans -= x;\n        else ans += x;\n    }\n    cout &lt;&lt; ans &lt;&lt; &#039;\\n&#039;;\n}\nB-Turtle Math: Fast Three Task\n题意\n有一个数组，可以对数组中的数进行任意次下方两种操作：\n\n将数移除\n将该数的数值加1\n\n求至少进行多少次上述操作，可以使数组所有元素之和是3的倍数？\n数据范围\nt(1≤t≤10^4)\nn(1≤n≤10^5)​\na_i(1\\le a_i\\le 10^4)\n思路\n统计数组a中模3为0、1、2的数量和余数总和。记总和为sum，余1的数量为x，余2的数量为y。考虑：\n\n若sum模3为0，则不需要操作\n若sum模3为2，则给任意一个数加1即可，操作1次。\n若sum模3为1，若有余1的数，则去掉这个数即可，否则进行两次加1操作。\n\n参考代码\nvoid solve() {\n    int n;cin &gt;&gt; n;\n    vector&lt;ll&gt;aa(n);\n    ll ans = 0;\n    ll x = 0, y = 0;\n    for (int i = 0;i &lt; n;i++) {\n        cin &gt;&gt; aa[i];\n        aa[i] %= 3;\n        ans += aa[i];\n        if (aa[i] == 1)x++;\n        else if (aa[i] == 2)y++;\n    }\n    if (ans%3 == 0) {\n        cout&lt;&lt;0&lt;&lt;&#039;\\n&#039;;\n    }\n    else if (ans % 3 == 2) {\n        cout &lt;&lt; 1 &lt;&lt; &#039;\\n&#039;;\n    }\n    else {\n        if (x &gt; 0)cout &lt;&lt; 1 &lt;&lt; &#039;\\n&#039;;\n        else cout &lt;&lt; 2 &lt;&lt; &#039;\\n&#039;;\n    }\n}\nC-Turtle Fingers: Count the Values of k\n题意\n给3个正整数a,b,l，找出满足l=k\\times a^x\\times b^y的k的个数，k,x,y均为非负整数。\n数据范围\nt(1≤t≤10^4)\na,b,l(2\\le a,b\\le 100,1\\le l\\le 10^6)\n思路\n2^{20}\\gt 10^6，可知，x,y的范围不超过20。\n预处理a^x和b^y，然后暴力遍历即可。\n参考代码\nvoid solve() {\n    ll a, b, l;cin &gt;&gt; a &gt;&gt; b &gt;&gt; l;\n    vector&lt;ll&gt;ax, by;\n    ax.push_back(1);by.push_back(1);\n    for (int i = 1;ax.back() &lt;= l;i++) {\n        ax.push_back(ax.back() * a);\n    }\n    for (int i = 1;by.back() &lt;= l;i++) {\n        by.push_back(by.back() * b);\n    }\n    set&lt;ll&gt;k;\n    for (int i = 0;i &lt; ax.size();i++) {\n        for (int j = 0;j &lt; by.size();j++) {\n            if (l%(ax[i] * by[j]) == 0) {\n                k.insert(l/(ax[i] * by[j]));\n            }\n        }\n    }\n    cout &lt;&lt; k.size() &lt;&lt; &#039;\\n&#039;;\n}\nD-Turtle Tenacity: Continual Mods\n题意\n给数组a重新排序，判断是否存在排序使得a_1 \\text{ }mod\\text{ } a_2 \\text{ }mod\\text{ } a_3\\dots a_{n-1}\\text{ }mod\\text{ }a_n=0。\n数据范围\nt(1≤t≤10^4)\nn(2≤n≤10^5)\na_i(1\\le a_i\\le 10^9)\n思路\n思考x\\text{ }mod\\text{ }y\n\n如果x\\lt y，则结果还是x\n如果x=y​，则结果是0\n\n如果最小的数是唯一的，则一定有解；如果最小的数不唯一，考虑是否有较大的数z使得z\\text{ }mod\\text{ }x≠0，如果存在，则有更小的唯一最小值，可以有解，否则无解。\n参考代码\nvoid solve() {\n    int n;cin &gt;&gt; n;\n    vector&lt;ll&gt;a(n);\n    for (int i = 0;i &lt; n;i++) {\n        cin &gt;&gt; a[i];\n    }\n    sort(a.begin(), a.end());\n    if (a[0] != a[1]) {\n        cout &lt;&lt; &quot;YES\\n&quot;;\n        return;\n    }\n    for (int i = 1;i &lt; n;i++) {\n        if (a[i] % a[0] != 0) {\n            cout &lt;&lt; &quot;YES\\n&quot;;\n            return;\n        }\n    }\n    cout &lt;&lt; &quot;NO\\n&quot;;\n}\nE-Turtle vs. Rabbit Race: Optimal Trainings\n题意\n训练量k是连续一段时间的每天的训练量的总和，每次训练的提高值u按照训练次数递减（第1次u，第2次u-1，第3次u-2，…，第k次u-k+1，，提高值可以是负数），每次给定一个起始日l和提高值u，寻找一个最佳的结束日r，使得训练提高值总和最高，如果有多个r的结果提供最高训练值，选r较小的那个。\n数据范围\nt(1≤t≤10^4)\nn(1≤n≤10^5)\na_i(1\\le a_i\\le 10^4)\nq(1\\le q\\le 10^5)\nl,u(1\\le l\\le n,1\\le u \\le 10^9)\n思路\n训练提高值总量S与训练量k之间的关系是S(k)=u\\times k-\\frac{k\\times (k-1)}{2}，是一个关于k先增后减的函数，最高值在k=u+0.5处取到，由于k为整数，S(k)的最高值应该在u和u+1处取到。\n\n在对称轴左边，二分查找在[l,u]的范围内最靠近u的k的取值，即小于等于u的最后一个k值。\n在对称轴右边，二分查找[u+1,n]的范围内最靠近u+1的k值，即大于等于u+1的第一个k值。\n\nk值可以通过前缀和进行筛选，k=pre[r]-pre[l-1]，则对pre数组进行二分查找u+pre[l-1]和u+1+pre[l-1]即可。\n对比这两个值对应的S(k)和r，以及只在l那天训练的效果，择优选择。\n参考代码\nll f(ll u, ll k) {\n    return k * u - k * (k - 1) / 2;\n}\n \nvoid solve() {\n    int n;cin &gt;&gt; n;\n    vector&lt;ll&gt;a(n + 1);\n    vector&lt;ll&gt;pre(n + 1);\n    pre[0] = 0;a[0] = 0;\n    for (int i = 1;i &lt;= n;i++) {\n        cin &gt;&gt; a[i];\n        pre[i] = pre[i - 1] + a[i];\n    }\n    int q;cin &gt;&gt; q;\n    while (q--) {\n        ll l, u;cin &gt;&gt; l &gt;&gt; u;\n        ll x = pre[l - 1];\n        int ru = upper_bound(pre.begin() + l, pre.end(), x + u) - pre.begin() - 1;\n        ll ans = a[l], ansr = l;\n        if (ru &gt;= l &amp;&amp; ru &lt;= n) {\n            if (f(u, pre[ru] - x) &gt; ans) {\n                ans = f(u, pre[ru] - x);\n                ansr = ru;\n            }\n        }\n        int ru1 = lower_bound(pre.begin() + l, pre.end(), x + u + 1) - pre.begin();\n        if (ru1 &gt;= l, ru1 &lt;= n) {\n            if (f(u, pre[ru1] - x) &gt; ans) {\n                ans = f(u, pre[ru1] - x);\n                ansr = ru1;\n            }\n        }\n        cout &lt;&lt; ansr &lt;&lt; &#039; &#039;;\n    }\n    cout &lt;&lt; &#039;\\n&#039;;\n}"},"03-algorithm/cfround930div2":{"slug":"03-algorithm/cfround930div2","filePath":"03-algorithm/cfround930div2.md","title":"💭Codeforces Round 930(div2)","links":[],"tags":["算法","CF"],"content":"A-Shuffle Party\n题意\n对一个数组，起初是a_i=i\n对操作swap(k)：\n设d是不等于k本身的k的最大除数，然后交换元素a_d和a_k。\n按顺序对每一个i=2,3,..,n进行swap(i)之后，找出1在数组中的位置。\n数据范围\nt(1≤t≤10^4)\nn(1≤n≤10^9)​\n思路\n简单模拟之后可以发现，a_1=1最后会挪到不大于n的最大2的次幂处。\n参考代码\nvoid solve() {\n    vector&lt;ll&gt;p;\n    ll x = 1;\n    while (x &lt;= 1e9) {\n        p.push_back(x);\n        x *= 2;\n    }\n    int t;cin &gt;&gt; t;\n    while(t--){\n        ll n;cin &gt;&gt; n;\n        ll ans = upper_bound(p.begin(), p.end(), n) - p.begin();\n        cout &lt;&lt; p[ans - 1] &lt;&lt; endl;\n    }\n}\nB-Binary Path\n题意\n一个2\\times n网格，网格充满0,1，找一条从(1,1)走到(2,n)的路径，要求找到字典序最小的路径并找到这个最小路径的路径数。\n数据范围\nt(1≤t≤10^4)\nn(2≤n≤2\\times 10^5)​\n思路\n路径的组成是第一行的前部分+第二行的后部分，长度是n+1。对从第一行到第二行的转折的位置进行枚举，假设往后一位可以获得字典序更小的则重新计数，若相同则累计路径数，若不同则代表没有更好的路径。\n参考代码\nvoid solve() {\n    int n;cin &gt;&gt; n;\n    vector&lt;string&gt;s(2);\n    cin &gt;&gt; s[0] &gt;&gt; s[1];\n    string st = s[0] + s[1];\n    ll cnt = 1;\n    ll ix = 2;\n    for (int i = 2;i + n - 2 &lt; 2 * n - 1;i++) {\n        ll j = i + n - 2;//[i,j]\n        if (st[i - 1] == &#039;0&#039; &amp;&amp; st[j] == &#039;1&#039;) {\n            cnt = 1;\n            ix = i;\n        }\n        else if (st[i - 1] == st[j]) {\n            cnt++;\n        }\n        else {\n            break;\n        }\n    }\n \n    string res = st.substr(0, ix) + st.substr(ix + n - 1);\n    string res1 = s[0][0] + s[1];\n    if (res1 &lt; res)res = res1;\n \n    cout &lt;&lt; res &lt;&lt; &#039;\\n&#039;;\n    cout &lt;&lt; cnt &lt;&lt; &#039;\\n&#039;;\n}\nC-Bitwise Operation Wizard\n题意\n交互题。\n对一个神秘序列p_0,p_1,...,p_{n-1}（是\\{0,1,...,n-1\\}的排列组合）。我们通过询问需要获得p_i\\oplus p_j最大的一个(i,j)对。\n每次询问任意索引(a,b,c,d)评审团计算x=(p_a|p_b)和y=(p_c|p_d)，并告知是x\\lt y,x\\gt y还是x=y。最多使用3n个查询。\n数据范围\nt(1≤t≤1000)\nn(2≤n≤10^4)​\n思路\n先两两比较找到最大的数，再找到与最大的数异或的结果最大的另一个数。\n参考代码\nchar r;\nchar ask(int a, int b, int c, int d) {\n    cout &lt;&lt; &quot;? &quot; &lt;&lt; a &lt;&lt; &#039; &#039; &lt;&lt; b &lt;&lt; &#039; &#039; &lt;&lt; c &lt;&lt; &#039; &#039; &lt;&lt; d &lt;&lt; endl;\n    cin &gt;&gt; r;\n    return r;\n}\n \nvoid solve() {\n    int n;cin &gt;&gt; n;\n    int pm = 0;\n    // 找n-1\n    for (int i = 1;i &lt; n;i++) {\n        if (ask(pm, pm, i, i) == &#039;&lt;&#039;) {\n            pm = i;\n        }\n    }\n    // 另一个数pn：与pm取或大于pm的最小值\n    int pn = 0;\n    for (int i = 1;i &lt; n;i++) {\n        ask(pm, i, pm, pn);\n        if (r == &#039;&gt;&#039;) {\n            pn = i;\n        }\n        else if (r == &#039;=&#039; &amp;&amp; ask(i, i, pn, pn) == &#039;&lt;&#039;) {\n            pn = i;\n        }\n    }\n    cout &lt;&lt; &quot;! &quot; &lt;&lt; pm &lt;&lt; &quot; &quot; &lt;&lt; pn &lt;&lt; endl;\n}"},"03-algorithm/cfround931div2":{"slug":"03-algorithm/cfround931div2","filePath":"03-algorithm/cfround931div2.md","title":"💭Codeforces Round 931(div2)","links":[],"tags":["算法","CF"],"content":"A-Too Min Too Max\n题意\n对一个数组，找到索引(i,j,k,l)使得|a_i-a_j|+|a_j-a_k|+|a_k-a_l|+|a_l-a_i|最大的值。\n数据范围\nt(1≤t≤500)\nn(4≤n≤100)​\na_i(-10^6\\le a_i\\le 10^6)\n思路\n选则最大的两个数和最小的两个数，结果为最大-最小+次大-最小+最大-次小+次大-次小。\n参考代码\nvoid solve() {\n    int n;cin &gt;&gt; n;\n    vector&lt;ll&gt;a(n);\n    for (int i = 0;i &lt; n;i++)\n        cin &gt;&gt; a[i];\n    sort(a.begin(), a.end());\n    cout &lt;&lt; a[n - 1] - a[0] + a[n - 2] - a[0] + a[n - 1] - a[1] + a[n - 2] - a[1] &lt;&lt; &#039;\\n&#039;;\n}\nB-Yet Another Coin Problem\n题意\n有一些5种不同面值的金币，面值有：1,3,6,10,15。找到使用金币数目最少的组合方式达到数值为n的组合。\n数据范围\nt(1≤t≤10^4)\nn(1≤n≤10^9)​\n思路\n打表。\n参考代码\nvoid solve() {\n    ll n;cin &gt;&gt; n;\n    vector&lt;ll&gt;p = { 0,\n    1,2,1,2,3,1,2,3,2,1,\n    2,2,2,3,1,2,3,2,3,2,\n    2,3,3,3,2,3,3,3,4,2\n    };\n    ll ans = n / 15 + p[n % 15];\n    if (n / 15 &gt; 0)\n        ans = min(ans, n / 15 - 1 + p[n % 15 + 15]);\n    cout &lt;&lt; ans &lt;&lt; endl;\n \n}\nC-Find a Mine\n题意\n交互题。\nn\\times m的地图有两个地雷，每次询问一个坐标点，评审机会返回距离询问点最近的地雷的与询问点的曼哈顿距离。\n数据范围\nt(1≤t≤3\\times 10^3)\nn,m (2≤n≤10^8,2\\le m\\le 10^8)​\n思路\n第一次询问可以获得一条斜线，斜线上至少有一个地雷。\n第二次询问可能可以找到正好一个交点，这个交点可能正好是地雷或者是两个地雷的行列序号的组合。再做第三次询问，得到两个交点至少有一个是地雷。第四次询问即可排除。\n参考代码\nbool f = false;\n \nint ask(int x, int y) {\n    cout &lt;&lt; &quot;? &quot; &lt;&lt; x &lt;&lt; &#039; &#039; &lt;&lt; y &lt;&lt; endl;\n    int res;cin &gt;&gt; res;\n    if (res == 0) {\n        cout &lt;&lt; &quot;! &quot; &lt;&lt; x &lt;&lt; &#039; &#039; &lt;&lt; y &lt;&lt; endl;\n        f = true;\n    }\n \n    return res;\n}\n \nvoid solve() {\n    int n, m;cin &gt;&gt; n &gt;&gt; m;\n    f = false;\n \n    int x1 = ask(1, 1);\n    if (f) { return; }\n \n    int x2 = ask(1, m);\n    if (f) { return; }\n \n    int x3 = ask(n, 1);\n    if (f) { return; }\n \n    int x, y;\n    if (x2 + x3 == n + m - 2) {\n        // 同一条斜线\n        y = (x1 + x3 - n + 1) / 2;\n        x = x1 - y;\n        x += 1;y += 1;\n        cout &lt;&lt; &quot;! &quot; &lt;&lt; x &lt;&lt; &#039; &#039; &lt;&lt; y &lt;&lt; endl;\n        return;\n    }\n    else if ((n + m - x2 - x3) % 2 != 0) {\n        // 有一个交点\n        if ((x1 + x2 - m + 1) % 2 == 0) {\n            x = (x1 + x2 - m + 1) / 2;\n            y = x1 - x;\n            x += 1;y += 1;\n            cout &lt;&lt; &quot;! &quot; &lt;&lt; x &lt;&lt; &#039; &#039; &lt;&lt; y &lt;&lt; endl;\n        }\n        else {\n            y = (x1 + x3 - n + 1) / 2;\n            x = x1 - y;\n            x += 1;y += 1;\n            cout &lt;&lt; &quot;! &quot; &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl;\n        }\n \n        return;\n    }\n \n    y = (x1 + x3 - n + 1) / 2;\n    x = x1 - y;\n    x += 1;y += 1;\n \n    if (x &lt; 1 || x &gt; n || y &lt; 1 || y &gt; m) {\n        f = true;\n    }\n    if (!f) {\n        int x4 = ask(x, y);\n        if (f) { return; }\n    }\n \n    x = (x1 + x2 - m + 1) / 2;\n    y = x1 - x;\n    x += 1;y += 1;\n    cout &lt;&lt; &quot;! &quot; &lt;&lt; x &lt;&lt; &#039; &#039; &lt;&lt; y &lt;&lt; endl;\n}"},"03-algorithm/cfround932div2":{"slug":"03-algorithm/cfround932div2","filePath":"03-algorithm/cfround932div2.md","title":"💭Codeforces Round 932(div2)","links":[],"tags":["算法","CF"],"content":"A-Entertainment in MAC\n题意\n可以对一个字符串进行两种操作：\n\n将字符串反转\n将该字符串反转后接在原串的后面。\n\n可以进行任意次上述操作，获得字典序最小的字符串。\n数据范围\nt(1≤t≤500)\nn(2≤n≤10^9)​\ns(1\\le |s|\\le 100)\n思路\n对比反转前后的字符串字典序大小，再决定是操作1还是操作2\n参考代码\nvoid solve() {\n    ll n;cin &gt;&gt; n;\n    string s;cin &gt;&gt; s;\n    string t = s;\n    reverse(t.begin(), t.end());\n    if (s &gt; t) {\n        cout &lt;&lt; t &lt;&lt; s &lt;&lt; endl;\n    }\n    else {\n        cout &lt;&lt; s &lt;&lt; endl;\n    }\n}\nB-Informatics in MAC\n题意\nMEX：不属于该数组的最小非负整数。\n对一个数组分成k个子段，要求每段的MEX都等于相同的数。\n找到这样的子段分法，或者报告不存在合法的分法。\n数据范围\nt(1≤t≤10^4)\nn(2≤n≤10^5)​\na_i(0\\le a_i\\lt n)\n思路\n假设MEX=2，则分成k段的方式为前k-1段只要都出现过0,1就进行分段，最后一段保证含0,1和达到第n个数。\n确定MEX：遍历数组a，找到最小的没有出现过的数（该数不大于n），该数即为MEX。\n参考代码\n// MEX:不属于该数组的最小非负整数\n \nvoid solve() {\n    ll n;cin &gt;&gt; n;\n    vector&lt;ll&gt;a(n + 1);\n    vector&lt;bool&gt;ck(n + 1, false);\n    for (int i = 1;i &lt;= n;i++) {\n        ll x;cin &gt;&gt; x;\n        a[i] = x;\n        ck[x] = true;\n    }\n \n    bool f = false;\n    int y = -1;\n    for (int i = 0;i &lt; n;i++) {\n        if (ck[i] == false) {\n            y = i;\n            f = true;\n            break;\n        }\n    }\n \n    if (!f) {\n        cout &lt;&lt; -1 &lt;&lt; endl;\n        return;\n    }\n \n    // MEX=y\n    // cout &lt;&lt; y &lt;&lt; endl;\n    if (y == 0) {\n        cout &lt;&lt; n &lt;&lt; endl;\n        for (int i = 1;i &lt;= n;i++) {\n            cout &lt;&lt; i &lt;&lt; &#039; &#039; &lt;&lt; i &lt;&lt; endl;\n        }\n        return;\n    }\n \n    int p = 1;\n    int cnt = 0;\n    vector&lt;pair&lt;int, int&gt;&gt;ans;\n    vector&lt;bool&gt;hs(y, false);\n    vector&lt;bool&gt;hsf(y, false);\n    for (int i = 1;i &lt;= n;i++) {\n        if (a[i] &lt; y &amp;&amp; !hs[a[i]]) {\n            hs[a[i]] = true;\n            cnt++;\n        }\n        if (cnt == y) {\n            ans.push_back({ p, i });\n            p = i + 1;\n            cnt = 0;\n            // 会不会Tle\n            hs = hsf;\n        }\n    }\n \n    if (ans.size() == 1) {\n        cout &lt;&lt; -1 &lt;&lt; endl;\n        return;\n    }\n \n    cout &lt;&lt; ans.size() &lt;&lt; endl;\n    for (int i = 0;i &lt; ans.size();i++) {\n        if (i != ans.size() - 1)\n            cout &lt;&lt; ans[i].first &lt;&lt; &quot; &quot; &lt;&lt; ans[i].second &lt;&lt; endl;\n        else {\n            cout &lt;&lt; ans[i].first &lt;&lt; &quot; &quot; &lt;&lt; n &lt;&lt; endl;\n        }\n    }\n \n}\nD-Exam in MAC\n题意\n有一个集合s。\n找到满足0\\le x\\le y\\le c且x+y和y-x均不包含在集合s中的整数对(x,y)的个数。\n数据范围\nt(1≤t≤2\\times 10^4)\nn(1≤n≤3\\times 10^5)​\nc(1\\le c\\le 10^9)\n思路\n容斥。\n合格的整数对=满足x+y\\in s+满足y-x\\in s-既满足x+y\\in s又满足y-x\\in s。\n参考代码\nvoid solve() {\n    ll n, c;cin &gt;&gt; n &gt;&gt; c;\n    ll tot = (c + 1) * (c + 2) / 2;\n    ll cnt0 = 0, cnt1 = 0;\n    for (ll i = 0;i &lt; n;i++) {\n        ll x;cin &gt;&gt; x;\n        tot -= x / 2 + 1;\n        tot -= c + 1 - x;\n        if (x &amp; 1)cnt1++;\n        else cnt0++;\n    }\n    tot += (cnt0 + 1) * cnt0 / 2 + cnt1 * (cnt1 + 1) / 2;\n    cout &lt;&lt; tot &lt;&lt; endl;\n}"},"03-algorithm/cfround933div3":{"slug":"03-algorithm/cfround933div3","filePath":"03-algorithm/cfround933div3.md","title":"💭Codeforces Round 933(div3)","links":[],"tags":["算法","CF"],"content":"A-Rudolf and the Ticket\n题意\n左边口袋有一些面值为b_1,b_2,b_3,...,b_n的硬币，右边有一些面值为c_1,c_2,c_3,...,c_m的硬币，问有多少个(f,s)可以使得b_f+c_s\\le k成立\n数据范围\nt(1≤t≤100)\nn,m(1≤n,m≤100)\nk(1\\le k\\le 2000)\nb_i,c_i(1\\le b_i,c_i\\le 1000)\n思路\n双层循环遍历\n参考代码\nvoid solve() {\n    ll n, m, k;cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;\n    vector&lt;ll&gt;b(n), c(m);\n    for (ll i = 0; i &lt; n; i++) cin &gt;&gt; b[i];\n    for (ll i = 0; i &lt; m; i++) cin &gt;&gt; c[i];\n    ll ans = 0;\n    sort(b.begin(), b.end());\n    sort(c.begin(), c.end());\n    for (ll i = 0;i &lt; n;i++) {\n        for (ll j = 0;j &lt; m;j++) {\n            if (b[i] + c[j] &lt;= k) {\n                ans++;\n            }\n            else { break; }\n        }\n    }\n    cout&lt;&lt;ans&lt;&lt;endl;\n}\nB-Rudolf and 121\n题意\n可以对一个数组执行如下操作：\n选中一个索引i(2\\le i\\le n-1)：\n\na_{i-1}=a_{i-1}-1\na_i=a_i-2\na_{i+1}=a_{i+1}-1​\n\n询问是否可以通过这个运算使得所有元素变为0\n数据范围\nt(1≤t≤10^4)\nn(3≤n≤2\\times 10^5)​\na_i(0\\leq a_i\\le 10^9)\n思路\n从左向右遍历，若有大于0的数则对其进行置零，且更新其后一位和两位的数值，直到出现负数或无法执行为止。检查操作后的a数组是否符合要求\n参考代码\nvoid solve() {\n    ll n;cin &gt;&gt; n;\n    vector&lt;ll&gt;a(n);\n    for (ll i = 0;i &lt; n;i++) {\n        cin &gt;&gt; a[i];\n    }\n    for (ll i = 0;i &lt; n;i++) {\n        if (a[i] &lt; 0) {\n            cout &lt;&lt; &quot;NO\\n&quot;; return;\n        }\n        if (a[i] &gt; 0) {\n            if(i+2&lt;n){\n                a[i + 1] -= 2 * a[i];\n                a[i + 2] -= a[i];\n                a[i] = 0;\n            }\n            else {\n                cout &lt;&lt; &quot;NO\\n&quot;;return;\n            }\n        }\n    }\n    cout &lt;&lt; &quot;YES\\n&quot;;\n}\nC-Rudolf and the Ugly String\n题意\n对字符串s，询问至少需要多少次删除字符的操作可以使得字符串中没有子段map和pie。\n数据范围\nt(1≤t≤10^4)\nn(1≤n≤10^6)​\n思路\n先查询子段mapie的数量，并删去字符p，再对剩下的字符串中存在的map和pie进行计数。\n参考代码\nvoid solve() {\n    ll n;cin &gt;&gt; n;\n    string s;cin &gt;&gt; s;\n    int p = s.find(&quot;mapie&quot;);\n    ll cnt = 0;\n    while (p != -1) {\n        s[p + 2] = &#039;x&#039;;\n        p = s.find(&quot;mapie&quot;, p + 1);\n        cnt++;\n    }\n    p = s.find(&quot;map&quot;);\n    while (p != -1) {\n        s[p + 2] = &#039;x&#039;;\n        p = s.find(&quot;map&quot;, p + 1);\n        cnt++;\n    }\n    p = s.find(&quot;pie&quot;);\n    while (p != -1) {\n        s[p] = &#039;x&#039;;\n        p = s.find(&quot;pie&quot;, p + 1);\n        cnt++;\n    }\n    cout &lt;&lt; cnt &lt;&lt; endl;\n}\nD-Rudolf and the Ball Game\n题意\n扔球游戏，n个人围成一圈，每次球可以选择顺时针或逆时针传球r_i(1\\le r_i \\le n-1)个单位，已知起始球的位置和每次传递的距离，以及部分时刻传球的方向。询问最后球到了谁的手上。\n数据范围\nt(1≤t≤10^4)\nn,m(1≤n≤1000,1\\le m\\le 1000)\nx(1\\le x\\le n)​\nr_i(1\\le r_i\\le n-1)\n思路\n按题意模拟即可，每次记录球的所有可能位置，并更新。\n参考代码\nvoid solve() {\n    ll n, m, x;cin &gt;&gt; n &gt;&gt; m &gt;&gt; x;\n    set&lt;ll&gt;xi;\n    xi.insert(x);\n    for (ll i = 0;i &lt; m;i++) {\n        ll r;string c;cin &gt;&gt; r &gt;&gt; c;\n        if (c == &quot;?&quot;) {\n            set&lt;ll&gt;yi;\n            for (auto j : xi) {\n                ll b1 = (j + r) % n, b2 = (j - r + n) % n;\n                if (b1 == 0) b1 = n;\n                if (b2 == 0) b2 = n;\n                yi.insert(b1);yi.insert(b2);\n            }\n            xi = yi;\n        }\n        else if (c == &quot;1&quot;) {\n            set&lt;ll&gt;yi;\n            for (auto j : xi) {\n                ll b1 = (j - r + n) % n;\n                if (b1 == 0) b1 = n;\n                yi.insert(b1);\n            }\n            xi = yi;\n        }\n        else {\n            set&lt;ll&gt;yi;\n            for (auto j : xi) {\n                ll b2 = (j + r) % n;\n                if (b2 == 0) b2 = n;\n                yi.insert(b2);\n            }\n            xi = yi;\n        }\n    }\n    cout &lt;&lt; xi.size() &lt;&lt; endl;\n    for (auto i : xi) {\n        cout &lt;&lt; i &lt;&lt; &quot; &quot;;\n    }cout &lt;&lt; &#039;\\n&#039;;\n}\nE-Rudolf and k Bridges\n题意\n需要在一条河上建桥，每个位置建立桥墩的花费是a_{i,j}+1，a_{i+j}是到水面的深度。桥要求宽为k，任意两个桥墩的距离不能超过d，桥的首尾都需要有支架。\n数据范围\nt(1≤t≤1000)\nn,k(1≤k\\le n≤100)​\nm(3\\le m\\le 2\\times 10^5)\n思路\n对每一行进行DP，可以获得每一行建桥的最小花费。再对其求前缀和，找到总花费最小的连续k段。\n进行DP状态转移时，需要优先选中距离不大于d的桥墩点中，花费最小的桥墩。\n参考代码\nvoid solve() {\n    ll n, m, k, d;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; d;\n    vector&lt;vector&lt;ll&gt;&gt;a(n, vector&lt;ll&gt;(m));\n    for (ll i = 0;i &lt; n;i++) {\n        for (ll j = 0;j &lt; m;j++) {\n            cin &gt;&gt; a[i][j];\n            a[i][j] += 1;\n        }\n    }\n    // 每行dp\n    vector&lt;ll&gt;spd(n, 0);\n    for (ll ni = 0;ni &lt; n;ni++) {\n        vector&lt;ll&gt;dp(m, 0);\n        for (ll i = 0;i &lt; m;i++) {\n            dp[i] = a[ni][i];\n        }\n        // 维护前d个值中的最小值\n        queue&lt;ll&gt;q1;\n        deque&lt;ll&gt;qmin;\n        q1.push(dp[0]);\n        qmin.push_back(dp[0]);\n \n        for (ll i = 1;i &lt; m;i++) {\n            if (i == 1)\n                dp[i] += dp[0];\n            else {\n                ll mn = qmin.front();\n                dp[i] = mn + dp[i];\n            }\n \n            if (q1.size() == d + 1) {\n                if (q1.front() == qmin.front()) {\n                    qmin.pop_front();\n                }\n                q1.pop();\n            }\n            q1.push(dp[i]);\n            while (!qmin.empty() &amp;&amp; dp[i] &lt; qmin.back()) {\n                qmin.pop_back();\n            }\n            qmin.push_back(dp[i]);\n        }\n        spd[ni] = dp[m - 1];\n    }\n \n    vector&lt;ll&gt;sum(n + 1, 0);\n    sum[0] = 0;\n    for (ll i = 1;i &lt;= n;i++) {\n        sum[i] = sum[i - 1] + spd[i - 1];\n    }\n    ll ans = sum[k];\n    for (ll i = k;i &lt;= n;i++) {\n        ans = min(ans, sum[i] - sum[i - k]);\n    }\n    cout &lt;&lt; ans &lt;&lt; endl;\n}"},"03-algorithm/cfround977div2":{"slug":"03-algorithm/cfround977div2","filePath":"03-algorithm/cfround977div2.md","title":"💭Codeforces Round 977 (Div. 2, based on COMPFEST 16 - Final Round)","links":[],"tags":["算法","CF"],"content":"A. Meaning Mean\n题意\n可以选择 2 个不同的索引i,j，将数组中这两个索引对应的数删除，然后将\\lfloor \\frac{a_i+a_j}{2} \\rfloor添加到数组的最后。可知到最后只会剩下一个数，最大化最后剩余的这个数x，并输出。\n数据范围\n\n2\\leq n \\leq 50\n1\\leq a_i\\leq 10^9\n\n思路\n考虑三个数a\\lt b\\lt c时，按照各种顺序合并的情况下，\\lfloor \\frac{\\lfloor \\frac{a+b}{2} \\rfloor+c}{2}\\rfloor是最好的操作。\n参考代码\nll a[maxn];\n \nvoid solve() {\n  int n;\n  cin &gt;&gt; n;\n  for (int i = 1; i &lt;= n; i++) {\n    cin &gt;&gt; a[i];\n  }\n  sort(a + 1, a + 1 + n);\n  ll tot = a[1];\n  for (int i = 2; i &lt;= n; i++) {\n    ll x = a[i];\n    tot = (tot + x) / 2;\n  }\n  cout &lt;&lt; tot &lt;&lt; &#039;\\n&#039;;\n}\nB. Maximize Mex\n题意\n对一个给定的数组a和给定的数x，可以进行如下操作：\n\n选择一个索引，a_i:=a_i + x。\n\n可以执行这个操作任意次，询问这个数组最大的MEX值是多少。\n数据范围\n\n1\\leq t\\leq 5000\n1\\leq n\\leq 2\\times 10^5\n0\\leq x\\leq 10^9\n\n思路\n赛后再交发现 T 了…剪枝优化了一下。\n首先容易观察到，a_i:=a_i + x的操作不会改变a_i所属的模x的同余系，在把a按照模x的值进行分组之后，对每个组，check 对应集合中是否能满足[1, n-1]的范围内的a_i都存在，遍历时，计数a_i=k\\times x + (a_i \\mod x)的k的数量，如果k从0到\\lfloor \\frac{n-1}{x}\\rfloor + ((n-1) \\mod x &gt;= a_i \\mod x)每一位都满足\\sum_0^{k_i} cnt[k_i] \\gt k_i，则说明同余集合中到ki\\times x+a_i\\mod x的值都是可以满足的。\n最后检测一下vis数组，寻找mex。\n参考代码\nll a[maxn];\nbool vis[maxn];\nvoid solve() {\n  ll n, x;\n  cin &gt;&gt; n &gt;&gt; x;\n  for (int i = 0; i &lt;= n; i++) {\n    vis[i] = false;\n  }\n  map&lt;ll, vector&lt;ll&gt;&gt; mp;\n  for (int i = 1; i &lt;= n; i++) {\n    cin &gt;&gt; a[i];\n    mp[a[i] % x].push_back(a[i]);\n  }\n \n  for (auto &amp;[i, v] : mp) {\n    sort(v.begin(), v.end());\n    ll tot = (n - 1) / x;\n    if ((n - 1) % x &gt;= i)\n      tot += 1;\n \n    vector&lt;ll&gt; cnt(tot, 0);\n    for (auto j : v) {\n      if ((j - i) / x &lt; tot) {\n        cnt[(j - i) / x]++;\n      } else {\n        break;\n      }\n    }\n    ll sum = 0ll;\n    for (int j = 0; j &lt; tot; j++) {\n      sum += cnt[j];\n      if (sum &lt;= j) {\n        break;\n      }\n      vis[j * x + i] = true;\n    }\n  }\n \n  for (int i = 0; i &lt;= n; i++) {\n    if (!vis[i]) {\n      cout &lt;&lt; i &lt;&lt; &#039;\\n&#039;;\n      return;\n    }\n  }\n}\nC. Adjust The Presentation (Easy Version &amp;&amp; Hard Version)\n题意\nn个人排成一队，依次播放m张幻灯片，当一个人播放过幻灯片之后，可以重新将他插入任意的位置，或者留在队首播放下一张幻灯片。每张幻灯片都有一个最佳播放者，如果所有的幻灯片都由其最佳播放者播放，则整个播放是完美的，输出YA，否则输出TIDAK。询问是否可以通过调整，使得所有的幻灯片都完美播放。\n同时支持q次修改幻灯片的最佳播放者，询问每次修改之后的播放效果，输出YA或TIDAK。\n数据范围\n\n1 \\leq t\\leq 10^4\n1\\leq n,m \\leq 2\\times 10^5\n0\\leq q\\leq 2\\times 10^5\n1\\leq a_i,b_i\\leq n\n1\\leq s_i\\leq m,1\\leq t_i\\leq n\n\n思路\n幻灯片i是否能被最佳播放者播放，只需要保证其播放者s_i在播放i时或之前出现，也就是说，如果数组b中每个编号最先出现的次序排序后，若恰好是a的前缀，则是可以满足的。\n差分数组计数a数组中第i个数a[i]在b中最先出现次序排序后的次序是否大于等于前一个数，即是否上升。利用set更新b中每个编号最先出现的位置。\n每次b_{s_i}:=t_i操作后，更新检查编号b[s_i]前后编号的新次序是否合法（与a中b[s_i]的前一位置的编号的最早位置相比是否上升），编号t_i前后是否合法，更新diff数组和sum值。\nll a[maxn], b[maxn], pos[maxn], diff[maxn];\nvector&lt;set&lt;ll&gt;&gt; st;\n \nvoid YorT(bool f) { f ? cout &lt;&lt; &quot;YA\\n&quot; : cout &lt;&lt; &quot;TIDAK\\n&quot;; }\n \nvoid solve() {\n  int n, m, q;\n  cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;\n \n  st.assign(n + 1, set&lt;ll&gt;());\n \n  for (int i = 1; i &lt;= n; i++) {\n    cin &gt;&gt; a[i];\n    pos[a[i]] = i;\n    st[i].insert(m + 1);\n    diff[i] = 0;\n  }\n  for (int i = 1; i &lt;= m; i++) {\n    cin &gt;&gt; b[i];\n    st[b[i]].insert(i);\n  }\n \n  auto check = [&amp;](int s) { // 检查a[s-1] -&gt; a[s]的合法情况,是否上升\n    if (s == 1 || s &gt; n)\n      return 0;\n    int res = 0;\n    if (diff[s] &amp;&amp; !(*st[a[s - 1]].begin() &lt;= *st[a[s]].begin())) {\n      diff[s] = 0;\n      res = -1;\n    } else if (!diff[s] &amp;&amp; *st[a[s - 1]].begin() &lt;= *st[a[s]].begin()) {\n      diff[s] = 1;\n      res = 1;\n    }\n    return res;\n  };\n \n  ll sum = 0ll;\n  for (int i = 2; i &lt;= n; i++) {\n    sum += check(i);\n  }\n \n  YorT(sum == n - 1);\n \n  while (q--) {\n    int s, t;\n    cin &gt;&gt; s &gt;&gt; t;\n    st[b[s]].erase(s);\n    st[t].insert(s);\n    sum += check(pos[b[s]]) + check(pos[b[s]] + 1) + check(pos[t]) +\n           check(pos[t] + 1);\n    b[s] = t;\n    YorT(sum == n - 1);\n  }\n}\nD. Boss, Thirsty\nE1. Digital Village (Easy Version) &amp;&amp; (Hard Version)\n题意\n居民房屋构成一个无向图，包含n个点m条边，其中p户需要网络服务，可以在任意的房屋中安置交换机，房屋s_i与交换机所在房屋s_j之间的延迟是s_i到s_j的简单路径上最大的延迟。可以任意选择放置交换机的位置，询问在逐渐增加交换机的过程中，所有需要网络服务的居民的最小总延迟。\n数据范围\n\n1\\leq t \\leq 2000\n2\\leq n,\\leq 5000\nn-1\\leq m \\leq 5000\n1\\leq p \\leq n\n1\\leq s\\leq n\n1\\leq u_i\\lt w_i\\leq n;1\\leq w_i\\leq 10^9\n\n思路\n参考代码"},"03-algorithm/cfround980div2":{"slug":"03-algorithm/cfround980div2","filePath":"03-algorithm/cfround980div2.md","title":"💭Codeforces Round 980 (Div. 2)","links":[],"tags":["算法","CF"],"content":"A. Profitable Interest Rate\n题意\n有两种储值方式——无利可图和盈利，“盈利”可以保证盈利，但是有最低储值要求，“无利可图”类型没有利息，但是可以让“盈利”的最低储值降低。在“无利可图”储值x元，可以让“盈利”的最低值要求降低2\\times x元，最低储值不能低于0元，两种储值均不能取出。现在Alice拥有a元，并想使存入“盈利”的金额越多越好，求Alice最多存入多少“盈利”类型的金额。\n数据范围\n\n1\\leq t\\leq 10^4\n1\\leq a,b\\leq 10^9\n\n思路\n假设存入x元在“无利可图”，则“盈利”的最低储值降为b-2\\times x，此时如果Alice的剩余金额a-x可以达到最低储值，则答案为a-x，否则为0，最小化x即可。\n参考代码\nvoid solve() {\n  ll a, b;\n  cin &gt;&gt; a &gt;&gt; b;\n  ll x = max(0ll, b - a);\n  ll ans = max(0ll, a - x);\n  cout &lt;&lt; ans &lt;&lt; &#039;\\n&#039;;\n}\nB. Buying Lemonade\n题意\n柠檬水售卖机有n个按钮，但是无法辨认每个按钮对应的槽位还剩多少柠檬水，购买者知道每个槽位最初的柠檬水数量，每按下一个按钮，如果该按钮对应的槽位还有柠檬水，则可以售出1瓶柠檬水，若槽位为空，则将没有任何东西掉出来。现在需要精确购买k瓶柠檬水，保证柠檬水售卖机里有足够的柠檬水，即\\sum_{i=1}^{n} a_i \\ge k。求问最少的可以保证达成任务的点击次数。\n数据范围\n\n1\\leq t\\leq 10^4\n1\\leq n\\leq 2\\times 10^5\n1\\leq k\\leq 10^9\n1\\leq a_i\\leq 10^9\n\nn之和不超过2\\times 10^5。\n思路\n基本的贪心购买思路是一直按同一个按钮，直到该槽位为空，考虑到购买k瓶至少需要k次基本点击，我们需要最小化会浪费的点击次数，即点空槽位的次数。\n假设当前每个槽位都至少有2瓶柠檬水，我们想最小化点空的次数，最好先把每个按钮都点击2次，如果此时的总数足够k，我们就计数次数，否则去掉空槽位（通过 1 次点击去除），我们要继续最小化。\n二分在每个按钮点击的次数，查询能买到的柠檬水总数，计数最少的次数，即第一个满足总数大于等于k的那个次数。\n参考代码\nll a[maxn];\n \nvoid solve() {\n  ll n, k;\n  cin &gt;&gt; n &gt;&gt; k;\n  for (ll i = 1; i &lt;= n; i++) {\n    cin &gt;&gt; a[i];\n  }\n  sort(a + 1, a + 1 + n);\n \n  auto get_cnt = [&amp;](ll cnt) {\n    ll ret = 0ll, tot = 0ll;\n    for (ll i = 1; i &lt;= n; i++) {\n      if (a[i] &lt; cnt) {\n        if (tot + a[i] &lt; k) {\n          ret += a[i] + 1;\n          tot += a[i];\n        } else {\n          ret += k - tot;\n          break;\n        }\n      } else {\n        if (tot + cnt &lt; k) {\n          ret += cnt;\n          tot += cnt;\n        } else {\n          ret += k - tot;\n          break;\n        }\n      }\n    }\n    return ret;\n  };\n  auto get_lemonade = [&amp;](ll cnt) {\n    ll tot = 0ll;\n    for (ll i = 1; i &lt;= n; i++) {\n      if (a[i] &lt; cnt) {\n        tot += a[i];\n      } else {\n        tot += cnt;\n      }\n    }\n    return tot;\n  };\n \n  // 可以获得k的第一个次数的下标\n  ll l = 1, r = n;\n  while (l &lt; r) {\n    ll mid = l + (r - l) / 2;\n    if (get_lemonade(a[mid]) &lt; k) {\n      l = mid + 1;\n    } else {\n      r = mid;\n    }\n  }\n  ll ans = get_cnt(a[l]);\n  cout &lt;&lt; ans &lt;&lt; &#039;\\n&#039;;\n}\nC. Concatenation of Arrays\n题意\n有n个二元组，将这些二元组重新排序后让序列的逆序数最小，输出排序后的结果。\n数据范围\n\n1\\leq t\\leq 10^4\n1\\leq n\\leq 10^5\n1\\leq a_{i,j}\\leq 10^9\n\n思路\n排序，将二元组按照两数之和、第一位数、第二位数的优先级顺序从小到大排序。\n参考代码\nvoid solve() {\n  ll n;\n  cin &gt;&gt; n;\n  vector&lt;pll&gt; v;\n  for (ll i = 1; i &lt;= n; i++) {\n    pll p;\n    cin &gt;&gt; p.first &gt;&gt; p.second;\n    v.push_back(p);\n  }\n  sort(v.begin(), v.end(), [&amp;](pll p1, pll p2) {\n    return make_tuple(p1.first + p1.second, p1.first, p1.second) &lt;\n           make_tuple(p2.first + p2.second, p2.first, p2.second);\n  });\n  for (auto i : v) {\n    cout &lt;&lt; i.first &lt;&lt; &#039; &#039; &lt;&lt; i.second &lt;&lt; &#039; &#039;;\n  }\n  cout &lt;&lt; &#039;\\n&#039;;\n}\nD. Skipping\n题意\n问答系统，对第i个题，如果选择回答，可以获得a_i分数，接下来只能选择序号j\\lt i且没有操作过的问题。也可以选择跳过，接下来可以选择j\\leq b_i的未操作过的题目。从1号问题开始回答。\n思路\n注意到，当跳到索引i时，所有1\\leq k\\leq i的没有回答过的题目，都可以通过依次回答。我们只需要贪心的选择前置和-到达某个位置的最小代价即可。\n考虑用一个全局multiset维护当前可以使用的代价，从1号问题开始，每个问题的b_i指向一个到b_i+1会“失效”的最小代价，每次移动时去除失效代价，并加入新的最小代价，维护最大得分即可。\n维护时可以注意到b_i\\leq i的跳题没有意义，不如直接向前答题，可以通过判断去除这种移动。\n参考代码\nvoid solve() {\n  cin &gt;&gt; n;\n  for (ll i = 1; i &lt;= n; i++) {\n    cin &gt;&gt; a[i];\n    pre[i] = pre[i - 1] + a[i];\n  }\n  for (ll i = 1; i &lt;= n; i++) {\n    cin &gt;&gt; b[i];\n  }\n \n  // ll ans = a[1];\n  multiset&lt;ll&gt; st;        // 可行代价\n  map&lt;ll, vector&lt;ll&gt;&gt; mp; // 存储到达i的所有可行代价\n  mp[2].push_back(0);\n  st.insert(0);\n  ll ans = a[1];\n  for (ll i = 1; i &lt;= n; i++) {\n    for (auto x : mp[i]) {\n      st.erase(st.find(x)); // 删去不再适用的代价\n    }\n \n    if (st.empty()) {\n      dis[i] = -1; // 没有可用的代价\n    } else {\n      dis[i] = *st.begin();\n    }\n \n    if (dis[i] == -1)\n      continue;\n    ans = max(ans, pre[i] - dis[i]);\n \n    if (b[i] &lt;= i)\n      continue;\n    // 可以拓展到点b[i],b[i]+1时刻这些代价都不再适用\n    ll d = dis[i] + a[i];\n    mp[b[i] + 1].push_back(d);\n    st.insert(d);\n  }\n \n  cout &lt;&lt; ans &lt;&lt; &#039;\\n&#039;;\n}"},"03-algorithm/cfround990div2":{"slug":"03-algorithm/cfround990div2","filePath":"03-algorithm/cfround990div2.md","title":"💭Codeforces Round 990 (Div. 2)","links":[],"tags":["算法","CF"],"content":"A. Alyona and a Square Jigsaw Puzzle\n题意\nAlyona按照顺时针围绕第一个拼图放置拼图，Alyona每天会按顺序放置一定数量的拼图，如果一天结束时拼图的组装部分没有任何已开始但未完成的层，Alyona会感到开心。给出每天放置拼图的数量，询问Alyona感到快乐的天数。\n数据范围\n\n1\\leq t\\leq 500\n1\\leq n\\leq 100\n1\\leq a_i\\leq 100,a_1=1\n\n思路\n检查每天完成添加拼图时的总拼图数是否恰好是一个奇数的平方数，若是则该天会感到快乐。\n代码\nvoid solve() {\n  cin &gt;&gt; n;\n  ll tot = 0, ans = 0;\n  for (ll i = 1; i &lt;= n; i++) {\n    cin &gt;&gt; a[i];\n    tot += a[i];\n    ld t = sqrtl(tot);\n    if ((ll)t &amp; 1 &amp;&amp; t == (ll)t) {\n      ans++;\n    }\n  }\n  cout &lt;&lt; ans &lt;&lt; &#039;\\n&#039;;\n}\nB. Replace Character\n题意\n在一个长度为n的字符串中，执行一次这样的操作：\n\n选择两个索引i,j(1\\leq i,j\\leq n)，可以选择i = j。\n进行赋值s_i:=s_j。\n\n要求输出在进行该操作之后，字典序最小的那个字符串。\n数据范围\n\n1\\leq t\\leq 500\n1\\leq n\\leq 10\n\n思路\n将其中一个数量最少的字母改成数量最多的字母，不过这个题数据范围很小，也可以直接暴力。\n代码\nvoid solve() {\n  cin &gt;&gt; n;\n  string s;\n  cin &gt;&gt; s;\n  map&lt;char, ll&gt; mp;\n  for (auto c : s) {\n    mp[c]++;\n  }\n  vector&lt;pll&gt; v;\n  for (auto i : mp) {\n    v.push_back({i.second, i.first - &#039;a&#039;});\n  }\n  sort(v.begin(), v.end(), greater&lt;&gt;());\n  v[0].first += 1, mp[v[0].second + &#039;a&#039;]++;\n  char cc = v[0].second + &#039;a&#039;;\n  v[v.size() - 1].first -= 1, mp[v[v.size() - 1].second + &#039;a&#039;]--;\n  string ans;\n  for (auto i : s) {\n    if (mp[i]) {\n      ans.push_back(i);\n      mp[i]--;\n    } else {\n      ans.push_back(cc);\n    }\n  }\n  cout &lt;&lt; ans &lt;&lt; &#039;\\n&#039;;\n}\nC. Swap Columns and Find a Path\n题意\n在一个2\\times n的矩阵中，从(1,1)走到(2,n)点，只能向右和向下走，每个位置上有一个a_{i,j}的分数，需要最大化路径上的总分。可以支持任意次这样的操作：\n\n选择两列i,j，将列i和列j进行交换，即swap(a_{1,i},a_{1,j})和swap(a_{2,i},a_{2,j}).\n\n请执行最大化路径上的数之和，并输出这个总和。\n数据范围\n\n1\\leq t\\leq 5000\n1\\leq n\\leq 5000\n-10^5\\leq a_{i,j}\\leq 10^5\n\n思路\n观察可知，选择的路径长度固定是n+1，由于只能向右或者向下走，实际的路径的形状一定是在第一行取前一段，再再第二行取后一段，对每列进行排序后贪心的选择最大的一组合法的数即可。\n书写的时候判断转折的一列时，也可以反向先算出2\\times n个数的总和，再贪心的减掉n-1个较小的数，注意只有转折的地方一列的两个数都能取到，而其他位置的数只能取一个值。\n代码\nll n, m;\nll a[5][maxn], pre[5][maxn], b[maxn];\nbool vis[maxn];\n \nvoid solve() {\n  ll n;\n  cin &gt;&gt; n;\n  vector&lt;pll&gt; v1, v2;\n  for (ll k = 1; k &lt;= 2; k++) {\n    for (ll i = 1; i &lt;= n; i++) {\n      cin &gt;&gt; a[k][i];\n      vis[i] = false;\n      if (k == 1) {\n        v1.push_back({a[k][i], i});\n      } else {\n        v2.push_back({a[k][i], i});\n      }\n    }\n  }\n  sort(v1.begin(), v1.end(), greater&lt;&gt;());\n  sort(v2.begin(), v2.end(), greater&lt;&gt;());\n  ll ans = 0, cnt = 0;\n  for (ll k = 1; k &lt;= 2; k++) {\n    for (ll i = 1; i &lt;= n; i++) {\n      ans += a[k][i];\n    }\n  }\n  ll p1 = n - 1, p2 = n - 1;\n  while (cnt &lt; n - 1) {\n    while (p1 &gt;= 0 &amp;&amp; vis[v1[p1].second]) {\n      p1--;\n    }\n    while (p2 &gt;= 0 &amp;&amp; vis[v2[p2].second]) {\n      p2--;\n    }\n    if (p1 != -1 &amp;&amp; p2 != -1) {\n      if (v1[p1].first &lt; v2[p2].first) {\n        ans -= v1[p1].first;\n        vis[v1[p1].second] = true;\n        p1--;\n      } else {\n        ans -= v2[p2].first;\n        vis[v2[p2].second] = true;\n        p2--;\n      }\n      cnt++;\n    } else if (p1 != -1) {\n      ans -= v1[p1].first;\n      vis[v1[p1].second] = true;\n      p1--;\n      cnt++;\n    } else if (p2 != -1) {\n      ans -= v2[p2].first;\n      vis[v2[p2].second] = true;\n      p2--;\n      cnt++;\n    } else {\n      break;\n    }\n  }\n  cout &lt;&lt; ans &lt;&lt; &#039;\\n&#039;;\n}\nD. Move Back at a Cost\n题意\n给出一个长度为n的数组a，可以执行如下操作：\n\n选择一个索引i，将a_i+1添加到数组的末尾，并删去a_i。\n\n可以执行这样的操作任意次，请输出字典序最小的操作之后的数组a。\n数据范围\n\n1\\leq t\\leq 10^4\n1\\leq n\\leq 10^5\n1\\leq a_i\\leq 10^9\n\n思路\n尽量保留原数组中从小到达排列的数，将其中不符合单调性的点挪到数组的后面，不要让这些将挪到数组后面的数再次挪动。\n维护一个全局的multiset，记录所有需要挪动的数字，将这些数+1 后依次添加到原来数组生成的有序序列的后面。\n代码\n \nvoid solve() {\n  ll n;\n  cin &gt;&gt; n;\n  multiset&lt;ll&gt; st;\n  for (ll i = 1; i &lt;= n; i++) {\n    cin &gt;&gt; a[i];\n    st.insert(a[i]);\n  }\n  ll p = 1;\n  multiset&lt;ll&gt; v;\n  vector&lt;ll&gt; ans;\n  while (p &lt;= n &amp;&amp; !st.empty()) {\n    while (p &lt;= n &amp;&amp; a[p] != *st.begin()) {\n      v.insert(a[p]);\n      st.erase(st.find(a[p]));\n      p++;\n    }\n    if (p &gt; n)\n      break;\n    ans.push_back(a[p]);\n    st.erase(st.find(a[p]));\n    p++;\n  }\n  while (!v.empty() &amp;&amp; ans.back() &gt; *v.begin() + 1) {\n    v.insert(ans.back());\n    ans.pop_back();\n  }\n  for (auto i : v) {\n    ans.push_back(i + 1);\n  }\n  for (auto i : ans) {\n    cout &lt;&lt; i &lt;&lt; &#039; &#039;;\n  }\n  cout &lt;&lt; &#039;\\n&#039;;\n}"},"03-algorithm/graph_basic":{"slug":"03-algorithm/graph_basic","filePath":"03-algorithm/graph_basic.md","title":"图论基础||存储图||DFS、BFS(图论)","links":[],"tags":["图论","算法","算法模板"],"content":"1.1图的定义\n上课讲过一大堆这里不再赘述，直接学习代码实现。\n1.2图的存储\n例图展示：\ngraph LR\nv1((v1))--4--&gt;v2((v2))\nv1((v1))--9--&gt;v6((v6))\nv3((v3))--19--&gt;v2((v2))\nv3((v3))--22--&gt;v1((v1))\nv4((v4))--17--&gt;v3((v3))\nv5((v5))--29--&gt;v8((v8))\nv6((v6))--12--&gt;v1((v1))\nv6((v6))--9--&gt;v5((v5))\nv6((v6))--4--&gt;v7((v7))\nv7((v7))--25--&gt;v4((v4))\nv8((v8))--7--&gt;v7((v7))\nv8((v8))--11--&gt;v3((v3))\n\n设n个点，m条边\n上图的数据（按照 起点-终点-权值）：\n8 12\n5 8 29\n6 1 12\n8 3 11\n1 2 4\n3 1 22\n4 3 17\n7 4 25\n6 5 9\n8 7 7\n1 6 9\n3 2 19\n6 7 4\n邻接矩阵\n\n遍历效率低、不能存重边、初始化效率低初始化O(n^2)时间，建图O(m)时间、空间开销大O(n^2)\n对于稀疏图来说大部分是INF，空间利用效率也不高\n\n前向星\n前向星涉及排序，所以其时间复杂度和排序算法有关，一般情况下时间复杂度为O(mlog m)，空间上需要两个数组（记录边的边数组、记录各点在边数组中起始位置的head数组），空间复杂度为O(m+n)\n优点：在点特别多时可以存储重边\n缺点：不能直接判断任意两个点之间是否有边。排序和初始化数组费时间。\n需要的数据结构如下：\nint head[maxn];\nstruct NODE{\n    int from;\t// 起点\n    int to;\t\t// 终点\n    int w;\t\t// 权值\n};\nNODE edge[maxm];\nNODE用来存储每条边的信息，边按照输入读取后再排序，排序之后使用head[maxn]来储存各个点的在edge[maxm]里的起始位置。\n排序方式：\nbool cmp(NODE a, NODE b){\n    if(a.from==b.from&amp;&amp;a.to==b.to)\n        return a.w&lt;b.w;\n    if(a.from==b.from)\n        return a.to&lt;b.to;\n    return a.from&lt;b.from;\n}\n完整代码：\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst long long maxn = 1e5 + 50, maxm = 1e7 + 50;\n \n \nstruct NODE {\n\tint from, to, w;\n}edge[maxm];\n \nint head[maxn];\n \nbool cmp(NODE a, NODE b) {\n\tif (a.from == b.from &amp;&amp; a.to == b.to)\n\t\treturn a.w &lt; b.w;\n\tif (a.from == b.from)\n\t\treturn a.to &lt; b.to;\n\treturn a.from &lt; b.from;\n}\n \nint main() {\n\tint n, m;\n\tcin &gt;&gt; n &gt;&gt; m;\n\t\n\t// 读入数据\n\tfor (int i = 0;i &lt; m;i++)\n\t\tcin &gt;&gt; edge[i].from &gt;&gt; edge[i].to &gt;&gt; edge[i].w;\n\t\n\t// 排序\n\tsort(edge, edge + m, cmp);\n \n\t// 初始化head\n\tmemset(head, -1, sizeof(head));\n \n\t// 制成点位数组\n\thead[edge[0].from] = 0;\t// 初始化\n\t// edge数组中起点为点i的在数组里的第一条边在下标head[i]处\n\tfor (int i = 1;i &lt; m;i++)\n\t\tif (edge[i].from != edge[i - 1].from)\n\t\t\t// 表明是新的起始点\n\t\t\thead[edge[i].from] = i;\n \n\t// 遍历输出各边信息（按点位输出）\n\tfor (int i = 1;i &lt;= n;i++) {\n\t\tcout &lt;&lt; &quot;以点v&quot; &lt;&lt; i &lt;&lt; &quot;为起点的边：&quot; &lt;&lt; endl;\n\t\tfor (int j = head[i];j &lt; m &amp;&amp; edge[j].from == i;j++) {\n\t\t\tcout &lt;&lt; &quot;v&quot; &lt;&lt; edge[j].from &lt;&lt; &quot;--&gt;v&quot; &lt;&lt; edge[j].to &lt;&lt; &quot; 权值为：&quot; &lt;&lt; edge[j].w &lt;&lt; &quot; 该边在数组edge中的序号为&quot; &lt;&lt; j &lt;&lt; endl;\n\t\t}\n\t\tcout &lt;&lt; endl;\n\t}\n \n\treturn 0;\n}\n \n// Output：\n/*\n以点v1为起点的边：\nv1--&gt;v2 权值为：4 该边在数组edge中的序号为0\nv1--&gt;v6 权值为：9 该边在数组edge中的序号为1\n \n以点v2为起点的边：\n \n以点v3为起点的边：\nv3--&gt;v1 权值为：22 该边在数组edge中的序号为2\nv3--&gt;v2 权值为：19 该边在数组edge中的序号为3\n \n以点v4为起点的边：\nv4--&gt;v3 权值为：17 该边在数组edge中的序号为4\n \n以点v5为起点的边：\nv5--&gt;v8 权值为：29 该边在数组edge中的序号为5\n \n以点v6为起点的边：\nv6--&gt;v1 权值为：12 该边在数组edge中的序号为6\nv6--&gt;v5 权值为：9 该边在数组edge中的序号为7\nv6--&gt;v7 权值为：4 该边在数组edge中的序号为8\n \n以点v7为起点的边：\nv7--&gt;v4 权值为：25 该边在数组edge中的序号为9\n \n以点v8为起点的边：\nv8--&gt;v3 权值为：11 该边在数组edge中的序号为10\nv8--&gt;v7 权值为：7 该边在数组edge中的序号为11\n \n*/\n邻接表\n图的一种链式存储结构，把图G中所有邻接于vi的顶点链接成为一个vi的单链表。\n三种实现方法：\n1. 动态建表\n动态建表的时间效率是O(m)，空间效率是O(m)，主要的时间损耗在于不断地申请新空间，且判断任意两个点之间是否有边相连的效率也低（需要搜索各个点的单链表）(感觉还好？)。\n数据结构：\nstruct EdgeNode {\n\tint to;\t\t// 终点\n\tint w;\t\t// 权值\n\tEdgeNode* next;\t\t// 下一边的指针\n};\n \nstruct VNode {\n\tint from;\t// 起点（这个数据结构中from没有传值，我们以遍历Adjlist时的遍历时序用于指定起点）\n\tEdgeNode* first;\t// 邻接表的头指针\n};\n完整代码：\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst long long maxn = 1e5 + 50, maxm = 1e7 + 50;\n \nstruct EdgeNode {\n\tint to;\t\t// 终点\n\tint w;\t\t// 权值\n\tEdgeNode* next;\t\t// 下一边的指针\n};\n \nstruct VNode {\n\tint from;\t// 起点（这个数据结构中from没有传值，我们以遍历Adjlist时的遍历时序用于指定起点）\n\tEdgeNode* first;\t// 邻接表的头指针\n};\n \nVNode Adjlist[maxn];\t// 全图\n \nint main() {\n\tint n, m;\n\tcin &gt;&gt; n &gt;&gt; m;\n\t\n\t// 读入数据\n\tfor (int i = 0;i &lt; m;i++) {\n\t\tint fi, ti, wi;\n\t\tcin &gt;&gt; fi &gt;&gt; ti &gt;&gt; wi;\n\t\t// 创建一个新的边结构数据\n\t\tEdgeNode* p = new EdgeNode();\n\t\t// 给该数据传值\n\t\tp-&gt;to = ti;\n\t\tp-&gt;w = wi;\n        \n\t\t// 该新边的next指针指向上一个链接到起点为fi的单链表中的起点\n        /*\n        （相当于在前面插入，这点可以观察遍历输出部分发现，比如先读入的v1--&gt;v2后读入的v1--&gt;v6，但在储存时我们将后来的v1--&gt;v6插入在了v1--&gt;v2前面）\n        */\n\t\tp-&gt;next = Adjlist[fi].first;\n \n\t\t// 将起点为fi的单链表的指针更新为这个新传入边的地址\n\t\tAdjlist[fi].first = p;\n\t}\n \n\t// 遍历\n\tfor (int i = 1;i &lt;= n;i++) {\n\t\tcout &lt;&lt; &quot;点v&quot; &lt;&lt; i &lt;&lt; &quot;为起点的边：&quot; &lt;&lt; endl;\n\t\tint ind = 0;\n\t\tfor (EdgeNode* k = Adjlist[i].first;k != NULL;k = k-&gt;next) {\n\t\t\t// 指针遍历该链表至结束\n\t\t\tcout &lt;&lt; &quot;v&quot; &lt;&lt; i &lt;&lt; &quot; --&gt;v&quot; &lt;&lt; k-&gt;to &lt;&lt; &quot; 权值为：&quot; &lt;&lt; k-&gt;w &lt;&lt; &quot; 该边记录在点v&quot; &lt;&lt; i &lt;&lt; &quot;的单链表的第&quot; &lt;&lt; ind++ &lt;&lt; &quot;个&quot; &lt;&lt; endl;\n\t\t}\n\t\tcout &lt;&lt; &quot;点v&quot; &lt;&lt; i &lt;&lt; &quot;为的度数为：&quot; &lt;&lt; ind &lt;&lt; endl;\n\t\tcout &lt;&lt; endl;\n\t}\n \n\treturn 0;\n}\n \n// Output:\n/*\n点v1为起点的边：\nv1 --&gt;v6 权值为：9 该边记录在点v1的单链表的第0个\nv1 --&gt;v2 权值为：4 该边记录在点v1的单链表的第1个\n点v1为的度数为：2\n \n点v2为起点的边：\n点v2为的度数为：0\n \n点v3为起点的边：\nv3 --&gt;v2 权值为：19 该边记录在点v3的单链表的第0个\nv3 --&gt;v1 权值为：22 该边记录在点v3的单链表的第1个\n点v3为的度数为：2\n \n点v4为起点的边：\nv4 --&gt;v3 权值为：17 该边记录在点v4的单链表的第0个\n点v4为的度数为：1\n \n点v5为起点的边：\nv5 --&gt;v8 权值为：29 该边记录在点v5的单链表的第0个\n点v5为的度数为：1\n \n点v6为起点的边：\nv6 --&gt;v7 权值为：4 该边记录在点v6的单链表的第0个\nv6 --&gt;v5 权值为：9 该边记录在点v6的单链表的第1个\nv6 --&gt;v1 权值为：12 该边记录在点v6的单链表的第2个\n点v6为的度数为：3\n \n点v7为起点的边：\nv7 --&gt;v4 权值为：25 该边记录在点v7的单链表的第0个\n点v7为的度数为：1\n \n点v8为起点的边：\nv8 --&gt;v7 权值为：7 该边记录在点v8的单链表的第0个\nv8 --&gt;v3 权值为：11 该边记录在点v8的单链表的第1个\n点v8为的度数为：2\n*/\n注意到，无向图中各点的度正好是各点的单链表中链节的个数，也就是上述代码中ind最后的结果值，而之余有向图，ind就是对应顶点的出度。\n若要求得入度则必须遍历整个邻接表或者建立一个逆链接表（以vi边为终边的链接表）。\n注意：一个图 的邻接表不是唯一的，其具体的邻接次序与边的输入次序有关。\n2. vector模拟链表实现\nvector模拟链表的实现方式与前一种区别不大（前插入和后插入的区别？反正基本没有质变）\n不过这种方式代码量少，不容易出错，也不用指针指来指去。也不需要我们来考虑内存的申请和释放。比较友好（qwq）\n需要数据结构：\nstruct EdgeNode {\n\tint to;\t\t// 终点\n\tint w;\t\t// 权值\n};\nvector&lt;EdgeNode&gt;mp[maxn];\n完整代码：\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst long long maxn = 1e5 + 50, maxm = 1e7 + 50;\n \nstruct EdgeNode {\n\tint to;\t\t// 终点\n\tint w;\t\t// 权值\n};\nvector&lt;EdgeNode&gt;mp[maxn];\nint main() {\n\tint n, m;\n\tcin &gt;&gt; n &gt;&gt; m;\n \n\t// 读入数据\n\tfor (int i = 0;i &lt; m;i++) {\n\t\tEdgeNode e;\n\t\tint fi, ti, wi;\n\t\tcin &gt;&gt; fi &gt;&gt; ti &gt;&gt; wi;\n\t\t\n\t\te.to = ti;\n\t\te.w = wi;\n\t\tmp[fi].push_back(e);\n\t}\n \n\t// 遍历\n\tfor (int i = 1;i &lt;= n;i++) {\n\t\tcout &lt;&lt; &quot;点v&quot; &lt;&lt; i &lt;&lt; &quot;为起点的边：&quot; &lt;&lt; endl;\n\t\t\n\t\tvector&lt;EdgeNode&gt;::iterator it = mp[i].begin();\n\t\tint ind = 0;\n\t\tfor (;it != mp[i].end();it++) {\n\t\t\tcout &lt;&lt; &quot;v&quot; &lt;&lt; i &lt;&lt; &quot;--&gt;v&quot; &lt;&lt; (*it).to &lt;&lt; &quot; 权值为：&quot; &lt;&lt; (*it).w &lt;&lt; &quot; 该边在所有以点v&quot; &lt;&lt; i &lt;&lt; &quot;为起点的边中序号为&quot; &lt;&lt; ind++ &lt;&lt; endl;\n\t\t}\n\t\tcout &lt;&lt; &quot;点v&quot; &lt;&lt; i &lt;&lt; &quot;的度数为：&quot; &lt;&lt; ind &lt;&lt; endl;\n\t\tcout &lt;&lt; endl;\n\t}\n\t\n \n\treturn 0;\n}\n// Output:\n/*\n点v1为起点的边：\nv1--&gt;v2 权值为：4 该边在所有以点v1为起点的边中序号为0\nv1--&gt;v6 权值为：9 该边在所有以点v1为起点的边中序号为1\n点v1的度数为：2\n \n点v2为起点的边：\n点v2的度数为：0\n \n点v3为起点的边：\nv3--&gt;v1 权值为：22 该边在所有以点v3为起点的边中序号为0\nv3--&gt;v2 权值为：19 该边在所有以点v3为起点的边中序号为1\n点v3的度数为：2\n \n点v4为起点的边：\nv4--&gt;v3 权值为：17 该边在所有以点v4为起点的边中序号为0\n点v4的度数为：1\n \n点v5为起点的边：\nv5--&gt;v8 权值为：29 该边在所有以点v5为起点的边中序号为0\n点v5的度数为：1\n \n点v6为起点的边：\nv6--&gt;v1 权值为：12 该边在所有以点v6为起点的边中序号为0\nv6--&gt;v5 权值为：9 该边在所有以点v6为起点的边中序号为1\nv6--&gt;v7 权值为：4 该边在所有以点v6为起点的边中序号为2\n点v6的度数为：3\n \n点v7为起点的边：\nv7--&gt;v4 权值为：25 该边在所有以点v7为起点的边中序号为0\n点v7的度数为：1\n \n点v8为起点的边：\nv8--&gt;v3 权值为：11 该边在所有以点v8为起点的边中序号为0\nv8--&gt;v7 权值为：7 该边在所有以点v8为起点的边中序号为1\n点v8的度数为：2\n \n*/\n3. ★★★静态建表（链式前向星）\n邻接表的静态建表存储图的方式也称链式前向星，基于前向星，以提高构造效率为目的设计的存储方式，最终形成的数据是一个变形的邻接表。\n链式前向星采用数组模拟链表的方式实现邻接表的功能，使用很少的额外空间，是目前建图和遍历效率最高的存储方式。\n数据结构：\nstruct EdgeNode {\n\tint to;\t\t// 终点\n\tint w;\t\t// 权值\n\tint next;\t// 下一位置\n};\nEdgeNode Edge[maxm];\nint head[maxn];\n数组模拟链表的主要方式是记录下一节点的位置在整个数组的位置坐标，并将这个标志坐标存在一个head数组中，遍历时根据输入的边的信息更新head对应的更新位置，并将原来的节点信息存在此时读入的边的next数据中。\n存值方式：\n// 读入数据\nfor (int i = 0;i &lt; m;i++) {\n    int fi, ti, wi;\n    cin &gt;&gt; fi &gt;&gt; ti &gt;&gt; wi;\n    Edge[i].to = ti;\n    Edge[i].w = wi;\n \n    Edge[i].next = head[fi];\n    head[fi] = i;\n}\n完整代码：\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst long long maxn = 1e5 + 50, maxm = 1e7 + 50;\n \nstruct EdgeNode {\n\tint to;\t\t// 终点\n\tint w;\t\t// 权值\n\tint next;\t// 下一位置\n};\nEdgeNode Edge[maxm];\nint head[maxn];\n \nint main() {\n\tint n, m;\n\tcin &gt;&gt; n &gt;&gt; m;\n \n\t// 初始化head\n\tmemset(head, -1, sizeof(head));\n\t\n\t// 读入数据\n\tfor (int i = 0;i &lt; m;i++) {\n\t\tint fi, ti, wi;\n\t\tcin &gt;&gt; fi &gt;&gt; ti &gt;&gt; wi;\n\t\tEdge[i].to = ti;\n\t\tEdge[i].w = wi;\n\t\t\n\t\tEdge[i].next = head[fi];\n\t\thead[fi] = i;\n\t}\n \n\t\n\t// 遍历\n\tfor (int i = 1;i &lt;= n;i++) {\n\t\tcout &lt;&lt; &quot;点v&quot; &lt;&lt; i &lt;&lt; &quot;为起点的边：&quot; &lt;&lt; endl;\n\t\t\n\t\tint ind = 0;\n\t\tfor (int j = head[i];j != -1;j = Edge[j].next) {\n\t\t\tcout &lt;&lt; &quot;v&quot; &lt;&lt; i &lt;&lt; &quot;--&gt;v&quot; &lt;&lt; Edge[j].to &lt;&lt; &quot; 权值为：&quot; &lt;&lt; Edge[j].w &lt;&lt; &quot; 该边在所有以点v&quot; &lt;&lt; i &lt;&lt; &quot;为起点的边中序号为&quot; &lt;&lt; ind++ &lt;&lt; endl;\n\t\t}\n\t\tcout &lt;&lt; &quot;点v&quot; &lt;&lt; i &lt;&lt; &quot;的度数为：&quot; &lt;&lt; ind &lt;&lt; endl;\n\t\tcout &lt;&lt; endl;\n\t}\n \n\t// 展示一下head数组里的内容：\n\tcout &lt;&lt; &quot;----------head数组里的内容----------&quot; &lt;&lt; endl;\n\tfor (int i = 1;i &lt;= n;i++)\n\t\tcout &lt;&lt; &quot;head[&quot; &lt;&lt; i &lt;&lt; &quot;]=&quot; &lt;&lt; head[i] &lt;&lt; endl;\n\tcout &lt;&lt; endl;\n \n\treturn 0;\n}\n \n// Output:\n/*\n点v1为起点的边：\nv1--&gt;v6 权值为：9 该边在所有以点v1为起点的边中序号为0\nv1--&gt;v2 权值为：4 该边在所有以点v1为起点的边中序号为1\n点v1的度数为：2\n \n点v2为起点的边：\n点v2的度数为：0\n \n点v3为起点的边：\nv3--&gt;v2 权值为：19 该边在所有以点v3为起点的边中序号为0\nv3--&gt;v1 权值为：22 该边在所有以点v3为起点的边中序号为1\n点v3的度数为：2\n \n点v4为起点的边：\nv4--&gt;v3 权值为：17 该边在所有以点v4为起点的边中序号为0\n点v4的度数为：1\n \n点v5为起点的边：\nv5--&gt;v8 权值为：29 该边在所有以点v5为起点的边中序号为0\n点v5的度数为：1\n \n点v6为起点的边：\nv6--&gt;v7 权值为：4 该边在所有以点v6为起点的边中序号为0\nv6--&gt;v5 权值为：9 该边在所有以点v6为起点的边中序号为1\nv6--&gt;v1 权值为：12 该边在所有以点v6为起点的边中序号为2\n点v6的度数为：3\n \n点v7为起点的边：\nv7--&gt;v4 权值为：25 该边在所有以点v7为起点的边中序号为0\n点v7的度数为：1\n \n点v8为起点的边：\nv8--&gt;v7 权值为：7 该边在所有以点v8为起点的边中序号为0\nv8--&gt;v3 权值为：11 该边在所有以点v8为起点的边中序号为1\n点v8的度数为：2\n \n----------head数组里的内容----------\nhead[1]=9\nhead[2]=-1\nhead[3]=10\nhead[4]=5\nhead[5]=0\nhead[6]=11\nhead[7]=6\nhead[8]=8\n*/\n除了不能直接用起点终点确定是否有边外，链式前向星几乎是完美的。\n1.3图的遍历\n从v0出发系统的访问图G中所有的顶点，每个顶点访问一次，称为图的遍历。\n深度优先遍历\n从一个节点开始，按照连接，访问到最后一个没有被访问的顶点，然后再从顺序上没有被访问的分路继续访问到最深处，如此循环至全部被访问。\n深度优先样例代码：\n// 用一个布尔型数组来标记是否被遍历到\nbool s[maxn] = { 0 };\n \nvoid dfs(int x) {\n\t// 传入节点名x\n\ts[x] = true;\t// 标记被访问\n\tcout &lt;&lt; x &lt;&lt; &quot; &quot;;\n\tfor (int i = head[x];i != -1;i = Edge[i].next) {\n\t\t// 找到该节点为起点的头位置，然后按顺序去遍历下一个和节点x相连的节点位置，并标记访问\n\t\tif (!s[Edge[i].to])\n\t\t\t// 如果当前边的终点未被访问，我们就去访问它\n\t\t\tdfs(Edge[i].to);\n\t\t\n\t\t// 当前边的终点如果已被访问，我们就访问和节点x的下一条边，即给i赋值为Edge[i].next\n\t}\n}\n完整代码：\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst long long maxn = 1e5 + 50, maxm = 1e7 + 50;\n \nstruct EdgeNode {\n\tint to;\t\t// 终点\n\tint w;\t\t// 权值\n\tint next;\t// 下一位置\n};\nEdgeNode Edge[maxm];\nint head[maxn];\n \n// 用一个布尔型数组来标记是否被遍历到\nbool s[maxn] = { 0 };\n \nvoid dfs(int x) {\n\t// 传入节点名x\n\ts[x] = true;\t// 标记被访问\n\tcout &lt;&lt; x &lt;&lt; &quot; &quot;;\t// 输出被标记的点（观察顺序）\n\tfor (int i = head[x];i != -1;i = Edge[i].next) {\n\t\t// 找到该节点为起点的头位置，然后按顺序去遍历下一个和节点x相连的节点位置，并标记访问\n\t\tif (!s[Edge[i].to])\n\t\t\t// 如果当前边的终点未被访问，我们就去访问它\n\t\t\tdfs(Edge[i].to);\n\t\t\n\t\t// 当前边的终点如果已被访问，我们就访问和节点x的下一条边，即给i赋值为Edge[i].next\n\t}\n}\n \nint main() {\n\tint n, m;\n\tcin &gt;&gt; n &gt;&gt; m;\n \n\t// 初始化head\n\tmemset(head, -1, sizeof(head));\n\t\n\t// 读入数据\n\tfor (int i = 0;i &lt; m;i++) {\n\t\tint fi, ti, wi;\n\t\tcin &gt;&gt; fi &gt;&gt; ti &gt;&gt; wi;\n\t\tEdge[i].to = ti;\n\t\tEdge[i].w = wi;\n\t\t\n\t\tEdge[i].next = head[fi];\n\t\thead[fi] = i;\n\t}\n \n\t// 深度优先访问，从顶点1开始（没有点0啦）\n\tdfs(1);\n\t// Output:\n\t/*\n\t\t1 6 7 4 3 2 5 8\n\t*/\n\t// 可以结合图去观察这个顺序，便于理解深度优先搜索\n \n \n\treturn 0;\n}\n \n注意：这里还是使用强推的链式前向星数据结构来储存图，因为边在读入的时候是前插入，所以后读入的边会先被遍历。\n广度优先遍历\n广度优先就是先访问顶点v0的所有边的终点，然后再访问第一条边往下延续的未被访问的顶点（第一条边往下没有就第二条边…如此搜索）\n广度优先用到了队列来记录遍历某顶点广度时，遍历的这个终点的下一点(next)是否被遍历，如果未被遍历则标记入队，等待当前顶点按照广度优先被遍历完终点后从该队列中获得下一轮被遍历的点。\n广度优先样例代码：\n（啊啊啊突然发现拼错单词了，其实队列的单词是queue，不过在c++里引用了stl容器还用queue命名不太好吧(虽然没影响)…不管了！算了，还是改过来吧QAQ）\n// 用一个布尔型数组来标记是否被遍历到\nbool s[maxn] = { 0 };\n \nvoid bfs(int x) {\n\tint queue[maxn];\n\tint iq = 0;\t\t// 遍历以x为顶点的起始状态时，队列是空的\n\tqueue[iq++] = x;\t// 给当前队列添加被访问的这个顶点x\n\t\n\tfor (int i = 0;i &lt; iq;i++) {\n\t\t\n\t\t// 这个队列按序输出可以反应搜索顺序\n\t\tcout &lt;&lt; queue[i] &lt;&lt; &quot; &quot;;\n\t\t\n\t\t// 按照广度优先构造顺序队列(入队的都算作被访问了，下次执行当前循环(i++)将会输出最后入队的该顶点)\n\t\t\n\t\tfor (int k = head[queue[i]];k != -1;k = Edge[k].next) {\n\t\t\t// 遍历当前节点x相连的节点，即当前边的终点，如果该点没有被访问过，则入队，标记已访问，队长++\n\t\t\tif (!s[Edge[k].to]) {\n\t\t\t\ts[Edge[k].to] = true;\n\t\t\t\tqueue[iq++] = Edge[k].to;\n\t\t\t}\n\t\t}\n\t}\n \n}\n完整代码：\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst long long maxn = 1e5 + 50, maxm = 1e7 + 50;\n \nstruct EdgeNode {\n\tint to;\t\t// 终点\n\tint w;\t\t// 权值\n\tint next;\t// 下一位置\n};\nEdgeNode Edge[maxm];\nint head[maxn];\n \n// 用一个布尔型数组来标记是否被遍历到\nbool s[maxn] = { 0 };\n \nvoid bfs(int x) {\n\tint queue[maxn];\n\tint iq = 0;\t\t// 遍历以x为顶点的起始状态时，队列是空的\n\tqueue[iq++] = x;\t// 给当前队列添加被访问的这个顶点x\n\t\n\tfor (int i = 0;i &lt; iq;i++) {\n\t\t\n\t\t// 这个队列按序输出可以反应搜索顺序\n\t\tcout &lt;&lt; queue[i] &lt;&lt; &quot; &quot;;\n\t\t\n\t\t// 按照广度优先构造顺序队列(入队的都算作被访问了，下次执行当前循环(i++)将会输出最后入队的该顶点)\n\t\t\n\t\tfor (int k = head[queue[i]];k != -1;k = Edge[k].next) {\n\t\t\t// 遍历当前节点x相连的节点，即当前边的终点，如果该点没有被访问过，则入队，标记已访问，队长++\n\t\t\tif (!s[Edge[k].to]) {\n\t\t\t\ts[Edge[k].to] = true;\n\t\t\t\tqueue[iq++] = Edge[k].to;\n\t\t\t}\n\t\t}\n\t}\n \n}\n \nint main() {\n\tint n, m;\n\tcin &gt;&gt; n &gt;&gt; m;\n \n\t// 初始化head\n\tmemset(head, -1, sizeof(head));\n\t\n\t// 读入数据\n\tfor (int i = 0;i &lt; m;i++) {\n\t\tint fi, ti, wi;\n\t\tcin &gt;&gt; fi &gt;&gt; ti &gt;&gt; wi;\n\t\tEdge[i].to = ti;\n\t\tEdge[i].w = wi;\n\t\t\n\t\tEdge[i].next = head[fi];\n\t\thead[fi] = i;\n\t}\n \n\tbfs(1);\n\t// Output:\n\t/*\n\t\t1 6 2 7 5 1 4 8 3\n\t*/\n\t// 结合图去观察该顺序，便于理解广度优先搜索\n \n\treturn 0;\n}\n \n\n深度优先和广度优先都是通过边来搜索检查邻边是否被遍历到，所以时间复杂度相同，不过访问序列不同。\n"},"03-algorithm/hdu24sd1":{"slug":"03-algorithm/hdu24sd1","filePath":"03-algorithm/hdu24sd1.md","title":"2024杭电钉耙编程联赛Day1||补题","links":[],"tags":["算法","杭电","2024暑假集训"],"content":"1001-循环位移\n(709/3775)\n题意\n将字符串S=S_0+S_1+S_2+...+S_{n-1}循环位移k次后得到S(k)=S_{k\\bmod n }+...+S_{n-1}+S+0+...+S_{(k-1)\\bmod n}。\n定义[A]={A(k),k\\in N}。给出T组串A,B，询问B有多少个子串在[A]​中。\n数据范围\n\n|A|\\leq |B|\n\\sum|B|\\leq 1048576\n\n思路\n思路1：字符串哈希\n记字符串A的长度是n，将字符串A转变为首尾相连的样子（A=A+A.substr(1,n-1)），并计算其中每个长度为n的哈希值，用map存值，再对字符串B进行哈希，同样也对长度为n的子串计算哈希值，若有符合的则计数。\n代码\n代码1：字符串哈希\nll ha[maxn], hb[maxn];\nll pwr[maxn];\n \nvoid solve() {\n    string a, b;cin &gt;&gt; a &gt;&gt; b;\n    ll n = a.size();\n    a = a.substr(1, n - 1) + a;\n    ll la = a.size(), lb = b.size();\n    a = &quot; &quot; + a, b = &quot; &quot; + b;\n    pwr[0] = 1;\n    map&lt;ll, bool&gt;mp;\n    for (ll i = 1;i &lt;= la;i++) {\n        ha[i] = ha[i - 1] * bas1 + a[i];\n        pwr[i] = pwr[i - 1] * bas1;\n        if (i - n &gt;= 0) {\n            ll x = ha[i] - ha[i - n] * pwr[n];\n            mp[x] = true;\n        }\n    }\n    ll ans = 0;\n    for (ll i = 1;i &lt;= lb;i++) {\n        hb[i] = hb[i - 1] * bas1 + b[i];\n        if (i - n &gt;= 0) {\n            ll x = hb[i] - hb[i - n] * pwr[n];\n            if (mp.count(x)) {\n                ans++;\n            }\n        }\n    }\n    cout &lt;&lt; ans &lt;&lt; endl;\n}\n1002-星星\n(991/1659)\n题意\n小A有n次获得星星的机会，第i次有如下5种选择：\n\n跳过\na_i的代价获得1颗星星\nb_i的代价获得2颗星星\nc_i的代价获得3颗星星\nd_i的代价获得4颗星星\n\n请问若想恰好获得k颗星星，所需要的最小代价是多少。\n数据范围\n\n1\\leq n\\leq 1000\n0\\leq k\\leq n\\times 4\n0\\lt a_i\\leq b_i\\leq c_i\\leq d_i\\leq 10^9\n\n思路\n基础的动态规划。记dp[i]表示获得i颗星星的最小代价。\n代码\nll a[maxn], b[maxn], c[maxn], d[maxn];\nll dp[4 * maxn];\n \nvoid solve() {\n    ll n, k;cin &gt;&gt; n &gt;&gt; k;\n    for (ll i = 1;i &lt;= n;i++) {\n        cin &gt;&gt; a[i] &gt;&gt; b[i] &gt;&gt; c[i] &gt;&gt; d[i];\n    }\n    fill(dp, dp + 4 * maxn, inf);\n    dp[0] = 0;\n    for (ll i = 1;i &lt;= n;i++) {\n        ll m = min(k, 4 * i);\n        for (ll j = m;j &gt;= 0;j--) {\n            if (j + 1 &lt;= m)\n                dp[j + 1] = min(dp[j] + a[i], dp[j + 1]);\n            if (j + 2 &lt;= m)\n                dp[j + 2] = min(dp[j] + b[i], dp[j + 2]);\n            if (j + 3 &lt;= m)\n                dp[j + 3] = min(dp[j] + c[i], dp[j + 3]);\n            if (j + 4 &lt;= m)\n                dp[j + 4] = min(dp[j] + d[i], dp[j + 4]);\n        }\n    }\n    cout &lt;&lt; dp[k] &lt;&lt; &quot;\\n&quot;;\n}\n1008-位运算\n(918/1427)\n题意\n有多少在范围[0,2^k)中的a,b,c,d构成的四元组(a,b,c,d)满足a \\\\&amp; b\\oplus c | d=n。\n数据范围\n\n1\\leq T\\leq 10\n1\\leq k\\leq 15,0\\leq n\\lt 2^k\n\n思路\n记x=a \\\\&amp; b\\oplus c | d，x的每一位只有1和0的可能，而每位上的数字只和a,b,c,d对应位是1或0有关，枚举四个数的1/0，统计x是0的组合和是1的组合的数量。再根据n的k位进行统计即可。\n代码\nvoid solve() {\n    ll n, k;cin &gt;&gt; n &gt;&gt; k;\n    ll cnt[2];cnt[0] = cnt[1] = 0;\n    for (int i = 0;i &lt;= 1;i++) {\n        for (int j = 0;j &lt;= 1;j++) {\n            for (int k = 0;k &lt;= 1;k++) {\n                for (ll l = 0;l &lt;= 1;l++) {\n                    ll x = i &amp; j ^ k | l;\n                    cnt[x]++;\n                }\n            }\n        }\n    }\n    vector&lt;int&gt;v;\n    ll ans = 1;\n    for (ll i = 0;i &lt; k;i++) {\n        v.push_back(n &amp; 1);\n        ans *= cnt[n &amp; 1];\n        n &gt;&gt;= 1;\n    }\n    cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;;\n}\n1012-并\n(241/1229)\n题意\n给出在二维平面上的n个矩形，随机选择k个不同的矩形(k\\in [1,n])，求这k个矩形所有覆盖部分的并集的面积的期望。\n数据范围\n\n1\\leq n\\leq 2\\times 10^3\n1\\leq x_{i,1}\\lt x_{i,2} \\leq 10^9\n1\\leq y_{i,1}\\lt y_{i,2} \\leq 10^9\n\n思路\n将横纵坐标离散化之后可以将这n个矩形覆盖的部分分割成不重叠的若干个小矩形，每个小矩形设置权值，代表被原来的n个矩形覆盖的次数。设某个小矩形的覆盖次数是m，则在选择k个矩形时，这个小矩形的贡献是：\\frac{\\binom{k}{n}-\\binom{k}{n-m}}{\\binom{k}{n}}（全集-选除该矩形以外的部分），预处理离散后的矩形以及被覆盖m次的所有矩形的总面积，枚举计数即可。\n代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\nconst int maxn = 2050;\nconst int mo998 = 998244353;\n \nstruct Rec {\n    ll x1, y1, x2, y2;\n}a[maxn];\n \nll X[maxn * 2], Y[maxn * 2];\n \nll fact[maxn], invfact[maxn]; // 阶乘,阶乘逆元\n \nll qpow(ll a, ll b) {\n    ll res = 1;\n    while (b) {\n        if (b &amp; 1)res = res * a % mo998;\n        b &gt;&gt;= 1;\n        a = a * a % mo998;\n    }\n    return res;\n}\n \nll inv(ll x) {\n    return qpow(x, mo998 - 2);\n}\n \nvoid init() {\n    // 预处理阶乘,阶乘逆元\n    fact[0] = invfact[0] = 1ll;\n    for (int i = 1;i &lt; maxn;i++) {\n        fact[i] = fact[i - 1] * i % mo998;\n        invfact[i] = invfact[i - 1] * inv(i) % mo998;\n    }\n}\n \nll C(int n, int k) {\n    // n选k的方案数\n    if (k &gt; n)return 0ll;\n    ll res = fact[n] * invfact[k] % mo998 * invfact[n - k] % mo998;\n    return res;\n}\n \nll Stot[maxn], rec[2 * maxn][2 * maxn];\n \nvoid solve() {\n    int n;cin &gt;&gt; n;\n    for (int i = 1;i &lt;= n;i++) {\n        ll x1, y1, x2, y2;\n        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;\n        a[i] = { x1,y1,x2,y2 };\n        X[i] = x1, X[i + n] = x2;\n        Y[i] = y1, Y[i + n] = y2;\n    }\n    sort(X + 1, X + 1 + 2 * n);\n    sort(Y + 1, Y + 1 + 2 * n);\n    int t1 = unique(X + 1, X + 1 + 2 * n) - X - 1;\n    int t2 = unique(Y + 1, Y + 1 + 2 * n) - Y - 1;\n    for (int i = 1;i &lt;= n;i++) {\n        auto [x1, y1, x2, y2] = a[i];\n        x1 = lower_bound(X + 1, X + 1 + t1, x1) - X; // 值x1在X[]中的位置\n        x2 = lower_bound(X + 1, X + 1 + t1, x2) - X;\n        y1 = lower_bound(Y + 1, Y + 1 + t2, y1) - Y;\n        y2 = lower_bound(Y + 1, Y + 1 + t2, y2) - Y;\n        // 差分计数\n        rec[x1][y1]++, rec[x2][y1]--;\n        rec[x1][y2]--, rec[x2][y2]++;\n    }\n    for (int i = 1;i &lt;= t1;i++) {\n        for (int j = 1;j &lt;= t2;j++) {\n            rec[i][j] += rec[i - 1][j] + rec[i][j - 1] - rec[i - 1][j - 1];\n        }\n    }\n    for (int i = 1;i &lt; t1;i++) {\n        for (int j = 1;j &lt; t2;j++) {\n            // 覆盖rec[i][j]次的矩形的面积\n            Stot[rec[i][j]] += (X[i + 1] - X[i]) * (Y[j + 1] - Y[j]) % mo998;\n            Stot[rec[i][j]] %= mo998;\n        }\n    }\n \n \n    for (int k = 1;k &lt;= n;k++) {\n        ll ans = 0, Cnk = C(n, k);\n        ll iCnk = inv(Cnk);\n        for (int i = 1;i &lt;= n;i++) {\n            ll Si = Stot[i];\n            ans += (Cnk - C(n - i, k) + mo998) % mo998 * iCnk % mo998 * Si % mo998;\n            ans %= mo998;\n        }\n        cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;;\n    }\n}\n \nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    init();\n    int t = 1;\n    // cin &gt;&gt; t;cin.tie(0);\n    while (t--)\n        solve();\n \n    return 0;\n}"},"03-algorithm/intervaldp":{"slug":"03-algorithm/intervaldp","filePath":"03-algorithm/intervaldp.md","title":"刷题记录||区间动态规划","links":[],"tags":["算法","DP"],"content":"区间动态规划一般以区间作为动态规划的阶段。\n[P1880]石子合并\n题目描述\n在一个圆形操场的四周摆放 N 堆石子，现要将石子有次序地合并成一堆，规定每次只能选相邻的 2 堆合并成新的一堆，并将新的一堆的石子数，记为该次合并的得分。\n试设计出一个算法,计算出将 N 堆石子合并成 1 堆的最小得分和最大得分。\n输入格式\n数据的第 1 行是正整数 N，表示有 N 堆石子。\n第 2 行有 N 个整数，第 i 个整数 a_i 表示第 i 堆石子的个数。\n输出格式\n输出共 2 行，第 1 行为最小得分，第 2 行为最大得分。\n样例 #1\n样例输入 #1\n4\n4 5 9 4\n样例输出 #1\n43\n54\n提示\n1\\leq N\\leq 100，0\\leq a_i\\leq 20​。\n思路\n考虑状态转移：\n每次合并区间[l,r]时，可以由区间[l,k]和[k+1,r]的状态转移过来，记f(i,j)是合并区间[i,j]的最大得分，sum(i,j)是合并[i,j]的得分，则有：\nf(i,j)=max(f(i,j),f(i,k)+f(k+1,j)+sum(i,j))\n此题考虑到是环形数组，可以将数组复制一倍，枚举区间长度是n的最优值。\n代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\ntypedef pair&lt;int, int&gt; pii;\nconst int maxn = 250;\nconst int mo109 = 1000000007;\n \nll a[maxn];\nll f1[maxn][maxn], f2[maxn][maxn];\n \nll pre[maxn];\n \nll sum(int l, int r) {\n    return pre[r] - pre[l - 1];\n}\n \nvoid solve() {\n    int n;cin &gt;&gt; n;\n    pre[0] = 0;\n    for (int i = 1;i &lt;= n;i++) {\n        cin &gt;&gt; a[i];\n        pre[i] = a[i] + pre[i - 1];\n    }\n    for (int i = n + 1;i &lt;= 2 * n;i++) {\n        pre[i] = a[i - n] + pre[i - 1];\n    }\n \n    for (int i = 0;i &lt;= 2 * n;i++) {\n        for (int j = 0;j &lt;= 2 * n;j++) {\n            f2[i][j] = f1[i][j] = 0;\n        }\n    }\n    for (int len = 1;len &lt;= n;len++) {\n        for (int i = 1;i + len &lt;= 2 * n;i++) {\n            int j = len + i - 1;\n            for (int k = i;k &lt; j;k++) {\n                if (!f1[i][j])f1[i][j] = f1[i][k] + f1[k + 1][j] + sum(i, j);\n                else f1[i][j] = min(f1[i][j], f1[i][k] + f1[k + 1][j] + sum(i, j));\n                f2[i][j] = max(f2[i][j], f2[i][k] + f2[k + 1][j] + sum(i, j));\n            }\n        }\n    }\n    ll mx = 0, mn = 1e18;\n    for (int i = 1;i &lt;= n;i++) {\n        int j = i + n - 1;\n        mx = max(mx, f2[i][j]);\n        mn = min(mn, f1[i][j]);\n    }\n    cout &lt;&lt; mn &lt;&lt; &#039;\\n&#039; &lt;&lt; mx &lt;&lt; &#039;\\n&#039;;\n}\n \nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int t = 1;\n    // cin &gt;&gt; t;cin.get();\n    while (t--)\n        solve();\n \n    return 0;\n}\n[P3146]248G\n题面翻译\n给定一个 1\\ \\times n 的地图，在里面玩 2048，每次可以合并相邻两个（数值范围 1\\sim 40），问序列中出现的最大数字的值最大是多少。注意合并后的数值并非加倍而是 +1，例如 2 与 2 合并后的数值为 3。\n题目描述\nBessie likes downloading games to play on her cell phone, even though she  doesfind the small touch screen rather cumbersome to use with her large hooves.\nShe is particularly intrigued by the current game she is playing.The game starts with a sequence of N positive integers (2 \\leq N\\leq 248), each in the range 1 \\ldots 40.  In one move, Bessie cantake two adjacent numbers with equal values and replace them a singlenumber of value one greater (e.g., she might replace two adjacent 7swith an 8).  The goal is to maximize the value of the largest numberpresent in the sequence at the end of the game.  Please help Bessiescore as highly as possible!\n输入格式\nThe first line of input contains N, and the next N lines give the sequence\nof N numbers at the start of the game.\n输出格式\nPlease output the largest integer Bessie can generate.\n样例 #1\n样例输入 #1\n4\n1\n1\n1\n2\n样例输出 #1\n3\n提示\nIn this example shown here, Bessie first merges the second and third 1s to\nobtain the sequence 1 2 2, and then she merges the 2s into a 3.  Note that it is\nnot optimal  to join the first two 1s.\n思路\n区间dp，考虑转移：\nf(i,j)=f(i,k)+1\\quad when:f(i,k)=f(k+1,j)\n同时要保证f(i,k)和f(k+1,j)在向f(i,j)转移之前，已经进行了”合并”。\n代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\ntypedef pair&lt;int, int&gt; pii;\nconst int maxn = 550;\nconst int mo109 = 1000000007;\n \nint a[maxn];\nint f[maxn][maxn];\nvoid solve() {\n    int n;cin &gt;&gt; n;\n    for (int i = 1;i &lt;= n;i++) {\n        cin &gt;&gt; a[i];\n    }\n    for (int i = 0;i &lt;= n;i++) {\n        for (int j = 0;j &lt;= n;j++) {\n            f[i][j] = 0;\n        }\n        if (i)\n            f[i][i] = a[i];\n    }\n    for (int len = 1;len &lt;= n;len++) {\n        for (int i = 1;i + len - 1 &lt;= n;i++) {\n            int j = i + len - 1;\n            for (int k = i;k + 1 &lt;= j;k++) {\n                if (f[i][k] == f[k + 1][j] &amp;&amp; f[i][k]) {\n                    f[i][j] = max(f[i][j], f[i][k] + 1);\n                }\n            }\n        }\n    }\n    int ans = a[1];\n    for (int i = 1;i &lt;= n;i++) {\n        for (int j = i;j &lt;= n;j++) {\n            ans = max(ans, f[i][j]);\n        }\n    }\n    cout &lt;&lt; ans &lt;&lt; &#039;\\n&#039;;\n}\n \nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int t = 1;\n    // cin &gt;&gt; t;cin.get();\n    while (t--)\n        solve();\n \n    return 0;\n}\n[NOIP2006 提高组] 能量项链\n题目描述\n在 Mars 星球上，每个 Mars 人都随身佩带着一串能量项链。在项链上有 N 颗能量珠。能量珠是一颗有头标记与尾标记的珠子，这些标记对应着某个正整数。并且，对于相邻的两颗珠子，前一颗珠子的尾标记一定等于后一颗珠子的头标记。因为只有这样，通过吸盘（吸盘是 Mars 人吸收能量的一种器官）的作用，这两颗珠子才能聚合成一颗珠子，同时释放出可以被吸盘吸收的能量。如果前一颗能量珠的头标记为 m，尾标记为 r，后一颗能量珠的头标记为 r，尾标记为 n，则聚合后释放的能量为 m \\times r \\times n（Mars 单位），新产生的珠子的头标记为 m，尾标记为 n。\n需要时，Mars 人就用吸盘夹住相邻的两颗珠子，通过聚合得到能量，直到项链上只剩下一颗珠子为止。显然，不同的聚合顺序得到的总能量是不同的，请你设计一个聚合顺序，使一串项链释放出的总能量最大。\n例如：设 N=4，4 颗珠子的头标记与尾标记依次为 (2,3)(3,5)(5,10)(10,2)。我们用记号 \\oplus 表示两颗珠子的聚合操作，(j \\oplus k) 表示第 j,k 两颗珠子聚合后所释放的能量。则第 4，1 两颗珠子聚合后释放的能量为：\n(4 \\oplus 1)=10 \\times 2 \\times 3=60。\n这一串项链可以得到最优值的一个聚合顺序所释放的总能量为：\n(((4 \\oplus 1) \\oplus 2) \\oplus 3)=10 \\times 2 \\times 3+10 \\times 3 \\times 5+10 \\times 5 \\times 10=710。\n输入格式\n第一行是一个正整数 N（4 \\le N \\le 100），表示项链上珠子的个数。第二行是 N 个用空格隔开的正整数，所有的数均不超过 1000。第 i 个数为第 i 颗珠子的头标记（1 \\le i \\le N），当 i&lt;N 时，第 i 颗珠子的尾标记应该等于第 i+1 颗珠子的头标记。第 N 颗珠子的尾标记应该等于第 1 颗珠子的头标记。\n至于珠子的顺序，你可以这样确定：将项链放到桌面上，不要出现交叉，随意指定第一颗珠子，然后按顺时针方向确定其他珠子的顺序。\n输出格式\n一个正整数 E（E\\le 2.1 \\times 10^9），为一个最优聚合顺序所释放的总能量。\n样例 #1\n样例输入 #1\n4\n2 3 5 10\n\n样例输出 #1\n710\n\n提示\nNOIP 2006 提高组 第一题\n思路\n将数组处理成环形数组，考虑转移：\nf(i,j)=max(f(i,j),f(i,k)+f(k+1,j)+head[i]\\times tail[k]\\times tail[j])\n枚举长度为n的区间，获得最大值。\n代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\ntypedef pair&lt;int, int&gt; pii;\nconst int maxn = 550;\nconst int mo109 = 1000000007;\n \nll h[maxn], t[maxn];\nll f[maxn][maxn];\nvoid solve() {\n    int n;cin &gt;&gt; n;\n    for (int i = 1;i &lt;= n;i++) {\n        cin &gt;&gt; h[i];\n        t[i - 1] = h[i];\n    }\n    for (int i = n + 1;i &lt;= 2 * n;i++) {\n        h[i] = h[i - n];\n        t[i - 1] = t[i - 1 - n];\n    }\n    t[2 * n] = t[n];\n \n    for (int i = 0;i &lt;= 2 * n;i++) {\n        for (int j = 0;j &lt;= 2 * n;j++) {\n            f[i][j] = 0;\n        }\n    }\n \n    for (int len = 1;len &lt;= n;len++) {\n        for (int i = 1;i + len - 1 &lt;= 2 * n;i++) {\n            int j = i + len - 1;\n            for (int k = i;k + 1 &lt;= j;k++) {\n                f[i][j] = max(f[i][j], f[i][k] + f[k + 1][j] + h[i] * t[k] * t[j]);\n            }\n        }\n    }\n    ll ans = 0;\n    for (int i = 1;i &lt;= n;i++) {\n        int j = i + n - 1;\n        ans = max(ans, f[i][j]);\n    }\n    cout &lt;&lt; ans &lt;&lt; &#039;\\n&#039;;\n}\n \nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int t = 1;\n    // cin &gt;&gt; t;cin.get();\n    while (t--)\n        solve();\n \n    return 0;\n}\n[NOIP2007 提高组] 矩阵取数游戏\n题目描述\n帅帅经常跟同学玩一个矩阵取数游戏：对于一个给定的 n \\times m 的矩阵，矩阵中的每个元素 a_{i,j} 均为非负整数。游戏规则如下：\n\n每次取数时须从每行各取走一个元素，共 n 个。经过 m 次后取完矩阵内所有元素；\n每次取走的各个元素只能是该元素所在行的行首或行尾；\n每次取数都有一个得分值，为每行取数的得分之和，每行取数的得分 = 被取走的元素值 \\times 2^i，其中 i 表示第 i 次取数（从 1 开始编号）；\n游戏结束总得分为 m 次取数得分之和。\n\n帅帅想请你帮忙写一个程序，对于任意矩阵，可以求出取数后的最大得分。\n输入格式\n输入文件包括 n+1 行：\n第一行为两个用空格隔开的整数 n 和 m。\n第 2\\sim n+1 行为 n \\times m 矩阵，其中每行有 m 个用单个空格隔开的非负整数。\n输出格式\n输出文件仅包含 1 行，为一个整数，即输入矩阵取数后的最大得分。\n样例 #1\n样例输入 #1\n2 3\n1 2 3\n3 4 2\n\n样例输出 #1\n82\n\n提示\n【数据范围】\n对于 60\\% 的数据，满足 1\\le n,m\\le 30，答案不超过 10^{16}。\n对于 100\\% 的数据，满足 1\\le n,m\\le 80，0\\le a_{i,j}\\le1000。\n【题目来源】\nNOIP 2007 提高第三题。\n思路\n设置f(i,j)表示取区间[i,j]获得的最大得分，根据题意可知，每行的最大值之间并不相关，可以分别计算每行取数得分的最大值再相加，注意此题涉及到高精度。\n考虑转移：\nf(i,j)可以由两种状态转移而来，一种是先取a[i]，再取f(i+1,j)，这时的得分是f(i+1,j)\\times 2 + a[i]\\times 2；另一种是先取a[j]，再取f(i,j-1)，这时的得分是f(i,j-1)\\times 2+a[j]\\times 2。两者取较大值即可。\n代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\ntypedef pair&lt;int, int&gt; pii;\nconst int maxn = 550;\nconst int mo109 = 1000000007;\nconst ll mo118 = 1e18;\n \nstruct int128 {\n    ll hig, low;\n    int128 operator+(const int128&amp; b)const {\n        int128 k = { 0ll,0ll };\n        k.low = low + b.low;\n        k.hig = k.low / mo118 + hig + b.hig;\n        k.low %= mo118;\n        return k;\n    }\n    int128 operator*(const int&amp; b)const {\n        int128 k = { 0ll,0ll };\n        k.low = b * low;\n        k.hig = k.low / mo118 + hig * b;\n        k.low %= mo118;\n        return k;\n    }\n    void output() {\n        if (!hig)cout &lt;&lt; low;\n        else cout &lt;&lt; hig &lt;&lt; setw(18) &lt;&lt; setfill(&#039;0&#039;) &lt;&lt; low;\n    }\n};\n \nbool leq(int128 a, int128 b) {\n    if (a.hig != b.hig)return a.hig &lt; b.hig;\n    return a.low &lt; b.low;\n}\n \nint128 a[maxn][maxn];\nint128 f[maxn][maxn];\nvoid solve() {\n    int n, m;cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1;i &lt;= n;i++) {\n        for (int j = 1;j &lt;= m;j++) {\n            cin &gt;&gt; a[i][j].low;\n            a[i][j].hig = 0ll;\n        }\n    }\n \n    int128 ans = { 0ll,0ll };\n    for (int ni = 1;ni &lt;= n;ni++) {\n        for (int i = 1;i &lt;= m;i++) {\n            for (int j = 1;j &lt;= m;j++) {\n                f[i][j] = { 0ll,0ll };\n            }\n        }\n \n        for (int len = 1;len &lt;= m;len++) {\n            for (int i = 1;i + len - 1 &lt;= m;i++) {\n                int j = i + len - 1;\n                int128 na = (f[i + 1][j] + a[ni][i]) * 2;\n                int128 nb = (f[i][j - 1] + a[ni][j]) * 2;\n                f[i][j] = max(na, nb, leq);\n            }\n        }\n        ans = ans + f[1][m];\n    }\n    ans.output();\n}\n \nint main() {\n    // ios::sync_with_stdio(false);\n    // cin.tie(0);\n    int t = 1;\n    // cin &gt;&gt; t;cin.get();\n    while (t--)\n        solve();\n \n    return 0;\n}\n[CQOI2007] 涂色\n题目描述\n假设你有一条长度为 5 的木板，初始时没有涂过任何颜色。你希望把它的 5 个单位长度分别涂上红、绿、蓝、绿、红色，用一个长度为 5 的字符串表示这个目标：\\texttt{RGBGR}。\n每次你可以把一段连续的木板涂成一个给定的颜色，后涂的颜色覆盖先涂的颜色。例如第一次把木板涂成 \\texttt{RRRRR}，第二次涂成 \\texttt{RGGGR}，第三次涂成 \\texttt{RGBGR}，达到目标。\n用尽量少的涂色次数达到目标。\n输入格式\n输入仅一行，包含一个长度为 n 的字符串，即涂色目标。字符串中的每个字符都是一个大写字母，不同的字母代表不同颜色，相同的字母代表相同颜色。\n输出格式\n仅一行，包含一个数，即最少的涂色次数。\n样例 #1\n样例输入 #1\nAAAAA\n\n样例输出 #1\n1\n\n样例 #2\n样例输入 #2\nRGBGR\n\n样例输出 #2\n3\n\n提示\n40\\% 的数据满足 1\\le n\\le 10。\n100\\% 的数据满足 1\\le n\\le 50。\n思路\n设f(i,j)表示完成区间[i,j]的最小涂色次数。取i\\leq k\\lt j则f(i,j)可以由f(i,k)和f(k+1,j)合并转移而来，转移时，若s[k]=s[k+1]，显然在区间[i,k]中涂位置k和涂位置k+1可以是同一步操作；若s[i]=s[j]，则涂位置i和j也可以是同一步操作，则转移方程如下：\nf(i,j)=f(i,k)+f(k+1,j)-(s[i]==s[j] \\or s[k]==s[k+1])\n代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\ntypedef pair&lt;int, int&gt; pii;\nconst int maxn = 550;\nconst int mo109 = 1000000007;\nconst ll mo118 = 1e18;\n \nll f[maxn][maxn];\nvoid solve() {\n    string s;cin &gt;&gt; s;\n    int n = s.size();\n    s = &quot; &quot; + s;\n    for (int i = 1;i &lt;= n;i++) {\n        for (int j = 1;j &lt;= n;j++) {\n            f[i][j] = 1e18;\n        }\n        f[i][i] = 1;\n    }\n    for (int len = 1;len &lt;= n;len++) {\n        for (int i = 1;i + len - 1 &lt;= n;i++) {\n            int j = i + len - 1;\n            // f[i][j]:完成[i,j]区间涂色的最小涂色次数\n            for (int k = i;k + 1 &lt;= j;k++) {\n                if (s[k] == s[k + 1] || s[i] == s[j])\n                    f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j] - 1);\n                else\n                    f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j]);\n            }\n        }\n    }\n    cout &lt;&lt; f[1][n] &lt;&lt; &quot;\\n&quot;;\n}\n \nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int t = 1;\n    // cin &gt;&gt; t;cin.get();\n    while (t--)\n        solve();\n \n    return 0;\n}\n[SCOI2003] 字符串折叠\n题目描述\n折叠的定义如下：\n\n\n一个字符串可以看成它自身的折叠。记作 S = S\n\n\nX(S) 是 X 个 S 连接在一起的串的折叠。记作 X(S) = SSSS…S。\n\n\n如果 A = A’, B = B’，则 AB = A’B’ 。例如：因为 3(A) = AAA, 2(B) = BB，所以 3(A)C2(B) = AAACBB，而 2(3(A)C)2(B) = AAACAAACBB\n\n\n给一个字符串，求它的最短折叠。\n例如 AAAAAAAAAABABABCCD 的最短折叠为：9(A)3(AB)CCD。\n输入格式\n仅一行，即字符串 S，长度保证不超过 100。\n输出格式\n仅一行，即最短的折叠长度。\n样例 #1\n样例输入 #1\nNEERCYESYESYESNEERCYESYESYES\n\n样例输出 #1\n14\n\n提示\n一个最短的折叠为：2(NEERC3(YES))\n思路\n设f(i,j)是区间[i,j]折叠之后的最短长度，如果区间[i,j]可以被折叠，则状态转移：\nf(i,j)=max(f(i,j),f(i,k)+2+Len((j-i+1)/(k-i+1)))\n代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\ntypedef pair&lt;int, int&gt; pii;\nconst int maxn = 550;\nconst int mo109 = 1000000007;\nconst ll mo118 = 1e18;\n \nstring s;\nint n;\nll f[maxn][maxn];\nll ff[maxn][maxn];\n \nint Len(int x) {\n    if (x == 1)return -2;\n    int res = 0;\n    while (x) {\n        res++;\n        x /= 10;\n    }\n    return res;\n}\n \nbool check(int l, int r, int p) {\n    for (int i = l + p;i &lt;= r;i++) {\n        if (s[i] == s[(i - l) % p + l])continue;\n        return false;\n    }\n    return true;\n}\n \nvoid solve() {\n    cin &gt;&gt; s;\n    n = s.size();\n    s = &quot; &quot; + s;\n    for (int i = 1;i &lt;= n;i++) {\n        for (int j = 1;j &lt;= n;j++) {\n            f[i][j] = max(0, j - i + 1); // S=S&#039;\n        }\n        f[i][i] = 1;\n    }\n \n    for (int len = 2;len &lt;= n;len++) { // 区间长度是len\n        for (int i = 1;i + len - 1 &lt;= n;i++) {\n            int j = i + len - 1;\n            for (int k = i;k + 1 &lt;= j;k++) {\n                f[i][j] = min(f[i][j], f[i][k] + f[k + 1][j]);\n            }\n            for (int d = 1;d + i - 1 &lt; j;d++) {\n                if (len % d)continue;\n                // [i,j]按照长度d进行折叠\n                int k = d + i - 1;\n                if (check(i, j, d)) {\n                    f[i][j] = min(f[i][j], f[i][k] + 2 + Len(len / d));\n                }\n            }\n        }\n    }\n \n    cout &lt;&lt; f[1][n] &lt;&lt; &#039;\\n&#039;;\n}\n \nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int t = 1;\n    // cin &gt;&gt; t;cin.get();\n    while (t--)\n        solve();\n \n    return 0;\n}"},"03-algorithm/lchot100":{"slug":"03-algorithm/lchot100","filePath":"03-algorithm/lchot100.md","title":"LeetCode Hot 100记录（19/100）","links":[],"tags":["算法","LeetCode"],"content":"哈希(3/3)\n1. 两数之和\n题意\n给定一个整数数组  nums  和一个整数目标值  target，请你在该数组中找出  和为目标值 target  的那  两个  整数，并返回它们的数组下标。\n你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。\n你可以按任意顺序返回答案。\n代码\nclass Solution {\npublic:\n    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {\n        unordered_map&lt;int, int&gt; mp;\n        int n = nums.size();\n        for (int i = 0; i &lt; n; i++) {\n            if (mp.count(target - nums[i])) {\n                return {mp[target - nums[i]], i};\n            }\n            mp[nums[i]] = i;\n        }\n        return {};\n    }\n};\n49. 字母异位词分组\n题意\n给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。\n字母异位词 是由重新排列源单词的所有字母得到的一个新单词。\n代码\nclass Solution {\npublic:\n    vector&lt;vector&lt;string&gt;&gt; groupAnagrams(vector&lt;string&gt;&amp; strs) {\n        unordered_map&lt;string, vector&lt;string&gt;&gt; mp;\n        for (auto&amp; s : strs) {\n            string t = s;\n            sort(t.begin(), t.end());\n            mp[t].push_back(s);\n        }\n        vector&lt;vector&lt;string&gt;&gt; v;\n        for (auto&amp; i : mp) {\n            v.push_back(move(i.second));\n        }\n        return v;\n    }\n};\n128. 最长连续序列\n题意\n给定一个未排序的整数数组  nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。\n请你设计并实现时间复杂度为  O(n)  的算法解决此问题。\n代码\nclass Solution {\npublic:\n    int longestConsecutive(vector&lt;int&gt;&amp; nums) {\n        if (nums.empty())\n            return 0;\n        if (nums.size() == 1)\n            return 1;\n \n        sort(nums.begin(), nums.end());\n        int ans = 1, mx = 1;\n        int n = nums.size();\n        for (int i = 1; i &lt; n; i++) {\n            if (nums[i] == nums[i - 1])\n                continue;\n            if (nums[i] == nums[i - 1] + 1) {\n                mx++;\n            } else {\n                mx = 1;\n            }\n            ans = max(mx, ans);\n        }\n        return ans;\n    }\n};\n双指针(4/4)\n283. 移动零\n题意\n给定一个数组  nums，编写一个函数将所有  0  移动到数组的末尾，同时保持非零元素的相对顺序。\n请注意 ，必须在不复制数组的情况下原地对数组进行操作。\n代码\nclass Solution {\npublic:\n    void moveZeroes(vector&lt;int&gt;&amp; nums) {\n        int pre = 0, cur = 0;\n        while (cur &lt; nums.size()) {\n            if (nums[cur]) {\n                if (pre != cur)\n                    swap(nums[pre], nums[cur]);\n                pre++;\n            }\n            cur++;\n        }\n    }\n};\n11. 盛最多水的容器\n题意\n给定一个长度为  n  的整数数组  height 。有  n  条垂线，第  i  条线的两个端点是  (i, 0)  和  (i, height[i]) 。\n找出其中的两条线，使得它们与  x  轴共同构成的容器可以容纳最多的水。\n返回容器可以储存的最大水量。\n说明： 你不能倾斜容器。\n代码\nclass Solution {\npublic:\n    int maxArea(vector&lt;int&gt;&amp; height) {\n        int l = 0, r = height.size() - 1;\n        int cur = (r - l) * min(height[l], height[r]);\n        int ans = cur;\n        while (l &lt; r) {\n            ans = max(ans, cur);\n            if (height[l] &lt; height[r]) {\n                l++;\n            } else {\n                r--;\n            }\n            cur = (r - l) * min(height[l], height[r]);\n        }\n        return ans;\n    }\n};\n15. 三数之和\n题意\n给你一个整数数组  nums ，判断是否存在三元组  [nums[i], nums[j], nums[k]]  满足  i != j、i != k  且  j != k ，同时还满足  nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为  0  且不重复的三元组。\n注意： 答案中不可以包含重复的三元组。\n代码\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {\n        int n = nums.size();\n        sort(nums.begin(), nums.end());\n        vector&lt;vector&lt;int&gt;&gt; res;\n        int i = 0;\n        while (i + 2 &lt; n) {\n            if (nums[i] &gt; 0) {\n                break;\n            }\n            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) {\n                i++;\n                continue;\n            }\n \n            int l = i + 1, r = n - 1;\n            while (l &lt; r) {\n                if (nums[i] + nums[l] + nums[r] &lt; 0) {\n                    l++;\n                } else if (nums[i] + nums[l] + nums[r] &gt; 0) {\n                    r--;\n                } else {\n                    res.push_back({nums[i], nums[l], nums[r]});\n                    while (l &lt; r &amp;&amp; nums[l] == nums[l + 1]) {\n                        l++;\n                    }\n                    while (l &lt; r &amp;&amp; nums[r] == nums[r - 1]) {\n                        r--;\n                    }\n                    l++, r--;\n                }\n            }\n            i++;\n        }\n        return res;\n    }\n};\n42. 接雨水\n题意\n给定  n  个非负整数表示每个宽度为  1  的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n代码\nclass Solution {\npublic:\n    int trap(vector&lt;int&gt;&amp; height) {\n        int n = height.size();\n        int lmx = 0, rmx = 0, mx = 0;\n        int ans = 0;\n        int l = 0, r = n - 1;\n        while (l &lt; r) {\n            lmx = max(lmx, height[l]);\n            rmx = max(rmx, height[r]);\n            if (height[l] &lt; height[r]) { // 低的存水上限已经定了\n                ans += lmx - height[l];\n                l++;\n            } else {\n                ans += rmx - height[r];\n                r--;\n            }\n        }\n        return ans;\n    }\n};\n滑动窗口(2/2)\n3. 无重复字符的最长子串\n题意\n给定一个字符串  s ，请你找出其中不含有重复字符的  最长子串  的长度。\n代码\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        int n = s.size();\n        if (!n) {\n            return 0;\n        }\n        unordered_map&lt;char, int&gt; cnt;\n        int l = 0, r = 1;\n        int ans = 1;\n        cnt[s[0]]++;\n        while (r &lt; n) {\n            while (r &lt; n &amp;&amp; cnt[s[r]] == 0) {\n                cnt[s[r]]++;\n                r++;\n            }\n            ans = max(r - l, ans);\n            while (l &lt; r &amp;&amp; cnt[s[r]] != 0) {\n                cnt[s[l]]--;\n                l++;\n            }\n            if (r &lt; n) {\n                cnt[s[r]]++;\n                r++;\n            }\n        }\n \n        return ans;\n    }\n};\n438. 找到字符串中所有字母异位词\n题意\n给定两个字符串  s  和  p，找到  s  中所有  p  的  异位词  的子串，返回这些子串的起始索引。不考虑答案输出的顺序。\n代码\nclass Solution {\npublic:\n    vector&lt;int&gt; findAnagrams(string s, string p) {\n        if (s.size() &lt; p.size() || s.empty() || p.empty()) {\n            return {};\n        }\n        vector&lt;int&gt; ts(26, 0), tp(26, 0);\n        int n = s.size(), m = p.size();\n        for (int i = 0; i &lt; m; i++) {\n            ts[s[i] - &#039;a&#039;]++, tp[p[i] - &#039;a&#039;]++;\n        }\n        int mc = 0;\n        for (int i = 0; i &lt; 26; i++) {\n            mc += tp[i] == ts[i];\n        }\n        int l = 0, r = m;\n        vector&lt;int&gt; pos;\n        while (r &lt;= n) {\n            if (mc == 26) {\n                pos.push_back(l);\n            }\n            if (r == n)\n                break;\n            mc -= tp[s[l] - &#039;a&#039;] == ts[s[l] - &#039;a&#039;];\n            mc -= tp[s[r] - &#039;a&#039;] == ts[s[r] - &#039;a&#039;];\n            ts[s[l] - &#039;a&#039;]--, ts[s[r] - &#039;a&#039;]++;\n            mc += tp[s[l] - &#039;a&#039;] == ts[s[l] - &#039;a&#039;];\n            mc += tp[s[r] - &#039;a&#039;] == ts[s[r] - &#039;a&#039;];\n            l++, r++;\n        }\n \n        return pos;\n    }\n};\n子串(3/3)\n560. 和为 K 的子数组\n题意\n给你一个整数数组  nums  和一个整数  k ，请你统计并返回  该数组中和为  k  的子数组的个数 。\n子数组是数组中元素的连续非空序列。\n代码\nclass Solution {\npublic:\n    int subarraySum(vector&lt;int&gt;&amp; nums, int k) {\n        int n = nums.size();\n        vector&lt;int&gt; pre(n + 1, 0);\n        unordered_map&lt;int, int&gt; mp;\n        int ans = 0;\n        mp[0] = 1;\n        for (int i = 0; i &lt; n; i++) {\n            pre[i + 1] = pre[i] + nums[i];\n            ans += mp[pre[i + 1] - k];\n            mp[pre[i + 1]]++;\n        }\n        return ans;\n    }\n};\n239. 滑动窗口最大值\n题意\n给你一个整数数组  nums，有一个大小为  k  的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的  k  个数字。滑动窗口每次只向右移动一位。\n返回  滑动窗口中的最大值 。\n代码\nvector&lt;int&gt; maxSlidingWindow(vector&lt;int&gt; &amp;nums, int k) {\n  deque&lt;int&gt; q;\n  int n = nums.size();\n  for (int i = 0; i &lt; k; i++) {\n    while (!q.empty() &amp;&amp; nums[q.back()] &lt; nums[i]) {\n      q.pop_back();\n    }\n    q.push_back(i);\n  }\n  vector&lt;int&gt; ans = {nums[q.front()]};\n  for (int i = k; i &lt; n; i++) {\n    while (!q.empty() &amp;&amp; q.front() &lt;= i - k) {\n      q.pop_front();\n    }\n    while (!q.empty() &amp;&amp; nums[q.back()] &lt; nums[i]) {\n      q.pop_back();\n    }\n    q.push_back(i);\n    ans.push_back(nums[q.front()]);\n  }\n \n  return ans;\n}\n76. 最小覆盖子串\n题意\n给你一个字符串  s 、一个字符串  t 。返回  s  中涵盖  t  所有字符的最小子串。如果  s  中不存在涵盖  t  所有字符的子串，则返回空字符串  &quot;&quot; 。\n代码\nclass Solution {\npublic:\n    string minWindow(string s, string t) {\n        int n = s.size(), m = t.size();\n        if (n &lt; m) {\n            return &quot;&quot;;\n        }\n        vector&lt;int&gt; mc(128, 0), cur(128, 0);\n        for (int i = 0; i &lt; m; i++) {\n            mc[t[i]]++, cur[s[i]]++;\n        }\n \n        int tot = 0;\n \n        for (char c = &#039;A&#039;; c &lt;= &#039;Z&#039;; c++) {\n            if (mc[c] &lt;= cur[c]) {\n                tot++;\n            }\n        }\n        for (char c = &#039;a&#039;; c &lt;= &#039;z&#039;; c++) {\n            if (mc[c] &lt;= cur[c]) {\n                tot++;\n            }\n        }\n \n        int L = 0, R = 0;\n        string ans = &quot;&quot;;\n        int l = 0, r = m;\n        if (tot == 52) {\n            if (R == 0 || r - l &lt; R - L) {\n                L = l, R = r;\n            }\n        }\n        while (r &lt; n) {\n            while (tot != 52 &amp;&amp; r &lt; n) {\n                tot -= cur[s[r]] &gt;= mc[s[r]];\n                cur[s[r]]++;\n                tot += cur[s[r]] &gt;= mc[s[r]];\n                r++;\n            }\n            while (l &lt; r &amp;&amp; mc[s[l]] &lt; cur[s[l]]) {\n                tot -= cur[s[l]] &gt;= mc[s[l]];\n                cur[s[l]]--;\n                tot += cur[s[l]] &gt;= mc[s[l]];\n                l++;\n            }\n            if (tot == 52) {\n                if (R == 0 || r - l &lt; R - L) {\n                    L = l, R = r;\n                }\n            }\n            tot -= cur[s[l]] &gt;= mc[s[l]];\n            cur[s[l]]--;\n            tot += cur[s[l]] &gt;= mc[s[l]];\n            l++;\n            while (l &lt; r &amp;&amp; mc[s[l]] == 0) {\n                tot -= cur[s[l]] &gt;= mc[s[l]];\n                cur[s[l]]--;\n                tot += cur[s[l]] &gt;= mc[s[l]];\n                l++;\n            }\n        }\n \n        return s.substr(L, R - L);\n    }\n};\n普通数组(5/5)\n53. 最大子数组和\n题意\n给你一个整数数组  nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n子数组是数组中的一个连续部分。\n代码\nclass Solution {\npublic:\n    int maxSubArray(vector&lt;int&gt;&amp; nums) {\n        int pre = 0;\n        int mx = nums.front();\n        for (int i : nums) {\n            pre = max(pre + i, i);\n            mx = max(mx, pre);\n        }\n        return mx;\n    }\n};\n56. 合并区间\n题意\n以数组  intervals  表示若干个区间的集合，其中单个区间为  intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回  一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。\n代码\nclass Solution {\npublic:\n    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt;&amp; intervals) {\n        sort(intervals.begin(), intervals.end());\n        vector&lt;vector&lt;int&gt;&gt; v;\n        int l = -1, r = -1;\n        for (auto&amp; a : intervals) {\n            if (l == -1) {\n                l = a[0], r = a[1];\n                continue;\n            }\n            if (a[0] &gt; r) {\n                v.push_back({l, r});\n                l = a[0];\n            }\n            r = max(r, a[1]);\n        }\n        v.push_back({l, r});\n        return v;\n    }\n};\n57. 轮转数组\n题意\n给定一个整数数组  nums，将数组中的元素向右轮转  k  个位置，其中  k  是非负数。\n代码\nclass Solution {\npublic:\n    void rotate(vector&lt;int&gt;&amp; nums, int k) {\n        int n = nums.size();\n        k %= n;\n        reverse(nums.begin(), nums.end());\n        reverse(nums.begin(), nums.begin() + k);\n        reverse(nums.begin() + k, nums.end());\n    }\n};\n58. 除自身以外数组的乘积\n题意\n给你一个整数数组  nums，返回 数组  answer ，其中  answer[i]  等于  nums  中除  nums[i]  之外其余各元素的乘积  。\n题目数据  保证  数组  nums之中任意元素的全部前缀元素和后缀的乘积都在   32 位  整数范围内。\n请  不要使用除法， 且在  O(n)  时间复杂度内完成此题。\n代码\nclass Solution {\npublic:\n    vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) {\n        int n = nums.size();\n        vector&lt;int&gt; pre(n, 1), suf(n, 1);\n        pre[0] = nums[0], suf[n - 1] = nums[n - 1];\n        for (int i = 1; i &lt; n; i++) {\n            pre[i] = pre[i - 1] * nums[i];\n            suf[n - i - 1] = suf[n - i] * nums[n - i - 1];\n        }\n        vector&lt;int&gt; arr;\n        for (int i = 0; i &lt; n; i++) {\n            if (i - 1 &gt;= 0 &amp;&amp; i + 1 &lt;= n - 1)\n                arr.push_back(pre[i - 1] * suf[i + 1]);\n            else if (i == 0)\n                arr.push_back(suf[1]);\n            else\n                arr.push_back(pre[n - 2]);\n        }\n        return arr;\n    }\n};\n59. 缺失的第一个正数\n题意\n给你一个未排序的整数数组  nums ，请你找出其中没有出现的最小的正整数。\n请你实现时间复杂度为  O(n)  并且只使用常数级别额外空间的解决方案。\n代码\nclass Solution {\npublic:\n    int firstMissingPositive(vector&lt;int&gt;&amp; nums) {\n        int n = nums.size();\n        for (int i = 0; i &lt; n; i++) {\n            if (nums[i] &lt;= 0)\n                continue;\n            while (nums[i] &lt;= n &amp;&amp; nums[i] - 1 &gt;= 0 &amp;&amp;\n                   nums[nums[i] - 1] != nums[i]) {\n                swap(nums[i], nums[nums[i] - 1]);\n            }\n        }\n        for (int i = 0; i &lt; n; i++) {\n            if (nums[i] != i + 1)\n                return i + 1;\n        }\n        return n + 1;\n    }\n};\n矩阵(2/4)\n73. 矩阵置零\n题意\n给定一个  m \\times n  的矩阵，如果一个元素为  0 ，则将其所在行和列的所有元素都设为  0 。请使用  原地  算法。\n代码\nclass Solution {\npublic:\n    void setZeroes(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {\n        int n = matrix.size();\n        if (!n)\n            return;\n        int m = matrix[0].size();\n        vector&lt;bool&gt; row(n), col(m);\n        for (int i = 0; i &lt; n; i++) {\n            for (int j = 0; j &lt; m; j++) {\n                if (matrix[i][j] == 0) {\n                    row[i] = col[j] = true;\n                }\n            }\n        }\n        for (int i = 0; i &lt; n; i++) {\n            for (int j = 0; j &lt; m; j++) {\n                if (row[i] || col[j])\n                    matrix[i][j] = 0;\n            }\n        }\n    }\n};\n54. 螺旋矩阵\n题意\n给你一个  m  行  n  列的矩阵  matrix ，请按照  顺时针螺旋顺序 ，返回矩阵中的所有元素。\n代码\nclass Solution {\npublic:\n    vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) {\n        int n = matrix.size();\n        if (!n)\n            return {};\n        if (n == 1)\n            return matrix[0];\n        int m = matrix[0].size();\n        if (m == 1) {\n            vector&lt;int&gt; v;\n            for (int i = 0; i &lt; n; i++)\n                v.emplace_back(matrix[i][0]);\n            return v;\n        }\n        int x = 0, y = 0, k = 0;\n        vector&lt;pair&lt;int, int&gt;&gt; dxy = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n        vector&lt;int&gt; v = {matrix[x][y]};\n        matrix[x][y] = -101;\n        while (v.size() &lt; n * m) {\n            int px = x + dxy[k].first, py = y + dxy[k].second;\n            if (px &lt; 0 || px &gt;= n || py &lt; 0 || py &gt;= m ||\n                matrix[px][py] == -101) {\n                k = (k + 1) % 4;\n                px = x + dxy[k].first, py = y + dxy[k].second;\n            }\n            v.push_back(matrix[px][py]);\n            matrix[px][py] = -101;\n            x = px, y = py;\n        }\n \n        return v;\n    }\n};\n48. 旋转图像\n题意\n给定一个  n\\times n 的二维矩阵  matrix  表示一个图像。请你将图像顺时针旋转 90 度。\n你必须在  原地  旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要  使用另一个矩阵来旋转图像。\n240. 搜索二维矩阵 II\n"},"03-algorithm/lineardp":{"slug":"03-algorithm/lineardp","filePath":"03-algorithm/lineardp.md","title":"刷题记录||线性动态规划","links":[],"tags":["算法","DP"],"content":"线性动态规划\n线性动态规划，即具有线性阶段划分的动态规划。\n[P1216]数字三角形\n题目描述\n观察下面的数字金字塔。\n写一个程序来查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到左下方的点也可以到达右下方的点。\n\n在上面的样例中，从 7 \\to 3 \\to 8 \\to 7 \\to 5 的路径产生了最大权值。\n输入格式\n第一个行一个正整数 r ,表示行的数目。\n后面每行为这个数字金字塔特定行包含的整数。\n输出格式\n单独的一行,包含那个可能得到的最大的和。\n样例 #1\n样例输入 #1\n5\n7\n3 8\n8 1 0\n2 7 4 4\n4 5 2 6 5\n样例输出 #1\n30\n提示\n【数据范围】\n对于 100\\% 的数据，1\\le r \\le 1000，所有输入在 [0,100] 范围内。\n题目翻译来自NOCOW。\nUSACO Training Section 1.5\nIOI1994 Day1T1\n参考代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 120;\nll number[maxn][maxn];\nll dp[maxn][maxn]; // 记录走到(i,j)点时最好的和\n \nint main() {\n    int n;\n    cin &gt;&gt; n;\n    for (int i = 1;i &lt;= n;i++)\n        for (int j = 1;j &lt;= i;j++)\n            cin &gt;&gt; number[i][j];\n    for (int i = 1;i &lt; n;i++)\n        dp[n][i] = number[n][i];\n    for (int i = n;i &gt; 1;i--) {\n        for (int j = 1;j &lt;= i;j++) {\n            dp[i - 1][j] = max(dp[i][j], dp[i][j + 1]) + number[i - 1][j];\n        }\n    }\n    cout &lt;&lt; dp[1][1] &lt;&lt; endl;\n \n    return 0;\n}\n[P1020]导弹拦截\n题目描述\n某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。\n输入导弹依次飞来的高度，计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。\n输入格式\n一行，若干个整数，中间由空格隔开。\n输出格式\n两行，每行一个整数，第一个数字表示这套系统最多能拦截多少导弹，第二个数字表示如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。\n样例 #1\n样例输入 #1\n389 207 155 300 299 170 158 65\n样例输出 #1\n6\n2\n提示\n对于前 50\\% 数据（NOIP 原题数据），满足导弹的个数不超过 10^4 个。该部分数据总分共 100 分。可使用\\mathcal O(n^2) 做法通过。\n对于后 50\\% 的数据，满足导弹的个数不超过 10^5 个。该部分数据总分也为 100 分。请使用 \\mathcal O(n\\log n) 做法通过。\n对于全部数据，满足导弹的高度为正整数，且不超过 5\\times 10^4。\n此外本题开启 spj，每点两问，按问给分。\n\n\\text{upd 2022.8.24}：新增加一组 Hack 数据。\n参考代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 1e5 + 50;\nvector&lt;int&gt;a, b, c;\nint main() {\n    int n;\n    while (cin &gt;&gt; n) { a.push_back(n); }\n    for (int i = 0;i &lt; a.size();i++) {\n        if (b.size() == 0 || a[i] &lt;= b.back())\n            b.push_back(a[i]);\n        else {\n            int l = 0, r = b.size() - 1;\n            int pos = 0;\n            while (l &lt; r) {\n                pos = (l + r) / 2;\n                if (b[pos] &gt;= a[i])l = pos + 1;\n                else r = pos;\n            }\n            b[l] = a[i];\n        }\n        if (c.size() == 0 || c.back() &lt; a[i])\n            c.push_back(a[i]);\n        else {\n            int l = 0, r = c.size() - 1;\n            int pos = 0;\n            while (l &lt; r) {\n                pos = (l + r) / 2;\n                if (c[pos] &lt; a[i])l = pos + 1;\n                else r = pos;\n            }\n            c[l] = a[i];\n        }\n    }\n    cout &lt;&lt; b.size() &lt;&lt; endl;\n    cout &lt;&lt; c.size() &lt;&lt; endl;\n \n    return 0;\n}\n[P1091]合唱队形\n题目描述\nn 位同学站成一排，音乐老师要请其中的 n-k 位同学出列，使得剩下的 k 位同学排成合唱队形。\n合唱队形是指这样的一种队形：设 k 位同学从左到右依次编号为 1,2, … ,k，他们的身高分别为 t_1,t_2, … ,t_k，则他们的身高满足 t_1&lt; \\cdots &lt;t_i&gt;t_{i+1}&gt; … &gt;t_k(1\\le i\\le k)。\n你的任务是，已知所有 n 位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。\n输入格式\n共二行。\n第一行是一个整数 n（2\\le n\\le100），表示同学的总数。\n第二行有 n 个整数，用空格分隔，第 i 个整数 t_i（130\\le t_i\\le230）是第 i 位同学的身高（厘米）。\n输出格式\n一个整数，最少需要几位同学出列。\n样例 #1\n样例输入 #1\n8\n186 186 150 200 160 130 197 220\n样例输出 #1\n4\n提示\n对于 50\\% 的数据，保证有 n \\le 20。\n对于全部的数据，保证有 n \\le 100。\n参考代码\nvoid solve() {\n    int n;cin &gt;&gt; n;\n    vector&lt;int&gt;t;\n    for (int i = 0; i &lt; n; i++) {\n        int x;cin &gt;&gt; x;\n        t.push_back(x);\n    }\n    int k = 1;\n    for (int m = 0;m &lt; n;m++) {\n        // 枚举中间位m\n        vector&lt;int&gt;l, r;\n        // 左边最长上升子序列\n        for (int i = 0;i &lt; m;i++) {\n            if (t[i] &gt;= t[m])continue;\n            if (l.size()!=0) {\n                if (t[i] &gt; l.back()) {\n                    l.push_back(t[i]);\n                }\n                else {\n                    auto it = lower_bound(l.begin(), l.end(), t[i]);\n                    *it = t[i];\n                }\n            }\n            else {\n                l.push_back(t[i]);\n            }\n        }\n        \n        // 右边最长上升子序列\n        for (int i = n - 1;i &gt; m;i--) {\n            if (t[i] &gt;= t[m])continue;\n            if (r.size()!=0) {\n                if (t[i] &gt; r.back()) {\n                    r.push_back(t[i]);\n                }\n                else {\n                    auto it = lower_bound(r.begin(), r.end(), t[i]);\n                    *it = t[i];\n                }\n            }\n            else {\n                r.push_back(t[i]);\n            }\n        }\n        k = max(k, (int)l.size() + (int)r.size() + 1);\n    }\n    cout &lt;&lt; n - k &lt;&lt; endl;\n}\n[P1095]守望者的逃离\n题目背景\n恶魔猎手尤迪安野心勃勃，他背叛了暗夜精灵，率领深藏在海底的娜迦族企图叛变。\n题目描述\n守望者在与尤迪安的交锋中遭遇了围杀，被困在一个荒芜的大岛上。\n为了杀死守望者，尤迪安开始对这个荒岛施咒，这座岛很快就会沉下去。到那时，岛上的所有人都会遇难。\n守望者的跑步速度为 17m/s，以这样的速度是无法逃离荒岛的。庆幸的是守望者拥有闪烁法术，可在 1s 内移动 60m，不过每次使用闪烁法术都会消耗魔法值 10 点。守望者的魔法值恢复的速度为 4 点每秒，只有处在原地休息状态时才能恢复。\n现在已知守望者的魔法初值 M，他所在的初始位置与岛的出口之间的距离 S，岛沉没的时间 T。你的任务是写一个程序帮助守望者计算如何在最短的时间内逃离荒岛，若不能逃出，则输出守望者在剩下的时间内能走的最远距离。\n注意：守望者跑步、闪烁或休息活动均以秒为单位，且每次活动的持续时间为整数秒。距离的单位为米。\n输入格式\n输入数据共一行三个非负整数，分别表示 M，S，T。\n输出格式\n输出数据共两行。\n第一行一个字符串 \\texttt{Yes} 或 \\texttt{No}，即守望者是否能逃离荒岛。\n第二行包含一个整数。第一行为 \\texttt{Yes} 时表示守望者逃离荒岛的最短时间；第一行为 \\texttt{No} 时表示守望者能走的最远距离。\n样例 #1\n样例输入 #1\n39 200 4\n样例输出 #1\nNo\n197\n样例 #2\n样例输入 #2\n36 255 10\n样例输出 #2\nYes\n6\n提示\n对于 30\\% 的数据，1  \\le  T   \\le  10， 1   \\le   S   \\le  100；\n对于 50\\% 的数据，1   \\le  T   \\le   10^3， 1   \\le  S  \\le   10^4；\n对于 100\\% 的数据，1   \\le   T   \\le   3\\times  10^5，0   \\le   M   \\le   10^3， 1   \\le  S   \\le   10^8。\n参考代码\nvoid solve() {\n    ll m, s, t;cin &gt;&gt; m &gt;&gt; s &gt;&gt; t;\n    vector&lt;ll&gt;f(t + 1);\n    f[0] = 0;ll bl = m;\n    for (ll i = 1;i &lt;= t;i++) {\n        if (bl &gt;= 10) {\n            f[i] = f[i - 1] + 60;\n            bl -= 10;\n        }\n        else {\n            f[i] = f[i - 1];\n            bl += 4;\n        }\n    }\n    for (int i = 1;i &lt;= t;i++) {\n        f[i] = max(f[i], f[i - 1] + 17);\n    }\n    if (f[t] &gt;= s) {\n        cout &lt;&lt; &quot;Yes\\n&quot;;\n        cout &lt;&lt; lower_bound(f.begin(), f.end(), s) - f.begin() &lt;&lt; endl;\n    }\n    else {\n        cout &lt;&lt; &quot;No\\n&quot; &lt;&lt; f[t] &lt;&lt; endl;\n    }\n}\n[P1541]乌龟棋\n题目背景\n小明过生日的时候，爸爸送给他一副乌龟棋当作礼物。\n题目描述\n乌龟棋的棋盘是一行 N 个格子，每个格子上一个分数（非负整数）。棋盘第 1 格是唯一的起点，第 N 格是终点，游戏要求玩家控制一个乌龟棋子从起点出发走到终点。\n乌龟棋中 M 张爬行卡片，分成 4 种不同的类型（M 张卡片中不一定包含所有 4 种类型的卡片，见样例），每种类型的卡片上分别标有 1,2,3,4 四个数字之一，表示使用这种卡片后，乌龟棋子将向前爬行相应的格子数。游戏中，玩家每次需要从所有的爬行卡片中选择一张之前没有使用过的爬行卡片，控制乌龟棋子前进相应的格子数，每张卡片只能使用一次。\n游戏中，乌龟棋子自动获得起点格子的分数，并且在后续的爬行中每到达一个格子，就得到该格子相应的分数。玩家最终游戏得分就是乌龟棋子从起点到终点过程中到过的所有格子的分数总和。\n很明显，用不同的爬行卡片使用顺序会使得最终游戏的得分不同，小明想要找到一种卡片使用顺序使得最终游戏得分最多。\n现在，告诉你棋盘上每个格子的分数和所有的爬行卡片，你能告诉小明，他最多能得到多少分吗？\n输入格式\n每行中两个数之间用一个空格隔开。\n第 1 行 2 个正整数 N,M，分别表示棋盘格子数和爬行卡片数。\n第 2 行 N 个非负整数，a_1,a_2,…,a_N，其中 a_i 表示棋盘第 i 个格子上的分数。\n第 3 行 M 个整数，b_1,b_2,…,b_M，表示 M 张爬行卡片上的数字。\n输入数据保证到达终点时刚好用光M张爬行卡片。\n输出格式\n1 个整数，表示小明最多能得到的分数。\n样例 #1\n样例输入 #1\n9 5\n6 10 14 2 8 8 18 5 17\n1 3 1 2 1\n样例输出 #1\n73\n提示\n每个测试点 1s。\n小明使用爬行卡片顺序为 1,1,3,1,2，得到的分数为 6+10+14+8+18+17=73。注意，由于起点是 1，所以自动获得第 1 格的分数 6。\n对于 30\\% 的数据有 1≤N≤30,1≤M≤12。\n对于 50\\% 的数据有 1≤N≤120,1≤M≤50，且 4 种爬行卡片，每种卡片的张数不会超过 20。\n对于 100\\% 的数据有 1≤N≤350,1≤M≤120，且 4 种爬行卡片，每种卡片的张数不会超过 40；0≤a_i≤100,1≤i≤N,1≤b_i≤4,1≤i≤M。\n参考代码\nvoid solve() {\n    ll n, m;cin &gt;&gt; n &gt;&gt; m;\n    vector&lt;ll&gt;a(n + 1);\n    for (ll i = 1;i &lt;= n;i++) {\n        cin &gt;&gt; a[i];\n    }\n    vector&lt;ll&gt;cnt(5);\n    for (int i = 0;i &lt; m;i++) {\n        ll x;cin &gt;&gt; x;\n        cnt[x]++;\n    }\n    vector&lt;vector&lt;vector&lt;vector&lt;ll&gt;&gt;&gt;&gt;dp(cnt[1] + 1, vector&lt;vector&lt;vector&lt;ll&gt;&gt;&gt;(cnt[2] + 1, vector&lt;vector&lt;ll&gt;&gt;(cnt[3] + 1, vector&lt;ll&gt;(cnt[4] + 1, 0))));\n \n    dp[0][0][0][0] = a[1];\n    for (int i = 0;i &lt;= cnt[1];i++) {\n        for (int j = 0;j &lt;= cnt[2];j++) {\n            for (int k = 0;k &lt;= cnt[3];k++) {\n                for (int l = 0;l &lt;= cnt[4];l++) {\n                    ll x = i * 1 + j * 2 + k * 3 + l * 4 + 1;   // 走到的格子是x\n                    if (i &gt; 0)\n                        // 走到x的时候，如果i &gt; 0，那么就可以从i - 1走到i，下面同理\n                        dp[i][j][k][l] = max(dp[i][j][k][l], dp[i - 1][j][k][l] + a[x]);\n                    if (j &gt; 0)\n                        dp[i][j][k][l] = max(dp[i][j][k][l], dp[i][j - 1][k][l] + a[x]);\n                    if (k &gt; 0)\n                        dp[i][j][k][l] = max(dp[i][j][k][l], dp[i][j][k - 1][l] + a[x]);\n                    if (l &gt; 0)\n                        dp[i][j][k][l] = max(dp[i][j][k][l], dp[i][j][k][l - 1] + a[x]);\n                }\n            }\n        }\n    }\n    cout &lt;&lt; dp[cnt[1]][cnt[2]][cnt[3]][cnt[4]] &lt;&lt; endl;\n}\n[P1868]饥饿的奶牛\n题目描述\n有一条奶牛冲出了围栏，来到了一处圣地（对于奶牛来说），上面用牛语写着一段文字。\n现用汉语翻译为：\n有 N 个区间，每个区间 x,y 表示提供的 x\\sim y 共 y-x+1 堆优质牧草。你可以选择任意区间但不能有重复的部分。\n对于奶牛来说，自然是吃的越多越好，然而奶牛智商有限，现在请你帮助他。\n输入格式\n第一行一个整数 N。\n接下来 N 行，每行两个数 x,y，描述一个区间。\n输出格式\n输出最多能吃到的牧草堆数。\n样例 #1\n样例输入 #1\n3\n1 3\n7 8\n3 4\n样例输出 #1\n5\n提示\n1 \\leq n \\leq 1.5 \\times 10^5，0 \\leq x \\leq y \\leq 3 \\times 10^6。\n参考代码\nvoid solve() {\n    ll n;cin &gt;&gt; n;\n    map&lt;ll, vector&lt;ll&gt;&gt; mp;\n    ll my = 0;\n    for (ll i = 0;i &lt; n;i++) {\n        ll x, y;cin &gt;&gt; x &gt;&gt; y;\n        x += 1;y += 1;  // 避免越界\n        my = max(my, y);\n        mp[y].push_back(x);\n    }\n    vector&lt;ll&gt;dp(my + 1, 0);\n    dp[0] = 0;\n    for (ll i = 1;i &lt;= my;i++) {\n        dp[i] = dp[i - 1];\n        if (mp.count(i)) {\n            for (ll j = 0;j &lt; mp[i].size();j++) {\n                ll y = mp[i][j];\n                dp[i] = max(dp[i], dp[y - 1] + i - y + 1);\n            }\n        }\n    }\n    cout &lt;&lt; dp[my] &lt;&lt; endl;\n}"},"03-algorithm/nc24sd1":{"slug":"03-algorithm/nc24sd1","filePath":"03-algorithm/nc24sd1.md","title":"🫟2024牛客暑假多校训练营Day1||补题","links":[],"tags":["2024暑假集训","算法","牛客"],"content":"A-Bit Common\n题意\n计算满足长度为n，每个元素小于2^m，且存在至少一个子序列满足按位AND后是1的序列的数量。\n答案对正整数q取模。\n数据范围\n\n1\\leq n,m\\leq 5000\n1\\leq q\\leq 10^9\n\n思路\n按位分析，对于一个长度为n的序列，序列中的数分为k个末尾是1的数和n-k个末尾是0的数。\n\n末尾为1的数中，除末位以外的数位（m-1位），每一位的组合是2^k-1种（要除去全为1的情况）。\n末尾为0的数中，除末位以外数位上的取值是任意的。\n选择哪些数是末尾1需要考虑组合数。\n\n所以，总方案数是：\n\\binom{n}{k}\\times (2^k-1)^{m-1}\\times (2^{n-k})^{(m-1)} = \\binom{n}{k}\\times (2^n-2^{n-k})^{m-1}\n最后对q取模即可。\n代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst ll maxn = 5050;\n \nll qpow(ll a, ll b, ll m) {\n    // 快速幂\n    ll res = 1;\n    while (b) {\n        if (b &amp; 1)res = res * a % m;\n        a = a * a % m;\n        b &gt;&gt;= 1;\n    }\n    return res % m;\n}\n \nll C[maxn][maxn];\n \nvoid solve() {\n    ll n, m, q;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;\n    C[0][0] = 1;\n    for (ll i = 1;i &lt;= n;i++) {\n        C[i][0] = 1, C[i][i] = 1;\n        for (ll j = 1;j &lt; i;j++) {\n            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % q;\n        }\n    }\n    ll ans = 0;\n    for (ll k = 1;k &lt;= n;k++) {\n        ll tmp = C[n][k];\n        ll x = (qpow(2, n, q) - qpow(2, n - k, q) + q) % q;\n        tmp *= qpow(x, m - 1, q);\n        tmp %= q;\n        ans = (ans + tmp + q) % q;\n    }\n    cout &lt;&lt; ans % q &lt;&lt; &quot;\\n&quot;;\n}\n \nint main() {\n    int _ = 1;\n    // cin &gt;&gt; _;cin.get();\n    while (_--)\n        solve();\n \n    return 0;\n}\nB-A Bit More Common\n题意\n在A题的条件下，增加要求满足存在两个不同的非空子序列AND和是1。\n数据范围\n\n1\\leq n,m\\leq 5000\n1\\leq q \\leq 10^9\n\n思路\n有A题的基础，我们已知至少有1个子序列的组合数，接下来我们计算只有1个子序列的组合数。两者相减即可求出答案。\n满足只有1个子序列的组合数所代表的情况是这样的：\n\\begin{aligned}\nlet:k=3\\\\\n101111\\\\\n010101\\\\\n111011\n\\end{aligned}\n需要满足每一个竖列至少有一个特殊的0（这个0同时是该数位上唯一的0），且这k个数每个数至少有1个0​（条件2）。\n对于偶数的组合种数还是不变的，为\\binom{n}{k}\\times 2^{(n-k)(m-1)}。\n\n\n当k=1时，子序列是\\\\{0b00000001\\\\}，只有一个数，剩余的n-k个数都是偶数。\n\n\n当k\\neq 1时，考虑：一共有m-1个特殊0，每个0有对应的数位，要将这m-1个0分配到k个位置（位置并不互相区分），每个位置至少有1个，也就是第二类斯特林数。\n\n\n考虑状态转移：\n现在有i个数，要从j-1个特殊位的基础上再增加一个特殊0，这个特殊位要么增加到第i个数（第i个数已经有至少1个特殊0）上，要么增加到前i-1个（已经至少包含一个特殊0的）数上，这两种增加方法都有i种不同的方案。\n这i个数中要包含j个特殊0的方案数记为f[i][j]，则存在递推式：\nf[i][j]= i\\times (f[i-1][j-1] + f[i][j-1])\n考虑到只有k个数中特殊0的个数大于等于k时的方案数才是有效的，同时，每个有效方案中，每一列除了作为特殊0的位置以外的位置都可以任意填（只要不是全1或者只有1个特殊0的情况），故这k个奇数的方案总数是\\sum_{t=k}^{m-1} f[k][t]\\times (2^k-1-k)^{m-1-t}，再乘此时的偶数方案数，即为k时的总数。\n代码\nll qpow(ll a, ll b, ll m) {\n    // 快速幂\n    ll res = 1;\n    a %= m;\n    while (b) {\n        if (b &amp; 1)res = res * a % m;\n        a = a * a % m;\n        b &gt;&gt;= 1;\n    }\n    return res % m;\n}\n \nll C[maxn][maxn];\nll f[maxn][maxn];\n \nvoid solve() {\n    ll n, m, q;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;\n    C[0][0] = 1ll;\n    for (ll i = 1;i &lt;= 5000;i++) {\n        C[i][0] = 1, C[i][i] = 1;\n        for (ll j = 1;j &lt;= 5000;j++) {\n            C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % q;\n        }\n    }\n    ll ans = 0;\n    for (ll k = 1;k &lt;= n;k++) {\n        ll tmp = C[n][k];\n        ll x = (qpow(2ll, n, q) - qpow(2ll, n - k, q) + q) % q;\n        tmp *= qpow(x, m - 1ll, q);\n        tmp %= q;\n        ans = (ans + tmp + q) % q;\n    }\n \n    ll res = qpow(2ll, (n - 1) * (m - 1) % q, q) * n % q;\n    // 存在1个子序列AND=1的，减去只有1个子序列AND=1的\n    f[0][0] = 1ll;\n    for (ll i = 1;i &lt;= 5000;i++) {\n        for (ll j = i;j &lt;= 5000;j++) {\n            f[i][j] = i * ((f[i - 1][j - 1] + f[i][j - 1]) % q) % q;\n        }\n    }\n    for (ll k = 2;k &lt;= n;k++) {\n        ll tmp = qpow(2ll, (n - k) * (m - 1) % q, q) % q * C[n][k] % q;\n        ll tmp2 = (qpow(2ll, k, q) - 1ll - k + q) % q;\n        ll cur = 1ll;\n        for (ll t = m - 1;t &gt;= k;t--) {\n            res = (res + f[k][t] * cur % q * C[m - 1][t] % q * tmp % q) % q;\n            cur = tmp2 * cur % q;\n        }\n    }\n \n    cout &lt;&lt; (ans - res + q) % q &lt;&lt; &quot;\\n&quot;;\n}\nC-Sum of Suffix Sums\n题意\n维护一个初始为空的非负整数序列，支持q次如下操作：\n每次移除末尾的t个整数，然后在末尾假如一个整数v，操作后输出当前序列所有后缀和的总和，答案对10^9+7取模。\n数据范围\n\n1\\leq q\\leq 5\\times 10^5\n0\\leq v\\leq 10^9\n\n思路\n每个数对后缀和总和的贡献是它当前位置的序号乘以它本身的值，也就是a_i的贡献是a_i\\times i​。根据这个特点和数据范围，我们可以维护后缀和总和。\n代码\nvoid solve() {\n    ll q;cin &gt;&gt; q;\n    vector&lt;ll&gt;a;\n    ll tot = 0;\n    while (q--) {\n        ll t, v;cin &gt;&gt; t &gt;&gt; v;\n        v %= mo;\n        for (ll i = 0;i &lt; t;i++) {\n            if (a.empty())break;\n            ll x = a.back();\n            tot -= x * a.size();\n            tot = (tot + mo) % mo;\n            a.pop_back();\n        }\n        a.push_back(v);\n        ll n = a.size() % mo;\n        tot = (tot + v * n % mo + mo) % mo;\n        cout &lt;&lt; tot &lt;&lt; &quot;\\n&quot;;\n    }\n}\nH-World Finals\n签到题。\n题意\nlzr010506队伍可以参加46th的WF和47th的WF，这两个WF将同时举行，所以lzr010506必须选择其中一个参加。lzr010506可以预知每个队伍的在比赛中的成绩（过题数和罚时），排名规则为过题数多优先，过题数相同则罚时少优先。\n除了lzr010506队伍，还有其他有资格参加两场比赛的队伍。提问，在给出所有队伍的预测成绩之后，lzr010506队伍能够获得的最好成绩排名是多少。\n数据范围\n\n1 \\leq number of teams \\leq 105\n\n思路\n最优情况是，除了lzr010506队伍，同时可以参加两场比赛的队伍都参加lzr010506队伍没有参加那一场，然后计算最佳排名即可。\n代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\n \nstruct team {\n    string s;\n    ll p, t;\n    bool operator&lt;(const team&amp; other)const {\n        if (other.p == p)return other.t &gt; t;\n        return other.p &lt; p;\n    }\n};\n \nvoid solve() {\n    ll n;cin &gt;&gt; n;\n    vector&lt;team&gt;t46(n);\n    map&lt;string, bool&gt;mp46;\n    for (ll i = 0;i &lt; n;i++) {\n        string s; ll p, t;\n        cin &gt;&gt; s &gt;&gt; p &gt;&gt; t;\n        t46[i] = { s,p,t };\n        mp46[s] = true;\n    }\n    ll m;cin &gt;&gt; m;\n    vector&lt;team&gt;t47(m);\n    map&lt;string, bool&gt;both;\n    for (ll i = 0;i &lt; m;i++) {\n        string s; ll p, t;\n        cin &gt;&gt; s &gt;&gt; p &gt;&gt; t;\n        t47[i] = { s,p,t };\n        if (mp46.count(s)) {\n            both[s] = true;\n        }\n    }\n    sort(t46.begin(), t46.end());\n    sort(t47.begin(), t47.end());\n    string st = &quot;lzr010506&quot;;\n    ll rk = min(n, m);\n    ll cnt = 1;\n    for (ll i = 0;i &lt; n;i++) {\n        if (t46[i].s == st) {\n            rk = min(cnt, rk);\n            break;\n        }\n        if (both.count(t46[i].s))continue;\n        cnt++;\n    }\n    cnt = 1;\n    for (ll i = 0;i &lt; m;i++) {\n        if (t47[i].s == st) {\n            rk = min(cnt, rk);\n            break;\n        }\n        if (both.count(t47[i].s))continue;\n        cnt++;\n    }\n    cout &lt;&lt; rk &lt;&lt; &quot;\\n&quot;;\n}\n \nint main() {\n    int t = 1;\n    // cin &gt;&gt; t;cin.get();\n    while (t--)\n        solve();\n \n    return 0;\n}\nI-Mirror Maze\n补出这题ddl也是死而无憾了。\n题意\n在n\\times m​的矩阵镜子迷宫里，给出一个点光源，光的传播与镜子的类型\\、|、-、/有关（详情戳这）。\n提问经过足够长的时间后，这束光被多少个不同的镜子反射过。\n数据范围\n\n1\\leq n,m \\leq 1000\n1\\leq q\\leq 10^5\n\n思路\n考虑到光路可逆，在迷宫中的所有可能存在的光路必然是链或者环，不会出现分叉或者是汇集。考虑数据范围1\\leq n,m\\leq 1000和光的方向有上下左右4个，可以通过记忆化搜索来记录已经搜索过的状态，保证每次搜索的复杂度在n\\times m以内，总复杂度不超过4\\times n\\times m。\n具体搜索方法见代码。\n代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\n \nmap&lt;pair&lt;ll, char&gt;, ll&gt;redir;\n \nvoid initRedir() {\n    redir[{1, &#039;|&#039;}] = 1;\n    redir[{1, &#039;-&#039;}] = 2;\n    redir[{1, &#039;/&#039;}] = 4;\n    redir[{1, &#039;\\\\&#039;}] = 3;\n \n    redir[{2, &#039;|&#039;}] = 2;\n    redir[{2, &#039;-&#039;}] = 1;\n    redir[{2, &#039;/&#039;}] = 3;\n    redir[{2, &#039;\\\\&#039;}] = 4;\n \n    redir[{3, &#039;|&#039;}] = 4;\n    redir[{3, &#039;-&#039;}] = 3;\n    redir[{3, &#039;/&#039;}] = 2;\n    redir[{3, &#039;\\\\&#039;}] = 1;\n \n    redir[{4, &#039;|&#039;}] = 3;\n    redir[{4, &#039;-&#039;}] = 4;\n    redir[{4, &#039;/&#039;}] = 1;\n    redir[{4, &#039;\\\\&#039;}] = 2;\n}\n \nbool vis[1005][1005][5] = { false }, visp[1005][1005] = { false };\nll n, m;\nchar maz[1005][1005];\nll mem[1005][1005][5] = { 0 };\n \nll circlelen;\n \nll dfs(ll u, ll v, ll dr, ll cnt) {\n    if (u&lt;1 || u&gt;n || v&lt;1 || v&gt;m) {\n        // 通过边界出射的点是链型光路\n        vis[u][v][dr] = false;visp[u][v] = false;\n        mem[u][v][dr] = cnt;\n        return cnt;\n    }\n    if (vis[u][v][dr]) {\n        // 因为访问过同样状态结束搜索的是环形光路\n        vis[u][v][dr] = false;visp[u][v] = false;\n        circlelen = cnt;\n        return cnt;\n    }\n    if (mem[u][v][dr])return mem[u][v][dr];\n \n    vis[u][v][dr] = true;\n \n    ll rdr = redir[{dr, maz[u][v]}];\n \n    if (!visp[u][v] &amp;&amp; dr != rdr) {\n        cnt++;\n        visp[u][v] = true;\n    }\n \n    if (rdr == 1) cnt = dfs(u - 1, v, 1, cnt);\n    else if (rdr == 2) cnt = dfs(u + 1, v, 2, cnt);\n    else if (rdr == 3) cnt = dfs(u, v - 1, 3, cnt);\n    else cnt = dfs(u, v + 1, 4, cnt);\n \n    // 回溯时复原状态\n    vis[u][v][dr] = false;\n    visp[u][v] = false;\n    // 若是环形光路，在dfs回溯时mem应该记录为环形路径的长度\n    if (circlelen)\n        mem[u][v][dr] = circlelen;\n    return cnt;\n}\n \nvoid solve() {\n    cin &gt;&gt; n &gt;&gt; m;\n    for (ll i = 1;i &lt;= n;i++) {\n        for (ll j = 1;j &lt;= m;j++) {\n            cin &gt;&gt; maz[i][j];\n        }\n    }\n    // pre();\n    ll q;cin &gt;&gt; q;\n    while (q--) {\n        ll u, v;string dir;\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; dir;\n        ll dr;\n        if (dir == &quot;above&quot;) { dr = 1;u--; }\n        else if (dir == &quot;below&quot;) { dr = 2;u++; }\n        else if (dir == &quot;left&quot;) { dr = 3; v--; }\n        else if (dir == &quot;right&quot;) { dr = 4; v++; }\n        circlelen = 0;\n        ll ans = dfs(u, v, dr, 0);\n        cout &lt;&lt; ans &lt;&lt; endl;\n    }\n}\n \nint main() {\n    initRedir();\n    int t = 1;\n    // cin &gt;&gt; t; cin.get();\n    while (t--)\n        solve();\n \n    return 0;\n}"},"03-algorithm/nc24sd10":{"slug":"03-algorithm/nc24sd10","filePath":"03-algorithm/nc24sd10.md","title":"🫟2024牛客暑假多校训练营Day10||补题","links":[],"tags":["2024暑假集训","算法","牛客"],"content":"A-Surrender to My Will\n题意\n根据上票状态判断是否投降。4票及以上赞同投降则投降成功。\n数据范围\n\n1\\leq i \\leq 5\n1\\leq j\\leq i,S[j]\\in\\\\{Y,N\\\\}\n\n思路\n计数模拟即可。\n代码\nvoid solve() {\n    string s;cin &gt;&gt; s;\n    int y = 0, n = 0;\n    for (auto c : s) {\n        if (c == &#039;Y&#039;)y++;\n        else if (c == &#039;N&#039;)n++;\n    }\n    if (y &gt;= 4)cout &lt;&lt; &quot;1\\n&quot;;\n    else if (n &gt;= 2)cout &lt;&lt; &quot;-1\\n&quot;;\n    else cout &lt;&lt; &quot;0\\n&quot;;\n}\nB-std::pair\n题意\n使用std::pair声明n个变量，进行对于这些变量的q个询问，回答其数据类型。\n数据范围\n\n1\\leq n,q\\leq 1000\n\n每行输入不超过5000字符\n思路\n按.分割询问的变量，逐层确定当前的数据类型。\n代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\nconst int maxn = 1e6 + 50;\n \nmap&lt;string, string&gt;mp;\n \nvoid solve() {\n    int n, q;cin &gt;&gt; n &gt;&gt; q;\n    for (int i = 0;i &lt; n;i++) {\n        string s1, s2;\n        cin &gt;&gt; s1 &gt;&gt; s2;\n        if (s2.back() == &#039;;&#039;)s2.pop_back();\n        mp[s2] = s1;\n    }\n \n    while (q--) {\n        string s;cin &gt;&gt; s;\n        s = s + &quot;.&quot;;\n        vector&lt;string&gt;stk;\n \n        int p = s.find(&quot;.&quot;);\n        int pr = 0;\n        while (p != -1) {\n            string t = s.substr(pr, p - pr);\n            stk.push_back(t);\n            s = s.substr(p + 1);\n            p = s.find(&quot;.&quot;);\n        }\n        string typ = mp[stk.front()];\n        for (int i = 1;i &lt; stk.size();i++) {\n            string c = stk[i];\n            vector&lt;int&gt;v;\n            int pp; // 中点的&#039;,&#039;位置\n            int cnt1, cnt2;\n            cnt1 = cnt2 = 0;\n            for (int j = 0;j &lt; typ.size();j++) {\n                if (typ[j] == &#039;&lt;&#039;) {\n                    cnt1++;\n                }\n                else if (typ[j] == &#039;,&#039;) {\n                    cnt2++;\n                    v.push_back(j);\n                }\n                else if (typ[j] == &#039;&gt;&#039;) {\n                    cnt1--, cnt2--;\n                    if (!cnt1 &amp;&amp; !cnt2) {\n                        pp = v.back();\n                        break;\n                    }\n                    v.pop_back();\n                }\n            }\n            if (c == &quot;first&quot;) {\n                typ = typ.substr(5, pp - 5);\n            }\n            else {\n                typ = typ.substr(pp + 1, typ.size() - pp - 2);\n            }\n        }\n \n        cout &lt;&lt; typ &lt;&lt; &quot;\\n&quot;;\n    }\n}\n \nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int t = 1;\n    // cin &gt;&gt; t;cin.get();\n    while (t--)\n        solve();\n \n    return 0;\n}\nF-Collinear Exception\n题意\n在\\\\{1,...,n\\\\}\\times \\\\{1,...,n\\\\}的坐标逐渐加入n\\times n个数，如果即将加入的这个数与已有的形成了三点共线，则该数不能被成功加入，输出一个长度为n\\times n的01串，表示第i个点能否成功加入。\n数据结构\n\n1\\leq n\\leq 1000\n1\\leq x_i,y_i\\leq n\n\n思路\n每行每列都不能拥有超过2个点，若某行或某列已经超过2个点则直接判不能加入，用一个vis数组记录某点是否能被成功加入，加入新点时，遍历图中已有的点，枚举与图中已有点形成的直线的斜率(dx,dy)，dx、dy互质，从当前点(x,y)向两边转移到(x\\pm dx,y\\pm dy)，并标记该处不能被访问。\n代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 1050;\nstruct point {\n    int x, y;\n};\nint X[maxn], Y[maxn];\nbool vis[maxn][maxn];\nvoid solve() {\n    int n;cin &gt;&gt; n;\n    vector&lt;point&gt;v;\n    for (int i = 1;i &lt;= n * n;i++) {\n        int x1, y1;cin &gt;&gt; x1 &gt;&gt; y1;\n        if (X[x1] + 1 &gt; 2 || Y[y1] + 1 &gt; 2 || vis[x1][y1]) {\n            cout &lt;&lt; &quot;0&quot;;\n            continue;\n        }\n        X[x1]++, Y[y1]++;\n        if (i == 1) {\n            v.push_back({ x1,y1 });\n            vis[x1][y1] = true;\n            cout &lt;&lt; &quot;1&quot;;continue;\n        }\n        for (auto [x2, y2] : v) {\n            if (y2 == y1 || x2 == x1)continue;\n            int dx = abs(x2 - x1), dy = abs(y2 - y1), c = (1.0 * (y1 - y2) / (x1 - x2) &gt; 0 ? 1 : -1);\n            int g = gcd(dx, dy);\n            dx /= g, dy /= g;\n            int x = x1, y = y1;\n            while (x &gt;= 1 &amp;&amp; x &lt;= n &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= n) {\n                vis[x][y] = true;\n                x += dx, y += c * dy;\n            }\n            x = x1, y = y1;\n            while (x &gt;= 1 &amp;&amp; x &lt;= n &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= n) {\n                vis[x][y] = true;\n                x -= dx, y -= c * dy;\n            }\n        }\n        v.push_back({ x1,y1 });\n        cout &lt;&lt; &quot;1&quot;;\n    }\n    cout &lt;&lt; &quot;\\n&quot;;\n}\n \nint main() {\n    int t = 1;\n    // cin &gt;&gt; t;cin.get();\n    while (t--)\n        solve();\n \n    return 0;\n}\nH-All-in at the Pre-flop\n题意\n两个玩家拥有a和b的筹码，在一场公平游戏中全押，等概率成为输家或赢家，若赢家的筹码不少于输家，游戏结束，该局赢家为最终胜利者。否则输家向赢家支付等同于赢家筹码的筹码。问游戏结束时两个玩家分别的胜率是多少（模998244353）。\n数据范围\n\n1\\leq a,b\\leq 998244353\n\n思路\n游戏结束时要求赢家筹码不少于输家，另f(x)为玩家筹码量为x时的胜率，n为总筹码数，也就是a+b，则有：\nf(0)=0,f(n)=1\n\\begin{cases}\nf(x)=\\frac{1}{2}\\times f(0)+\\frac{1}{2}\\times f(2 x)\\quad x\\lt n/2\\\\\nf(x)=\\frac{1}{2}\\times f(n)+\\frac{1}{2}\\times f(2 x-n)\\quad x\\geq  n/2\n\\end{cases}\n玩家押上x筹码后，对方押上n-x筹码，若x\\geq n-x则玩家为赢家时直接胜利，为输家时向对方交付n-x筹码，自己留下x-(n-x)=2\\times x-n筹码，这时候的胜率变为f(2x-n)，发生这两种情况的概率都是0.5。打表后发现f(x)=\\frac{x}{n}是线性方程的解。\n输出\\frac{a}{a+b}和\\frac{a}{a+b}。\n代码\nll qpow(ll a, ll b) {\n    ll res = 1;\n    while (b) {\n        if (b &amp; 1)res = res * a % mo998;\n        b &gt;&gt;= 1;\n        a = a * a % mo998;\n    }\n    return res;\n}\n \nll inv(ll x) {\n    return qpow(x, mo998 - 2);\n}\n \nvoid solve() {\n    ll a, b;cin &gt;&gt; a &gt;&gt; b;\n    ll c = (a + b) % mo998;\n    cout &lt;&lt; a * inv(c) % mo998 &lt;&lt; &quot; &quot; &lt;&lt; b * inv(c) % mo998 &lt;&lt; &quot;\\n&quot;;\n}"},"03-algorithm/nc24sd2":{"slug":"03-algorithm/nc24sd2","filePath":"03-algorithm/nc24sd2.md","title":"🫟2024牛客暑假多校训练营Day2||补题","links":[],"tags":["2024暑假集训","算法","牛客"],"content":"A-Floor Tiles\n题意\n存在A型、B型两种砖：\n\n现用这两种砖拼成N\\times M的矩形，提问是否有恰好存在K条曲线的平铺方式，曲线如下：\n\n数据范围\n\n1\\leq T\\leq 10^5\n1\\leq N,M\\leq 800\n1\\leq K \\leq 2\\times N\\times M\n\n思路\n边缘一圈的点所在的线一定不是一个环，所以最少的线数相当于都是A型或B型时的线数，也就是N\\times M个，若要比N\\times M个多，则多的部分只能是图形中环的数目，贪心的让所有的环最小，则能构造出最多的环，最小的环如例图中一样，当平铺的方式是\n\\begin{aligned}\nAB\\\\\nBA\n\\end{aligned}\n时，形成的环是最小的。\n同时注意到，成环的四块砖块是可以共用的，也就是说在：\n\\begin{aligned}\nABAB\\\\\nBABA\\\\\nABAB\n\\end{aligned}\n中有3个环。\n首先构造成环数量最多的N\\times M，在输出时记录当前已经拥有多少个环，若超过所需的数量则不再输出可以成环的砖块类型。\n代码\nvoid solve() {\n    int x, y;\n    char ty;\n    int n, m, k;\n    char a = &#039;A&#039;, b = &#039;B&#039;;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;\n    cin &gt;&gt; x &gt;&gt; y &gt;&gt; ty;\n    vector&lt;string&gt;ans(n + 1, string(m + 1, &#039;X&#039;));\n    for (int i = 1;i &lt;= n;i++) {\n        for (int j = 1;j &lt;= m;j++) {\n            if (abs(i + j - x - y) % 2) {\n                ans[i][j] = a + b - ty;\n            }\n            else {\n                ans[i][j] = ty;\n            }\n        }\n    }\n \n    int cnt = n + m;\n    for (int i = 1;i &lt;= n;i++) {\n        for (int j = 1;j &lt;= m;j++) {\n            if (ans[i][j] == a &amp;&amp; ans[i][j - 1] == b &amp;&amp; ans[i - 1][j] == b &amp;&amp; ans[i - 1][j - 1] == a)\n                cnt++;\n        }\n    }\n \n    if (cnt &lt; k || k &lt; n + m) {\n        cout &lt;&lt; &quot;No\\n&quot;;\n        return;\n    }\n \n    k -= n + m;\n    cout &lt;&lt; &quot;Yes\\n&quot;;\n    for (int i = 1;i &lt;= n;i++) {\n        for (int j = 1;j &lt;= m;j++) {\n            if (k &gt; 0) {\n                cout &lt;&lt; ans[i][j];\n                if (ans[i][j] == a &amp;&amp; ans[i][j - 1] == b &amp;&amp; ans[i - 1][j] == b &amp;&amp; ans[i - 1][j - 1] == a)\n                    k--;\n            }\n            else cout &lt;&lt; ty;\n        }\n        cout &lt;&lt; &#039;\\n&#039;;\n    }\n}\nB-MST\n题意\n给定一个n顶点的带权无向图G。\n每次询问一个点集S，求S关于G的导出子图的最小生成树的质量，若无则输出-1。\n数据范围\n\n2\\leq n\\leq 10^5\n1\\leq m,q\\leq 10^5\n1\\leq w_i \\leq 10^9\n\\sum k_i\\leq 10^5\n\n思路\n注意点数n和边数m的范围都不超过10^5，若通过枚举两个点来确定符合条件的边，则复杂度是O(n^2)，而如果按照枚举边来确定符合条件的边，复杂度是O(m)，于是优化的思路是根据每次k和\\sqrt {maxn}的大小关系来选择加入边的方式。\n代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 1e5 + 50;\nstruct edge {\n    int s, t, w;\n    bool operator&lt;(const edge&amp; e)const {\n        return w &lt; e.w;\n    }\n};\n \nvector&lt;vector&lt;edge&gt;&gt;graph;\nmap&lt;pair&lt;int, int&gt;, int&gt;gp;\n \nint s[maxn];\nint fa[maxn];\nint findfa(int x) {\n    if (x == fa[x])return x;\n    return fa[x] = findfa(fa[x]);\n}\n \nll krus(int n, vector&lt;edge&gt;subgraph) {\n    ll res = 0;\n    int cnt = 0;\n    for (auto e : subgraph) {\n        if (cnt == n - 1)break;\n        if (!cnt) {\n            fa[e.t] = e.s;\n            res += e.w;\n            ++cnt;\n            continue;\n        }\n        auto [u, v, w] = e;\n        int fu = findfa(u), fv = findfa(v);\n        if (fu == fv)continue;\n        fa[fu] = fv;\n        res += w;\n        ++cnt;\n    }\n    int fx = findfa(s[1]);\n    for (int i = 2;i &lt;= n;i++) {\n        if (fx != findfa(s[i])) {\n            return -1ll;\n        }\n    }\n \n    return res;\n}\n \nvoid solve() {\n    int n, m, q;cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;\n    graph.assign(n + 1, vector&lt;edge&gt;());\n    for (int i = 0;i &lt;= n;i++)fa[i] = i;\n \n    for (int i = 1;i &lt;= m;i++) {\n        int u, v, w;cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;\n        graph[u].push_back({ u,v,w });\n        graph[v].push_back({ v,u,w });\n        gp[{u, v}] = w;\n        gp[{v, u}] = w;\n    }\n    while (q--) {\n        int k;cin &gt;&gt; k;\n        map&lt;int, bool&gt;mp;\n        for (int i = 1;i &lt;= k;i++) {\n            cin &gt;&gt; s[i];\n            fa[s[i]] = s[i];\n            mp[s[i]] = true;\n        }\n        vector&lt;edge&gt;subgraph;\n        if (k * k &lt; maxn) { // 点少\n            // 取出符合要求的边\n            for (int i = 1;i &lt;= k;i++) {\n                for (int j = i + 1;j &lt;= k;j++) {\n                    int u = s[i], v = s[j];\n                    if (gp.count({ u,v })) {\n                        int w = gp[{u, v}];\n                        subgraph.push_back({ u,v,w });\n                    }\n                }\n            }\n        }\n        else {\n            for (int i = 1;i &lt;= k;i++) {\n                int u = s[i];\n                for (auto e : graph[u]) {\n                    if (mp.count(e.t))\n                        subgraph.push_back(e);\n                }\n            }\n        }\n        sort(subgraph.begin(), subgraph.end());\n        cout &lt;&lt; krus(k, subgraph) &lt;&lt; &quot;\\n&quot;;\n    }\n}\n \nint main() {\n    int t = 1;\n    while (t--)\n        solve();\n \n    return 0;\n}\nC-Red Walking on Grid\n题意\n在一个2\\times n​的网格中，每个格子要么是红色（R），要么是白色（W）。每次只能踩在当前格子的上下左右相邻的红色格子上，并且在离开当前的格子之后，当前格子将从红色变为白色，提问最长。\n数据范围\n\n1\\leq n\\leq 10^6\n\n思路\n直接从左往右搜索即可，若当前列有红色格子，则它可以由前一列相邻格子的步数+1转移过来，或者是从下方或上方的红色格子转移过来，两者选更优的解作为答案即可。\n代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst ll maxn = 1e6 + 50;\nconst ll mo = 1e9 + 7;\n \nll n;\nchar mp[3][maxn];\nll dp[3][maxn] = { 0 };\nvoid solve() {\n    cin &gt;&gt; n;\n    for (ll i = 1;i &lt;= 2;i++) {\n        for (ll j = 1;j &lt;= n;j++)\n            cin &gt;&gt; mp[i][j];\n    }\n    mp[1][0] = mp[2][0] = mp[1][n + 1] = mp[2][n + 1] = &#039;W&#039;;\n    ll ans = 0;\n    for (ll i = 1;i &lt;= n;i++) {\n        if (mp[1][i] == &#039;R&#039;)dp[1][i] = dp[1][i - 1] + 1;\n        if (mp[2][i] == &#039;R&#039;)dp[2][i] = dp[2][i - 1] + 1;\n        if (mp[1][i] == &#039;R&#039; &amp;&amp; mp[2][i] == &#039;R&#039;) {\n            ll tmp = dp[1][i];\n            if (dp[1][i] &lt; dp[2][i] + 1) {\n                dp[1][i] = dp[2][i] + 1;\n            }\n            if (dp[2][i] &lt; tmp + 1) {\n                dp[2][i] = tmp + 1;\n            }\n        }\n        ll tmp = max(dp[1][i], dp[2][i]);\n        ans = max(tmp, ans);\n    }\n    cout &lt;&lt; max(ans - 1, 0ll) &lt;&lt; endl;\n}\n \nint main() {\n    int t = 1;\n    // cin &gt;&gt; t;cin.get();\n    while (t--)\n        solve();\n \n    return 0;\n}\nE-GCD VS XOR\n有人卡签到。。。TAT\n题意\n给定正整数x，求满足gcd(x,y)=x\\oplus y的小于x的正整数y。若无则打印-1\n数据范围\n\n1\\leq t\\leq 10^4\n1\\leq x\\leq 10^{18}\n\n思路\n距离考虑，对于数x=0b10011010，考虑异或的性质A\\oplus 0=A,A\\oplus A=0，设x\\oplus y=k，y\\lt x，我们直接构造k为x最右侧的1开始的数，这样的k可以满足必然为x的倍数，同时，若要满足gcd(x,y)=k，构造y的时候要满足除了lowbit(x)以外的数位都与x相同。\n代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst ll N = 1000001;\n \nll lowbit(ll x) { return x &amp; -x; }\n \nvoid solve() {\n    ll x;cin &gt;&gt; x;\n    ll ans = -1;\n    if (lowbit(x) != x) {\n        ans = x - lowbit(x);\n    }\n \n    cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;;\n}\n \nint main() {\n    int _ = 1;\n    cin &gt;&gt; _;cin.get();\n    while (_--)\n        solve();\n \n    return 0;\n}\nH-Instructions Substring\n题意\n有一个操作字符串，由W，S，A，D组成，对应上下左右位移一位，从原点(0,0)开始，将操作字符串的一个非空连续子段作为选择的操作，问有多少操作可以经过目标点(x,y)。\n数据范围\n\n1\\leq n\\leq 2\\times 10^5\n-10^5\\leq x,y\\leq 10^5\n\n思路\n考虑记录每次操作后的坐标(u,v)，对该偏移坐标(\\Delta x,\\Delta y)计数，并逐步计算到达目标(x,y)需要去除的偏移坐标量(u-\\Delta x,v - \\Delta y)，这个需要去掉的操作数乘以当前的步数坐标（去掉(u-\\Delta x,v-\\Delta y)之后，从当前步开始，之后不管在哪停下，都是有效的路径数目），之后对该偏移坐标数清零，避免重复计数（之后新出现的只在之后的操作中被计数）。\n代码\nll n, x, y;\nstring st;\nmap&lt;char, pair&lt;ll, ll&gt;&gt;dxy;\nmap&lt;ll, map&lt;ll, ll&gt;&gt;mp; // mp[i][j]:x位移量为i,y位移量为j的操作数量。\nvoid solve() {\n    cin &gt;&gt; n &gt;&gt; x &gt;&gt; y;\n    cin &gt;&gt; st;\n    dxy[&#039;A&#039;] = { 0,-1 };\n    dxy[&#039;D&#039;] = { 0,1 };\n    dxy[&#039;S&#039;] = { -1,0 };\n    dxy[&#039;W&#039;] = { 1,0 };\n    if (!x &amp;&amp; !y) {\n        cout &lt;&lt; n * (n + 1) / 2 &lt;&lt; endl;\n        return;\n    }\n    ll ans = 0;\n    ll u = 0, v = 0;\n    mp[0][0] = 1; // 原点形成的符合{0,0}方案数有1个\n    for (ll i = 0;i &lt; n;i++) {\n        u += dxy[st[i]].second;\n        v += dxy[st[i]].first;\n        if (mp.count(u - x)) {\n            // u-x:当前走了u步，去掉之前在x轴上走过的u-x步可以到目标x轴\n            if (mp[u - x].count(v - y)) {   // 同理\n                // 满足去除前面的多余x,y位移，之后的操作都是符合要求的。\n                ans += mp[u - x][v - y] * (n - i);\n                // 这次使用过去除符合要求的位移的操作方案数目了,之后重新出现的相同位移情况需要重新计数。\n                mp[u - x][v - y] = 0;\n            }\n        }\n        mp[u][v]++;\n    }\n \n    cout &lt;&lt; ans &lt;&lt; endl;\n}\nI-Red Playing Cards\n题意\n对于一个长度为2\\times n的一维数组，1到n每个元素恰好出现两次。每次操作可以删掉一个长度不小于2的首尾相同的连续子数组，获得该连续子数组的首尾元素值乘以元素数量的分数。为最终可以得到多少分。\n数据范围\n\n1\\leq a_i\\leq n\\leq 3000\n\n思路\n每个数有两个坐标，假设数i的坐标为l_i和r_i，预处理出以数i为一个操作时的分数f(i)，那么对于区间[l_i,r_i]，可以计算其中每个数的贡献（即i），若出现满足l_i\\lt l_j \\lt r_j\\lt r_i ，则用max(i,j)代替区间[l_j,r_j]的贡献。\n计算区间[l_i,k]的最大分数g(k)，g(k)符合：\ng(k)= \n\\begin{cases}\nmax(g(k-1) + i,g(l_j-1)+f(j)),&amp; (k=r_j \\quad and \\quad l_i \\lt l_j)\\\\\ng(k-1) + i &amp; \n\\end{cases}\n直到k=r_i，得到f(i)=g(r_i)。\n代码\nvoid solve() {\n    ll n;cin &gt;&gt; n;\n    vector&lt;ll&gt;a(2 * n + 3);\n    map&lt;ll, plr&gt;idx;\n    for (ll i = 2;i &lt;= 2 * n + 1;i++) {\n        cin &gt;&gt; a[i];\n        if (idx.count(a[i])) {\n            idx[a[i]].r = i;\n            idx[a[i]].len = idx[a[i]].r - idx[a[i]].l + 1;\n        }\n        else idx[a[i]].l = i;\n    }\n \n    // 用0包裹数组，取0这一对不影响结果，但是方便统计最佳分数\n    a[1] = a[2 * n + 2] = 0ll;\n    idx[0] = { 1,2 * n + 2,2 * n + 2 }; \n \n    vector&lt;pair&lt;plr, ll&gt;&gt;idv;\n    for (auto i : idx) {\n        idv.push_back({ i.second, i.first });\n    }\n    sort(idv.begin(), idv.end());\n \n    vector&lt;ll&gt;f(n + 1);\n    for (auto x : idv) {\n        ll i = x.second;\n        ll li = x.first.l, ri = x.first.r;\n \n        vector&lt;ll&gt;g(2 * n + 2);\n        for (ll k = li;k &lt;= ri;k++) {\n            ll j = a[k];\n            ll lj = idx[j].l, rj = idx[j].r;\n            if (li &lt; lj &amp;&amp; k == rj) {\n                g[k] = max(g[k - 1] + i, g[lj - 1] + f[j]);\n            }\n            else {\n                g[k] = g[k - 1] + i;\n            }\n        }\n        f[i] = g[ri];\n    }\n    cout &lt;&lt; f[0] &lt;&lt; endl;\n}"},"03-algorithm/nc24sd3":{"slug":"03-algorithm/nc24sd3","filePath":"03-algorithm/nc24sd3.md","title":"🫟2024牛客暑假多校训练营Day3||补题","links":[],"tags":["2024暑假集训","算法","牛客"],"content":"A-Bridging the Gap 2\n题意\n在河岸的一侧有n个人，每个人有一个体力值h_i，有一艘船可以将人从一侧载到另一侧，每次航行需要至少L个人掌舵，每次掌舵会花费每个掌舵人的一点体力，当体力不足一点时，这个人不能再掌舵，船的容量最大是R，提问是否能够将这些人都运送到对岸。\n数据范围\n\n1\\leq L\\lt R\\leq n\\leq 5\\times 10^5​\n1\\leq h_i\\leq 5\\times 10^5\n\n思路\n贪心的运输，从左岸运输的最小次数是k=\\lceil \\frac{n-R}{R-L} \\rceil，计算每个人最多的来回次数a_i，假如满足\\sum_{i-1}^{n} min(k,a_i)\\geq k\\times L，则可以将所有人都运输到对岸。\n代码\nll h[maxn], a[maxn];\nvoid solve() {\n    int n, L, R;cin &gt;&gt; n &gt;&gt; L &gt;&gt; R;\n    ll sum = 0, k = (n - L - 1) / (R - L);\n    for (int i = 0;i &lt; n;i++) {\n        cin &gt;&gt; h[i];\n        a[i] = (h[i] - 1) / 2;\n        sum += min(k, a[i]);\n    }\n    if (sum &gt;= k * L)cout &lt;&lt; &quot;Yes\\n&quot;;\n    else cout &lt;&lt; &quot;No\\n&quot;;\n}\nB-Crash Test\n题意\n小车有n个引擎，第i个引擎可以让车前进h[i]米。在小车起点正前方距离为D处有一反弹墙面，小车如果撞在墙上将会被回弹与当前剩余的前进米数相同的距离，并保持车头朝向墙面。小车可以使用任意引擎任意次，询问距离墙面最近的距离是多少。\n数据范围\n\n1\\leq n\\leq 100\n1\\leq D \\leq 10^{18}\n1\\leq h[i]\\leq 10^{18}\n\n思路\n假设当前选择了某个引擎，并只使用这个引擎，易知，我们可以将距离d减小到\\min(d\\bmod h[i],h[i]-d\\bmod h[i])。\n接下来选择另一种引擎，在刚才的基础上，我们可以将距离减小到\\min(d\\bmod h[i+1],h[i+1]-d\\bmod h[i+1])。\n设gcd(h[i],h[i+1])=k，h[i]=ak,h[i+1]=bk，则d的变化其实是这样的：\n\\begin{align*}\nd_1=\\&amp;\\min(d_0\\bmod ak,d_0-d_0\\bmod ak)\\\\\n=\\&amp;\\min(d_0\\bmod k,d_0-d_0\\bmod k)\\\\\nd_2=\\&amp;\\min(d_1\\bmod bk,d_1-d_1\\bmod bk)\\\\\n=\\&amp;\\min(d_1\\bmod k,d_1-d_1\\bmod k)\\\\\n=\\&amp;d_1\\\\\n=\\&amp;\\min(d_0\\bmod k,d_0-d_0\\bmod k)\\\\\n\\&amp;.......\n\\end{align*}\n观察结果，可以发现最小的|dis-d|之和所有引擎的gcd有关，计算h[]数组的gcd即可。\n代码\nvoid solve() {\n    ll n, d;cin &gt;&gt; n &gt;&gt; d;\n    vector&lt;ll&gt;h(n + 1);\n    for (ll i = 1;i &lt;= n;i++) {\n        cin &gt;&gt; h[i];\n    }\n    sort(h.begin() + 1, h.end());\n    ll x = h[n];\n    for (ll i = n;i &gt;= 1;i--) {\n        x = gcd(x, h[i]);\n    }\n    cout &lt;&lt; min(d % x, x - d % x) &lt;&lt; endl;\n}\nD-Dominoes!\n题意\n一张多米诺骨牌的左右两端各有一个数字，给出n张这样的多米诺骨牌，是否存在一个可以另所有相邻且不在同一张牌上的两个数字不一样的序列。\n数据范围\n\n1\\leq n\\leq 2\\times 10^5\n1\\leq x_i,y_i\\leq 10^9\n\n思路\n首先注意到当 某个数字的数量大于等于n+2时，一定没有合法的排列。\n而如果符合\\lt n+2，一定有合法序列。\n如果所有骨牌都满足x_i\\neq y_i，则只要满足每次从两侧加入的牌相邻没有相同数字即可，一定有合法序列。\n优先考虑排列x_i=y_i的骨牌。将x_i = y_i的骨牌按照数量从大到小排序，每次选择一张牌，假设这张牌的数字是p，之后选择现存数量最多的且符合x_j = y_j\\neq p的一张牌，放在右侧，接下来继续取两侧相同骨牌中数目最多的，若两侧相同骨牌数目不足2种，则加入任意两侧不同的牌，注意接触端的条件\n代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst ll maxn = 2e5 + 50;\n \nstruct Domi {\n    ll x, y;\n \n    bool operator==(const Domi&amp; d)const {\n        return tie(x, y) == tie(d.x, d.y);\n    }\n    bool operator!=(const Domi&amp; d)const {\n        return tie(x, y) != tie(d.x, d.y);\n    }\n    bool operator&lt;(const Domi&amp; d)const {\n        return tie(x, y) &lt; tie(d.x, d.y);\n    }\n};\n \nbool compare(const pair&lt;ll, Domi&gt;&amp; a, const pair&lt;ll, Domi&gt;&amp; b) {\n    if (a.first == b.first)return a.second &lt; b.second;\n    return a.first &gt; b.first;\n}\n \nvoid solve() {\n    ll n;cin &gt;&gt; n;\n    vector&lt;Domi&gt;v, w;\n    map&lt;ll, ll&gt;cnt;\n    for (ll i = 1;i &lt;= n;i++) {\n        ll x, y;cin &gt;&gt; x &gt;&gt; y;\n        if (x &gt; y) { x = x ^ y, y = x ^ y, x = x ^ y; }\n        cnt[x]++, cnt[y]++;\n        if (x == y)\n            v.push_back({ x,y });\n        else\n            w.push_back({ x,y });\n    }\n    ll lv = v.size();\n    ll lw = w.size();\n \n \n    for (auto i : cnt) {\n        if (i.second &gt;= n + 2) {\n            cout &lt;&lt; &quot;No\\n&quot;;\n            return;\n        }\n    }\n    cout &lt;&lt; &quot;Yes\\n&quot;;\n \n    if (n == 1) {\n        struct Domi d;\n        if (v.empty()) {\n            d = w.back();\n        }\n        else {\n            d = v.back();\n        }\n        cout &lt;&lt; d.x &lt;&lt; &quot; &quot; &lt;&lt; d.y &lt;&lt; &quot;\\n&quot;;\n        return;\n    }\n \n    sort(v.begin(), v.end());\n    ll c = 1;\n    priority_queue&lt;pair&lt;ll, Domi&gt;&gt;pris;\n    for (ll i = 1;i &lt; lv;i++) {\n        if (v[i] != v[i - 1]) {\n            pris.push({ c,v[i - 1] });\n            c = 1;\n        }\n        else {\n            c++;\n        }\n    }\n    if (lv) {\n        pris.push({ c,v.back() });\n    }\n \n    vector&lt;Domi&gt;ans;\n    ll pw = 0;\n    ll las = -1;\n    while (!pris.empty() || pw &lt; lw) {\n        if (pris.empty()) {\n            struct Domi x = w[pw++];\n            if (x.x == las) {\n                x = { x.y,x.x };\n            }\n            ans.push_back(x);\n            las = x.y;\n            continue;\n        }\n \n        auto [cntx, x] = pris.top();pris.pop();\n        if (las != x.x) {\n            cntx--;\n            if (cntx) {\n                pris.push({ cntx,x });\n            }\n            ans.push_back(x);\n            las = x.y;\n            continue;\n        }\n \n        if (pris.empty()) {\n            pris.push({ cntx,x });\n            x = w[pw++];\n            if (x.x == las) {\n                x = { x.y,x.x };\n            }\n            ans.push_back(x);\n            las = x.y;\n            continue;\n        }\n \n        auto [cnty, y] = pris.top();pris.pop();\n        pris.push({ cntx,x });\n        cnty--;\n        if (cnty) {\n            pris.push({ cnty,y });\n        }\n        ans.push_back(y);\n        las = y.y;\n    }\n \n    for (auto i : ans) {\n        cout &lt;&lt; i.x &lt;&lt; &quot; &quot; &lt;&lt; i.y &lt;&lt; &quot;\\n&quot;;\n    }\n}\n \nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int t = 1;\n    // cin &gt;&gt; t;cin.get();\n    while (t--)solve();\n \n    return 0;\n}\nE-Malfunctioning Typewriter\n题意\n有一台打字机，对于每次键入的字符（只有0或1），每次有p的概率正确键入，有n句长度为m的不会重复的诗句，这些诗句可以以任意顺序组合成一首长度为n的诗。询问在打字这首诗的时候，有多大的概率成果打出。\n数据范围\n\n1\\leq n,m\\leq 1000\n0.5\\leq q\\leq 1\n\n思路\n将n句诗建立字典树，对每个节点统计以该结点为前缀的字符串数目。\n考虑到只有01，每个节点下最多只有0或1的子节点。记某个节点为u，将节点u前缀打对的概率可以预处理（f(x,y)表示打对x个1，y个0的概率），打对一整首诗歌是遍历完字典树上的每个字符串1次，对于字典树上的某个非叶子节点，在遍历时，经过该结点的数目是它的子树中有多少个叶子结点决定的，假设有x是从该节点（表示一个前缀）往后以1为根节点的子树中的叶子结点数目，y是以0为根节点的子树中叶子结点的数目，那么在决策当前是否正确输出了0/1的概率是f(x,y)（相当于在当前节点输出正确的x个1和y个0的概率代表这一步打字输出了x+y个合法下行子串的概率），故总概率是\\prod_u f(sz(lp),sz(rp))。\n对f(x,y)的预处理：\nf(x,y)=\\max(p\\times f(x-1,y)+(1-p)\\times f(x,y),p\\times f(x,y-1)+(1-p)\\times f(x-1,y))\n代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\nconst ll maxn = 1010;\n \nint node = 0;\nint nxt[maxn * maxn][2];\nint sz[maxn * maxn];\nvoid triInsert(string s) {\n    int n = s.size();\n    int p = 0;\n    for (int i = 0;i &lt; n;i++) {\n        int c = s[i] - &#039;0&#039;;\n        if (!nxt[p][c])nxt[p][c] = ++node;\n        sz[nxt[p][c]]++; // 以这个点为前缀的字符串数目\n        p = nxt[p][c];\n    }\n}\n \n \nld f[maxn][maxn];\nvoid solve() {\n    int n, m;ld p;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; p;\n    vector&lt;string&gt;st(n);\n    for (int i = 0;i &lt; n;i++) {\n        string s;cin &gt;&gt; s;\n        triInsert(s);\n    }\n    f[0][0] = 1.0; // 打出0个1,0个0概率为1\n    for (int x = 0;x &lt;= n;x++) {\n        // f(x,y):恰好正确打出x个1,y个0\n        for (int y = 0;y &lt;= n;y++) {\n            if (!x &amp;&amp; !y)continue;\n            ld w = x ? f[x - 1][y] : 0.0;\n            ld v = y ? f[x][y - 1] : 0.0;\n            f[x][y] = max(\n                p * w + (1 - p) * v,\n                p * v + (1 - p) * w\n            );\n        }\n    }\n    ld ans = 1.0;\n    for (int i = 0;i &lt;= node;i++) {\n        ans *= f[sz[nxt[i][0]]][sz[nxt[i][1]]];\n    }\n    printf(&quot;%.12lf&quot;, ans);\n}\n \nint main() {\n    int _ = 1;\n    // cin &gt;&gt; _;cin.get();\n    while (_--)\n        solve();\n \n    return 0;\n}\nJ-Rigged Games\n题意\n比赛由大分比和小分比一同决定最终的胜负，小分比Bo2a-1：先胜出a场为胜。大分比Bo2b-1：先胜出b场为胜。记1次小分比胜负为大分比的一场。\n现在有一个长度为n的01字符串，字符串是无限循环重复的，用于记录每一次比赛的胜负，从01字符串的每个位置开始比赛，询问谁会赢得整个比赛。\n数据范围\n\n1\\leq n,a,b\\leq 10^5\n\n思路\n倍增思想，在01循环串中，记录每个位置开始后进行Bo2a-1小局的胜负，以及下一步从哪个位置开始。数组f[i][j]表示从i开始进行2^j轮后到达的位置、对应的0、1​的胜利次数。\n在统计Bo2b-1时，我们要找到第一次0或1胜利b次以上的位置，将j倒序处理，2b-1是最多获得终局的次数，b是最少获得终局的次数。假设b=5，需要至少5局，至多9局定胜负，注意到9=2^3+2^0，在计数恰好9局时，应当只统计先2^3=8局，然后往后再统计2^0=1局（这里先1后8也不会影响结果，只要保证不超过9局即可）。在计算Bo2b-1的结果时，每次统计恰好2b-1。\n代码\nstruct status {\n    int n0, n1;\n    int overpos;\n}f[maxn][20]; // 从位置i开始结束j小局后的状态\n \nvoid solve() {\n    ll n, a, b;cin &gt;&gt; n &gt;&gt; a &gt;&gt; b;\n    string s;cin &gt;&gt; s;\n    // 更新Bo2a-1的状态\n    int w0 = 0, w1 = 0; // 统计0/1胜利多少次\n    int pos = 0;\n    for (int i = 0;i &lt; n;i++) {\n        // 位置i开始\n        while (w0 &lt; a &amp;&amp; w1 &lt; a) { // 未出小局结果\n            if (s[pos] == &#039;1&#039;)w1++;\n            else w0++;\n            pos = (pos + 1) % n;\n        }\n        if (w0 &gt;= a) {\n            f[i][0] = { 1,0,pos };\n        }\n        else {\n            f[i][0] = { 0,1,pos };\n        }\n        if (s[i] == &#039;1&#039;)w1--;\n        else w0--; // 下一次循环会从i+1开始,减去i位置的分\n    }\n    // 倍增结果\n    for (int j = 1;j &lt; 20;j++) {\n        // 枚举进行了2^j局\n        for (int i = 0;i &lt; n;i++) {\n            // 枚举开始位置\n            // 第i位置开始进行2^j局=第i开始进行2^(j-1)局+第i开始进行2^(j-1)局后的位置pos开始进行2^(j-1)局\n            int pos = f[i][j - 1].overpos;\n            f[i][j].overpos = f[pos][j - 1].overpos;\n            f[i][j].n0 = f[i][j - 1].n0 + f[pos][j - 1].n0;\n            f[i][j].n1 = f[i][j - 1].n1 + f[pos][j - 1].n1;\n        }\n    }\n    // 进行Bo2b-1的结果统计\n    for (int i = 0;i &lt; n;i++) {\n        int w0 = 0, w1 = 0;\n        int tot = 0;\n        int pos = i;\n        for (int j = 0;j &lt; 20;j++) {\n            // 从pos开始进行2^j次比赛,累计0/1的胜利次数\n            if ((2 * b - 1) &gt;&gt; j &amp; 1) {\n                w0 += f[pos][j].n0;\n                w1 += f[pos][j].n1;\n                pos = f[pos][j].overpos;\n            }\n        }\n        // cout &lt;&lt; w0 &lt;&lt; &quot; &quot; &lt;&lt; w1 &lt;&lt; endl; // 出现第一个胜利b次时正确\n        if (w0 &gt;= b)cout &lt;&lt; &#039;0&#039;;\n        else cout &lt;&lt; &#039;1&#039;;\n    }\n    cout &lt;&lt; &quot;\\n&quot;;\n}\nL-Sudoku and Minesweeper\n题意\n给出一个9\\times 9的数独，在这个数独的基础上构造一个扫雷地图，将数独上的一些数字替换为*，但是不能将所有数字都替换为*，使得整个扫雷地图合法。\n思路\n在铺满地雷的地图上保留一些数字，数字8表明该格周围都是*，所以选择保留所有的8，并再次遍历一遍所有的地图（注意边界），删掉不符合要求的8。\n或者另一个想法：中间3\\times 3的格子中中一定有一个数字8，在去掉除了这个8以外的所有数字之后，这个8一定是符合要求的。\n代码\nchar mp[10][10];\n \nvoid solve() {\n    for (int i = 1;i &lt;= 9;i++) {\n        for (int j = 1;j &lt;= 9;j++) {\n            cin &gt;&gt; mp[i][j];\n            if (mp[i][j] != &#039;8&#039;)mp[i][j] = &#039;*&#039;;\n        }\n    }\n    vector&lt;pair&lt;int, int&gt;&gt;dxy = {\n        {-1,-1},{-1,0},{-1 ,1},\n        {0,-1},{0 ,1},\n        {1,-1},{1,0},{1 ,1},\n    };\n    for (int i = 1;i &lt;= 9;i++) {\n        for (int j = 1;j &lt;= 9;j++) {\n            if (mp[i][j] == &#039;*&#039;)continue;\n            int x = mp[i][j] - &#039;0&#039;;\n            int y = 0;\n            for (int k = 0;k &lt; 8;k++) {\n                int ii = i + dxy[k].first, jj = j + dxy[k].second;\n                if (ii &gt;= 1 &amp;&amp; ii &lt;= 9 &amp;&amp; jj &gt;= 1 &amp;&amp; jj &lt;= 9)\n                    if (mp[ii][jj] == &#039;*&#039;) { y++; }\n            }\n            if (x != y)mp[i][j] = &#039;*&#039;;\n        }\n    }\n    for (int i = 1;i &lt;= 9;i++) {\n        for (int j = 1;j &lt;= 9;j++) {\n            cout &lt;&lt; mp[i][j];\n        }\n        cout &lt;&lt; &quot;\\n&quot;;\n    }\n}"},"03-algorithm/nc24sd4":{"slug":"03-algorithm/nc24sd4","filePath":"03-algorithm/nc24sd4.md","title":"🫟2024牛客暑假多校训练营Day4||补题","links":[],"tags":["2024暑假集训","算法","牛客"],"content":"A-LCT\n题意\n给定一棵有根树，每次询问前i条边组成的森林中，第c_i个点为根的树的深度。\n数据范围\n\n2\\leq n\\leq 10^6\n1\\leq a_i,b_i,c_i\\leq n,a_i\\neq b_i\n\n思路\n带权并查集，维护每个节点在当前所属树的层数，维护所有以该节点为根节点的树的深度。\n代码\nint deep[maxn], fa[maxn], dis[maxn];\nint findfa(int x) {\n    if (x == fa[x])return x;\n    int fx = findfa(fa[x]);\n    // 更新deep,旧根:fa[x],新根:fx\n    deep[x] += deep[fa[x]];\n    return fa[x] = fx;\n}\n \nvoid merge(int u, int v) {\n    int fu = findfa(u);\n    fa[v] = fu;\n    deep[v] = deep[u] + 1;\n    dis[fu] = max(dis[fu], dis[v] + deep[v]);\n}\n \nvoid solve() {\n    int n;cin &gt;&gt; n;\n    for (int i = 1;i &lt;= n;i++) {\n        fa[i] = i;\n        deep[i] = 0;\n        dis[i] = 0;\n    }\n    for (int i = 1;i &lt;= n - 1;i++) {\n        int u, v, c;cin &gt;&gt; u &gt;&gt; v &gt;&gt; c;\n        merge(u, v);\n        cout &lt;&lt; dis[c] &lt;&lt; &quot; &quot;;\n    }\n    cout &lt;&lt; &quot;\\n&quot;;\n}\nC-Sort4\n题意\n给出一个排列，每次选择四个位置交换其中的元素，求将该排列排序成上升序列的最小操作次数。\n数据范围\n\n1\\leq t\\leq 10^5\n1\\leq n\\leq 10^6\n\n思路\n令p_i是排序之后数a_i的位置，每个(p_i,a_i)对应了一个关系。易知这样的关系会形成若干个环，如果环的长度是3或4，则一次交换可以让这个环上的数字都归位，如果是大于4的环，每次在这个环上进行一次操作可以让环的长度减少3，如果是两个长度为2的环，则一次操作可以让两个长度为2的环归位。\n代码\nint p[maxn], fa[maxn], len[maxn];\n \nint findfa(int x) {\n    if (x == fa[x])return x;\n    int fx = findfa(fa[x]);\n    len[fa[x]] = len[fx];\n    return fa[x] = fx;\n}\n \nvoid merge(int x, int y) {\n    int fx = findfa(x), fy = findfa(y);\n    if (fx == fy)return;\n    fa[fx] = fy;\n    len[fy] += len[fx];\n}\n \nvoid solve() {\n    int n;cin &gt;&gt; n;\n    for (int i = 1;i &lt;= n;i++) {\n        len[i] = 1;fa[i] = i;\n    }\n    for (int i = 1;i &lt;= n;i++) {\n        cin &gt;&gt; p[i];\n        merge(i, p[i]);\n    }\n    map&lt;int, int&gt;mp;\n    for (int i = 1;i &lt;= n;i++) {\n        int fx = findfa(i);\n        if (mp.count(fx))continue;\n        mp[fx] = len[fx];\n    }\n    int ans = 0, cnt2 = 0;\n    for (auto [i, s] : mp) {\n        if (s == 1)continue;\n        else if (s == 3 || s == 4)ans++;\n        else if (s &gt; 4) {\n            int t = s / 3;\n            ans += t;\n            if (s % 3 == 2) {\n                cnt2++;\n            }\n        }\n        else cnt2++;\n    }\n    ans += (cnt2 + 1) / 2;\n    cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;;\n}\nF-Good Tree\n题意\n一棵树，树上的边权都是1，定义f(u)=\\sum_v dis(u,v)，给出一个x，寻找一个满足存在两个点u,v使得f(u)-f(v)=x成立的最少节点子树，输出节点数。\n数据范围\n\n1\\leq t\\leq 10^5\n1\\leq x \\leq 10^{18}\n\n思路\nf(u)为点u到各个其他节点的距离之和，只有u\\rightarrow v一条路径的时候，f(u)=f(v)=dia(u,v)，若要增加f(u)和f(v)之间的差值，每在v上增加一个在v的子树中的节点，f(u)-f(v)的值就会增加一倍dis(u,v)。\n当有奇数个点，2\\times k +1个点，另dis(u,v)=k，剩余k个点都是v的子树中的节点，f(u)-f(v)最大是k^2。\n当有偶数个点，2\\times k+2，同理，f(u)-f(v)的最大值是k(k+1)。\n下一个奇数是(k+1)^2，再下一个偶数的是(k+1)(k+2)…\n故对于一个确定的x，我们需要确定落在哪个(k^2,(k+1)^2]区间，然后再确定是在区间(k^2,k(k+1)]还是(k(k+1),(k+1)^2]，也就是点数应该至少是大于2\\times k+1还是2\\times k+2。\n在区间(k(k+1),(k+1)^2)中，一定可以构造出2\\times k+3的方法；\n在区间(k^2,k(k+1)]中，如果k为奇数，可以构造出2\\times k+3，如果k为偶数，可以构造出2\\times k+2。\n代码\nvoid solve() {\n    ll x;cin &gt;&gt; x;\n    ll k = sqrtl(x); // 注意开方long long\n    if (k * k == x) {\n        cout &lt;&lt; 2 * k + 1 &lt;&lt; &quot;\\n&quot;;\n    }\n    else if (k * (k + 1) &lt; x) {\n        cout &lt;&lt; 2 * k + 3 &lt;&lt; &quot;\\n&quot;;\n    }\n    else if ((x - k * k) % 2ll != k % 2ll) {\n        cout &lt;&lt; 2 * k + 3 &lt;&lt; &quot;\\n&quot;;\n    }\n    else {\n        cout &lt;&lt; 2 * k + 2 &lt;&lt; &quot;\\n&quot;;\n    }\n}\nG-Horse Drinks Water\n题意\n将军饮马问题。在平面坐标轴中，只有x\\text{、} y轴的飞负半轴是水源，给出马儿的坐标和营地的坐标，求最短距离。\n数据范围\n\n1\\leq t\\leq 10^5\n0\\leq x_G,y_G,x_T,u_T\\leq 10^9\n\n思路\n将坐标按坐标轴对称，求距离。\n代码\nld dist(ld r, ld c) {\n    return sqrt(r * r + c * c);\n}\n \nvoid solve() {\n    ll x1, y1, x2, y2;\n    cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;\n    ld ans1 = dist(1.0 * abs(y1 - y2), 1.0 * (abs(x1) + abs(x2)));\n    ld ans2 = dist(1.0 * (abs(y1) + abs(y2)), 1.0 * abs(x1 - x2));\n    ld ans = min(ans1, ans2);\n    printf(&quot;%.12lf\\n&quot;, ans);\n}\nH-Yet Another Origami Problem\n题意\n可以选择任意坐标p，进行如下二选一操作：\n\n若符合a_i\\leq a_p，可以重新赋值a_i\\leftarrow a_i + 2(a_p-a_i)。\n若符合a_i\\geq a_p，可以重新赋值a_i \\leftarrow a_i-a(a_i-a_p)\n\n可以进行上述操作若干次，求问可以将a数组的范围收敛到多小。\n数据范围\n\n1\\leq t\\leq 5\\times 10^5\n1\\leq n\\leq 10^5\n0\\leq a_i\\leq 10^{16}\n\n思路\n上面的操作可以进行无数次，通过模拟可以意识到，这是一个类似折纸的操作，是将某个数沿着某条线折叠到另一边的操作。注意到每次操作不是必须要对每个a_i进行这样的翻折的，例如当a_i\\lt a_p时选择操作2，可以避免a_i的翻折。\n通过翻折让数组的范围收束到最小。假设当前只有3个各不相同的数，这三个数从小到大排列之后是\\{a,b,c\\}，那么在数轴上形成了距离x=b-a和y=c-b，对于这三个数来说，通过折叠，假设是a沿着b向c折叠，将x变为x\\bmod y（不断沿着y的两边折叠，直到落在b\\text{、} c之间），若此时x\\neq 0，则y也可以通过一样的方法收束到小于x的某个长度。故获得的最小的范围应该是x\\text{、}y的gcd。\n同样的思想可以拓展到多个数的时候。\n代码\nll a[maxn];\nvoid solve() {\n    int n;cin &gt;&gt; n;\n    for (int i = 0;i &lt; n;i++) { cin &gt;&gt; a[i]; }\n    sort(a, a + n);\n    if (n == 1) {\n        cout &lt;&lt; 0 &lt;&lt; &quot;\\n&quot;;\n        return;\n    }\n    if (n == 2) {\n        cout &lt;&lt; a[1] - a[0] &lt;&lt; &quot;\\n&quot;;\n        return;\n    }\n    ll ans = a[1] - a[0];\n    for (int i = 2;i &lt; n;i++) {\n        ans = gcd(ans, a[i] - a[i - 1]);\n    }\n    cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;;\n}\nI-Friends\n题意\nn个人从左到右排成一排，编号从1到n-1，这n个人之间有m对好朋友，求有多少个区间[l,r]中每两对都是好朋友。\n数据范围\n\n1\\leq n,m \\leq 10^6\n\n思路\n假设已有一个区间[l,r]符合要求，且r是以l为左端点的时候最远的符合要求的右端点。那么显然有：\n当加入r+1时，r+1号与[l,r]中的至少一个人不是好友关系。同时，区间[l+1,r]是一个友好区间，于是在移动左端点时，右端点只需要从上一个左端点的最远右端点开始检查即可。\n代码\nvoid solve() {\n    int n, m;cin &gt;&gt; n &gt;&gt; m;\n    vector&lt;map&lt;int, bool&gt;&gt;links(n + 1);\n    for (int i = 0;i &lt; m;i++) {\n        int u, v;cin &gt;&gt; u &gt;&gt; v;\n        links[u][v] = true;\n        links[v][u] = true;\n    }\n    int ans = 0;\n    int prer = 1;\n    for (int i = 1;i &lt;= n;i++) {\n        int j = prer;\n        while (j &lt;= n) {\n            // check\n            bool f = true;\n            for (int k = i;k &lt; j;k++) {\n                if (links[j].count(k))continue;\n                f = false;\n                break;\n            }\n            if (!f)break;\n            j++;\n        }\n        ans += j - i;\n        prer = j - 1;\n    }\n \n    cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;;\n}"},"03-algorithm/nc24sd5":{"slug":"03-algorithm/nc24sd5","filePath":"03-algorithm/nc24sd5.md","title":"🫟2024牛客暑假多校训练营Day5||补题","links":[],"tags":["2024暑假集训","算法","牛客"],"content":"\nTODO"},"03-algorithm/nc24sd6":{"slug":"03-algorithm/nc24sd6","filePath":"03-algorithm/nc24sd6.md","title":"🫟2024牛客暑假多校训练营Day6||补题","links":[],"tags":["2024暑假集训","算法","牛客"],"content":"A-Cake\n题意\nOscar和Grammy玩游戏，第一阶段两人轮流在有根树上走，走到叶子停止，经过的边有两种，标0边或者标1边，记录走下的01串。设01串的长度是m，第二阶段Oscar将蛋糕切成m份，有些蛋糕可以是空的，按照第一阶段的01串顺序依次拿蛋糕（1代表Grammy拿，0代表Oscar拿），两人都想获得最多的蛋糕，求最后Grammy获得的蛋糕比例。\n数据范围\n\n1\\leq n\\leq 2\\times 10^5\n\n思路\n在第二阶段，Oscar分蛋糕的时候，是对当前串寻找一个0占比最大的前缀，然后拿走占比一致的蛋糕。\n于是，在第一阶段时，首先树上每个节点即代表一个前缀，预处理出每个节点为前缀时0的占比，在之后两人轮流取数时，Oscar会取选择下一个节点轮流选择后0占比最大的节点，Grammy会选择0占比最小的节点。\n代码\nstruct edge {\n    int s, t, typ;\n};\n \nstruct status {\n    int cnt0, cnt1;\n    status(int a, int b) :cnt0(a), cnt1(b) {}\n    status operator+(const status&amp; s)const {\n        return status(s.cnt0 + cnt0,s.cnt1 + cnt1);\n    }\n};\n \nvector&lt;vector&lt;edge&gt;&gt;tree;\n \ndouble dfs(int p, int fr, int who, status now, double mx) { \n    // mx为路径中0比例最大的前缀中0的比例\n    if (tree[p].size() == 1 &amp;&amp; fr) {\n        return mx;\n    }\n \n    double ans = 1.0 * who;\n    for (int i = 0;i &lt; tree[p].size();i++) {\n        struct edge e = tree[p][i];\n        if (e.t == fr)continue;\n        double nxt = dfs(e.t, p, 1 - who, now + status(1 - e.typ, e.typ), max(mx, 1.0 * (now.cnt0 + 1 - e.typ) / (now.cnt0 + now.cnt1 + 1)));\n        if (who) { // Grammy选择(当前路径+接下来的路径)中0比例少的\n            ans = min(ans, nxt);\n        }\n        else { // Oscar选择0比例多的\n            ans = max(ans, nxt);\n        }\n    }\n    return ans;\n}\n \nvoid solve() {\n    int n;cin &gt;&gt; n;\n \n    tree.assign(n + 1, vector&lt;edge&gt;());\n \n    for (int i = 0;i &lt; n - 1;i++) {\n        int u, v, t;\n        cin &gt;&gt; u &gt;&gt; v &gt;&gt; t;\n        tree[u].push_back({ u,v,t });\n        tree[v].push_back({ v,u,t });\n    }\n    double ans = dfs(1, 0, 1, { 0,0 }, 0.0);\n    cout &lt;&lt; fixed &lt;&lt; setprecision(15) &lt;&lt; 1.0 - ans &lt;&lt; &quot;\\n&quot;;\n}\nB-Cake 2\n题意\n对一个正n边形，顶点按顺时针标为0\\sim n-1，在每一个i和(i+k)\\bmod n的顶点之间切一刀，问最终能切出多少块蛋糕。\n数据范围\n\n1\\leq n\\leq 10^6\n2\\leq k\\leq n-2\n\n思路\n找规律可以发现除了2\\times k=n时答案为n，其他情况都符合n\\times \\min(n-k,k) +1。\n代码\nvoid solve() {\n    ll n, k;cin &gt;&gt; n &gt;&gt; k;\n    if (n == k * 2) {\n        cout &lt;&lt; n &lt;&lt; &quot;\\n&quot;;\n    }\n    else {\n        k = min(k, n - k);\n        cout &lt;&lt; k * n + 1 &lt;&lt; &quot;\\n&quot;;\n    }\n}\nD-Puzzle: Wagiri\n题意\n无向图中有两种边，对原图进行删边，要求删完边之后图仍是联通的，且所有的轮边只在环中出现，所有的切边都不在环，判断是否存在合适的删边操作，若有再输出结果的连接情况。\n数据范围\n\n1\\leq n\\leq 10^5\nn-1\\leq m\\leq 2\\times 10^5\n1\\leq u_i,v_i\\leq n\nt_i\\in \\\\{&quot;Lun&quot;,&quot;Qie&quot;\\\\}\n\n思路\n将所有的Lun边中成环的部分进行缩点，再根据Qie边对这些点生成一棵树。\n代码\nstruct E {\n    int id;\n    int s, t;\n    int typ;\n};\n \nvector&lt;vector&lt;E&gt;&gt;edge;\nll deep, top, sum, res = 0;\nll dfn[maxn], low[maxn], color[maxn], vis[maxn], stk[maxn];\n \nvector&lt;E&gt;ans;\n \nvoid tarjan(int v, int fa) {\n    dfn[v] = ++deep;\n    low[v] = deep;\n    vis[v] = 1;\n    stk[++top] = v; // 入栈\n \n    for (int i = 0;i &lt; edge[v].size();i++) {\n        auto e = edge[v][i];\n        if (e.typ == 0 || e.t == fa) // 忽略Qie边和避免重边环\n            continue;\n        if (dfn[e.t] == 0) {\n            tarjan(e.t, v);\n            low[v] = min(low[v], low[e.t]);\n        }\n        else {\n            if (vis[e.t]) {\n                low[v] = min(low[v], low[e.t]);\n            }\n        }\n    }\n \n    if (low[v] == dfn[v]) { // 形成强联通分量或仅自己,缩点\n        color[v] = ++sum;\n        vis[v] = 0;\n        while (stk[top] != v) {\n            color[stk[top]] = sum;\n            vis[stk[top--]] = 0;\n        }\n        top--;\n    }\n}\n \nint fa[maxn];\nint findfa(int u) {\n    if (fa[u] == u)return u;\n    return fa[u] = findfa(fa[u]);\n}\n \nvoid solve() {\n    int n, m;cin &gt;&gt; n &gt;&gt; m;\n    edge.assign(n + 1, vector&lt;E&gt;());\n    for (int i = 1;i &lt;= m;i++) {\n        int u, v;cin &gt;&gt; u &gt;&gt; v;\n        string s;cin &gt;&gt; s;\n        int c = (s == &quot;Lun&quot; ? 1 : 0);\n        edge[u].push_back({ ++tot,u,v,c });\n        edge[v].push_back({ ++tot,v,u,c });\n    }\n \n    memset(dfn, 0, sizeof(dfn));\n \n    for (int i = 1;i &lt;= n;i++) {\n        if (dfn[i] == 0) {\n            tarjan(i, -1);\n        }\n    }\n \n    // for (int i = 1;i &lt;= n;i++) {\n    //     cout &lt;&lt; color[i] &lt;&lt; &quot; &quot;; // 各个点的颜色\n    // }\n    // cout &lt;&lt; &quot;\\n&quot;;\n \n    for (int i = 1;i &lt;= n;i++) {\n        for (int j = 0;j &lt; edge[i].size();j++) {\n            auto e = edge[i][j];\n            if (color[e.t] == color[i]) { // s,t相同颜色的轮边直接加入答案\n                if (e.typ == 1)\n                    ans.push_back(e);\n            }\n        }\n    }\n \n    for (int i = 1;i &lt;= sum;i++)fa[i] = i;\n    int cntc = sum;\n    for (int i = 1;i &lt;= n;i++) {\n        for (int j = 0;j &lt; edge[i].size();j++) {\n            auto e = edge[i][j];\n            if (e.typ == 1) { // 跳过轮边\n                continue;\n            }\n            if (color[i] != color[e.t]) {\n                int f1 = findfa(color[i]);\n                int f2 = findfa(color[e.t]);\n                if (f1 != f2) {\n                    fa[f1] = f2;\n                    ans.push_back(e); // 用e将两个颜色连起来\n                    cntc--;\n                }\n            }\n        }\n    }\n \n    if (cntc == 1) {\n        cout &lt;&lt; &quot;YES\\n&quot;;\n        // 去除加入的双向边\n        map&lt;pair&lt;ll, ll&gt;, bool&gt;mp;\n        for (auto e : ans) {\n            if (e.s &lt; e.t) {\n                mp[{e.s, e.t}] = true;\n            }\n            else {\n                mp[{e.t, e.s}] = true;\n            }\n        }\n        cout &lt;&lt; mp.size() &lt;&lt; &quot;\\n&quot;;\n        for (auto [e, f] : mp) {\n            cout &lt;&lt; e.first &lt;&lt; &quot; &quot; &lt;&lt; e.second &lt;&lt; &quot;\\n&quot;;\n        }\n    }\n    else {\n        cout &lt;&lt; &quot;NO\\n&quot;;\n    }\n}\nH-Genshin Impact’s Fault\n题意\n每次抽卡的结果是3星、4星、5星非Up、5星Up四种结果中的一种。同时也符合如下的要求：\n\n连续10抽中不会全是3星。\n连续90抽中至少有一个是5星非Up或5星Up\n每两个连续的5星中至少有一个是5星非Up\n\n给出一个抽卡结果序列，判断该抽卡结果是否符合上述规则。\n数据范围\n\n1\\leq T\\leq 10^5\n1\\leq |S|\\leq 10^6\n\n思路\n模拟。\n代码\nvoid solve() {\n    string s;cin &gt;&gt; s;\n    bool hasup = true;\n    int cnt10 = 0, cnt90 = 0;\n    bool f = true;\n    for (auto c : s) {\n        if (c == &#039;4&#039; || c == &#039;5&#039; || c == &#039;U&#039;)cnt10 = 0;\n        else cnt10++;\n        if (cnt10 == 10) {\n            f = false;break;\n        }\n \n        if (c == &#039;5&#039; &amp;&amp; !hasup) {\n            f = false;break;\n        }\n \n        if (c == &#039;5&#039; || c == &#039;U&#039;) {\n            cnt90 = 0;\n            if (c == &#039;U&#039;)\n                hasup = true;\n            else if (c == &#039;5&#039;)\n                hasup = false;\n        }\n        else {\n            cnt90++;\n \n        }\n        if (cnt90 == 90) {\n            f = false;break;\n        }\n    }\n \n    f ? cout &lt;&lt; &quot;valid\\n&quot; : cout &lt;&lt; &quot;invalid\\n&quot;;\n}\nF-Challenge NPC 2\n题意\n在一个森林的补图中寻找哈密顿路径。\n注：哈密顿路径指经过图中所有顶点一次且仅经过一次。\n数据范围\n\nn\\leq 5\\times 10^5\n\n思路\n森林中有且只有一棵菊花是无解的。剩余情况中，假如树是一棵菊花，则将其分为花瓣和花心两部分，花瓣可以连成一条路径，花心单独成为一条路径，假如不是一棵菊花，则寻找树的一个叶子结点，再从叶子结点进行BFS，按照246…135…的顺序将点穿起来，加入答案。\n最后将不能相连的一组花瓣花心分别接在答案的两边，输出答案即可。\n代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\nconst int maxn = 5e5 + 50;\nconst ll mo998 = 998244353;\n \nstruct edge {\n    int s, t;\n};\n \nvector&lt;vector&lt;edge&gt;&gt;tree;\nint fa[maxn];\nint rk[maxn];\nint deg[maxn];\nbool vis[maxn];\n \nint findfa(int x) {\n    if (fa[x] == x)return x;\n    return fa[x] = findfa(fa[x]);\n}\n \nvector&lt;int&gt;ans;\nvector&lt;pair&lt;vector&lt;int&gt;, vector&lt;int&gt;&gt;&gt;tmp; // 不能相邻的两条路\n \nint tail, c;\n \nvoid getpath(vector&lt;int&gt;v) {\n    if (v.size() == 1) {\n        vis[v.front()] = true;\n        ans.push_back(v.front());\n        return;\n    }\n    if (v.size() == 2) {\n        tmp.push_back({ {v.front()},{v.back()} });\n        return;\n    }\n    // 判断菊花\n    int n = v.size();\n    vector&lt;int&gt;wi, wj;\n    for (int i = 0;i &lt; n;i++) {\n        int p = v[i];\n        if (deg[p] == n - 1) {\n            wj.push_back(p);\n        }\n        else if (deg[p] == 1) {\n            wi.push_back(p);\n        }\n    }\n \n    if (wj.size() == 1) {\n        tmp.push_back({ wi,wj });\n        return;\n    }\n \n    // 寻找叶子结点\n    for (auto i : v) {\n        if (tree[i].size() == 1) {\n            tail = i;\n            break;\n        }\n    }\n \n    // 分层bfs\n    c = 0;\n    wi.clear();\n    vector&lt;int&gt;x;\n    x.push_back(tail);\n    while (!x.empty()) {\n        vector&lt;int&gt;y;\n        for (auto p : x) {\n            vis[p] = true;\n            for (int i = 0;i &lt; tree[p].size();i++) {\n                struct edge e = tree[p][i];\n                if (vis[e.t])continue;\n                y.push_back(e.t);\n            }\n            if (c)ans.push_back(p);\n            else wi.push_back(p);\n        }\n        c = 1 - c;\n        x = y;\n    }\n    for (auto i : wi) {\n        ans.push_back(i);\n    }\n}\n \nvoid solve() {\n    int n, m;cin &gt;&gt; n &gt;&gt; m;\n \n    tree.assign(n + 1, vector&lt;edge&gt;());\n    for (int i = 1;i &lt;= n;i++) {\n        fa[i] = i;\n        deg[i] = 0;\n        vis[i] = false;\n        rk[i] = 1;\n    }\n \n    for (int i = 0;i &lt; m;i++) {\n        int u, v;cin &gt;&gt; u &gt;&gt; v;\n        deg[u]++, deg[v]++;\n        tree[u].push_back({ u,v });\n        tree[v].push_back({ v,u });\n \n        int fu = findfa(u), fv = findfa(v);\n        if (rk[fu] &gt; rk[fv])fa[fv] = fu;\n        else {\n            if (rk[fu] == rk[fv])rk[fv]++;\n            fa[fu] = fv;\n        }\n    }\n \n \n    map&lt;int, vector&lt;int&gt;&gt;mp;\n    for (int i = 1;i &lt;= n;i++) {\n        int f = findfa(i);\n        mp[f].push_back(i);\n    }\n \n    ans.clear(), tmp.clear();\n \n    for (auto i : mp) {\n        getpath(i.second);\n    }\n \n    if (ans.empty() &amp;&amp; tmp.size() == 1) {\n        cout &lt;&lt; -1 &lt;&lt; &quot;\\n&quot;;\n        return;\n    }\n    \n    if (tmp.size() &gt;= 2) { // 只有两个菊花时要交叉放\n        auto [v1, v2] = tmp[0];\n        auto [w1, w2] = tmp[1];\n        for (int i = 0;i &lt; v1.size();i++) {\n            ans.push_back(v1[i]);\n        }\n        for (int i = 0;i &lt; w1.size();i++) {\n            ans.push_back(w1[i]);\n        }\n        for (int i = 0;i &lt; v2.size();i++) {\n            ans.push_back(v2[i]);\n        }\n        for (int i = 0;i &lt; w2.size();i++) {\n            ans.push_back(w2[i]);\n        }\n        tmp.erase(tmp.begin());\n        tmp.erase(tmp.begin());\n    }\n \n    vector&lt;int&gt;x, y;\n    for (auto [w, v] : tmp) {\n        for (auto i : w) {\n            x.push_back(i);\n        }\n        for (auto i : v) {\n            y.push_back(i);\n        }\n    }\n \n \n    for (auto i : x) {\n        cout &lt;&lt; i &lt;&lt; &quot; &quot;;\n    }\n \n    for (auto i : ans) {\n        cout &lt;&lt; i &lt;&lt; &quot; &quot;;\n    }\n \n    for (auto i : y) {\n        cout &lt;&lt; i &lt;&lt; &quot; &quot;;\n    }\n \n    cout &lt;&lt; &quot;\\n&quot;;\n}\n \nint main() {\n    ll t;\n    cin &gt;&gt; t;\n    while (t--)\n        solve();\n \n    return 0;\n}"},"03-algorithm/nc24sd7":{"slug":"03-algorithm/nc24sd7","filePath":"03-algorithm/nc24sd7.md","title":"🫟2024牛客暑假多校训练营Day7||补题","links":[],"tags":["2024暑假集训","算法","牛客"],"content":"I-Fight Against the Monster\n题意\n使用机器对抗怪兽，一台机器有以下两种功能：\n\n战斗：使怪兽血量减少1点，后技巧丧失所有功能\n创造：需要m台机器同时使用，创造出k台新机器，每台机器仅能使用一次创造功能。\n\n怪兽初始血量是h，血量下降至0​时死亡，请计算初始最少需要多少机器才能打败怪兽。\n数据范围\n\n1\\leq t\\leq 2\\times 10^5\n1\\leq k\\leq m \\leq 10^6\n0\\leq h\\leq 10^9\n\n思路\n根据机器的功能特点，我们尽可能让每台机器进行创造。若最初有x台机器，则进行一次创造之后拥有x+k(x\\ge m)台机器，其中有k+x-m台机器拥有创造能力，最多拥有的机器数目是直到拥有创造能力的机器数目低于m时拥有的机器数目。可以发现除了第一次使用m台机器进行创造，之后使用m台机器进行创造时，可以使用k台新制造的机器加上m-k台最初拥有的机器进行创造，那么最多拥有的机器数目是：\nf(x)=\n\\begin{cases}\nx\\quad x\\lt m\\\\\nx+k\\times (\\lfloor (x-m)/(m-k)\\rfloor+1)\n\\end{cases}\n二分寻找符合条件的最少的最初机器数即可。\n不过队友在赛时提供了一种更加直观不必二分求解的方法：\n怪兽每受到m点攻击时，可以将这m点攻击看成是花费m-k台机器，在保证至少能发出一次m点攻击时，最初的机器数目要有m个，同时，怪物剩余不足m点血量时，只能再用额外的机器进行攻击。相关代码也贴在下面了。\n代码\n// 二分\nll m, k, h;\nll getmax(ll x) {\n    if (x &lt; m)return x;\n    return x + k * ((x - m) / (m - k) + 1);\n}\n \nvoid solve() {\n    cin &gt;&gt; m &gt;&gt; k &gt;&gt; h;\n    if (m == k || h &lt;= m) {\n        cout &lt;&lt; min(h, m) &lt;&lt; &quot;\\n&quot;;\n        return;\n    }\n    ll l = m, r = h + 1;\n    while (l &lt; r) {// [l,r)\n        ll x = (l + r) &gt;&gt; 1;\n        if (h &gt; getmax(x)) {\n            l = x + 1;\n        }\n        else {\n            r = x;\n        }\n    }\n    cout &lt;&lt; l &lt;&lt; &quot;\\n&quot;;\n}\n \n// 直接求解\nvoid solve(){\n    cin &gt;&gt; m &gt;&gt; k &gt;&gt; h;\n    ll ans = (h / m) * (m - k);\n    if(h / m) ans += max(h % m, k);\n    else ans = h;\n    cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;;\n}\nJ-Ball\n题意\n坐标轴上有一根木棒，左端点在原点(0,0)处，垂直y轴放置，右端点在(l,0)处，在坐标轴上有一个点P(x,y)，询问在木棒上是否有一个点，满足当木棒绕着该点旋转时可以击中点P，如有则输出该点坐标，若无输出-1。\n数据范围\n\n1\\leq T\\leq 10^4\n1\\leq l\\leq 10^5\n-10^5\\leq x,y \\leq 10^5\n\n思路\n木棒可以到达的最大范围是以(0,0)为旋转中心和以(l,0)为旋转中心的旋转范围的并集。\n代码\nld sqr(ld dx, ld dy) {\n    return sqrt(dx * dx + dy * dy);\n}\n \nld dist(ll x1, ll y1, ll x2, ll y2) {\n    return sqr(1.0 * (x1 - x2), 1.0 * (y1 - y2));\n}\n \nvoid solve() {\n    ll l, x, y;cin &gt;&gt; l &gt;&gt; x &gt;&gt; y;\n    ld d1 = dist(0, 0, x, y), d2 = dist(l, 0, x, y);\n    if (d1 &gt; l &amp;&amp; d2 &gt; l) {\n        cout &lt;&lt; &quot;No\\n&quot;;return;\n    }\n    cout &lt;&lt; &quot;Yes\\n&quot;;\n    if (d1 &lt;= l) {\n        cout &lt;&lt; &quot;0.00000000\\n&quot;;\n    }\n    else if (d2 &lt;= l) {\n        printf(&quot;%.8lf\\n&quot;, 1.0 * l);\n    }\n}\nK-Strings, Subsequences, Reversed Subsequences, Prefixes\n题意\n给出一个字符串s和一个字符串t，要求在s中寻找以t为前缀，以t的翻转串为后缀的s的子串，求这样的本质不同的子串数目。\n数据范围\n\n1\\leq n,m \\leq 10^6\ns_i,t_i\\in [a,z]\n\n思路\n前缀和后缀可以直接暴力从s最左侧和最右侧枚举，前后缀还要加上有公共重叠部分的数目，之后的问题就是如何计算中间部分的本质不同的子串了。\n另中间部分的字符串为s&#039;，在s&#039;上，设f[i]表示到第i位时拥有多少个本质不同的子串，将a[i]加入时，a[i]可以加入在f[i-1]时的所有本质不同的子串的后面，这样形成的字符串中，与原来答案重复的是上一个字符a[i]加入时拥有的本质不同的字符串数目，所以转移方程是这样：\nf[i]=2\\times f[i-1]-f[last[a[i]]-1]\n在处理前后缀的时候，当前后缀所处的最小区域有相交时，枚举允许重叠的长度时要至少从重叠部分的长度开始进行枚举。\n代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\nconst ll mo998 = 998244353;\nconst ll mo109 = 1000000007;\nconst int maxn = 1e5 + 50;\n \nvoid solve() {\n    ll n, m;cin &gt;&gt; n &gt;&gt; m;\n    string s, t;cin &gt;&gt; s &gt;&gt; t;\n    ll l = 0, r = n - 1;\n    ll p0 = 0;\n    while (p0 &lt; m &amp;&amp; l &lt; n) {\n        if (t[p0] == s[l]) {\n            p0++;\n        }\n        l++;\n    }\n    if (p0 != m) {\n        cout &lt;&lt; 0 &lt;&lt; &quot;\\n&quot;;\n        return;\n    }\n    p0 = 0;\n    ll pos = 0;\n    while (p0 &lt; m &amp;&amp; r &gt;= 0) {\n        if (t[p0] == s[r]) {\n            p0++;\n            if (r &gt;= l)pos = p0; // 独自能自匹配的长度\n        }\n        r--;\n    }\n    if (p0 != m) {\n        cout &lt;&lt; 0 &lt;&lt; &quot;\\n&quot;;\n        return;\n    }\n    // 处理回文\n    ll cnt = 0;\n    vector&lt;ll&gt;h1(m + 5), h2(m + 5), p(m + 5);\n    ll b = 131;\n    t = &quot; &quot; + t;\n    p[0] = 1;\n    for (int i = 1;i &lt;= m;i++) {\n        h1[i] = h1[i - 1] * b + t[i];\n        h2[i] = h2[i - 1] * b + t[m - i + 1];\n        p[i] = p[i - 1] * b;\n    }\n    for (int i = 1;i &lt;= m;i++) { // 判断长度为i的前后缀是否相同\n        ll hh1 = h1[m] - h1[m - i] * p[i];\n        ll hh2 = h2[i] - h2[0] * p[i];\n        if (hh1 == hh2)cnt++;\n    }\n \n    int len = r - l + 1;\n    if (len &lt; 0) {\n        ll ans = 0;\n        len = m - pos;\n        for (ll i = len;i &lt;= m;i++) {\n            ll hh1 = h1[m] - h1[m - i] * p[i];\n            ll hh2 = h2[i] - h2[0] * p[i];\n            if (hh1 == hh2)ans++;\n        }\n        cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;;\n        return;\n    }\n    string a = s.substr(l, len);\n    vector&lt;ll&gt;f(len + 5, 0), las(30, -1);\n    a = &quot; &quot; + a;\n    f[0] = 1;\n    for (ll i = 1;i &lt;= len;i++) {\n        int c = a[i] - &#039;a&#039;;\n        if (las[c] != -1)\n            f[i] = (2 * f[i - 1] % mo109 - f[las[c] - 1] + mo109) % mo109;\n        else\n            f[i] = 2 * f[i - 1] % mo109;\n        las[c] = i;\n    }\n    cout &lt;&lt; f[len] + cnt &lt;&lt; &quot;\\n&quot;;\n}\n \nint main() {\n    int _ = 1;\n    while (_--)\n        solve();\n \n    return 0;\n}\n "},"03-algorithm/nc24sd8":{"slug":"03-algorithm/nc24sd8","filePath":"03-algorithm/nc24sd8.md","title":"🫟2024牛客暑假多校训练营Day8||补题","links":[],"tags":["2024暑假集训","算法","牛客"],"content":"A-Haitang and Game\n题意\n给出一个数组，两人轮流，每次选择数组中的两个数，若这两个数的gcd不在当前的数组里，就将这两个数的gcd加入到数组中，不能再加数的一方输。\n数据范围\n\n1\\leq t\\leq 100\n1\\leq n\\leq 10^5\n1\\leq a_i\\leq 10^5\n\n思路\n整个数组的最终含有哪些数是确定的，枚举1\\sim a_{max}的每个数，记为x，查看数组中大于x的整数倍的数，若这些倍数的gcd恰好等于x，则x会出现在最终的数组中。\n代码\nvoid solve() {\n    int n;cin &gt;&gt; n;\n    vector&lt;int&gt;a(n);\n    vector&lt;bool&gt;vis(100005, false);\n    int mx = -1;\n    for (int i = 0;i &lt; n;i++) {\n        cin &gt;&gt; a[i];\n        vis[a[i]] = true;\n        if (mx != -1)mx = max(mx, a[i]);\n        else mx = a[i];\n    }\n    if (n == 1) {\n        cout &lt;&lt; &quot;Haitang\\n&quot;;return;\n    }\n    int ans = 0;\n    for (int i = 1;i &lt;= mx;i++) {\n        if (vis[i])continue;\n        vector&lt;int&gt;g;\n        for (int j = 2 * i;j &lt;= mx;j += i) {\n            if (vis[j])g.push_back(j);\n        }\n        if (g.size() &gt;= 2) {\n            int k = gcd(g[0], g[1]);\n            for (int j = 2;j &lt; g.size();j++) {\n                k = gcd(k, g[j]);\n            }\n            if (k == i) {\n                ans++;\n                vis[i] = true;\n            }\n        }\n    }\n    if (ans % 2) {\n        cout &lt;&lt; &quot;dXqwq\\n&quot;;\n    }\n    else {\n        cout &lt;&lt; &quot;Haitang\\n&quot;;\n    }\n}\nK-Haitang and Ava\n题意\n符合以下条件的字符串的合法的：\n\n空串是合法的。\n在合法串S的前面或后面加ava​形成的字符串是合法的。\n在合法串S的前面或后面加avava​形成的字符串是合法的。\n\n给你一个字符串，判断它是否合法。\n数据范围\n\n1\\leq T\\leq 1.7\\times 10^5\n3\\leq |S| \\leq 5\\times 10^5\n\n思路\n逐步删去前缀或后缀，若最后能删成空串，则为合法串。\n代码\nvoid solve() {\n    string s;cin &gt;&gt; s;\n    int l = 0, r = s.size() - 1;\n    while (l &lt;= r) {\n        string t;\n        if (r - l + 1 &gt;= 5) {\n            t = s.substr(l, 5);\n            if (t == &quot;avava&quot;) {\n                l += 5;continue;\n            }\n            t = s.substr(r - 4, 5);\n            if (t == &quot;avava&quot;) {\n                r -= 5;continue;\n            }\n        }\n        if (r - l + 1 &gt;= 3) {\n            t = s.substr(l, 3);\n            if (t == &quot;ava&quot;) {\n                l += 3;continue;\n            }\n            t = s.substr(r - 2, 3);\n            if (t == &quot;ava&quot;) {\n                r -= 3;continue;\n            }\n        }\n        break;\n    }\n    if (l &gt; r) {\n        cout &lt;&lt; &quot;Yes\\n&quot;;\n    }\n    else {\n        cout &lt;&lt; &quot;No\\n&quot;;\n    }\n}"},"03-algorithm/nc24wd1":{"slug":"03-algorithm/nc24wd1","filePath":"03-algorithm/nc24wd1.md","title":"🎉2024牛客寒假营1||补题","links":[],"tags":["2024寒假训练","算法","牛客"],"content":"A-DFS搜索\n题意\n给一个字符串，判断其中是否包含dfs子序列和DFS子序列。\n数据范围\nT(1≤T≤100)\nn(1≤n≤50)\n思路\n直接搜。\n参考代码\nvoid solve() {\n    int n;cin &gt;&gt; n;\n    string s;cin &gt;&gt; s;\n    int f1 = 1, f2 = 1;\n    int p = s.find(&#039;D&#039;);\n    if (p != -1) {\n        p = s.find(&#039;F&#039;, p);\n        if (p != -1) {\n            p = s.find(&#039;S&#039;, p);\n            if (p == -1) { f1 = 0; }\n        } else { f1 = 0; }\n    }\n    else { f1 = 0; }\n    p = s.find(&#039;d&#039;);\n    if (p != -1) {\n        p = s.find(&#039;f&#039;, p);\n        if (p != -1) {\n            p = s.find(&#039;s&#039;, p);\n            if (p == -1) { f2 = 0; }\n        } else { f2 = 0; }\n    }\n    else { f2 = 0; }\n    cout &lt;&lt; f1 &lt;&lt; &quot; &quot; &lt;&lt; f2 &lt;&lt; endl;\n}\nB-关鸡\n题意\n\n从点(1, 0)出发，在宽为22、长为2×10^9^+12×10^9^+1的管道中有一些不可跨越的坐标点，判断最少添加几个着火点，使得无法走到左右端点。\n数据范围\nT(1≤T≤1e4)\n0≤n≤1e5\nr,c(1≤r≤2,−1e9≤c≤1e9)\n思路\n分别堵住两端的管道即可，堵住有三种情况：\n   x\t\t  1 2 3\n 1 2 3  或者     x\n参考代码\nvoid solve() {\n    int n;cin &gt;&gt; n;\n    map&lt;pair&lt;ll, ll&gt;, bool&gt;fires;   // 记录是否有某个点\n    int fl = 2, fr = 2, fn = 0; // 空白，左2右2\n    for (int i = 0;i &lt; n;i++) {\n        ll r, c;cin &gt;&gt; r &gt;&gt; c;\n        fires[{c, r}] = true;\n        if ((c == -1 &amp;&amp; r == 1) || (c == 0 &amp;&amp; r == 2) || (c == 1 &amp;&amp; r == 1))fn++;   // 环绕\n        if (c &lt;= 0)fl = 1;\n        if (c &gt;= 0)fr = 1;\n    }\n    for (auto i = fires.begin(); i != fires.end();i++) {\n        auto pr = i-&gt;first;bool hs = i-&gt;second;\n        ll c = pr.first, r = pr.second;\n        for (int j = -1;j &lt; 2;j++) {\n            if (fires.find({ c + j, (3 - r) }) != fires.end()) {\n                if (c &lt; 0) { fl = 0; }  // 左边不用再加\n                if (c &gt; 0) { fr = 0; }  // 右边不用再加\n            }\n        }\n    }\n    int ans = 3 - fn;\n    cout &lt;&lt; min(ans, fl + fr) &lt;&lt; endl;\n}\nC-按闹分配\n题意\n有n个人要排队办理业务，每个人的不满意度Di按照办完本人业务后的那一刻一共花费了多少时间来算，办事人员合理安排排队顺序，使得总不满意度S_{min}=\\sum_{i=1}^{n}D_i最小，记为S_{min}。\n然后急急鸡带着需要花费tc时间的业务想插队，办事人员对其的容忍度M如果不小于急急鸡插队后的不满意度S_{c}与S_{min}的差值，则会允许急急鸡插队。\n有q组询问，每组询问给出容忍度M，求出在该容忍度下急急鸡最快能办完业务的时间。\n数据范围\nn,Q,t_c(1≤n,Q≤105,1≤t_c≤1e9)\nt_i(1≤t_i≤1e6)\nM(0≤M≤1e18)\n思路\n初始从小到大排，求每个客户的不满意度Di（做前缀和）\n参考代码\nvoid solve() {\n    ll n, q, tc;cin &gt;&gt; n &gt;&gt; q &gt;&gt; tc;\n    vector&lt;ll&gt;t(n+1);\n    for (int i = 0;i &lt; n;i++) {\n        cin &gt;&gt; t[i];\n    }\n    t[n] = 0;\n    sort(t.begin(), t.end());\n    ll tn = 0ll;\n    vector&lt;ll&gt;d(n+1);\n    for (int i = 0;i &lt;= n;i++) {\n        d[i] = tn + t[i];   // 第i个人的不满意度\n        tn += t[i]; // 时间线\n    }\n    while (q--) {\n        ll m;cin &gt;&gt; m;\n        ll l = 0, r = n;\n        while (l &lt; r) {\n            ll x = (l + r) &gt;&gt; 1;    // 插在x号客户前面\n            if ((n - x) * tc &lt;= m) {\n                // 可以\n                r = x;\n            }\n            else {\n                l = x + 1;\n            }\n        }\n        // 最早：插在l的前面\n        cout &lt;&lt; d[l] + tc &lt;&lt; endl;\n    }\n}\nD-本题又主要考察了贪心\n题意\n大骗子！\nn个人的比赛，还剩m局，每局的结果有：\n\n胜方加3分，败方不得分\n平局各加一分\n\n求一号选手最好的名次（并列的取并列的排名）\n数据范围\nT(1≤T≤100)\nn,m(2≤n≤10,1\\leq m\\leq 10)\n0\\leq a_i\\leq 100\nu_i,v_i,1\\leq u_i,v_i\\leq n,u_i≠v_i\n思路\n不会贪，数据范围小可以直接dfs暴力每种情况取最优，O(3^m)\n参考代码\nint dfs(vector&lt;int&gt;a, vector&lt;pair&lt;int, int&gt;&gt;tb, int now) {\n    if (now == tb.size()) {     // 最后一局\n        int rk = 1;\n        for (int i = 1;i &lt; a.size();i++) {\n            if (a[i] &gt; a[1])rk++;\n        }\n        return rk;\n    }\n    int ret = a.size() - 1;\n    int u = tb[now].first, v = tb[now].second;\n    // u赢\n    a[u] += 3;\n    ret = min(ret, dfs(a, tb, now + 1));\n    a[u] -= 3;\n    // v赢\n    a[v] += 3;\n    ret = min(ret, dfs(a, tb, now + 1));\n    a[v] -= 3;\n    // 平局\n    a[v] += 1;a[u] += 1;\n    ret = min(ret, dfs(a, tb, now + 1));\n    a[v] -= 1;a[u] -= 1;\n \n    return ret;\n}\nvoid solve() {\n    int n, m;cin &gt;&gt; n &gt;&gt; m;\n    vector&lt;int&gt;a(n + 1);\n    for (int i = 1;i &lt;= n;i++)cin &gt;&gt; a[i];\n    vector&lt;pair&lt;int, int&gt;&gt;tb;\n    for (int i = 0;i &lt; m;i++) {\n        int u, v;cin &gt;&gt; u &gt;&gt; v;\n        tb.push_back({ u,v });\n    }\n    int ans = dfs(a, tb, 0);\n    cout &lt;&lt; ans &lt;&lt; &#039;\\n&#039;;\n}\nF-鸡数题\n题意\n求有多少个长为m的数组a同时满足以下条件：\n\n对任意i，都有a_i&gt;0\n数组a严格递增\na_1|a_2|...|a_{m-1}|a_m=2^n-1（其中|为按位或操作）\n对任意i≠j有a_i\\&amp;a_j=0（其中&amp;为按位与操作）\n\n答案要对10^9+7取模\n数据范围\n1\\leq n,m\\leq 10^5\n思路\n条件3说明，在2进制下的2^n-1（也就是数(\\overbrace{11\\dots111}^n)_2）每一位1都至少在a_1~a_m中出现一次，数组a的大小为m，联合条件4说明每个数位上的1最多只能出现1次，所以问题转化为，将n个不同位置上1分配给m个数，且每个数至少有1个1。可知n\\geq m。\n也就是一个第二类斯特林数n\\brace m。\n递推式：\n{n\\brace k}={n-1\\brace k-1}+k{n-1\\brace k}\n边界是：{n\\brace m}=[n=0]。\n通项：\n{n\\brace m}=\\sum_{i=0}^m \\frac{(-1)^{m-i}\\times i^n}{i!\\times (m-i)!}\n参考代码\nvoid solve() {\n    ll n, m;cin &gt;&gt; n &gt;&gt; m;\n    if (n &lt; m) { cout &lt;&lt; &quot;0\\n&quot;; return; }\n    // 阶乘\n    vector&lt;ll&gt;fac;\n    fac.push_back(1);fac.push_back(1);\n    for (ll i = 2;i &lt;= n;i++) {\n        ll faci = (fac.back() * i) % mod;\n        fac.push_back(faci);\n    }\n    vector&lt;ll&gt;finv(n + 1); // 阶乘的逆元\n    finv[n] = powerMod(fac[n], mod - 2, mod);\n    for (int i = n - 1;i &gt;= 0;i--) {\n        finv[i] = finv[i + 1] * (i + 1) % mod;\n    }\n \n    ll ans = 0ll;\n    for (ll i = 0;i &lt;= m;i++) {\n        ll ansi = 1ll;\n        if ((m - i) &amp; 1)ansi = -1;\n \n        ansi *= powerMod(i, n, mod);\n        ansi *= finv[i] * finv[m - i] % mod;\n        ans = (ans + ansi) % mod + mod;     // 加一个mod取正数\n        ans %= mod;\n    }\n    cout &lt;&lt; ans &lt;&lt; &#039;\\n&#039;;\n}\nG-why买外卖\n题意\n一些可以叠加的满ai减bi的券，现在有m元，提问可以买到食物的原价最大值是多少。\n数据范围\nT(1≤T≤1e4)\nn,m(1≤n≤1e5,1≤m≤1e9)\na_i,b_i(1≤a_i,b_i≤1e9)\n思路\n前缀和，按照ai升序排列，能用ai的券的食物一定也能使用原价小于等于ai的所有的券，最后枚举原价即可。\n参考代码\nvoid solve() {\n    ll n, m;cin &gt;&gt; n &gt;&gt; m;\n    map&lt;ll, ll&gt;discnt;\n    for (int i = 0;i &lt; n;i++) {\n        ll a, b;cin &gt;&gt; a &gt;&gt; b;\n        discnt[a] += b;    // 一次前缀和，合并相同ai的券\n    }\n    for (auto i = discnt.begin(); i != discnt.end();i++) {\n        ll price = i-&gt;first, discount = i-&gt;second;\n        auto j = i;j++;\n        if (j != discnt.end()) {\n            (j-&gt;second) += discount;    // 第二次前缀和，合并小于等于ai的券\n        }\n    }\n    ll x = m;\n    for (auto i = discnt.begin();i != discnt.end();i++) {\n        ll price = i-&gt;first, discount = i-&gt;second;\n        if (m + discount &gt;= price)x = m + discount;    // 枚举，取最大原价\n    }\n    cout &lt;&lt; x &lt;&lt; endl;\n}\nI-It’s bertrand paradox. Again!\n题意\n有两种生成平面上的圆的方式，给已生成的数据判断是哪种方式生成的。\nbit-noob的方法：\n\n随机等概率地从开区间(−100,100)生成两个整数x,y。\n随机等概率地从闭区间[1,100]中生成一个r。\n判断(x,y)为圆心、r为半径的圆是否满足要求，若不满足，返回步骤2重新生成r，若满足，则将该圆加入到结果中。\n\nbuaa-noob的方法：\n\n随机等概率地从开区间(−100,100)生成两个整数x,y，随机等概率地从闭区间[1,100]中生成一个r。\n判断(x,y)为圆心、r为半径的圆是否满足要求，若不满足，返回步骤1重新生成x,y,r，若满足，则将该圆加入到结果中。\n\n数据范围\nn=10^5\n0&lt; x_i,y_i&lt; 100,0&lt; r_i\\leq100\n思路\n两种方法中，第一种的x和y的取值更容易受到r的限制，在r均匀分布在[1,100]的情况下，bit-noob的方法相对于buaa-noob的方法，x,y会更偏向集中在原点附近。\n参考代码\nvoid solve() {\n    int n;cin &gt;&gt; n;\n    int cnt = 0;\n    for (int i = 0;i &lt; n;i++) {\n        int x, y, r;cin &gt;&gt; x &gt;&gt; y &gt;&gt; r;\n        if (abs(x) &lt;= 50 &amp;&amp; abs(y) &lt;= 50)cnt++;\n    }\n    if (cnt &lt; n - cnt)cout &lt;&lt; &quot;bit-noob\\n&quot;;\n    else cout &lt;&lt; &quot;buaa-noob\\n&quot;;\n}\nH-01背包，但是bit\n题意\nn个物品，每个物品有价值v_i和重量w_i，所选物品的总重量是所选物品重量的按位或运算的结果，求总重量不超过m的最大价值和\n数据范围\nT(1≤T≤10^4)\nn,m(1≤n≤10^5,0\\leq m\\leq 10^8)\nv_i,w_i(0\\leq v_i,w_i\\leq 10^8)\n思路\n枚举m右移位后的数字，能被这个位数低于m、数位上全是1的新m覆盖的都能拿\n状态转换：拿新筛出来的可选与原来的比较，取价值较大的那个\n参考代码\nvoid solve() {\n    ll n, m;cin &gt;&gt; n &gt;&gt; m;\n    vector&lt;ll&gt;v(n), w(n);\n    ll ans = 0;\n    for (int i = 0;i &lt; n;i++) {\n        cin &gt;&gt; v[i] &gt;&gt; w[i];\n        if ((w[i] | m) == m)ans += v[i];\n    }\n \n    for (ll i = m;i &gt; 0;i -= i &amp; -i) {\n        // i每次抹去最后一位1，再重新取全1\n        ll xi = i - 1;\n        ll ansi = 0;\n        for (int j = 0;j &lt; n;j++) {\n            if ((w[j] | xi) == xi)\n                ansi += v[j];\n        }\n        ans = max(ans, ansi);\n    }\n \n    cout &lt;&lt; ans &lt;&lt; &#039;\\n&#039;;\n}\nL-要有光\n题意\n\n如图，有一点光源在轨迹L(x=c,y=0,0\\leq z\\leq d)上移动，存在一宽为2w，高为h的绿墙W，和一无限大的白墙S，求投影在地面上的阴影的面积。\n数据范围\n1\\leq T\\leq 10^4\n1\\leq c,d,h,w\\leq 10^4\n输出浮点数误差小于10^{-4}\n思路\n当点光源放在地面上时投影最大(z=0时)，这个投影是一个等腰梯形（大三角形截去一个小三角形）。\n参考代码\nvoid solve() {\n    double c, d, h, w;cin &gt;&gt; c &gt;&gt; d &gt;&gt; h &gt;&gt; w;\n    double ans = 3.0 * c * w;\n    cout &lt;&lt; ans &lt;&lt; endl;\n}\nM-牛客老粉才知道的秘密\n题意\n\n就像上图一样，当可见范围移动时固定位移为6格，当移动碰到末端时会以末端为最远到达处。给出比赛总题数，判断像这样移动可能的位置数目。\n数据范围\n1\\leq T\\leq 10^5\n6\\leq n\\leq 10^9\n思路\n判断n是否是6的倍数即可，如果正好是6的倍数，那么返回时并不产生新的位置。\n参考代码\nvoid solve() {\n    ll n;cin &gt;&gt; n;\n    if (n % 6)cout &lt;&lt; n / 6 + n / 6 &lt;&lt; &#039;\\n&#039;;\n    else cout &lt;&lt; n / 6 &lt;&lt; &#039;\\n&#039;;\n}"},"03-algorithm/nc24wd2":{"slug":"03-algorithm/nc24wd2","filePath":"03-algorithm/nc24wd2.md","title":"🎉2024牛客寒假营2||补题","links":[],"tags":["2024寒假训练","算法","牛客"],"content":"A-Tokitsukaze and Bracelet\n题意\n根据手环的三个属性值判断手环的等级。\n\n对攻击百分比来说，+0为100%，+1为150%，+2为200%\n对体力和精神来说，+0在\\{29,30,31,32\\}里选择，+1在\\{34,36,38,40\\}里选择，+2固定为45\n\n数据范围\nn(1≤n≤100)\na_i,b_i,c_i(a_i∈\\{100,150,200\\};b_i,ci∈\\{29,30,31,32,34,36,38,40,45\\})\n思路\n模拟即可\n参考代码\nvoid solve() {\n    int lv1[3] = { 100,150,200 };\n    int lv2[9] = { 29,30,31,32,34,36,38,40,45 };\n    int a, b, c;cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n    int ans = 0;\n    for (int i = 0;i &lt; 3;i++) {\n        if (a == lv1[i]) { ans += i; break; }\n    }\n    for (int i = 0;i &lt; 9;i++) {\n        if (b == lv2[i]) {\n            if (i &lt; 4)ans += 0;\n            else if (i &lt; 8)ans += 1;\n            else ans += 2;\n            break;\n        }\n    }\n    for (int i = 0;i &lt; 9;i++) {\n        if (c == lv2[i]) {\n            if (i &lt; 4)ans += 0;\n            else if (i &lt; 8)ans += 1;\n            else ans += 2;\n            break;\n        }\n    }\n    cout &lt;&lt; ans &lt;&lt; endl;\n}\nB-Tokitsukaze and Cats\n题意\n关猫，每个猫被限制在一个单元格内就算被关住了，如图：\n\n给猫的坐标，询问至少需要多少片防猫网能把他们全都关住。\n数据范围\nn, m, k (1≤n,m≤300;1≤k≤n⋅m)\nx_i, y_i (1≤xi≤n; 1≤yi≤m)\n思路\n遍历坐标点判断它上下左右是否有隔板，如果没有则补充。\n参考代码\nvoid solve() {\n    int n, m, k;cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;\n    map&lt;pair&lt;int, int&gt;, bool&gt;cats;\n    int ans = 0;\n    while (k--) {\n        int x, y;cin &gt;&gt; x &gt;&gt; y;\n        cats[{ x, y }] = true;\n        pair&lt;int, int&gt;pu = { x - 1,y }, pd = { x + 1,y }, pl = { x,y - 1 }, pr = { x,y + 1 };\n        int cnt = 4;\n        if (cats.count(pu) != 0)cnt -= 1;\n        if (cats.count(pd) != 0)cnt -= 1;\n        if (cats.count(pl) != 0)cnt -= 1;\n        if (cats.count(pr) != 0)cnt -= 1;\n        ans += cnt;\n    }\n    cout &lt;&lt; ans &lt;&lt; endl;\n}\nE&amp;F-Tokitsukaze and Eliminate\n题意\n有一排n个宝石，第i个的颜色是col_i，可以进行如下的操作：\n选一种颜色x，将颜色为x的最右边的那颗宝石及其右边的所有宝石全部消除。\n数据范围\nT(1\\leq T\\leq 2 * 10^5)\nn(1\\leq n\\leq 2 * 10^5)\neasy：1\\leq col_i\\leq min(n,2)\nhard：1\\leq col_i\\leq n\n思路\n贪心，从右边枚举，当找到最后一种达到两次出现的颜色后，进行一次对该颜色的操作，直到所有宝石都被消除。\n参考代码\nvoid solve() {\n    int n;cin &gt;&gt; n;\n    vector&lt;int&gt;col(n + 1);\n    set&lt;int&gt;cls;\n    for (int i = 1;i &lt;= n;i++) {\n        cin &gt;&gt; col[i];\n        cls.insert(col[i]);\n    }\n    int tn = cls.size();    // 颜色种数\n    map&lt;int, int&gt;clrs;\n    map&lt;int, int&gt;colors;\n    int ans = 0;\n    int cnt = 0;\n    int pi = n;\n    while (tn != 0) {\n        for (int i = n;i &gt; 0;i--) {\n            colors[col[i]]++;\n            if (colors[col[i]] == 1) {\n                cnt++;  // 达到两次及以上的颜色数\n                if (cnt == tn) {\n                    ans++;\n                    cnt = 0;\n                    colors = clrs;\n                    pi = i - 1;\n                }\n            }\n        }\n        tn = colors.size();\n        colors = clrs;\n        n = pi;cnt = 0;\n    }\n    cout &lt;&lt; ans &lt;&lt; endl;\n}\nI-Tokitsukaze and Short Path (plus)\n题意\n有一个n个顶点的完全图G，顶点编号是1到n，编号为i的顶点值是a_i，边权的计算方式如下：\nw_{u,v}=\n\\begin{cases}\n0&amp; \\text{u=v}\\\\\n|a_u+a_v|+|a_u-a_v|&amp; \\text{u ≠ v}\n\\end{cases}\ndist(i,j)定义为以i为起点到j的最短路。\n求：\n\\sum_{i=1}^{n}\\sum_{j=1}^{n}dist(i,j)\n数据范围\nT(1\\leq T\\leq 2\\times 10^5)\nn(1\\leq n\\leq 2\\times 10^5)\na_i(1\\leq a_i\\leq 2\\times 10^5)\n思路\n|a_i+a_j|+|a_i-a_j|=\n\\begin{cases}\n&amp;a_i+a_j+a_i-a_j&amp;=2\\times a_i&amp;\\quad a_i\\ge a_j \\\\\n&amp;a_i+a_j+a_j-a_i&amp;=2\\times a_j&amp;\\quad a_i\\lt a_j \n\\end{cases}\n对a进行排序，计算每个数对总和的贡献，也就是比某数小的数的个数。\n参考代码\nvoid solve() {\n    int n;cin &gt;&gt; n;\n    vector&lt;ll&gt;a(n);\n    for (int i = 0;i &lt; n;i++) {\n        cin &gt;&gt; a[i];\n    }\n    sort(a.begin(), a.end());\n    ll ans = 0;\n    for (int i = 0;i &lt; n;i++) {\n        ans += a[i] * i;\n    }\n    cout &lt;&lt; 4 * ans &lt;&lt; &#039;\\n&#039;;\n}\nJ-Tokitsukaze and Short Path (minus)\n题意\n有一个n个顶点的完全图G，顶点编号是1到n，编号为i的顶点值是a_i，边权的计算方式如下：\nw_{u,v}=\n\\begin{cases}\n0&amp; \\text{u=v}\\\\\n|a_u+a_v|-|a_u-a_v|&amp; \\text{u ≠ v}\n\\end{cases}\ndist(i,j)定义为以i为起点到j的最短路。\n求：\n\\sum_{i=1}^{n}\\sum_{j=1}^{n}dist(i,j)\n数据范围\nT(1\\leq T\\leq 2\\times 10^5)\nn(1\\leq n\\leq 2\\times 10^5)\na_i(1\\leq a_i\\leq 2\\times 10^5)\n思路\n|a_i+a_j|-|a_i-a_j|=\n\\begin{cases}\n&amp;a_i+a_j-a_i+a_j&amp;=2\\times a_j&amp;\\quad a_i\\ge a_j \\\\\n&amp;a_i+a_j-a_j+a_i&amp;=2\\times a_i&amp;\\quad a_i\\lt a_j \n\\end{cases}\n如果u到v的直接路径的长度大于dist(u,w)+dist(v,w)，则取后者，假设dist(u,v)=2\\times a_v，则有dist(u,w)+dist(v,w)=2\\times a_v+2\\times a_v=4\\times a_v，则只有当2\\times a_w的值小于a_v时取后者找到数组中的最小值。\n对a​进行排序，计算每个数对总和的贡献次数，也就是比某数或2×最小a_i大的数的个数。\n参考代码\nvoid solve() {\n    int n;cin &gt;&gt; n;\n    vector&lt;ll&gt;a(n);\n    ll mn = 1e18;\n    for (int i = 0;i &lt; n;i++) {\n        cin &gt;&gt; a[i];\n        mn = min(mn, a[i]);\n    }\n    sort(a.begin(), a.end());\n    ll ans = 0;\n    for (int i = 0;i &lt; n;i++) {\n        ans += min(mn * 2, a[i]) * (n - i - 1);\n    }\n    cout &lt;&lt; 4 * ans &lt;&lt; &#039;\\n&#039;;\n}"},"03-algorithm/nc24wd3":{"slug":"03-algorithm/nc24wd3","filePath":"03-algorithm/nc24wd3.md","title":"🎉2024牛客寒假营3||补题","links":[],"tags":["2024寒假训练","算法","牛客"],"content":"A-智乃与瞩目狸猫、幸运水母、月宫龙虾\n题意\n在不考虑单词词性的前提下，只要求两个单词的首字母忽略大小写相同时就认为它们可能是一组ubuntu代号，请你编写程序判断给定的两个单词是否可能是一个ubuntu代号。\n数据范围\nT(1\\leq T \\leq 10^5)\nS,T(1\\leq |S|,|T|\\leq 50)\n思路\n按题意判断即可\n参考代码\nvoid solve() {\n    string s, t;cin &gt;&gt; s &gt;&gt; t;\n    if (s[0] == t[0] || abs(s[0] - t[0]) == abs(&#039;a&#039; - &#039;A&#039;)) {\n        cout &lt;&lt; &quot;Yes\\n&quot;;\n    }\n    else cout &lt;&lt; &quot;No\\n&quot;;\n}\nB-智乃的数字手串\n题意\n一个首尾相连的数组，若相邻的两个数之和为偶数选择拿走一个然后可以随意交换一对数，轮流操作，不能再操作的一方输。清楚姐姐先手。\n数据范围\nT(1\\leq T \\leq 10^4)\nN(1\\leq N\\leq 26)\na_i(0\\leq a_i \\leq 10^9)\n思路\n只有1个数时直接取走，先手赢。\n2个数时：奇偶/奇奇/偶偶，都是后手赢。\n3个数时：奇偶奇/偶奇偶/奇奇奇/偶偶偶，都是先手赢。\n…\n结束时候的状态是奇偶奇偶...奇偶，如果数量是奇数个，一定存在奇奇/偶偶，操作后可能直接结束游戏或继续，如果数量是偶数个且可操作，则转移为奇数时的状态且此时下一位操作者一定可以再操作。双方的操作不会改变他面对该数字串时数字的个数的奇偶性。也就是说，只有一直面对奇数个数的一方才能赢。\n故判断原始长度，看先手是否在奇数位。\n参考代码\nvoid solve() {\n    int n;cin &gt;&gt; n;\n    vector&lt;ll&gt;a(n);\n    for (int i = 0;i &lt; n;i++) {\n        cin &gt;&gt; a[i];\n    }\n    if (n &amp; 1)cout &lt;&lt; &quot;qcjj\\n&quot;;\n    else cout &lt;&lt; &quot;zn\\n&quot;;\n}\nD-chino’s bubble sort and maximum subarray sum(easy version)\n题意\n对一个数组内的元素进行恰好K次相邻元素交换后，求整个数组的最大子段和。\n数据范围\nN,K(2\\leq N\\leq 10^3,0\\leq K \\leq 1)\na_i(-10^9\\leq a_i \\leq 10^9)\n思路\neasy版本的K只有两种取值（0和1），N的范围不大，分类处理，进行dp即可。\n参考代码\nll maxsum(vector&lt;ll&gt;a) {\n    int n = a.size();\n    ll sum = a[0];\n    ll b = 0;\n    for (int i = 0;i &lt; n;i++) {\n        if (b &gt; 0)b += a[i];\n        else b = a[i];\n        if (b &gt; sum)sum = b;\n    }\n    return sum;\n}\n \nvoid solve() {\n    int n, k;cin &gt;&gt; n &gt;&gt; k;\n    vector&lt;ll&gt;a(n);\n    for (int i = 0;i &lt; n;i++)cin &gt;&gt; a[i];\n    ll ans;\n    if (k == 0) {\n        ans = maxsum(a);\n    }\n    else {\n        for (int i = 0;i &lt; n - 1;i++) {\n            a[i] = a[i] ^ a[i + 1];\n            a[i + 1] = a[i] ^ a[i + 1];\n            a[i] = a[i] ^ a[i + 1];\n            if (i != 0) ans = max(ans, maxsum(a));\n            else ans = maxsum(a);\n            a[i] = a[i] ^ a[i + 1];\n            a[i + 1] = a[i] ^ a[i + 1];\n            a[i] = a[i] ^ a[i + 1];\n        }\n    }\n    cout &lt;&lt; ans &lt;&lt; endl;\n}\nG-智乃的比较函数(easy version)\n题意\n给出一些cmp函数的规定，判断他们之间是否存在逻辑矛盾。\ncmp的排序规则是这样的：\ncmp(x,y)=1表示规定x&gt;y，即x的顺序严格先于y\n数据范围\nT(1\\leq T\\leq 2\\times 10^4)\nN(1\\leq N\\leq 2)\nx,y,z(x,y\\in \\{1,2,3\\},z\\in\\{0,1\\})，表示第i个约束关系为cmp(a_x,a_y)=z。\n思路\n只有3个数、两个约束关系时，不能构成a_x&lt;a_y且a_y&lt;a_z且a_x&gt;a_z，只需判断最多存在2中约束关系时的逻辑是否合法。\n对于两个数x、y，不合法的约束关系只有：cmp(x,y)=1且cmp(y,x)=1\n参考代码\nvoid solve() {\n    int n;cin &gt;&gt; n;\n    vector&lt;vector&lt;int&gt;&gt;rules(4, vector&lt;int&gt;(4, -1));\n    bool f = true;\n    for (int i = 0;i &lt; n;i++) {\n        int x, y, z;cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;\n        if (!f)continue;\n        if (x == y &amp;&amp; z == 1)f = false;\n        if (z == 1 &amp;&amp; rules[y][x] == 1) {\n            f = false;\n        }\n        if (rules[x][y] == -1) {\n            rules[x][y] = z;\n            if (z == 1)\n                rules[y][x] = 0;\n        }\n        else if (rules[x][y] != z)\n            f = false;\n    }\n    if (f)cout &lt;&lt; &quot;Yes\\n&quot;;\n    else cout &lt;&lt; &quot;No\\n&quot;;\n}\nH-智乃的比较函数(normal version)\n题意\n同G\n数据范围\nT(1\\leq T\\leq 2\\times 10^4)\nN(1\\leq N\\leq 50)\nx,y,z(x,y\\in \\{1,2,3\\},z\\in\\{0,1\\})，表示第i个约束关系为cmp(a_x,a_y)=z。\n思路\n和G相比，N的范围大于2，不合法的情况增加了，但是依然只是3个数据之间判断合法性。\n新增的三个关系不合法的情况有：\n\nx&lt;y,x&lt;z,z&lt;x\nx\\leq y,y\\leq z,z&lt;x\n\n分别特判即可。\n参考代码\nvoid solve() {\n    int n;cin &gt;&gt; n;\n    vector&lt;vector&lt;int&gt;&gt;rules(4, vector&lt;int&gt;(4, -1));\n    bool f = true;\n    for (int i = 0;i &lt; n;i++) {\n        int x, y, z;cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;\n        if (!f)continue;\n        if (x == y &amp;&amp; z == 1)f = false;\n        if (z == 1 &amp;&amp; rules[y][x] == 1) {\n            f = false;\n        }\n        if (rules[x][y] == -1) {\n            rules[x][y] = z;\n            if (z == 1)\n                rules[y][x] = 0;\n        }\n        else if (rules[x][y] != z)\n            f = false;\n    }\n    if (rules[1][2] == 1 &amp;&amp; rules[2][3] == 1 &amp;&amp; rules[3][1] == 1)\n        f = false;\n    if (rules[1][3] == 1 &amp;&amp; rules[3][2] == 1 &amp;&amp; rules[2][1] == 1)\n        f = false;\n    for (int x = 1;x &lt;= 3;x++) {\n        for (int y = 1;y &lt;= 3;y++) {\n            if (y == x)continue;\n            int z = 6 - x - y;\n            if (rules[x][y] == 0 &amp;&amp; rules[y][z] == 0 &amp;&amp; rules[x][z] == 1)\n                f = false;\n        }\n    }\n    if (f)cout &lt;&lt; &quot;Yes\\n&quot;;\n    else cout &lt;&lt; &quot;No\\n&quot;;\n}\nL&amp;M-智乃的36倍数(easy/hard version)\n题意\n定义一种运算f，可以将正整数按照字面值从左到右拼接，如：f(123,569)=1234569。\n一个正整数数组，其中有多少对有序对i,j(i≠j)满足f(a_i,a_j)是36的倍数。\n数据范围\neasy:\nN(1\\leq N\\leq 1000)\na_i(1\\leq a_i \\leq 10)\nhard：\nN(1\\leq N\\leq 10^5)\na_i(1\\leq a_i \\leq 10^{18})\n思路\neasy版本的数据较小，直接双层循环暴力即可。\nhard版本可以考虑同余，k是y的位数。\nf(x,y)=x\\times 10^{k}+y\nf(x,y)\\% 36=0\n(x\\times 10^{k}+y)\\%36=0\n(x\\%36\\times 10^{k}\\%36+y\\%36)\\%36=0\n对数组预处理后，枚举以y结尾。\n参考代码\n// 暴力easy version\nvoid solve() {\n    int n;cin &gt;&gt; n;\n    vector&lt;int&gt;a(n);\n    for (int i = 0;i &lt; n;i++) {\n        cin &gt;&gt; a[i];\n    }\n    int cnt = 0;\n    for (int i = 0;i &lt; n;i++) {\n        for (int j = i + 1;j &lt; n;j++) {\n            int n1 = a[i] * 10 + a[j];\n            int n2 = a[j] * 10 + a[i];\n            if (n1 % 36 == 0)cnt++;\n            if (n2 % 36 == 0)cnt++;\n        }\n    }\n    cout &lt;&lt; cnt &lt;&lt; &#039;\\n&#039;;\n}\n// hard version\nvoid solve() {\n    int n;cin &gt;&gt; n;\n    vector&lt;ll&gt;a(n);\n    map&lt;int, int&gt;cnt;\n    for (int i = 0;i &lt; n;i++) {\n        cin &gt;&gt; a[i];\n        cnt[a[i] % 36]++;\n    }\n    ll k = 1;\n    vector&lt;int&gt;dk(19);\n    for (int i = 1;i &lt; 19;i++) {\n        k *= 10;\n        dk[i] = k % 36;\n    }\n    auto getlen = [](ll x) {\n        int i = 0;\n        while (x) {\n            i++;x /= 10;\n        }\n        return i;\n        };\n    ll ans = 0;\n    for (int i = 0;i &lt; n;i++) {\n        int x = a[i] % 36;\n        int z = getlen(a[i]);\n        for (int j = 0;j &lt; 36;j++) {\n            if ((j * dk[z] + x) % 36 == 0) {\n                ans += cnt[j];\n                if (j == x)ans -= 1;\n            }\n        }\n    }\n    cout &lt;&lt; ans &lt;&lt; &#039;\\n&#039;;\n}"},"03-algorithm/nc24wd4":{"slug":"03-algorithm/nc24wd4","filePath":"03-algorithm/nc24wd4.md","title":"🎉2024牛客寒假营4||补题","links":[],"tags":["2024寒假训练","算法","牛客"],"content":"A-柠檬可乐\n题意\n输入a,b,k，判断a\\ge k\\times b是否成立\n数据范围\na,b,k(1\\leq a,b,k\\leq 100)\n思路\n简单判断\n参考代码\nvoid solve() {\n    int a, b, k;cin &gt;&gt; a &gt;&gt; b &gt;&gt; k;\n    if (a &gt;= k * b)cout &lt;&lt; &quot;good\\n&quot;;\n    else cout &lt;&lt; &quot;bad\\n&quot;;\n}\nB-左右互博\n题意\n有n堆石子，每次选择某堆石子，选一个整数y(2\\leq y\\leq x)，将石子分为\\lfloor \\frac{x}{y} \\rfloor和x-\\lfloor \\frac{x}{y} \\rfloor，直到某人不能操作时结束，不能操作者输。\n数据范围\nn,a_i(1\\leq n,a_i \\leq 2\\times 10^5)\n思路\n相当于每次至少分出1个石子出来，计算将所有石头分出1颗一份的操作数，判断拿到最后一颗石子的是谁即可。\n参考代码\nvoid solve() {\n    ll n;cin &gt;&gt; n;\n    vector&lt;ll&gt;a(n);\n    ll sum = 0;\n    for (int i = 0;i &lt; n;i++){\n        cin &gt;&gt; a[i];\n        sum += a[i] - 1;\n    }\n    if (sum % 2) {\n        cout &lt;&lt; &quot;gui\\n&quot;;\n    }\n    else cout &lt;&lt; &quot;sweet\\n&quot;;\n}\nC-冬眠\n题意\n给一个n\\times m的字符矩阵，每天有q次行循环移动或列循环移动，共执行p次，最后询问第x行y​列是什么字符。\nop=1表示行循环移动\nop=2表示列循环移动\n数据范围\n1\\leq n,m,p,q\\leq 100\n思路\n记录循环移动顺序，然后将(x,y)的字符逆顺序模拟即可。\n参考代码\nvoid solve() {\n    int n, m, x, y;\n    cin &gt;&gt; n &gt;&gt; m &gt;&gt; x &gt;&gt; y;\n    x -= 1, y -= 1;\n    vector&lt;string&gt;rec(n);\n    for (int i = 0;i &lt; n;i++) {\n        cin &gt;&gt; rec[i];\n    }\n    int p, q;cin &gt;&gt; p &gt;&gt; q;\n    vector&lt;pair&lt;int, int&gt;&gt;opz;\n    for (int i = 0;i &lt; q;i++) {\n        int z, op;cin &gt;&gt; op &gt;&gt; z;\n        opz.push_back({ op,z });\n    }\n    for (int i = 0;i &lt; p;i++) {\n        for (int j = q - 1;j &gt;= 0;j--) {\n            int op = opz[j].first, z = opz[j].second;\n            if (op == 1 &amp;&amp; x == z - 1) {\n                y -= 1;\n                y = (y + m) % m;\n            }\n            else if (op == 2 &amp;&amp; y == z - 1) {\n                x -= 1;\n                x = (x + n) % n;\n            }\n            // cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; &#039;\\n&#039;;\n        }\n    }\n    cout &lt;&lt; rec[x][y] &lt;&lt; &#039;\\n&#039;;\n}\nD-守恒\n题意\n有一个长度为n的数组，每次操作可以对数组a中的两个元素其中一个加1，另一个减1，要求每次操作后各元素任然是正整数，求操作结束后整个数组的最大公约数有多少种不同的值？\n数据范围\n1\\leq n,a_i\\leq 2\\times 10^5\n思路\n特判n=1的时候（答案为1）\nn\\ge 2时，枚举最大公约数，计数合适的数的数量即可。\n参考代码\nvoid solve() {\n    ll n;cin &gt;&gt; n;\n    vector&lt;ll&gt;a(n);\n    ll sum = 0ll;\n    for (int i = 0;i &lt; n;i++) {\n        cin &gt;&gt; a[i];sum += a[i];\n    }\n    if (n == 1) {\n        cout &lt;&lt; 1 &lt;&lt; &#039;\\n&#039;;return;\n    }\n    \n    set&lt;ll&gt;res;\n    ll f = sum / n;\n    for (ll k = 1;k * k &lt;= sum;k++) {\n        if (sum % k == 0) {\n            ll x = sum / k;\n            if (x &gt;= n &amp;&amp; k &lt;= f) {\n                res.insert(k);\n            }\n            if (k * k != sum &amp;&amp; k &gt;= n &amp;&amp; sum / k &lt;= f) {\n                res.insert(sum / k);\n            }\n        }\n    }\n    cout &lt;&lt; res.size() &lt;&lt; &#039;\\n&#039;;\n}"},"03-algorithm/nc24wd5":{"slug":"03-algorithm/nc24wd5","filePath":"03-algorithm/nc24wd5.md","title":"🎉2024牛客寒假营5||补题","links":[],"tags":["2024寒假训练","算法","牛客"],"content":"A-mutsumi的质数合数\n题意\n一个由n个正整数组成的数组，求其中质数和合数共有几个。\n数据范围\nn(1\\leq n\\leq 100)\na_i(1\\leq a_i\\leq 100)\n思路\n1不是质数也不是合数。\n参考代码\nvoid solve() {\n    int n;cin &gt;&gt; n;\n    int ans = 0;\n    for (int i = 0;i &lt; n;i++) {\n        int x;cin &gt;&gt; x;\n        if (x&gt;1)ans++;\n    }\n    cout &lt;&lt; ans &lt;&lt; &#039;\\n&#039;;\n}\nC-anon的私货\n题意\n给一个数组中一些位置插入0，要求插入后任意不是全0子段的平均值大于等于1，询问最多插入多少个0\n数据范围\nn(1\\leq n\\leq 10^5)\na_i(1\\leq a_i\\leq 10^9)\n思路\n从第一位开始贪，统计在每一位前最多可以插入多少个0，考虑两数之间的0的数目不能大于这2位之间允许的最大值。\n参考代码\nvoid solve() {\n    int n;cin &gt;&gt; n;\n    vector&lt;ll&gt;a(n + 2);\n    vector&lt;ll&gt;b(n + 2);\n    for (int i = 1;i &lt;= n;i++) {\n        cin &gt;&gt; a[i];\n        b[i] = a[i] - 1;\n    }\n    b[0] = 1e9 + 50;\n    b[n + 1] = 1e9 + 50;\n    ll ans = 0;\n \n    for (int i = 0;i &lt;= n;i++) {\n        // for (int j = 0;j &lt;= n + 1;j++)cout &lt;&lt; b[j] &lt;&lt; &#039; &#039;;cout &lt;&lt; endl;\n        if (b[i] &gt;= b[i + 1]) {\n            ans += b[i + 1];\n            ll tmp = b[i + 1];\n            b[i + 1] = 0;\n            b[i] -= tmp;\n        }\n        else {\n            ans += b[i];\n            ll tmp = b[i];\n            b[i] = 0;\n            b[i + 1] -= tmp;\n        }\n    }\n \n    cout &lt;&lt; ans &lt;&lt; endl;\n}\nE-soyorin的数组操作（easy）\n题意\n有一个长为n的数组a\n操作：选择一个不超过n的偶数k，a_i=a_i+i(1\\leq i\\leq k)\n询问是否能在任意操作后使得数组非降序。\n数据范围\nT(1≤T≤10^6)\nn(1≤n≤10^5)\na_i(1\\leq a_i\\leq 10^{12})\n思路\n操作的效果是使得a_{i+1}-a{i}的值增大1，从后往前遍历，将靠后的部分先操作为非降序（操作的效果会影响到前段）\n参考代码\nvoid solve() {\n    int n;cin &gt;&gt; n;\n    vector&lt;ll&gt;a(n + 1);\n    for (int i = 1;i &lt;= n;i++) {\n        cin &gt;&gt; a[i];\n    }\n    if (n % 2 == 0 || n == 1) {\n        // 加個無窮次總能彌補不合適的地方\n        cout &lt;&lt; &quot;YES\\n&quot;;return;\n    }\n \n    // a(n-1)上限是a(n)，在這個上限下能不能把它變成需要的\n    ll d = 0;   // 操作次數(對應相鄰兩個數之間的差距減少d(越靠後增加的越多\n    for (int i = n - 1;i &gt;= 1;i--) {\n        if (a[i] &gt; a[i + 1] + d) {\n            cout &lt;&lt; &quot;NO\\n&quot;;return;\n        }\n        if (i % 2 == 0)\n            d += (a[i + 1] - a[i] + d) / i;\n    }\n    cout &lt;&lt; &quot;YES\\n&quot;;\n}\nG&amp;H-sakiko的排列构造（easy/hard）\n题意\n构造一个长为n的排列，使得排列中每个p_i+i(1\\leq i\\leq n)都是质数。\n输出符合要求的排列，若无解输出-1。\n数据范围\nn(1\\leq n\\leq 10^6)\n思路\n排列是1\\sim n的，下标也是1\\sim n的，从p_i=n开始给寻找匹配的下标(在可选范围内从小到大)，也就是寻找使得p_i+i是质数的最小i，即比p_i大的最小质数。如果该符合要求的质数可以被找到就缩小范围，直到所有的数都可以被确定。(从ac结果看似乎并不存在无法被构造出的排列耶)\n参考代码\nvoid solve() {\n    ll n;cin &gt;&gt; n;\n    if (n == 1) {\n        cout &lt;&lt; &quot;1\\n&quot;;\n        return;\n    }\n    else if (n == 2) {\n        cout &lt;&lt; &quot;2 1\\n&quot;;\n        return;\n    }\n \n    vector&lt;ll&gt;primes(n * 2 + 1);\n    vector&lt;bool&gt;isprime(n * 2 + 1, true);\n \n    isprime[0] = isprime[1] = false;\n    for (int i = 2;i &lt;= 2 * n;i++) {\n        if (isprime[i]) {\n            primes.push_back(i);\n            for (int j = i + i;j &lt;= 2 * n;j += i) {\n                isprime[j] = false;\n            }\n        }\n    }\n \n    ll x = n;\n    ll pos = n;\n    vector&lt;ll&gt;a(n + 1);\n    while (pos &gt;= 1) {\n        bool f = false;\n        for (int i = pos + 1;i &lt;= pos * 2;i++) {\n            if (isprime[i]) {\n                f = true;\n                x = i;break;\n            }\n        }\n        \n        // 从ac结果看似乎并不存在-1的情况(好神奇！)\n//         if (!f) {\n//             cout &lt;&lt; -1 &lt;&lt; &#039;\\n&#039;;return;\n//         }\n//         if (x &gt; pos * 2) {\n//             cout &lt;&lt; -1 &lt;&lt; &#039;\\n&#039;;return;\n//         }\n        \n        // ai+i=x\n        for (int i = pos;i &gt;= x - pos;i--) {\n            a[i] = x - i;\n        }\n        pos = x - pos - 1;\n    }\n    for (int i = 1;i &lt;= n;i++) {\n        cout &lt;&lt; a[i] &lt;&lt; &#039; &#039;;\n    }cout &lt;&lt; &#039;\\n&#039;;\n}\nI-rikki的最短路\n题意\n给出一位轴上的3个坐标，rikki需要把A带到T的坐标，初始rikki在原点，且只知道T的坐标，到达T之后可以知道A的坐标。\nrikki有一个范围为k的视野，在[u-k,u+k]视野内的A可以被发现。\n数据范围\nt,a(-10^9\\leq t,a\\leq 10^9),k(1\\leq k\\leq 10^9)\n思路\n签到模拟(怎么会有人签到交7发才过啊(小声))\n视野只有在出发点的时候看A有用，其他情况按规则来qwq\n参考代码\nvoid solve() {\n    ll t, a, k;cin &gt;&gt; t &gt;&gt; a &gt;&gt; k;\n    if (a &gt;= -k &amp;&amp; a &lt;= k) {\n        if (a * t &gt; 0) {\n            cout &lt;&lt; t &lt;&lt; &#039;\\n&#039;;return;\n        }\n        else {\n            cout &lt;&lt; abs(2 * a - t) &lt;&lt; &#039;\\n&#039;;return;\n        }\n    }\n    else if (a * t &gt; 0) {\n        if (abs(a) &lt; abs(t)) {\n            cout &lt;&lt; abs(t) &lt;&lt; &#039;\\n&#039;;return;\n        }\n        else {\n            cout &lt;&lt; abs(a) + abs(a - t) &lt;&lt; &#039;\\n&#039;;return;\n        }\n    }\n    else {\n        cout &lt;&lt; 3 * abs(t) + 2 * abs(a) &lt;&lt; &#039;\\n&#039;;return;\n    }\n}\nJ-rikki的数组陡峭值\n题意\n数组的陡峭值：数组相邻元素之差的绝对值之和。\n给出数组a中每个元素a_i的范围[l_i,r_i]，求最小的陡峭值。\n数据范围\nn(1\\leq n\\leq 10^5)\nl_i,r_i(1\\leq l_i,r_i\\leq 10^9)\n思路\n贪心，从前往后遍历，如果a_i和a_{i+1}的范围有重合，则直接将a_i和a_{i+1}的值取成同一个数，陡峭值不增加，更新a_{i+1}的范围为两数重合的范围。如果范围不重合，两数分别取靠近的两个端点，并将a_{i+1}的范围缩成1个点。\n参考代码\nvoid solve() {\n    int n;cin &gt;&gt; n;\n    vector&lt;ll&gt;l(n + 1), r(n + 1);\n    for (int i = 1;i &lt;= n;i++) {\n        cin &gt;&gt; l[i] &gt;&gt; r[i];\n    }\n    // 這題該不會能貪吧(破防\n    ll ans = 0;\n    for (int i = 1;i &lt; n;i++) {\n        ll x = max(l[i], l[i + 1]);\n        ll y = min(r[i], r[i + 1]);\n        if (x &lt;= y) {\n            // 貪貪貪\n            l[i + 1] = x;r[i + 1] = y;\n        }\n        else {\n            ans += abs(x - y);\n            if (r[i + 1] &lt; l[i])\n                l[i + 1] = r[i + 1];\n            else\n                r[i + 1] = l[i + 1];\n        }\n    }\n    cout &lt;&lt; ans &lt;&lt; endl;\n}\nK-soyorin的通知\n题意\nsoyorin要把消息传递给n个人，每个知道消息的可以将消息传递给其他人。\n第i个人可以花费a_i将消息通知给最多b_i个人，前提是第i个人已知消息，消息源通知一个人花费为p。求最小花费。\n数据范围\nn(1\\leq n\\leq 1000)\np(1\\leq p\\leq 10^6)\na_i,b_i(1\\leq a_i,b_i\\leq 10^6)\n思路\ndp，更新通知i个人的最小花费。每当第i个人知道消息时更新使得j人知道消息的花费。\n参考代码\nvoid solve() {\n    ll n, p;cin &gt;&gt; n &gt;&gt; p;\n    vector&lt;ll&gt;a(n + 1), b(n + 1);\n    for (int i = 1;i &lt;= n;i++) {\n        cin &gt;&gt; a[i] &gt;&gt; b[i];\n    }\n    // dp：通知i個人的最小花費j,dp[i]=j\n    vector&lt;ll&gt;dp(n + 1);\n    for (int i = 1;i &lt;= n;i++)\n        dp[i] = p * i;\n \n    for (int i = 1;i &lt;= n;i++) {\n        for (int j = 1;j &lt;= n;j++) {\n            // 第i個人已經被通知的情況下，通知j個人，花費a[i]\n            if (j - b[i] &gt; 0)\n                dp[j] = min(dp[j], dp[j - b[i]] + a[i]);\n            else\n                dp[j] = min(dp[j], dp[1] + a[i]);\n        }\n    }\n \n    cout &lt;&lt; dp[n] &lt;&lt; &#039;\\n&#039;;\n}\nL-anon的星星\n题意\n赢一局可以收到1颗星星，输一局失去1颗星星，没有平局。\n已知一共玩了n局，共获得了x颗星星，求胜利了几局失败了几局。\n如果无法知道胜利的局数和失败的局数输出-1。\n数据范围\nn(1\\leq n\\leq 1000)\nx(-n\\leq x\\leq n)\n思路\n赢k局就是失败n-k局，星星数是k-(n-k)。如果k有合法值就是合法的。\n参考代码\nvoid solve() {\n    ll n, x;cin &gt;&gt; n &gt;&gt; x;\n    if ((n + x) &amp; 1) {\n        cout &lt;&lt; -1 &lt;&lt; &#039;\\n&#039;;\n    }\n    else {\n        ll k = (n + x) / 2;\n        cout &lt;&lt; k &lt;&lt; &#039; &#039; &lt;&lt; n - k &lt;&lt; &#039;\\n&#039;;\n    }\n}\nM-mutsumi的排列连通\n题意\n有两个长度为n的排列上下组成2\\times n的矩形。\n有操作：选择数字x，将矩形中的x删去。\n询问至少多少次操作后，可以将矩形分成至少2个连通块（连通块不一定是矩形）。\n如果无法实现，输出-1。\n数据范围\nT(1\\leq T\\leq 10^5)\nn(1\\leq n\\leq 10^5)\n排列a(1\\leq a_i\\leq n)\n排列b(1\\leq b_i\\leq n)\nn总和不超过10_5\n思路\n特判n=1,2。\nn\\ge 3的最多删2个即可实现需求。\n遍历寻找是否存在a_i=b_i或者a_i=b_{i+1}或者a_i=b_{i-1}的情况，注意边界判断。\n参考代码\nvoid solve() {\n    int n;cin &gt;&gt; n;\n    vector&lt;ll&gt;a(n + 1), b(n + 1);\n    for (int i = 1;i &lt;= n;i++) {\n        cin &gt;&gt; a[i];\n    }\n    for (int i = 1;i &lt;= n;i++) {\n        cin &gt;&gt; b[i];\n    }\n    if (n == 1) {\n        cout &lt;&lt; &quot;-1\\n&quot;;return;\n    }\n    if (n == 2) {\n        if (a[1] == b[1]) {\n            cout &lt;&lt; &quot;-1\\n&quot;;\n        }\n        else {\n            cout &lt;&lt; &quot;1\\n&quot;;\n        }\n        return;\n    }\n    for (int i = 1;i &lt;= n;i++) {\n        if ((i != 1 &amp;&amp; i != n &amp;&amp; a[i] == b[i]) || (i &gt; 1 &amp;&amp; a[i] == b[i - 1]) || (i &lt; n &amp;&amp; a[i] == b[i + 1])) {\n            cout &lt;&lt; &quot;1\\n&quot;;return;\n        }\n    }\n    cout &lt;&lt; &quot;2\\n&quot;;return;\n \n}"},"03-algorithm/nc24wd6":{"slug":"03-algorithm/nc24wd6","filePath":"03-algorithm/nc24wd6.md","title":"🎉2024牛客寒假营6||补题","links":[],"tags":["2024寒假训练","算法","牛客"],"content":"A-宇宙的终结\n题意\n在[l,r]中寻找某个恰好是三个不同素数的乘积的数，并输出任意一个合法答案即可。\n数据范围\n1\\leq l\\leq r \\leq 100\n思路\n数据小，模拟即可\n参考代码\nvoid solve() {\n    vector&lt;bool&gt;isprime(101, true);    // 判断素数\n    isprime[0] = isprime[1] = false;\n    for (int i = 2;i &lt;= 100;i++) {\n        if (isprime[i]) {\n            for (int j = i + i;j &lt;= 100;j += i) {\n                isprime[j] = false;\n            }\n        }\n    }\n \n    int l, r;\n    cin &gt;&gt; l &gt;&gt; r;\n    for (int i = 2;i &lt;= r;i++) {\n        for (int j = 2;j &lt;= r;j++) {\n            for (int k = 2;k &lt;= r;k++) {\n                if (isprime[i] &amp;&amp; isprime[j] &amp;&amp; isprime[k] &amp;&amp; i != j &amp;&amp; j != k &amp;&amp; i != k) {\n                    if (i * j * k &gt;= l &amp;&amp; i * j * k &lt;= r) {\n                        cout &lt;&lt; i * j * k;return;\n                    }\n                }\n            }\n        }\n    }\n    cout &lt;&lt; -1;\n}\nB-爱恨的纠葛\n题意\n定义两个等长数组的亲密值：|a_i-b_i|(1\\leq i\\leq n)的最小值。给定2个数组，可以任意排列a数组的元素顺序，输出一个亲密度最小的方案（数组a的操作结果）。\n数据范围\n1\\leq n\\leq 10^5\n1\\leq a,b \\leq 10^9\n思路\n将a,b数组的数据放入 一个数组中，进行排序，从第一位开始遍历，如果某两个相邻的数一个来自于a数组，一个来自于b数组，更新最小的差的绝对值，将a数组中的这两个相匹配的位置进行互换后输出a\n参考代码\nvoid solve() {\n    int n;cin &gt;&gt; n;\n    vector&lt;ll&gt;a(n), b(n);\n    vector&lt;pair&lt;ll, pair&lt;int,int&gt;&gt;&gt;c;\n    for (int i = 0;i &lt; n;i++) {\n        cin &gt;&gt; a[i];\n        c.push_back({ a[i],{0,i} });\n    }\n    for (int i = 0;i &lt; n;i++) {\n        cin &gt;&gt; b[i];\n        c.push_back({ b[i],{1,i} });\n    }\n    sort(c.begin(), c.end());\n    ll ans = 1e9 + 20;\n    int pa = 0, pb = 0;\n    for (int i = 1;i &lt; 2 * n;i++) {\n        if (c[i].second.first != c[i - 1].second.first) {\n            if (c[i].first - c[i - 1].first &lt; ans) {\n                ans = c[i].first - c[i - 1].first;\n                if(c[i].second.first == 0) {\n                    pa = c[i].second.second;\n                    pb = c[i - 1].second.second;\n                } else {\n                    pa = c[i - 1].second.second;\n                    pb = c[i].second.second;\n                }\n            }\n        }\n    }\n    ll tp = a[pa];a[pa] = a[pb];a[pb] = tp;\n    for (int i = 0;i &lt; n;i++) {\n        cout &lt;&lt; a[i] &lt;&lt; &#039; &#039;;\n    }\n}\nC-心绪的解剖\n题意\n将n分解为三个斐波那契数列之和。\n数据范围\n1\\leq q \\leq 10^5\n1\\leq n\\leq 10^9\n思路\n斐波那契数列到F_{45}是大于10^{10}的，联系到斐波那契数列的单调性，每次二分出不大于n的一位F_x，再在n中减去这个F_x直到n为0，如果三次二分后无法使得n=0则无解。\n参考代码\nvoid solve() {\n    ll q;cin &gt;&gt; q;\n    vector&lt;ll&gt;f(45, 0);\n    f[0] = 0;f[1] = 1;\n    for (int i = 2;i &lt; 45;i++) {\n        f[i] = f[i - 1] + f[i - 2];\n    }\n    \n    while (q--) {\n        ll n;cin &gt;&gt; n;\n        int p1 = upper_bound(f.begin(), f.end(), n) - f.begin();\n        p1--;\n        n -= f[p1];\n        ll f1 = f[p1];\n        if (n == 0) {\n            cout &lt;&lt; f1 &lt;&lt; &quot; 0 0\\n&quot;;continue;\n        }\n        int p2 = upper_bound(f.begin(), f.end(), n) - f.begin();\n        p2--;\n        n -= f[p2];\n        ll f2 = f[p2];\n        if (n == 0) {\n            cout &lt;&lt; f1 &lt;&lt; &#039; &#039; &lt;&lt; f2 &lt;&lt; &quot; 0\\n&quot;;continue;\n        }\n        int p3 = upper_bound(f.begin(), f.end(), n) - f.begin();\n        p3--;\n        n -= f[p3];\n        ll f3 = f[p3];\n        if (n == 0)\n            cout &lt;&lt; f1 &lt;&lt; &#039; &#039; &lt;&lt; f2 &lt;&lt; &#039; &#039; &lt;&lt; f3 &lt;&lt; &#039;\\n&#039;;\n        else\n            cout &lt;&lt; &quot;-1\\n&quot;;\n    }\n}\nD-友谊的套路\n题意\n一场BO5的游戏（五局三胜），已知某队伍获胜的概率是p，询问出现二追三的概率是多少？（二追三：先输两局，然后赢三局）\n数据范围\n0\\lt p\\lt 1\n思路\n赢赢输输输or输输赢赢赢\n参考代码\nvoid solve() {\n    double p;cin &gt;&gt; p;\n    double ans = 0.0;\n    double q = 1 - p;\n    ans += p * p * q * q * q + q * q * p * p * p;\n    printf(&quot;%.6f&quot;, ans);\n}\nE-未来的预言\n题意\nBO机制：BOx代表x局先胜x/2+1次为赢，x为奇数。\n给出一个字符串，表示两队的获胜情况。R代表红队获胜，P代表紫队获胜。\n判断哪队获得了胜利，或是还没有决出结果，以及结束时的局数。\n数据范围\n1\\leq x\\leq 10^5\n思路\n遍历统计，先赢到x/2次的获胜。\n参考代码\nvoid solve() {\n    int n;\n    scanf(&quot;BO%d&quot;, &amp;n);\n    n = n / 2 + 1;\n    string res;cin &gt;&gt; res;\n    int a = 0, b = 0;\n    for (int i = 0;i &lt; res.size();i++) {\n        if (res[i] == &#039;R&#039;) {\n            a++;\n        }\n        else {\n            b++;\n        }\n        if (a == n) {\n            cout &lt;&lt; &quot;kou!\\n&quot; &lt;&lt; i + 1;\n            return;\n        }\n        if (b == n) {\n            cout &lt;&lt; &quot;yukari!\\n&quot; &lt;&lt; i + 1;\n            return;\n        }\n    }\n    cout &lt;&lt; &quot;to be continued.\\n&quot;;\n    cout &lt;&lt; res.size();\n}\nI-时空的交织\n题意\n一个n行m列的矩阵，每个元素由a数组和b数组决定，第i行第j列的元素为a_i\\times b_j，选出一个子矩阵，使得子矩阵内的元素和尽可能大，输出该子矩阵的元素和。\n数据范围\n1\\leq n,m\\leq 10^5\n-10^4 \\leq a_i,b_i\\leq 10^4\n思路\n对a\\text{、} b数组分别求最大子段和和最小子段和，最大子矩阵元素和是这四个数分别相乘的积中最大的一个。\n参考代码\nvoid solve() {\n    ll n, m;cin &gt;&gt; n &gt;&gt; m;\n    vector&lt;ll&gt;a(n), b(m);\n    for (int i = 0;i &lt; n;i++)cin &gt;&gt; a[i];\n    for (int i = 0;i &lt; m;i++)cin &gt;&gt; b[i];\n    vector&lt;ll&gt;pa(n), qa(n);\n    pa[0] = qa[0] = a[0];\n    ll xa, ya;xa = ya = a[0];\n    for (int i = 1;i &lt; n;i++) {\n        if(pa[i-1]+a[i]&gt;a[i]){\n            pa[i] = pa[i - 1] + a[i];\n        }\n        else{\n            pa[i] = a[i];\n        }\n        xa = max(xa, pa[i]);\n        \n        if (qa[i - 1] + a[i] &lt; a[i]) {\n            qa[i] = qa[i - 1] + a[i];\n        }\n        else{\n            qa[i] = a[i];\n        }\n        ya = min(ya, qa[i]);\n    }\n    vector&lt;ll&gt;pb(m), qb(m);\n    pb[0] = qb[0] = b[0];\n    ll xb, yb;xb = yb = b[0];\n    for (int i = 1;i &lt; m;i++) {\n        if(pb[i-1]+b[i]&gt;b[i]){\n            pb[i] = pb[i - 1] + b[i];\n        }\n        else{\n            pb[i] = b[i];\n        }\n        xb = max(xb, pb[i]);\n        if(qb[i-1]+b[i]&lt;b[i]){\n            qb[i] = qb[i - 1] + b[i];\n        }\n        else{\n            qb[i] = b[i];\n        }\n        yb = min(yb, qb[i]);\n    }\n    \n    cout &lt;&lt; max(xa * xb, max(xa * yb, max(ya * yb, ya * xb))) &lt;&lt; endl;\n}"},"03-algorithm/nc25wd1":{"slug":"03-algorithm/nc25wd1","filePath":"03-algorithm/nc25wd1.md","title":"🎈2025牛客暑寒假多校训练营Day1（完結）","links":[],"tags":["2025寒假训练","算法","牛客"],"content":"A 茕茕孑立之影\n题意\n找一个不超过1e18的数x，使得x既不是任何a_i的倍数，也不是任何a_i的因数。若没有输出-1。\n数据范围\n\n1\\leq n\\leq 1e5\n1\\leq a_i\\leq 1e9\n\n思路\n观察到，如果数组中有1则不存在这样的数。\n1\\leq a_i\\leq 1e9，而1\\leq x\\leq 1e18，有解时任意数=输出一个大于1e9的质数即可。\n代码\nvoid solve() {\n  ll n;\n  cin &gt;&gt; n;\n  for (ll i = 1; i &lt;= n; i++) {\n    cin &gt;&gt; a[i];\n  }\n  sort(a + 1, a + 1 + n);\n  if (a[1] == 1) {\n    cout &lt;&lt; &quot;-1\\n&quot;;\n  } else {\n    cout &lt;&lt; &quot;100000007\\n&quot;;\n  }\n}\nB 一气贯通之刃\n题意\n给一棵树，寻找一条简单路径，使之遍历树上所有的顶点，输出起点和终点。如果没有这样的解则输出-1。\n简单路径是指这样一条路径，其经过的顶点和边互不相同。\n数据范围\n\n2\\leq n\\leq 1e5\n1\\leq u_i,v_i\\leq n,u_i\\neq v_i\n\n思路\n只有整个树是一条链时，从一个叶子节点到另一个叶子节点，才能有符合要求的简单路径。\n代码\nll deg[maxn];\nvoid solve() {\n  ll n;\n  cin &gt;&gt; n;\n  for (ll i = 1; i &lt;= n - 1; i++) {\n    ll u, v;\n    cin &gt;&gt; u &gt;&gt; v;\n    deg[u]++, deg[v]++;\n  }\n  vector&lt;ll&gt; v;\n  for (ll i = 1; i &lt;= n; i++) {\n    if (deg[i] == 1) {\n      v.push_back(i);\n    }\n  }\n  if (v.size() != 2) {\n    cout &lt;&lt; &quot;-1\\n&quot;;\n  } else {\n    cout &lt;&lt; v[0] &lt;&lt; &#039; &#039; &lt;&lt; v[1] &lt;&lt; &#039;\\n&#039;;\n  }\n}\nC 兢兢业业之移\n题意\n有一个n\\times n的 01 矩阵，n是偶数，其中有刚好\\frac{n^2}{4}个1，请将这些 1 全部移动到矩阵左上角的位置，即1\\leq i\\leq \\frac{n}{2},q\\leq j\\leq \\frac{n}{2}的位置，规定移动只能与共边的方格交换，交换次数不超过\\frac{n^3}{2}。\n数据范围\n\n2\\leq n\\leq 100\n\n思路\n考虑一条移动路径将 1 移动到左上角某个 0 的位置，如果这个路径上有其他的 1，显然移动路径中间的 1 到同样的目标 0 位置的次数是更小的。\n从左上角坐标点进行 bfs，最先碰到的 1 是最近的，还原 bfs 的路径。还原 bfs 的路径可以通过存储 bfs 时拓展的父节点来回溯获得。\n或者考虑寻找最短路时，路径只可能是直线或者直角线，假设路径需要“拐弯”才能到达某个 1，那这个“拐弯”的地方肯定是 1。这样的路径的长度正好是曼哈顿距离，n比较小，可以遍历所有的 1 来选择举例要填的 0 最近的点。还原路径的时候按照先纵向再横向或者先横向再纵向都可以。\n代码 1：曼哈顿距离\nll n;\nmap&lt;pll, bool&gt; vis;\nvector&lt;pii&gt; dxy = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\nvector&lt;array&lt;ll, 4&gt;&gt; ans;\nvoid solve() {\n  cin &gt;&gt; n;\n  ans.clear(), vis.clear();\n  vector&lt;pll&gt; v;\n  for (ll i = 1; i &lt;= n; i++) {\n    for (ll j = 1; j &lt;= n; j++) {\n      char c;\n      cin &gt;&gt; c;\n      if (c == &#039;1&#039;) {\n        v.push_back({i, j});\n      }\n    }\n  }\n \n  auto dis = [&amp;](pll p1, pll p2) {\n    return abs(p1.first - p2.first) + abs(p1.second - p2.second);\n  };\n  for (ll i = 1; i &lt;= n / 2; i++) {\n    for (ll j = 1; j &lt;= n / 2; j++) {\n      pll pi = {i, j};\n      pll p = {10000, 10000};\n      for (auto pj : v) {\n        if (!vis.count(pj) &amp;&amp; dis(pi, pj) &lt; dis(pi, p)) {\n          p = pj;\n        }\n      }\n      vis[p] = true;\n      auto [x, y] = p;\n      while (x &gt; i) {\n        ans.push_back({x, y, x - 1, y}), x -= 1;\n      }\n      while (x &lt; i) {\n        ans.push_back({x, y, x + 1, y}), x += 1;\n      }\n      while (y &gt; j) {\n        ans.push_back({x, y, x, y - 1}), y -= 1;\n      }\n      while (y &lt; j) {\n        ans.push_back({x, y, x, y + 1}), y += 1;\n      }\n    }\n  }\n \n  cout &lt;&lt; ans.size() &lt;&lt; &#039;\\n&#039;;\n  for (auto [q, w, e, r] : ans) {\n    cout &lt;&lt; q &lt;&lt; &#039; &#039; &lt;&lt; w &lt;&lt; &#039; &#039; &lt;&lt; e &lt;&lt; &#039; &#039; &lt;&lt; r &lt;&lt; &#039;\\n&#039;;\n  }\n}\n代码 2：宽搜\nll n;\nchar maz[250][250];\nvector&lt;pii&gt; dxy = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n \nbool vis[250][250], inq[250][250];\nvector&lt;array&lt;ll, 4&gt;&gt; ans;\n \npii trace[250][250];\n \nvoid solve() {\n  cin &gt;&gt; n;\n  ans.clear();\n  vector&lt;pii&gt; v;\n  for (int i = 1; i &lt;= n; i++) {\n    for (int j = 1; j &lt;= n; j++) {\n      cin &gt;&gt; maz[i][j];\n      vis[i][j] = false;\n    }\n  }\n  // bfs\n  for (ll i = 1; i &lt;= n / 2; i++) {\n    for (ll j = 1; j &lt;= n / 2; j++) {\n \n      for (ll ii = 1; ii &lt;= n; ii++) {\n        for (ll jj = 1; jj &lt;= n; jj++) {\n          inq[ii][jj] = false;\n        }\n      }\n \n      bool flag = false;\n      pii o = {i, j};\n      trace[i][j] = {i, j};\n \n      queue&lt;pii&gt; q;\n      q.push({i, j});\n      inq[i][j] = true;\n      while (!q.empty()) {\n        pii pi = q.front();\n        q.pop();\n        if (maz[pi.first][pi.second] == &#039;1&#039;) {\n          o = pi;\n          flag = true;\n          break;\n        }\n        if (maz[pi.first][pi.second] == &#039;1&#039;)\n          break;\n        for (auto [dx, dy] : dxy) {\n          int px = pi.first + dx, py = pi.second + dy;\n          if (px &lt; 1 || px &gt; n || py &lt; 1 || py &gt; n)\n            continue;\n          if (vis[px][py] || inq[px][py])\n            continue;\n \n          trace[px][py] = pi;\n          if (maz[px][py] == &#039;1&#039;) {\n            o = {px, py};\n            flag = true;\n            break;\n          }\n          inq[px][py] = true;\n          q.push({px, py});\n        }\n        if (flag)\n          break;\n      }\n      // 必然有解的\n      maz[o.first][o.second] = &#039;0&#039;;\n      // 路径还原\n      while (o.first != i || o.second != j) {\n        pii i = trace[o.first][o.second];\n        ans.push_back({o.first, o.second, i.first, i.second});\n        o = i;\n      }\n      maz[o.first][o.second] = &#039;1&#039;;\n      vis[i][j] = true;\n    }\n  }\n \n  cout &lt;&lt; ans.size() &lt;&lt; &#039;\\n&#039;;\n  for (auto [q, w, e, r] : ans) {\n    cout &lt;&lt; q &lt;&lt; &#039; &#039; &lt;&lt; w &lt;&lt; &#039; &#039; &lt;&lt; e &lt;&lt; &#039; &#039; &lt;&lt; r &lt;&lt; &#039;\\n&#039;;\n  }\n}\nD 双生双宿之决\n题意\n双生数组定义：数组大小为偶数，有且只有 2 种数，这两种数的数量相同。\n判断一个数组是不是双生数组。\n数据范围\n\n1\\leq n\\leq 1e5\n1\\leq a_i\\leq 1e9\n\n思路\n按性质判断即可。\n代码\nvoid solve() {\n  ll n;\n  cin &gt;&gt; n;\n  map&lt;ll, ll&gt; mp;\n  for (ll i = 1; i &lt;= n; i++) {\n    cin &gt;&gt; a[i];\n    mp[a[i]]++;\n  }\n  if (mp.size() != 2) {\n    cout &lt;&lt; &quot;No\\n&quot;;\n    return;\n  }\n  vector&lt;pll&gt; v(mp.begin(), mp.end());\n  if (v[0].second == v[1].second) {\n    cout &lt;&lt; &quot;Yes\\n&quot;;\n  } else {\n    cout &lt;&lt; &quot;No\\n&quot;;\n  }\n}\nE 双生双宿之错\n题意\n将一个数组变成双生数组，可以进行的操作是将某个数+1 或-1，求最小操作次数。\n数据范围\n\n1\\leq n\\leq 1e5\n1\\leq a_i\\leq 1e9\n\n思路\n首先想到，将数组分为小的一半和大的一半，这两半各找一个数作为双生数组中的标准数。\n这个数是中位数：\n考虑当前的中位数是x，代表有至少一半的数小于等于x，也有至少一半的数大于等于x，如果将x变成x+1，假设原来的花费是y，有c的数小于等于x。那么现在的花费是y&#039; = y+c-(n-c)，由于c\\ge n/2，故y&#039;\\gt y，x-1的情况也是同理。\n特别的，当两边的中位数是同一个数的时候，需要对某一边进行+1 或-1，取 min。\n代码\nvoid solve() {\n  ll n;\n  cin &gt;&gt; n;\n  for (ll i = 1; i &lt;= n; i++) {\n    cin &gt;&gt; a[i];\n  }\n  sort(a + 1, a + 1 + n);\n  auto check = [&amp;](ll x, ll l, ll r) {\n    ll tot = 0;\n    for (ll i = l; i &lt;= r; i++) {\n      tot += abs(x - a[i]);\n    }\n    return tot;\n  };\n  // 左右两半各找一个中位数\n  ll x = a[(1 + n / 2) / 2];\n  ll y = a[(n / 2 + 1 + n) / 2];\n  ll ansx = check(x, 1, n / 2), ansy = check(y, n / 2 + 1, n);\n  ll ans = ansx + ansy;\n  if (x == y) {\n    ans = inf;\n    ans = min(ans, check(x + 1, 1, n / 2) + ansy);\n    ans = min(ans, ansx + check(y + 1, n / 2 + 1, n));\n    ans = min(ans, check(x - 1, 1, n / 2) + ansy);\n    ans = min(ans, ansx + check(y - 1, n / 2 + 1, n));\n  }\n  cout &lt;&lt; ans &lt;&lt; &#039;\\n&#039;;\n}\nF 双生双宿之探\n题意\n计算一个数组中有多少连续子数组是双生数组。\n数据范围\n\n1\\leq n\\leq 1e5\n1\\leq a_i\\leq 1e9\n\n思路\n根据双生数组的特点，选出所有仅包含两种数的区间，在这个确定的最大的仅包含两种数的区间内计算区间中有多少个双生数组，由于仅包含两种数，可以将某种数记为 1，另一种记为-1，计算该段区间的前缀和，前缀和相同的两个端点之间的区间是双生数组。\n代码\nvoid solve() {\n  ll n;\n  cin &gt;&gt; n;\n  for (ll i = 1; i &lt;= n; i++) {\n    cin &gt;&gt; a[i];\n  }\n  ll ans = 0;\n  ll l = 1, r = 1;\n  set&lt;ll&gt; st;\n  st.insert(a[l]);\n  while (r &lt;= n) {\n    // 仅包含两种元素的最远的r\n    while (r + 1 &lt;= n &amp;&amp; (st.size() &lt; 2 || st.find(a[r + 1]) != st.end())) {\n      st.insert(a[++r]);\n    }\n    if (st.size() == 2) {\n      // 计算区间内区间和是0的数量\n      ll x1 = *st.begin();\n      pre[l - 1] = 0;\n      map&lt;ll, ll&gt; mp;\n      mp[0]++;\n      for (ll i = l; i &lt;= r; i++) {\n        if (a[i] == x1)\n          pre[i] = pre[i - 1] + 1;\n        else\n          pre[i] = pre[i - 1] - 1;\n        mp[pre[i]]++;\n      }\n      for (auto i : mp) {\n        ans += (i.second - 1) * i.second / 2;\n      }\n    } else {\n      break;\n    }\n    // 去掉一种数\n    while (l - 1 &lt;= r) {\n      if (pre[r] - pre[l - 1] == r - l + 1 ||\n          pre[l - 1] - pre[r] == r - l + 1) {\n        break;\n      }\n      l++;\n    }\n    st.clear();\n    st.insert(a[l]);\n  }\n  cout &lt;&lt; ans &lt;&lt; &#039;\\n&#039;;\n}\nG 井然有序之衡\n题意\n将数组变成一个排列，可以进行的操作是将某个数+1，同时将另一个数-1，询问最小操作次数，若不能实现则输出-1。\n数据范围\n\n1\\leq n\\leq 1e5\n-1e9\\leq a_i\\leq 1e9\n\n思路\n排列中的数是 1~n，如果进行操作，一定是将大数减去的 1 加到小数上，让两个数都趋向要变成的数。从 n 开始枚举到 1，如果当前的排列数i在数组中不存在，则选一个大于i的数，将它减去的数统计到答案中，过程中判断可行性。\n代码\nvoid solve() {\n  ll n;\n  cin &gt;&gt; n;\n  ll tot = 0;\n  multiset&lt;ll, greater&lt;&gt;&gt; st;\n  for (ll i = 1; i &lt;= n; i++) {\n    cin &gt;&gt; a[i];\n    tot += a[i];\n    st.insert(a[i]);\n  }\n  if (tot != (1 + n) * n / 2) {\n    cout &lt;&lt; &quot;-1\\n&quot;;\n    return;\n  }\n  ll ans = 0ll, x = n;\n  while (!st.empty() &amp;&amp; x &gt;= 1) {\n    if (st.find(x) != st.end()) {\n      st.erase(st.find(x));\n      x--;\n      continue;\n    }\n    if (*st.begin() &lt; x)\n      break;\n    ans += *st.begin() - x;\n    x--;\n    st.erase(st.begin());\n  }\n  cout &lt;&lt; ans &lt;&lt; &#039;\\n&#039;;\n}\nH 井然有序之窗\n题意\n构造一个长度为 n 的排列，要求每个数i都符合在[l_i,r_i]范围内，如果不存在这样的排列，则输出-1，否则输出构造的排列。\n数据范围\n\n1\\leq n\\leq 1e5\n1\\leq l_i\\leq r_i\\leq n\n\n思路\n按照 1~n 的顺序构造排列，每次从可以使用的区间中取右端点最近的区间。\n代码\nvoid solve() {\n  ll n;\n  cin &gt;&gt; n;\n  vector&lt;pair&lt;pll, ll&gt;&gt; v;\n  for (ll i = 1; i &lt;= n; i++) {\n    pll p;\n    cin &gt;&gt; p.first &gt;&gt; p.second;\n    v.push_back({p, i});\n  }\n  // 关键字顺序l,r,id\n  sort(v.begin(), v.end());\n  multiset&lt;pair&lt;ll, pair&lt;pll, ll&gt;&gt;&gt; st; // 右端点r小的排在前面\n  ll pi = 0;\n  for (ll x = 1; x &lt;= n; x++) {\n    for (; pi &lt; (ll)v.size(); pi++) {\n      pll p = v[pi].first;\n      if (p.first &lt;= x &amp;&amp; p.second &gt;= x) {\n        st.insert({p.second, v[pi]});\n        continue;\n      }\n      break;\n    }\n    if (st.empty()) {\n      cout &lt;&lt; &quot;-1\\n&quot;;\n      return;\n    }\n    a[st.begin()-&gt;second.second] = x;\n    st.erase(st.begin());\n    while (!st.empty() &amp;&amp; st.begin()-&gt;first == x) {\n      st.erase(st.begin());\n    }\n  }\n  for (ll i = 1; i &lt;= n; i++) {\n    cout &lt;&lt; a[i] &lt;&lt; &quot; \\n&quot;[i == n];\n  }\n}\nI 井然有序之桠\n题意\n给出排列a，构造另一个排列b，使得\\sum_{i=1}^{n} gcd(a_i,b_i)=k。\n数据范围\n\n1\\leq n\\leq 1e5\n1\\leq a_i\\leq n\n\n思路\n构造排列使\\sum gcd(a_i,i)=k，易知k的合法上界是\\frac{(n+1)\\times n}{2}，下届是n。从大到小遍历，找到某个端点，将数组分为[1,r]和[r+1,n]两组，右侧区间均取a_i=i，这个区间可以为空，找到最小的r-1+r\\leq k&#039;成立的端点r，遍历的过程中k减去端点划过的值。\n分类讨论，记x=k-(r-1)。如果x为偶数，则取a_x=x，剩余的1,...,x-1,x+1,...r从大到小两两一组交换，实现除了a_x=x的其他小组都是 1。\n如果x为奇数，如果r为偶数，会出现gcd(x-1,x+1)，这个值是2，不符合要求，这时取a_2=2和a_{x-1}=x-1，可以实现与a_x=x一样的构造效果，注意判断x=2的情况。\n特殊的，当x=3时，可以构造a_2=4和a_4=2，这时gcd(a_2,4)+gcd(a_4,2)=4=3+1可行。\n代码\nvoid solve() {\n  ll n, k;\n  cin &gt;&gt; n &gt;&gt; k;\n  set&lt;ll&gt; st;\n  for (ll i = 1; i &lt;= n; i++) {\n    cin &gt;&gt; a[i];\n    b[i] = a[i], c[a[i]] = i;\n    st.insert(i);\n  }\n  if (k &lt; n) {\n    cout &lt;&lt; &quot;-1\\n&quot;;\n    return;\n  }\n  ll s = 0ll, r = n;\n  while (r &gt;= 1) {\n    if (k &lt; r - 1 + r)\n      break;\n    st.erase(r);\n    k -= r;\n    r--;\n  }\n  if (k == 0) {\n    for (ll i = 1; i &lt;= n; i++) {\n      cout &lt;&lt; b[i] &lt;&lt; &#039; &#039;;\n    }\n    cout &lt;&lt; &#039;\\n&#039;;\n    return;\n  }\n  // [r+1~n]都对应ai=i\n  ll x = k - (r - 1);\n  // 把a[1~r]构造成r-1+x\n  if (x &amp; 1) {\n    if (r &amp; 1) {\n      st.erase(x);\n    } else if (x - 1 &gt; 2) {\n      st.erase(x - 1), st.erase(2);\n    } else if (x == 3 &amp;&amp; r &gt;= 4) {\n      b[c[2]] = 4, b[c[4]] = 2;\n      st.erase(2), st.erase(4);\n    } else if (x != 1) {\n      cout &lt;&lt; &quot;-1\\n&quot;;\n      return;\n    }\n  } else {\n    st.erase(x);\n  }\n  vector&lt;ll&gt; v(st.begin(), st.end());\n  for (ll i = v.size() - 1; i - 1 &gt;= 0; i -= 2) {\n    swap(b[c[v[i]]], b[c[v[i - 1]]]);\n  }\n \n  for (ll i = 1; i &lt;= n; i++) {\n    cout &lt;&lt; b[i] &lt;&lt; &#039; &#039;;\n  }\n  cout &lt;&lt; &#039;\\n&#039;;\n}\n \nJ 硝基甲苯之袭\n题意\n在数组中选两个元素a_i,a_j,(i\\neq j)，求满足a_i \\oplus a_j = gcd(a_i,a_j)的i,j对数量。\n数据范围\n\n1\\leq n\\leq 2e5\n1\\leq a_i\\leq 2e5\n\n思路\nx\\oplus y = g，则有y=x\\oplus g，对每个a_i，枚举g，若有符合g == gcd(x,x\\oplus g)的则计入答案，答案要去掉一半重复计数的。\n代码\nll a[maxn];\n// 记录每个数的因数\nvector&lt;ll&gt; MP[maxn];\n \nvoid solve() {\n  ll n;\n  cin &gt;&gt; n;\n  map&lt;ll, ll&gt; mp;\n  for (ll i = 1; i &lt;= n; i++) {\n    cin &gt;&gt; a[i];\n    mp[a[i]]++;\n  }\n  ll ans = 0ll;\n  for (ll i = 1; i &lt;= n; i++) {\n    ll x = a[i];\n    for (ll g : MP[x]) {\n      // 枚举x的因数, x^y=g -&gt; y=x^g, g=gcd(x,x^g)\n      if (mp.count(x ^ g) &amp;&amp; g == gcd(x, x ^ g)) {\n        ans += mp[x ^ g];\n      }\n    }\n  }\n  cout &lt;&lt; ans / 2 &lt;&lt; &#039;\\n&#039;;\n}\n \nvoid init() {\n  for (ll i = 1; i &lt; maxn; i++) {\n    for (ll j = i; j &lt; maxn; j += i) {\n      MP[j].push_back(i);\n    }\n  }\n}\nK 硝基甲苯之魇\n题意\n求一个数组中，有多少个区间[l,r](l\\lt r)满足区间内元素的最大公约数恰好等于它们的异或和。\n数据范围\n\n1\\leq n\\leq 2e5\n1\\leq a_i\\leq 1e9\n\n思路\n对于一个固定的区间[l,r]，其最大公约数可以用某种数据结构维护（线段树/ST 表/…），实现复杂度为O(logn)的查询。\n区间异或和可以利用前缀异或实现，根据异或的性质A \\oplus 0 = A、A\\oplus A=0，对于数组的前缀异或(pre[i]=pre[i-1]\\oplus a[i])，有a_l\\oplus a_{l+1}\\oplus \\dots \\oplus a_r=pre[r]\\oplus pre[l-1]，提供O(1)的查询。\n固定右端点r，当l逐渐减少，其区间gcd会逐渐变小，且变化的次数是 log 级别的，通过在数据结构上二分，找出这些变化的端点，并统计在这个区间中异或和是对应的 gcd 的数量的左端点，统计数量。这个异或的数量可以通过在求前缀异或数组时预处理获得，用 map 存一下每个前缀异或值出现的位置数组，查询时，二分统计[l_l,l_r]中xor为g\\oplus pre[r]的数量。\n\n代码\nll a[maxn], pre[maxn];\n// ST表\nll dp[maxn][30];\nvoid rmq_st(ll n) {\n  for (ll i = 1; i &lt;= n; i++) {\n    dp[i][0] = a[i]; // 2^0\n  }\n  ll m = log(1 * n) / log(2.0);\n  for (ll j = 1; j &lt;= m; j++) {\n    ll t = n - (1 &lt;&lt; j) + 1;\n    for (ll i = 1; i &lt;= t; i++) {\n      dp[i][j] = gcd(dp[i][j - 1], dp[i + (1 &lt;&lt; (j - 1))][j - 1]);\n    }\n  }\n}\nll rmq_find(ll l, ll r) { // 从l开始,长度为r的区间\n  ll k = log(1.0 * (r - l + 1)) / log(2.0);\n  return gcd(dp[l][k], dp[r - (1 &lt;&lt; k) + 1][k]);\n}\n \nvoid solve() {\n  ll n;\n  cin &gt;&gt; n;\n  map&lt;ll, vector&lt;ll&gt;&gt; mp;\n  mp[0].push_back(0);\n  for (ll i = 1; i &lt;= n; i++) {\n    cin &gt;&gt; a[i];\n    pre[i] = pre[i - 1] ^ a[i];\n    mp[pre[i]].push_back(i);\n  }\n  rmq_st(n);\n  ll ans = 0;\n  for (ll R = 2; R &lt;= n; R++) {\n    // 枚举右端点\n    ll L = R - 1;\n    while (L &gt;= 1) {\n      ll g = rmq_find(L, R);\n      ll xl = 1, xr = L;\n      while (xl &lt; xr) {\n        ll mid = (xl + xr) / 2;\n        if (rmq_find(mid, R) == g) {\n          xr = mid;\n        } else {\n          xl = mid + 1;\n        }\n      }\n      // [xl,L]是符合rmq_find(i,R)=g的区间\n      ll x = g ^ pre[R];\n      if (mp.count(x)) {\n        auto &amp;v = mp[x];\n        ans += lower_bound(v.begin(), v.end(), L) -\n               lower_bound(v.begin(), v.end(), xl - 1);\n      }\n      L = xl - 1;\n    }\n  }\n \n  cout &lt;&lt; ans &lt;&lt; &#039;\\n&#039;;\n}\nL 一念神魔之耀\n题意\n有l盏灯，初始状态用一个字符串表示，0表示关闭，1表示开启，每一轮操作可以操作连续的x个或y个灯，将其状态反转，询问是否存在一种操作方式让所有的灯状态相同，如果没有输出-1。\n数据范围\n\n1\\leq T\\leq 500\n1\\le l\\leq 500\n1\\leq x,y\\leq \\frac{l}{3}\n操作轮数n\\leq l^2\n\n思路\n假设x=y，将灯的状态调整成全 1，可以遍历每个 0，以这些 0 为左端点反转一个长度x，当某个 0 的右侧空间不足一个长度x时显然无解。\nx\\neq y,x\\gt y时，如果可以反转长度x，则在x上再反转一个y，可以得到仅反转x-y的效果，以此类推，直到最短的长度，这个过程也是辗转相除法的过程，最短的长度是g=gcd(x,y)。\n尝试按照长度g反转所有 0 的位置，反转s[i]=&#039;0&#039;,[i,i+x-1]中的g长度的部分，则需要将剩余的[i+g,i+x-1]的部分恢复，不定方程ax+bx=g一定有解，当需要恢复的区间[l,r]长度大于等于y时进行一次长度为y的操作，如果不足y则考虑边界后哦向左或者向右拓展长度为x，并在接下来的操作中恢复。\n代码\nvoid solve() {\n  ll n, x, y;\n  string s;\n  cin &gt;&gt; n &gt;&gt; x &gt;&gt; y &gt;&gt; s;\n  ll g = gcd(x, y);\n  s = &quot;1&quot; + s;\n  vector&lt;array&lt;ll, 2&gt;&gt; ans;\n  auto rev = [&amp;](ll l, ll r) {\n    for (ll i = l; i &lt;= r; i++) {\n      s[i] = &#039;1&#039; - s[i] + &#039;0&#039;;\n    }\n    ans.push_back({l, r});\n  };\n  ll p = 1;\n  while (p + g - 1 &lt;= n) { // 少于g的长度无法改变\n    if (s[p] == &#039;1&#039;) {\n      p++;\n      continue;\n    }\n \n    // 反转接下来的g个长度子串\n    ll l, r;              // 需要反转回去的部分\n    if (p + x - 1 &lt;= n) { // 反转[p,p+g-1]部分的子串\n      rev(p, p + x - 1);\n      l = p + g, r = p + x - 1;\n    } else {\n      rev(p + g - x, p + g - 1);\n      l = p + g - x, r = p - 1;\n    }\n \n    while (l &lt;= r) {\n      if (r - l + 1 &gt;= y) {\n        rev(l, l + y - 1);\n        l += y;\n      } else if (r + x &lt;= n) { // 向右拓展\n        rev(r + 1, r + x);\n        r += x;\n      } else { // 向左拓展\n        rev(l - x, l - 1);\n        l -= x;\n      }\n    }\n    p++;\n  }\n \n  if (s.find(&#039;0&#039;) != -1) {\n    cout &lt;&lt; &quot;-1\\n&quot;;\n    return;\n  }\n \n  cout &lt;&lt; ans.size() &lt;&lt; &#039;\\n&#039;;\n  for (auto [l, r] : ans) {\n    cout &lt;&lt; l &lt;&lt; &#039; &#039; &lt;&lt; r &lt;&lt; &#039;\\n&#039;;\n  }\n}\nM 数值膨胀之美\n题意\n定义一个数组的极差是数组的最大值和最小值的差，现在有一个数组，恰好进行一次下述操作：选择一个非空区间，将区间中的数都乘以 2。求这个数组最小的极差。\n数据范围\n\n1\\leq n\\leq 1e5\n1\\leq a_i\\leq 1e9\n\n思路\n极差是最大值减去最小值，将最大值翻倍肯定会增大极差，考虑将最小值乘 2 才能得到更小的极差，依次枚举翻倍最小值、次小值，若当前的区间是连续的，与上一个合法区间取更小的极差，维护数组的极差。\n代码\nvoid solve() {\n  ll n;\n  cin &gt;&gt; n;\n  vector&lt;array&lt;ll, 2&gt;&gt; v;\n  multiset&lt;ll&gt; mst; // 维护极差\n  for (ll i = 1; i &lt;= n; i++) {\n    cin &gt;&gt; a[i];\n    mst.insert(a[i]);\n    v.push_back({a[i], i});\n  }\n  sort(v.begin(), v.end());\n  ll ans = inf;\n  set&lt;ll&gt; st; // 维护已经翻倍的点\n  for (auto [x, i] : v) {\n    st.insert(i);\n    mst.erase(mst.find(x)), mst.insert(x * 2);\n    if (*prev(st.end()) - *st.begin() + 1 == (ll)st.size()) { // 区间连续\n      ans = min(ans, *prev(mst.end()) - *mst.begin());        // 更新答案\n    }\n  }\n \n  cout &lt;&lt; ans &lt;&lt; &#039;\\n&#039;;\n}"},"03-algorithm/nc25wd2":{"slug":"03-algorithm/nc25wd2","filePath":"03-algorithm/nc25wd2.md","title":"🎈2025牛客暑寒假多校训练营Day2","links":[],"tags":["2025寒假训练","算法","牛客","组合数学","计算几何","字符串","ST表"],"content":"A 一起奏响历史之音！\n题意\n中国传统五声调中包含 1、2、3、5、6，判断一个乐谱是否仅由全部或部分五声调铺成。\n思路\n按题意判断即可。\n代码\nvoid solve() {\n  bool flag = true;\n  set&lt;ll&gt; st = {1, 2, 3, 5, 6};\n  ll x;\n  while (cin &gt;&gt; x) {\n    if (st.find(x) == st.end()) {\n      flag = false;\n    }\n  }\n  if (flag) {\n    cout &lt;&lt; &quot;YES\\n&quot;;\n  } else {\n    cout &lt;&lt; &quot;NO\\n&quot;;\n  }\n}\nB 能去你家蹭口饭吃吗\n题意\n给出一个数组a，找到一个整数，要求整数尽可能大，但是至少要比数组中一半数量的数小。\n数据范围\n\n1\\leq n\\leq 5e5\n1\\leq a_i\\leq 1e6\n\n思路\n如果数组长度为奇数，则取中位数-1，即a[n-n/2]-1。\n如果数组长度为偶数，则取下标更大的中位数-1，即a[n/2+1]-1。\n代码\nvoid solve() {\n  ll n;\n  cin &gt;&gt; n;\n  for (ll i = 1; i &lt;= n; i++) {\n    cin &gt;&gt; a[i];\n  }\n  sort(a + 1, a + 1 + n);\n  if (n &amp; 1)\n    cout &lt;&lt; a[n - n / 2] - 1 &lt;&lt; &#039;\\n&#039;;\n  else\n    cout &lt;&lt; a[n / 2 + 1] - 1 &lt;&lt; &#039;\\n&#039;;\n}\nD 字符串里串\n题意\n定义字符串s的可爱度k：最大的满足存在长度为k的连续子串a和严格不连续子串b，使得a=b。\n给出字符串s，求其可爱度。\n数据范围\n\n3\\leq m \\leq 2e5\n\n思路\nb是不连续子串，可以设计a和b仅最后一位或开头一位的在原串中的位置不同，那么只需要寻找符合条件的数量大于等于 2 的字母，并比较分别去掉两端得到的最长的串的长度。\n代码\nvoid solve() {\n  ll n;\n  string s;\n  cin &gt;&gt; n &gt;&gt; s;\n  s = &quot; &quot; + s;\n  map&lt;char, vector&lt;ll&gt;&gt; mp;\n  for (ll i = 1; i &lt;= n; i++) {\n    char c = s[i];\n    mp[c].push_back(i);\n  }\n  ll ans = 0;\n  for (auto [c, v] : mp) {\n    if (v.size() &gt;= 2) {\n      ll m = v.size();\n      ans = max(ans, v[m - 2]);\n    }\n  }\n  for (auto [c, v] : mp) {\n    if (v.size() &gt;= 2) {\n      ll m = v.size();\n      ans = max(ans, n - v[1] + 1);\n    }\n  }\n  cout &lt;&lt; ans &lt;&lt; &#039;\\n&#039;;\n}\nC 字符串外串\n题意\n定义字符串s的可爱度k：最大的满足存在长度为k的连续子串a和严格不连续子串b，使得a=b。构造长度为n的由小写字母组成的字符串，使其可爱度为m，或报告没有这样的合法字符串。\n数据范围\n\n3\\leq m\\leq n\\leq n\\leq 2e5\n\n思路\na,b两种字符串至少要有 1 位对应原串的位置不同，当n=m时显然无解。\n设字符串t是a,b左端对齐之后公共的部分，长度为m-1，小写字母只有 26 个，当n-m\\gt 26时，不管怎么填后n-m的字母，都不可能与让所有在i\\geq m的范围内的字母只出现一次，出现多次则可爱度会增加。按照这样的思路构造前m-1长度的字符串，并保证在后一半的部分中字符s[m-1]出现且仅出现一次。\n代码\nvoid solve() {\n  ll n, m;\n  cin &gt;&gt; n &gt;&gt; m;\n  if (n - m &lt; 1) {\n    cout &lt;&lt; &quot;NO\\n&quot;;\n    return;\n  }\n  string s;\n  if (m == n - 1) {\n    for (ll i = 1; i &lt;= n; i++) {\n      if (i == n - 1 || i == n) {\n        s.push_back(&#039;b&#039;);\n      } else {\n        s.push_back(&#039;a&#039;);\n      }\n    }\n  } else if (n - m &lt;= 26) {\n    for (ll i = 0; i &lt; n; i++) {\n      s.push_back(&#039;a&#039; + i % 26);\n    }\n    s.back() = s[m - 1];\n  } else {\n    cout &lt;&lt; &quot;NO\\n&quot;;\n    return;\n  }\n  cout &lt;&lt; &quot;YES\\n&quot; &lt;&lt; s &lt;&lt; &#039;\\n&#039;;\n}\nE 一起走很长的路！\n题意\n一列多米诺骨牌，质量是a_i，有q次询问，询问一个区间[l,r]，推倒第l位的多米诺骨牌，如果\\sum_{i=l}^{i-1}\\geq a_i，则第a_i块可以顺利倒下，为了使第r块可以顺利倒下，可以进行一种操作：选择某个多米诺骨牌，将其质量+1 或-1，对每个询问返回最少的可以推倒r的操作数。\n数据范围\n\n1\\leq n,q\\leq 2e5\n1\\leq a_i\\leq 1e9\n1\\leq l\\leq r\\leq n\n\n思路\n对于一个区间，如果要进行操作时，肯定是将+1 加在第l位的牌上。\n当l=1时，容易直到，想要第i块牌倒下，需要\\max(a_i-pre_{i-1},0)的操作次数，pre_i是前i项的质量和，故在整个区间上，只需要取\\max(a_i-pre_{i-1}),(l+1\\leq i\\leq r)。\n在区间[l,r]中，如果要推倒第i块牌，则需要构造新的以l为左端点的pre，这个pre的值可以由pre_i-pre_{l-1}推倒，代入上式，则答案是\\max(a_i-(pre_i-pre_{l-1}))。用某种数据结构维护区间最大值。\n代码\n// ST表\nll dp[maxn][30];\nvoid rmq_st(ll n) {\n  for (ll i = 1; i &lt;= n; i++) {\n    dp[i][0] = b[i]; // 2^0\n  }\n  ll m = log(1 * n) / log(2.0);\n  for (ll j = 1; j &lt;= m; j++) {\n    ll t = n - (1 &lt;&lt; j) + 1;\n    for (ll i = 1; i &lt;= t; i++) {\n      dp[i][j] = max(dp[i][j - 1], dp[i + (1 &lt;&lt; (j - 1))][j - 1]);\n    }\n  }\n}\nll rmq_find(ll l, ll r) { // 从l开始,长度为r的区间\n  ll k = log(1.0 * (r - l + 1)) / log(2.0);\n  return max(dp[l][k], dp[r - (1 &lt;&lt; k) + 1][k]);\n}\n \nvoid solve() {\n  ll n, q;\n  cin &gt;&gt; n &gt;&gt; q;\n  for (ll i = 1; i &lt;= n; i++) {\n    cin &gt;&gt; a[i];\n    pre[i] = pre[i - 1] + a[i];\n    b[i] = a[i] - pre[i - 1];\n  }\n  rmq_st(n);\n  while (q--) {\n    ll l, r;\n    cin &gt;&gt; l &gt;&gt; r;\n    if (l == r) {\n      cout &lt;&lt; &quot;0\\n&quot;;\n      continue;\n    }\n    // ans=max(a[i]-(pre[i]-pre[l-1]))\n    ll t = rmq_find(l + 1, r) + pre[l - 1]; // [l+1,r]需要推倒\n    ll ans = max(t, 0ll);\n    cout &lt;&lt; ans &lt;&lt; &#039;\\n&#039;;\n  }\n}\nF 一起找神秘的数！\n题意\n在区间[l,r]中找到两个数x,y，使之满足x+y=(x\\ordinarycolon y)+(x \\land y)+(x \\oplus y)，求这样的数对的数量。\n数据范围\n\n1\\leq T \\leq 2e5\n0\\leq l\\leq r\\leq 1e18\n\n思路\n打表猜结论，发现只有x=y时等式成立。\n代码\nvoid solve() {\n  ll l, r;\n  cin &gt;&gt; l &gt;&gt; r;\n  cout &lt;&lt; r - l + 1 &lt;&lt; &#039;\\n&#039;;\n}\nG 一起铸最好的剑！\n题意\n在m的幂次中找到最接近n的数。\n数据范围\n\n1\\leq T \\leq 1e5\n1\\leq n,m\\leq 1e9\n\n思路\n模拟。\n代码\nvoid solve() {\n  ll n, m;\n  cin &gt;&gt; n &gt;&gt; m;\n  if (m == 1) {\n    cout &lt;&lt; &quot;1\\n&quot;;\n    return;\n  }\n  p[0] = 1, p[1] = m;\n  ll pi = 1;\n  ll mx = abs(p[pi] - n);\n  ll i = 1;\n  for (; p[i] &lt;= n; i++) {\n    if (abs(p[i] - n) &lt; mx) {\n      pi = i;\n      mx = abs(p[i] - n);\n    }\n    p[i + 1] = p[i] * m;\n  }\n  if (abs(p[i] - n) &lt; mx) {\n    pi = i;\n    mx = abs(p[i] - n);\n  }\n  cout &lt;&lt; pi &lt;&lt; &#039;\\n&#039;;\n}\nH 一起画很大的圆！\n题意\n在矩形的边界上找三个不共线的点，使得过这三个点确定的圆的面积最大。\n数据范围\n\n-1e6\\leq a,b,c,d\\leq 1e6\n\n思路\n合适的点的候选在矩形的四个直角附近一个单位长度的点中选，暴力枚举三个点，并判断取半径最大的圆。\n代码\nld getcir2(pll p1, pll p2, pll p3) {\n  auto [x1, y1] = p1;\n  auto [x2, y2] = p2;\n  auto [x3, y3] = p3;\n  ld r;\n  ld a = x1 - x2, b = y1 - y2, c = x1 - x3, d = y1 - y3;\n  ld e = ((x1 * x1 - x2 * x2) + (y1 * y1 - y2 * y2)) / 2.0;\n  ld f = ((x1 * x1 - x3 * x3) + (y1 * y1 - y3 * y3)) / 2.0;\n  ld det = b * c - a * d;\n  if (fabs(det) &lt; 1e-5) {\n    r = -1;\n    return r;\n  }\n  ld x0 = -(d * e - b * f) / det;\n  ld y0 = -(a * f - c * e) / det;\n  r = hypot(x1 - x0, y1 - y0);\n  return r;\n}\n \nvoid solve() {\n  ll a, b, c, d;\n  cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;\n  vector&lt;pll&gt; v = {\n      {a, c}, {a + 1, c}, {a, c + 1}, {a, d}, {a + 1, d}, {a, d - 1},\n      {b, c}, {b - 1, c}, {b, c + 1}, {b, d}, {b - 1, d}, {b, d - 1},\n  };\n  pll p1 = {a, c}, p2 = {a + 1, c}, p3 = {a, c + 1};\n  ld r = getcir2(p1, p2, p3);\n  for (ll i = 0; i &lt; (ll)v.size(); i++) {\n    for (ll j = 0; j &lt; (ll)v.size(); j++) {\n      for (ll k = 0; k &lt; (ll)v.size(); k++) {\n        ld ri = getcir2(v[i], v[j], v[k]);\n        if (ri != -1 &amp;&amp; r &lt; ri) {\n          r = ri;\n          p1 = v[i], p2 = v[j], p3 = v[k];\n        }\n      }\n    }\n  }\n  cout &lt;&lt; p1.first &lt;&lt; &#039; &#039; &lt;&lt; p1.second &lt;&lt; &#039;\\n&#039;;\n  cout &lt;&lt; p2.first &lt;&lt; &#039; &#039; &lt;&lt; p2.second &lt;&lt; &#039;\\n&#039;;\n  cout &lt;&lt; p3.first &lt;&lt; &#039; &#039; &lt;&lt; p3.second &lt;&lt; &#039;\\n&#039;;\n}\n \nI\n题意\n数据范围\n思路\n代码\nJ 数据时间？\n题意\n有n个数据，每条数据由user_id、login_date、login_time组成，表示员工号，登录日期和登录时间。员工号是不超过1e20的整数，登录日期是一个YYYY-MM-DD模式的日期，登录时间是hh:mm:ss模式的时间。\n现在查询h年m月的员工在通勤时间（07:00:00-09:00:00和18:00:00-20:00:00）、午休时间（11:00:00-13:00:00）和临睡时间（22:00:00-01:00:00）的登录人次情况，同一个人在同一个时间段的多次登录算作一人次。时间段均包含边界。\n数据范围\n\n1\\leq n\\leq 1e5\n2000\\leq h\\leq 2030;1\\leq m\\leq 12\n1\\leq user_{id}\\leq 10^{20}\n日期和时间的格式如题意所述。\n\n思路\n按题意模拟。\n代码\nvoid solve() {\n  ll n, h, m;\n  cin &gt;&gt; n &gt;&gt; h &gt;&gt; m;\n  map&lt;string, vector&lt;pair&lt;string, string&gt;&gt;&gt; mp;\n  map&lt;string, bool&gt; mp1, mp2, mp3;\n  for (ll i = 1; i &lt;= n; i++) {\n    string id, t;\n    ll dy, dm, dd;\n    char c;\n    cin &gt;&gt; id &gt;&gt; dy &gt;&gt; c &gt;&gt; dm &gt;&gt; c &gt;&gt; dd &gt;&gt; t;\n    if (dy == h &amp;&amp; dm == m) {\n      string s = t;\n      ll st = ((s[0] - &#039;0&#039;) * 10 + (s[1] - &#039;0&#039;)) * 3600 +\n              ((s[3] - &#039;0&#039;) * 10 + (s[4] - &#039;0&#039;)) * 60 + (s[6] - &#039;0&#039;) * 10 +\n              (s[7] - &#039;0&#039;);\n      if ((st &gt;= 7 * 3600 &amp;&amp; st &lt;= 9 * 3600)||(st &gt;= 18 * 3600 &amp;&amp; st &lt;= 20 * 3600)) {\n        mp1[id] = true;\n      } else if (st &gt;= 11 * 3600 &amp;&amp; st &lt;= 13 * 3600) {\n        mp2[id] = true;\n      } else if ((st &gt;= 22 * 3600 &amp;&amp; st &lt;= 24 * 3600) ||\n                 (st &gt;= 0 * 3600 &amp;&amp; st &lt;= 1 * 3600)) {\n        mp3[id] = true;\n      }\n    }\n  }\n  cout &lt;&lt; mp1.size() &lt;&lt; &#039; &#039; &lt;&lt; mp2.size() &lt;&lt; &#039; &#039; &lt;&lt; mp3.size() &lt;&lt; &#039;\\n&#039;;\n}\nK 可以分开吗？\n题意\n有一块n\\times m的方块组成的矩阵，其中有一些蓝色方块，其余为灰色方块，定义两块方块的连通的：只有当两块方块在四连通方向有共边。\n当一个蓝色极大连通块可以脱离矩阵时，其任何蓝色方块不与任何灰色方块有共边。现在先在矩阵中通过移除灰色方块，取出一个蓝色极大连通块，求最少的操作次数。\n数据范围\n\n1\\leq n,m\\leq 500\n\n思路\n并查集。\n遍历所有的蓝色方块，并查集维护每个蓝色方块寻找它属于的蓝色极大连通块，再通过遍历这些连通块的每个小方块的周围四格，统计需要敲掉的灰色方块的数量。\n代码\nll n, m;\nll a[maxn], b[maxn];\nll fa[maxn];\nchar maz[600][600];\n \nll find(ll x) {\n  if (fa[x] == x) {\n    return x;\n  }\n  return fa[x] = find(fa[x]);\n}\nvoid merge(ll u, ll v) {\n  ll fu = find(u), fv = find(v);\n  if (fu == fv) {\n    return;\n  }\n  fa[fu] = fv;\n}\nvector&lt;pll&gt; dxy = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n \nvoid solve() {\n  cin &gt;&gt; n &gt;&gt; m;\n \n  for (ll i = 0; i &lt;= (n + 5) * (m + 5); i++) {\n    fa[i] = i;\n  }\n \n  vector&lt;pll&gt; v;\n  for (ll i = 1; i &lt;= n; i++) {\n    for (ll j = 1; j &lt;= m; j++) {\n      cin &gt;&gt; maz[i][j];\n      if (maz[i][j] == &#039;1&#039;) {\n        v.push_back({i, j});\n      }\n    }\n  }\n \n  // 并查集\n  for (auto [x, y] : v) {\n    for (auto [dx, dy] : dxy) {\n      ll px = dx + x, py = dy + y;\n      if (maz[px][py] == &#039;1&#039;) {\n        merge((px - 1) * m + py, (x - 1) * m + y);\n      }\n    }\n  }\n  map&lt;ll, vector&lt;pll&gt;&gt; mp;\n  for (auto i : v) {\n    ll x = (i.first - 1) * m + i.second;\n    ll fx = find(x);\n    mp[fx].push_back(i);\n  }\n \n  ll res = n * m - v.size();\n  for (auto [i, vi] : mp) {\n    set&lt;pll&gt; st;\n    for (auto [x, y] : vi) {\n      for (auto [dx, dy] : dxy) {\n        ll px = dx + x, py = dy + y;\n        if (px &lt; 1 || px &gt; n || py &lt; 1 || py &gt; m)\n          continue;\n        if (maz[px][py] == &#039;0&#039;) {\n          st.insert({px, py});\n        }\n      }\n    }\n    res = min(res, (ll)st.size());\n  }\n  cout &lt;&lt; res &lt;&lt; &#039;\\n&#039;;\n}\nL\n题意\n数据范围\n思路\n代码\nM 那是我们的影子\n题意\n在3\\times n的矩阵中，每个格子要么是1\\sim 9的数字，要么是?。求将所有的?填入1\\sim 9的数字，任意3\\times 3的九宫格中的数字都不重复，求合法的填写方式的数量，答案对1e9+7取模。\n数据范围\n\n3\\leq n\\leq 1e5\n\n思路\n易知，所有i\\mod 3相同的列的数字组成都是一样的。\n几种无合法解的情况：\n\n某一列有重复的数字\n某个i\\mod 3的组中数字的种数多于 3 种\n\n排除不合法的情况后，进行排列组合，将所有九宫格的数字位置情况汇总成一个标准九宫格后，里面有一些位置依然是?，数字不确定，这些不确定的k个位置对应k个没有出现过的数字，将其分成3组，分别对应每列的空缺位，这样的组合方法有\\binom{k}{col_0}\\times \\binom{k-col_0}{col_1}\\times \\binom{k-col_0-col_1}{col_2}种。\n完成上面这一步之后，相当于九宫格的每列对应的数集合是确定的。接下来遍历每一列，乘上在空缺位上的全排列数。\n代码\n#include &lt;bits/stdc++.h&gt;\n \nusing namespace std;\n \ntypedef double ld;\ntypedef unsigned long ul;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair&lt;ll, ll&gt; pll;\n \nconst ll maxn = 2e6 + 50;\nconst ll inf = 0x3f3f3f3f3f;\nconst ll mo998 = 998244353;\nconst ll mo1e9 = 1000000007;\n \nll qpow(ll a, ll b) {\n  ll ret = 1;\n  while (b) {\n    if (b &amp; 1)\n      ret = (ret * a) % mo1e9;\n    a = a * a % mo1e9;\n    b &gt;&gt;= 1;\n  }\n  return ret;\n}\nll inv(ll x) { return qpow(x, mo1e9 - 2); }\n \n// 逆元求组合数\nll fz[maxn], fm[maxn];\nll C(ll n, ll m) {\n  if (n &lt; m)\n    return 0ll;\n  if (n == m)\n    return 1ll;\n  return fz[n] * fm[m] % mo1e9 * fm[n - m] % mo1e9;\n}\nll A(ll x, ll y) { return fz[x] * C(x, y) % mo1e9; }\n \nll maz[5][maxn];\n \nvoid solve() {\n  ll n;\n  cin &gt;&gt; n;\n  vector&lt;string&gt; s(4);\n  cin &gt;&gt; s[1] &gt;&gt; s[2] &gt;&gt; s[3];\n \n  // 第0,3,6...相同，i%3相同的数字组成一模一样\n  vector&lt;set&lt;ll&gt;&gt; col(5, set&lt;ll&gt;()); // 第0/1/2列的数字\n  vector&lt;ll&gt; q(n + 10, 0ll);         // 每列的?数量\n \n  for (ll i = 0; i &lt; n; i++) {\n    set&lt;ll&gt; tmp;\n    for (ll t = 1; t &lt;= 3; t++) {\n      char c = s[t][i];\n      if (c != &#039;?&#039;) {\n        maz[t][i] = c - &#039;0&#039;;\n        if (tmp.count(maz[t][i])) { // 列有重复\n          cout &lt;&lt; &quot;0\\n&quot;;\n          return;\n        }\n        tmp.insert(maz[t][i]);\n        col[i % 3].insert(maz[t][i]);\n        if (col[i % 3].size() &gt; 3) { // 种数不合法\n          cout &lt;&lt; &quot;0\\n&quot;;\n          return;\n        }\n      } else {\n        maz[t][i] = -1;\n        q[i]++;\n      }\n    }\n  }\n \n  set&lt;ll&gt; usd;\n  for (ll i = 0; i &lt; 3; i++) {\n    for (auto j : col[i]) {\n      usd.insert(j);\n    }\n  }\n  vector&lt;ll&gt; v = {\n      3 - (ll)col[0].size(),\n      3 - (ll)col[1].size(),\n      3 - (ll)col[2].size(),\n  };\n  ll tot = v[0] + v[1] + v[2];\n  if (tot + usd.size() != 9) {\n    cout &lt;&lt; &quot;0\\n&quot;;\n    return;\n  }\n \n  ll ans = 1ll * C(tot, v[0]) * C(tot - v[0], v[1]) % mo1e9;\n \n  for (ll i = 0; i &lt; n; i++) {\n    ll k = q[i];\n    ans = ans * A(k, k) % mo1e9;\n  }\n \n  cout &lt;&lt; ans &lt;&lt; &#039;\\n&#039;;\n}\n \nvoid init() {\n  ll w = maxn - 10;\n  fz[0] = fm[0] = 1;\n  for (ll i = 1; i &lt;= w; i++) {\n    fz[i] = fz[i - 1] * i % mo1e9;\n  }\n  fm[w] = inv(fz[w]);\n  for (ll i = w - 1; i &gt;= 1; i--) {\n    fm[i] = fm[i + 1] * (i + 1) % mo1e9;\n  }\n}\n \nint main(void) {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  ll _t = 1;\n  cin &gt;&gt; _t;\n  cin.get();\n  init();\n  while (_t--)\n    solve();\n \n  return 0;\n}"},"03-algorithm/nc25wd3":{"slug":"03-algorithm/nc25wd3","filePath":"03-algorithm/nc25wd3.md","title":"🎈2025牛客暑寒假多校训练营Day3（完結）","links":[],"tags":["2025寒假训练","字典树","数论分块","换根dp","随机化算法","模拟","ST表","算法"],"content":"A 智乃的博弈游戏\n题意\n有一堆n个石子，每次可以拿走x个石子，要求x是一个不大于n且与n互质的数，当面对1时选手获胜，询问智乃（先手玩家）能否获胜。\n数据范围\n\n1\\leq n\\leq 1e18\n\n思路\n必胜点是剩余 1，则 2 是必败点，两个选手都不希望对手面对 1，都希望对手面对 2。\n如果当前剩余n是奇数，则选手一定可以操作将剩余数量变成偶数（只拿一个）。面对偶数的选手，能选的互质的数一定是一个奇数，偶数减去奇数会变成奇数，下一轮回到奇数的情况，如果某一方保持偶数，一定会到剩余2的情况，也就是必败点。\n于是本题博弈和初始状态的奇偶性相关。\n代码\nn = int(input())\nif n &amp; 1:\n    print(&quot;Yes&quot;)\nelse:\n    print(&quot;No&quot;)\nB 智乃的质数手串\n题意\n有一个环形的手串，第一个小球的编号是0，上面有一个数字a_0…第n个小球的编号是n-1，上面有一个数字a_{n-1}。\n遵循以下规则：\n\n手串上只有一个小球，则可以直接取下。\n若当前小球上的数字和其顺时针相邻的下一个小球的数字相加的和是一个质数，则可以拿下当前的小球。\n\n给出手串的结构，请问是否可以将小球全部取下来，取下来的合法序号顺序是什么？\n数据范围\n\n1\\leq n\\leq 1e5\n1\\leq a_i\\leq 1e5\n\n思路\n当手串是链状的时候，若要将第一个取下来，则需要将序号大于 1 的第一个小球前的所有小球取下来，或者第二个小球前的所有小球取下来…很明显这是一个栈的结构，当将要入栈的小球可以和栈顶的数构成质数，则进行pop操作，知道栈为空或不能构成质数，才停止操作，将小球入栈。\n而在环状手串上，需要维护一个长度为n的区间，在这个区间上测试是否存在栈的大小只剩 1 的情况，当栈底的小球的序号与栈顶的序号超过n的区间长度，需要将栈底的pop，这个数据结构需要支持两端的pop操作，应当使用deque模拟操作。\n代码\n#include &lt;bits/stdc++.h&gt;\n \nusing namespace std;\n \ntypedef double ld;\ntypedef unsigned long ul;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair&lt;ll, ll&gt; pll;\n \nconst ll maxn = 2e6 + 50;\n \nll lowbit(ll x) { return x &amp; -x; }\n \nll a[maxn], b[maxn], c[maxn], d[maxn];\nll pre[maxn], suf[maxn];\nll diff[maxn];\nbool vis[maxn];\n \nvector&lt;ll&gt; primes;\nbool isprime[maxn];\nvoid init_prime() {\n  ll w = maxn - 1;\n  for (ll i = 0; i &lt;= w; i++) {\n    isprime[i] = true;\n  }\n  isprime[0] = isprime[1] = false;\n  for (ll i = 2; i &lt;= w; i++) {\n    if (!isprime[i])\n      continue;\n    for (ll j = 2 * i; j &lt;= w; j += i) {\n      isprime[j] = false;\n    }\n  }\n}\nvector&lt;vector&lt;ll&gt;&gt; factors;\nvoid init_factor() {\n  ll w = maxn - 1;\n  factors.assign(w + 1, vector&lt;ll&gt;());\n  for (ll i = 1; i &lt;= w; i++) {\n    for (ll j = i; j &lt;= w; j += i) {\n      factors[j].push_back(i);\n    }\n  }\n}\n \nvoid solve() {\n  ll n;\n  cin &gt;&gt; n;\n  for (ll i = 0; i &lt; n; i++) {\n    cin &gt;&gt; a[i];\n    a[i + n] = a[i];\n  }\n  deque&lt;pll&gt; q;\n  ll pos = -1;\n  for (ll i = 0; i &lt; 2 * n; i++) {\n    while (!q.empty() &amp;&amp; isprime[a[i] + q.back().first]) {\n      q.pop_back();\n    }\n    while (!q.empty() &amp;&amp; i - q.front().second + 1 &gt; n) {\n      q.pop_front();\n    }\n    q.push_back({a[i], i});\n    if (q.size() == 1 &amp;&amp; i &gt;= n) {\n      pos = i % n; // 最后一个入栈的数\n      break;\n    }\n  }\n \n  if (pos == -1) {\n    cout &lt;&lt; &quot;No\\n&quot;;\n    return;\n  }\n  cout &lt;&lt; &quot;Yes\\n&quot;;\n  q.clear();\n  for (ll i = pos + 1; i &lt;= pos + n; i++) {\n    while (!q.empty() &amp;&amp; isprime[a[i] + q.back().first]) {\n      cout &lt;&lt; q.back().second &lt;&lt; &#039; &#039;;\n      q.pop_back();\n    }\n    q.push_back({a[i], i % n});\n  }\n  cout &lt;&lt; q.back().second &lt;&lt; &#039;\\n&#039;;\n}\n \nvoid init() { init_prime(); }\n \nint main(void) {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  ll _t = 1;\n  init();\n  while (_t--) {\n    solve();\n  }\n \n  return 0;\n}\nC 智乃的 Notepad(Easy version)\n题意\n有n个字符串，需要将它们都单独呈现在显示屏上，只能使用26个字母和退格键(\\b可以删去一个字符)，提问至少需要敲几下键盘？\n数据范围\n\n1\\leq n\\leq 1e5\nm=1\n\\sum|s_i|\\leq 1e6\n\n思路\n当两个单词前缀相同时，对比分别打印两个单词，可以减少一个公共前缀的长度的次数，最后可以把最长的单词留在屏幕上。\n若建立字典树，答案就是字典树上边的数量的两倍减去最长单词的长度。\n也可以根据字典序排序，也可以把前缀相同的放在相邻的位置。\n代码：字典序排序\nvoid solve() {\n  ll n, m;\n  cin &gt;&gt; n &gt;&gt; m;\n  ll mx = 0;\n  vector&lt;string&gt; v;\n  for (ll i = 1; i &lt;= n; i++) {\n    string s;\n    cin &gt;&gt; s;\n    v.push_back(s);\n    mx = max((ll)s.size(), mx);\n  }\n  sort(v.begin(), v.end());\n  while (m--) {\n    ll l, r;\n    cin &gt;&gt; l &gt;&gt; r;\n    ll ans = v[0].size() * 2;\n    for (ll i = 1; i &lt; n; i++) {\n      ll j = 0;\n      ans += v[i].size() * 2;\n      while (j &lt; (ll)v[i - 1].size() &amp;&amp; j &lt; (ll)v[i].size() &amp;&amp;\n             v[i - 1][j] == v[i][j]) {\n        j++;\n      }\n      ans -= j * 2;\n    }\n    cout &lt;&lt; ans - mx &lt;&lt; &#039;\\n&#039;;\n  }\n}\n代码：字典树\nll tot = 0;\nll tree[maxn][26];\nbool exist[maxn];\nvoid insert(string s, ll n) {\n  ll p = 0;\n  for (ll i = 0; i &lt; n; i++) {\n    ll c = s[i] - &#039;a&#039;;\n    if (!tree[p][c]) {\n      tree[p][c] = ++tot;\n    }\n    p = tree[p][c];\n  }\n  exist[p] = true;\n}\n \nvoid solve() {\n  ll n, m;\n  cin &gt;&gt; n &gt;&gt; m;\n  ll mx = 0;\n  for (ll i = 1; i &lt;= n; i++) {\n    string s;\n    cin &gt;&gt; s;\n    insert(s, s.size());\n    mx = max((ll)s.size(), mx);\n  }\n  while (m--) {\n    ll l, r;\n    cin &gt;&gt; l &gt;&gt; r;\n    ll ans = tot * 2 - mx;\n    cout &lt;&lt; ans &lt;&lt; &#039;\\n&#039;;\n  }\n}\nD 智乃的 Notepad(Hard version)\n题意\n情景同 C 题，在此版本，需要支持m次查询，得到完成打印区间[l,r]内的单词需要的最少操作次数。\n数据范围\n\n1\\leq n\\leq 1e5\n1\\leq m\\leq 1e5\n\\sum|s_i|\\leq 1e6\n\n思路\n离线处理查询的区间，范围[l,r]内的操作数是以[l,r]内的单词建立的字典树的边数 ×2-最长单词长度，考虑字典树的建树过程，每个单词会覆盖前若干个单词的部分前缀，在覆盖的过程中，前面的单词的贡献的点数部分转移到当前的单词上，将字符串的序号看作不同的颜色，在着色的过程中，更新各个颜色对应的贡献，在加入新的单词i时，可以计算所有以i为右端点的查询区间的答案。\n代码\nll lowbit(ll x) { return (x) &amp; (-x); }\n \nll n, m;\nll a[maxn], b[maxn], c[maxn];\n \nll bitree[maxn];          // BIT树\nvoid update(ll p, ll x) { // 单点修改a[p]+=x\n  while (p &amp;&amp; p &lt;= n) {\n    bitree[p] += x;\n    p += lowbit(p);\n  }\n}\nll query(ll n) {\n  ll ans = 0, p = n;\n  while (p) {\n    ans += bitree[p];\n    p -= lowbit(p);\n  }\n  return ans;\n}\nll query(ll l, ll r) { return query(r) - query(l - 1); }\n \nll tot = 0;\nll tree[maxn][26], clr[maxn];\nvoid insert(string s, ll t) {\n  ll n = s.size();\n  s = &quot; &quot; + s;\n  ll p = 0;\n  for (ll i = 1; i &lt;= n; i++) {\n    ll c = s[i] - &#039;a&#039;;\n    if (!tree[p][c]) {\n      tree[p][c] = ++tot;\n    }\n    p = tree[p][c];\n    if (clr[p]) {\n      update(clr[p], -1);\n    }\n    clr[p] = t; // 当前颜色\n    update(clr[p], 1);\n  }\n}\n \n// ST表\nll dp[maxn][50]; // 0/1:最小值/最大值\nvoid rmq_st(ll n, vector&lt;ll&gt; &amp;v) {\n  for (ll i = 1; i &lt;= n; i++) {\n    dp[i][0] = v[i]; // 2^0\n  }\n  ll m = log(1 * n) / log(2.0);\n  for (ll j = 1; j &lt;= m; j++) {\n    ll t = n - (1 &lt;&lt; j) + 1;\n    for (ll i = 1; i &lt;= t; i++) {\n      dp[i][j] = max(dp[i][j - 1], dp[i + (1 &lt;&lt; (j - 1))][j - 1]);\n    }\n  }\n}\nll rmq_query(ll l, ll r) { // 从l开始,长度为r的区间最大值\n  ll k = log(1.0 * (r - l + 1)) / log(2.0);\n  ll mx = max(dp[l][k], dp[r - (1 &lt;&lt; k) + 1][k]);\n  return mx;\n}\n \nvoid solve() {\n  cin &gt;&gt; n &gt;&gt; m;\n \n  vector&lt;string&gt; s(n + 1);\n  vector&lt;ll&gt; sz(n + 1);\n \n  for (ll i = 1; i &lt;= n; i++) {\n    cin &gt;&gt; s[i];\n    sz[i] = s[i].size();\n  }\n  rmq_st(n, sz);\n \n  vector&lt;array&lt;ll, 3&gt;&gt; v;\n  for (ll i = 1; i &lt;= m; i++) {\n    ll l, r;\n    cin &gt;&gt; l &gt;&gt; r;\n    v.push_back({r, l, i});\n  }\n  sort(v.begin(), v.end());\n \n  ll cr = 0;\n  for (auto [r, l, i] : v) {\n    while (cr &lt; r) {\n      cr++;\n      insert(s[cr], cr);\n    }\n    a[i] = 2 * query(l, r) - rmq_query(l, r);\n  }\n  for (ll i = 1; i &lt;= m; i++) {\n    cout &lt;&lt; a[i] &lt;&lt; &#039;\\n&#039;;\n  }\n}\nE 智乃的小球\n题意\n在水平线上有n个小球，每个小球有一个初始速度，记向右为正，小球的初始速度要么为1m/s，要么为-1m/s，其质量都相同，坐标为p_i。询问在足够长的时间内，能否发生k次碰撞，以及第k次碰撞发生的时间。\n数据范围\n\n1\\leq n\\leq 1e5\n1\\leq k\\leq 1e9\n0\\leq p_i\\leq 1e9,v_i\\in \\{-1,1\\}\n\n保证一开始所有的小球位置不同。\n思路\n根据高中物理常识，易得，当两个质量相同的小球相向碰撞，会交换彼此的速度。由于本题中所有小球的速度都是1m/s或-1m/s，可以把交换速度看作两个小球互相穿过对方，依然按照原来的速度向前运动。\n也就是说，本题询问若干向右的小球和向左的小球能相遇多少次，这个值可以枚举某个方向的小球的初始位置，再在另一个方向的小球中二分查找当前的小球会遇到多少相向的小球，再对时间进行二分。\n第k次碰撞的时刻的值大概率是浮点数，在二分时间的时候注意精度不要太小，容易超时。\n代码\nvoid solve() {\n  ll n, k;\n  cin &gt;&gt; n &gt;&gt; k;\n  vector&lt;ld&gt; v1, v2;\n  for (ll i = 1; i &lt;= n; i++) {\n    ll p, v;\n    cin &gt;&gt; p &gt;&gt; v;\n    if (v == 1)\n      v1.push_back(p);\n    else\n      v2.push_back(p);\n  }\n  sort(v1.begin(), v1.end()), sort(v2.begin(), v2.end());\n  // k可行性\n  ll mk = 0;\n  for (ll pi : v1) {\n    mk += v2.end() - upper_bound(v2.begin(), v2.end(), pi);\n  }\n  if (k &gt; mk) {\n    cout &lt;&lt; &quot;No\\n&quot;;\n    return;\n  }\n \n  auto check = [&amp;](ld t) {\n    // 这段时间内的碰撞次数\n    ll tot = 0;\n    t /= 1e7;\n    for (ll pi : v1) {\n      ll t1 = v2.end() - lower_bound(v2.begin(), v2.end(), pi);\n      ll t2 = v2.end() - lower_bound(v2.begin(), v2.end(), pi + 2 * t);\n      ll ti = t1 - t2;\n      tot += ti;\n    }\n    return tot;\n  };\n  ll l = 0, r = 1e16;\n  while (l + 1 &lt; r) { // [l,r]\n    ll mid = (l + r) / 2;\n    if (check(mid) &gt;= k) {\n      r = mid;\n    } else {\n      l = mid;\n    }\n  }\n  cout &lt;&lt; &quot;Yes\\n&quot;;\n  cout &lt;&lt; fixed &lt;&lt; setprecision(9) &lt;&lt; 1.0 * l / 1e7 &lt;&lt; &#039;\\n&#039;;\n}\nF 智乃的捉迷藏\n题意\n在三角形的三个角和三条边着 6 个位置分别设计放多少人，人数总和是n，让 A、B、C 三个人分别能看到 a、b、c 数量的人。\n数据范围\n\n1\\leq n\\leq 20\n1\\leq a,b,c\\leq n\n\n思路\n赛时是直接冲了 6 重循环，暴力 for 遍历枚举 6 个位置的数量可以通过此题（注意边界）。\n也可以仅枚举 3 个顶点的位置，计算三边位置的值，判断成立条件。\n代码：枚举 6 位\nvoid solve() {\n  ll n, a, b, c;\n  cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n  bool flag = false;\n  for (ll i = 0; i &lt;= n; i++) {\n    for (ll j = 0; j + i &lt;= n; j++) {\n      for (ll k = 0; k + j + i &lt;= n; k++) {\n        for (ll x = 0; x + k + j + i &lt;= n; x++) {\n          for (ll y = 0; y + x + k + j + i &lt;= n; y++) {\n            ll z = n - (y + x + k + j + i);\n            if (x + y + z == a &amp;&amp; z + i + j == b &amp;&amp; x + k + j == c) {\n              flag = true;\n              break;\n            }\n          }\n          if (flag)\n            break;\n        }\n        if (flag)\n          break;\n      }\n      if (flag)\n        break;\n    }\n    if (flag)\n      break;\n  }\n  if (flag) {\n    cout &lt;&lt; &quot;Yes\\n&quot;;\n \n  } else {\n    cout &lt;&lt; &quot;No\\n&quot;;\n  }\n}\n代码：枚举 3 位\nvoid solve() {\n  ll n, a, b, c;\n  cin &gt;&gt; n &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n  for (ll i = 0; i &lt;= n; i++) {\n    for (ll j = 0; i + j &lt;= n; j++) {\n      for (ll k = 0; i + j + k &lt;= n; k++) {\n        // 枚举1 3 5号位置\n        ll x = a - i - j, y = b - j - k, z = c - i - k;\n        if (x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; z &gt;= 0 &amp;&amp; (i + j + k + x + y + z == n)) {\n          cout &lt;&lt; &quot;Yes\\n&quot;;\n          return;\n        }\n      }\n    }\n  }\n  cout &lt;&lt; &quot;No\\n&quot;;\n}\nG 智乃与模数\n题意\n对一个正整数n，选择所有1\\leq i\\leq n的i作为模数，记录余数序列，再将余数序列降序排列，求前k大的数之和。\n数据范围\n\n1\\leq k\\leq n\\leq 1e9\n\n思路\n分块，枚举商，在商比较小的时候，商是连续有值的，当商比较大的时候，可能会出现商和商之间不再连续，如n=5时，商为1的有\\{5,4,3\\}，商为2的有\\{2\\}，商为3,4的集合都是空的，商为5的集合是\\{1\\}，对每个商相同的集合，可以发现其余数符合等差数列的规律，公差是商的值。商不连续的情况的数值范围比较小，可以通过打表记录这部分的余数。\n二分找出第k大的余数的值，再在每个按商分块的集合中，利用等差数列公式，计算余数大于等于k的余数之和，再减去多算的数量（这部分多算的数都是余数数值为k的数）。\n代码\nvoid solve() {\n  ll n, k;\n  cin &gt;&gt; n &gt;&gt; k;\n \n  vector&lt;pll&gt; v;\n  vector&lt;ll&gt; w;\n  for (ll i = 1; i &lt;= n; i++) {\n    if (n / (n / i) == i) {\n      ll l = n / (i + 1) + 1, r = n / i;\n      v.push_back({l, r});\n    } else {\n      v.push_back({1, n / i});\n      for (ll j = 1; j &lt;= n / i; j++) { // 打表商不连续的部分\n        w.push_back(n % j);\n      }\n      break;\n    }\n  }\n  sort(w.begin(), w.end());\n \n  ll ans = 0ll, cnt = 0ll;\n  auto check = [&amp;](ll x) {\n    // 统计有多少大于等于k的\n    ll ret = 0ll;\n    ans = 0ll;\n    for (auto &amp;[l, r] : v) {\n      ll s = n / r, t = (r - l + 1);\n      if (n / l != s) {\n        for (auto p = lower_bound(w.begin(), w.end(), x); p != w.end(); p++) {\n          ret++;\n          ans += *p;\n        }\n        break;\n      }\n      ll at = n % l, a1 = n % r, d = s;\n      if (x &lt;= a1) {\n        ll j = t;\n        ret += j, ans += (at + a1) * j / 2;\n        continue;\n      }\n      ll ti = (x - a1) / d + 2 - ((x - a1) % d == 0);\n      ll j = max(0ll, t - ti + 1);\n      ret += j, ans += (at + a1 + (t - j) * d) * j / 2;\n    }\n    cnt = ret;\n    return ret;\n  };\n  ll l = 0, r = n;\n  while (l + 1 &lt; r) {\n    ll mid = (l + r) / 2;\n    if (check(mid) &gt;= k) {\n      l = mid;\n    } else {\n      r = mid;\n    }\n  }\n  ans -= (cnt - k) * l;\n  cout &lt;&lt; ans &lt;&lt; &#039;\\n&#039;;\n}\n类似题：因数个数和\nH 智乃与黑白树\n题意\n一棵节点数为n的黑白树，每个节点为黑色或白色，定义一棵黑白树的权值是树中所有黑色节点到白色节点的简单路径长度之和，路径长度是路径中经过边的数量。\n询问如果切掉第i条边，产生的两棵子树的权值分别是多少？\n数据范围\n\n2\\leq n\\leq 1e5\n\n思路\n换根更新以i为根的子树的权值。\n{{&lt; mermaid &gt;}}\nflowchart TB\nc1((p))-.连接.→a1((v))\nsubgraph 子树v\na1⇒a2((s1))\na1⇒a3((s2))\nend\nsubgraph 当前的树p\nc1⇒c2((s1))\nc1⇒c3((s2))\nend\n{{&lt; /mermaid &gt;}}\n如图，当前的操作是将子树v的信息更新到以p为根的树上，记以i为根的子树的黑/白色节点数是num[i][0/1]，子树i中的黑/白色节点到根i的距离之和是g[i][0/1]，f[i]为子树i的权值，那么在 dfs 递归更新的时候，转移是：\nvoid pushup(ll rt, ll p) { // 更新以rt为根，p为子节点的信息\n  f[rt] += f[p] + g[rt][0] * num[p][1] + g[rt][1] * num[p][0] +\n           (num[p][0] + g[p][0]) * num[rt][1] +\n           (num[p][1] + g[p][1]) * num[rt][0];\n  g[rt][0] += num[p][0] + g[p][0], g[rt][1] += num[p][1] + g[p][1];\n  num[rt][0] += num[p][0], num[rt][1] += num[p][1];\n}\n而删边的时候转移是反过来：\nvoid cutlink(ll rt, ll p) { // 切断rt为父节点的子树p\n  g[rt][0] -= num[p][0] + g[p][0], g[rt][1] -= num[p][1] + g[p][1];\n  num[rt][0] -= num[p][0], num[rt][1] -= num[p][1];\n  f[rt] -= f[p] + g[rt][0] * num[p][1] + g[rt][1] * num[p][0] +\n           (num[p][0] + g[p][0]) * num[rt][1] +\n           (num[p][1] + g[p][1]) * num[rt][0];\n}\n在切边的时候，按顺序换根，更新权值。\n代码\nll f[maxn], g[maxn][2], num[maxn][2], clr[maxn];\nll fa[maxn];\nvector&lt;vector&lt;ll&gt;&gt; tree;\nvoid add_edge(ll u, ll v) {\n  tree[u].push_back(v);\n  tree[v].push_back(u);\n}\n \nvoid pushup(ll rt, ll p) { // 更新以rt为根，p为子节点的信息\n  f[rt] += f[p] + g[rt][0] * num[p][1] + g[rt][1] * num[p][0] +\n           (num[p][0] + g[p][0]) * num[rt][1] +\n           (num[p][1] + g[p][1]) * num[rt][0];\n  g[rt][0] += num[p][0] + g[p][0], g[rt][1] += num[p][1] + g[p][1];\n  num[rt][0] += num[p][0], num[rt][1] += num[p][1];\n}\nvoid cutlink(ll rt, ll p) { // 切断rt为父节点的子树p\n  g[rt][0] -= num[p][0] + g[p][0], g[rt][1] -= num[p][1] + g[p][1];\n  num[rt][0] -= num[p][0], num[rt][1] -= num[p][1];\n  f[rt] -= f[p] + g[rt][0] * num[p][1] + g[rt][1] * num[p][0] +\n           (num[p][0] + g[p][0]) * num[rt][1] +\n           (num[p][1] + g[p][1]) * num[rt][0];\n}\n \nvoid dfs(ll p, ll fr) {\n  fa[p] = fr;\n  num[p][clr[p]]++;\n  for (auto v : tree[p]) {\n    if (v == fr)\n      continue;\n    dfs(v, p);\n    pushup(p, v);\n  }\n}\n \nvoid solve() {\n  ll n;\n  string s;\n  cin &gt;&gt; n &gt;&gt; s;\n  s = &quot; &quot; + s;\n  for (ll i = 1; i &lt;= n; i++) {\n    clr[i] = s[i] == &#039;w&#039;;\n  }\n  tree.assign(n + 1, vector&lt;ll&gt;());\n  vector&lt;pll&gt; ve;\n  for (ll i = 1; i &lt;= n - 1; i++) {\n    ll u, v;\n    cin &gt;&gt; u &gt;&gt; v;\n    add_edge(u, v);\n    ve.push_back({u, v});\n  }\n  ll cur = 1; // 当前根节点\n  dfs(cur, -1);\n  for (auto [u, v] : ve) {\n    ll p;\n    if (fa[v] == u)\n      p = v;\n    else\n      p = u;\n    vector&lt;pll&gt; w;\n    while (p != cur) {\n      w.push_back({fa[p], p}); // 要切除的边\n      p = fa[p];\n    }\n    reverse(w.begin(), w.end());\n    for (ll k = 0; k &lt; (ll)w.size(); k++) {\n      auto [i, j] = w[k];\n      // 将i&lt;-j变成j-&gt;i\n      cutlink(i, j);\n      if (k == (ll)w.size() - 1)\n        cout &lt;&lt; f[u] &lt;&lt; &#039; &#039; &lt;&lt; f[v] &lt;&lt; &#039;\\n&#039;;\n      pushup(j, i);\n      fa[i] = j;\n      cur = j;\n    }\n  }\n}\n类似提：树学\nI 智乃的兔子跳\n题意\n在坐标\\{x_1,x_2,\\dots ,x_n\\}上各有一个胡萝卜，这n个胡萝卜的坐标各不重合，兔子要选择一个起始坐标p和一个跳跃步长k，以获得最多的胡萝卜个数。求出获得最多胡萝卜的p和k。\n数据范围\n\n1\\leq n\\leq 1e5\n1\\leq x_i\\leq 1e9\n0\\leq p\\leq 1e9\n2\\leq k\\leq 1e9\n\n思路\n随机化算法，如果每个坐标上都有胡萝卜，设计步长为 2，可以获得\\max \\text{(奇数个数,偶数个数)}个胡萝卜，任选两个胡萝卜，在最佳方案中的概率会大于\\frac{1}{2}\\times \\frac{1}{2}，随机选择两个胡萝卜，枚举其距离的质因数，更新最优的方案，随机的次数不超过可行的时间复杂度即可。\n代码\nvoid solve() {\n  ll n;\n  cin &gt;&gt; n;\n  for (ll i = 1; i &lt;= n; i++) {\n    cin &gt;&gt; a[i];\n  }\n \n  if (n == 1) {\n    cout &lt;&lt; a[1] &lt;&lt; &quot; 2\\n&quot;;\n    return;\n  }\n \n  ll ans = 0, pi = a[1], ki = 2;\n  auto update = [&amp;](ll p, ll k) {\n    ll cnt = 0;\n    for (ll i = 1; i &lt;= n; i++) {\n      if ((a[i] - p) % k == 0)\n        cnt++;\n    }\n    if (cnt &gt; ans) {\n      ans = cnt;\n      pi = p, ki = k;\n    }\n  };\n \n  auto check = [&amp;](ll x, ll y) {\n    x = a[x], y = a[y];\n    ll d = abs(y - x);\n    ll k = d;\n    ll p = x % k;\n    for (ll t = 2; t * t &lt;= d; t++) {\n      if (d % t == 0) {\n        while (d % t == 0)\n          d /= t;\n        k = t;\n        p = x % k;\n        update(p, k);\n      }\n    }\n \n    if (d &gt; 1) {\n      k = d;\n      p = x % k;\n      update(p, k);\n    }\n  };\n \n  random_device rd;\n  mt19937 gen(rd());\n  uniform_int_distribution&lt;&gt; rnd(1, n);\n \n  ll tot = 100;\n  while (tot--) {\n    ll i = rnd(gen);\n    ll j = rnd(gen);\n    while (i == j) {\n      j = rnd(gen);\n    }\n    if (abs(a[i] - a[j]) &lt;= 1)\n      continue;\n    check(i, j);\n  }\n \n  cout &lt;&lt; pi &lt;&lt; &#039; &#039; &lt;&lt; ki &lt;&lt; &#039;\\n&#039;;\n}\nJ 智乃画二叉树\n题意\n使用\\、/、_画六边形二叉树，形似：\n\n要去掉不存在的节点，并用一圈*区分范围。\n数据范围\n\n1\\leq n\\leq 99\n1\\leq k\\leq 7\n\n思路\n先画出满二叉树，再根据树的结构填写序号和删去节点。\n代码\nll a[maxn], b[maxn];\nll fa[maxn];\n \nll tot;\npll tree[400];\n \nll w(ll i) {\n  if (i == 1)\n    return 4;\n  return (w(i - 1) + 1) &lt;&lt; 1;\n}\nll h(ll i) { return 3 * (1ll &lt;&lt; (i - 1)); }\n \nll H, W;\n \nchar maz[200][400];\nvoid paint() { // 满二叉树\n  memset(maz, &#039; &#039;, sizeof(maz));\n  vector&lt;pll&gt; v;\n  for (ll j = 0; j &lt; 3; j++) {\n    for (ll i = 1; i &lt;= W; i++) {\n      char c = &#039; &#039;;\n      if ((j == 0 &amp;&amp; i % 6 == 1) || (j == 1 &amp;&amp; i % 6 == 4) ||\n          (j == 2 &amp;&amp; i % 12 == 7)) {\n        c = &#039;\\\\&#039;;\n      } else if ((j == 0 &amp;&amp; i % 6 == 4) || (j == 1 &amp;&amp; i % 6 == 1) ||\n                 (j == 2 &amp;&amp; i % 12 == 4)) {\n        c = &#039;/&#039;;\n      } else if ((j == 0 || j == 2) &amp;&amp; (i % 6 == 2 || i % 6 == 3)) {\n        c = &#039;_&#039;;\n      } else if (j == 1 &amp;&amp; i % 6 == 2) {\n        c = &#039;0&#039;;\n      }\n      maz[H - j][i] = c;\n      if (j == 2 &amp;&amp; (i % 12 == 4 || i % 12 == 7)) {\n        v.push_back({H - j, i});\n      }\n    }\n  }\n \n  while (v.size() &gt;= 2) {\n    while (v.size() &gt;= 2 &amp;&amp; v[1].second - v[0].second &gt; 3) { // 延长线\n      vector&lt;pll&gt; tmp;\n      for (ll i = 0; i &lt; (ll)v.size(); i++) {\n        pll p = v[i];\n        char c = maz[p.first][p.second];\n        if (i % 2 == 0)\n          p.first -= 1, p.second += 1;\n        else\n          p.first -= 1, p.second -= 1;\n        maz[p.first][p.second] = c;\n        tmp.push_back(p);\n      }\n      v = tmp;\n    }\n \n    vector&lt;pll&gt; tmp;\n \n    for (ll i = 0; i + 1 &lt; (ll)v.size(); i += 2) {\n      pll p = v[i];\n      p.first -= 1;\n      maz[p.first][p.second] = &#039;\\\\&#039;, maz[p.first][p.second + 1] = &#039;_&#039;,\n      maz[p.first][p.second + 2] = &#039;_&#039;, maz[p.first][p.second + 3] = &#039;/&#039;,\n      p.first -= 1;\n      maz[p.first][p.second] = &#039;/&#039;, maz[p.first][p.second + 1] = &#039;0&#039;,\n      maz[p.first][p.second + 3] = &#039;\\\\&#039;;\n      p.first -= 1;\n      maz[p.first][p.second + 1] = maz[p.first][p.second + 2] = &#039;_&#039;;\n      if (i % 4 == 0) {\n        p.second += 3;\n        maz[p.first][p.second] = &#039;/&#039;;\n        tmp.push_back(p);\n      } else {\n        maz[p.first][p.second] = &#039;\\\\&#039;;\n        tmp.push_back(p);\n      }\n    }\n    v = tmp;\n  }\n \n  maz[v.front().first][v.front().second] = &#039; &#039;;\n \n  tot = 1;\n  for (ll i = 1; i &lt;= H; i++) {\n    for (ll j = 1; j &lt;= W; j++) {\n      if (maz[i][j] == &#039;0&#039;) {\n        tree[tot++] = {i, j};\n      }\n    }\n  }\n}\n \nvoid dfs(ll p, ll i) {\n  if (p &lt; 10)\n    maz[tree[i].first][tree[i].second] = p + &#039;0&#039;;\n  else\n    maz[tree[i].first][tree[i].second] = p / 10 + &#039;0&#039;,\n    maz[tree[i].first][tree[i].second + 1] = p % 10 + &#039;0&#039;;\n \n  if (a[p] != -1)\n    dfs(a[p], i * 2);\n  if (b[p] != -1)\n    dfs(b[p], i * 2 + 1);\n}\nll nI, I, nJ, J;\nvoid cut_zero() {\n  for (ll i = 1; i &lt; tot; i++) {\n    pll p = tree[i];\n    if (maz[p.first][p.second] != &#039;0&#039;) {\n      I = max(I, p.first + 1);\n      J = max(J, p.second + 2);\n      nI = min(nI, p.first - 1);\n      nJ = min(nJ, p.second - 1);\n      continue;\n    }\n    // 删掉六边形\n    maz[p.first][p.second] = maz[p.first][p.second - 1] =\n        maz[p.first][p.second + 2] = &#039; &#039;;\n    maz[p.first + 1][p.second - 1] = maz[p.first + 1][p.second] =\n        maz[p.first + 1][p.second + 1] = maz[p.first + 1][p.second + 2] = &#039; &#039;;\n    maz[p.first - 1][p.second] = maz[p.first - 1][p.second + 1] = &#039; &#039;;\n    // 删掉延长线\n    char c = maz[p.first - 1][p.second - 1];\n    if (c == &#039; &#039;) {\n      c = maz[p.first - 1][p.second + 2];\n      p.first -= 1, p.second += 2;\n    } else {\n      p.first -= 1, p.second -= 1;\n    }\n    while (c != &#039; &#039; &amp;&amp; maz[p.first][p.second] == c) {\n      maz[p.first][p.second] = &#039; &#039;;\n      if (c == &#039;/&#039;)\n        p.first -= 1, p.second += 1;\n      else\n        p.first -= 1, p.second -= 1;\n    }\n  }\n}\n \nvoid solve() {\n  ll n, k;\n  cin &gt;&gt; n &gt;&gt; k;\n  for (ll i = 1; i &lt;= n; i++) {\n    fa[i] = -1;\n  }\n  H = h(k), W = w(k);\n  paint();\n  for (ll i = 1; i &lt;= n; i++) {\n    cin &gt;&gt; a[i] &gt;&gt; b[i];\n    if (a[i] != -1)\n      fa[a[i]] = i;\n    if (b[i] != -1)\n      fa[b[i]] = i;\n  }\n  ll rt = -1;\n  for (ll i = 1; i &lt;= n; i++) {\n    if (fa[i] == -1) {\n      rt = i;\n      break;\n    }\n  }\n  // 填数\n  dfs(rt, 1);\n  // 删\n  nI = H, nJ = W, I = 1, J = 1;\n  cut_zero();\n  // 打印\n  for (ll i = nI - 1; i &lt;= I + 1; i++) {\n    for (ll j = nJ - 1; j &lt;= J + 1; j++) {\n      if (i == nI - 1 || i == I + 1 || j == nJ - 1 || j == J + 1) {\n        cout &lt;&lt; &#039;*&#039;;\n      } else {\n        cout &lt;&lt; maz[i][j];\n      }\n    }\n    cout &lt;&lt; &#039;\\n&#039;;\n  }\n}\nK 智乃的逆序数\n题意\n定义一个紧密排序数组：将数组元素按照从小到大排序后，相邻元素之间的差值是1。当两个数组没有任何相同元素，则这两个数组是不相交的。\n现在有n个互不相交的紧密数组，用这些数组中的元素组合成一个逆序数恰好为k的新数组，要求新数组中的数之间保持各自在原来数组中的相对顺序。\n数据范围\n\n1\\leq n\\leq 1000\n0\\leq k\\leq 1e6\n1\\leq a_{i,j}\\leq 1e9\n测试文件的数组长度之和不超过10^3\n\n思路\n新数组中不改变数字之间在原数组中的相对顺序，且这些数组不会相交，那么每个数组是一个范围在[l,r]的数的排列，不管怎么改变他们在新数组中的位置，这个小排列中的数形成的逆序数对对数不会减少或增加，当按照最小值排序依次填入新数组时，就是逆序数最小的新数组。\n数组之间按照最小值为第一关键字升序排序，如果排序序号较大的数组中的元素放在序号小的数组中的数前面，会增加逆序数。最多的逆序数是数组按照逆序填入新数组时，从大到小枚举数组，计算元素需要向前移动几个位置能恰好满足k，也可以按组进行冒泡排序，合法的冒泡排序交换的次数就是增加的逆序数的数量。\n代码：枚举\npair&lt;vector&lt;ll&gt;, ll&gt; inverse_num(vector&lt;ll&gt; v) {  // 归并排序求逆序数\n  ll n = v.size();\n  if (n &lt;= 1)\n    return {v, 0};\n  ll mid = n / 2;\n  vector&lt;ll&gt; vl, vr;\n  for (ll i = 0; i &lt; n; i++) {\n    if (i &lt; mid)\n      vl.push_back(v[i]);\n    else\n      vr.push_back(v[i]);\n  }\n  auto [arr_l, invl] = inverse_num(vl);\n  auto [arr_r, invr] = inverse_num(vr);\n  ll nl = arr_l.size(), nr = arr_r.size();\n \n  arr_l.push_back(inf), arr_r.push_back(inf);\n \n  ll i = 0, j = 0;\n \n  vector&lt;ll&gt; arr;\n  ll inv = invl + invr;\n  while (i &lt; nl || j &lt; nr) {\n    if (arr_l[i] &lt;= arr_r[j]) {\n      inv += j;\n      arr.push_back(arr_l[i]);\n      i++;\n    } else {\n      arr.push_back(arr_r[j]);\n      j++;\n    }\n  }\n  return {arr, inv};\n}\n \nvoid solve() {\n  ll n, k;\n  cin &gt;&gt; n &gt;&gt; k;\n \n  vector&lt;vector&lt;ll&gt;&gt; v;\n  vector&lt;array&lt;ll, 3&gt;&gt; info;\n \n  ll tot_len = 0;\n  ll min_ans = 0, max_ans = 0;\n  for (ll i = 0; i &lt; n; i++) {\n    ll m;\n    cin &gt;&gt; m;\n    tot_len += m;\n    vector&lt;ll&gt; w(m);\n    for (auto &amp;j : w) {\n      cin &gt;&gt; j;\n    }\n    v.push_back(w);\n    ll ni = inverse_num(w).second;\n    info.push_back({*min_element(w.begin(), w.end()), m, i});\n    min_ans += ni, max_ans += ni;\n  }\n \n  // 每个数组的最小元素，大小，位置\n  sort(info.begin(), info.end());\n  for (ll i = 0; i &lt; n; i++) {\n    auto [l, m, idx] = info[i];\n    if (i == 0) {\n      pre[i] = m;\n    } else {\n      pre[i] = pre[i - 1] + m;\n    }\n  }\n  for (ll i = n - 1; i &gt;= 0; i--) {\n    auto [l, m, idx] = info[i];\n    max_ans += (pre[i] - m) * m;\n  }\n  if (k &lt; min_ans || k &gt; max_ans) {\n    cout &lt;&lt; &quot;No\\n&quot;;\n    return;\n  }\n \n  cout &lt;&lt; &quot;Yes\\n&quot;;\n  ll ans = min_ans, i = n - 1, p = 0;\n  ll las = -1;\n  vector&lt;ll&gt; arr(tot_len, -1);\n  while (ans &lt; k &amp;&amp; i &lt; n &amp;&amp; i &gt;= 0) {\n    auto [l, m, idx] = info[i];\n    auto w = v[idx];\n    if (ans + (pre[i] - m) * m &lt;= k) {\n      // 数组idx放在首位\n      for (ll j = p; j &lt;= p + m - 1; j++) {\n        arr[j] = w[j - p];\n      }\n      p += m;\n      ans += (pre[i] - m) * m;\n      i--;\n      continue;\n    }\n \n    ll t = (k - ans) / (pre[i] - m); // 完整挪动t个数\n    for (ll j = p; j &lt;= p + t - 1; j++) {\n      arr[j] = w[j - p];\n    }\n    p += t;\n    ll ti = (pre[i] - m) * (t + 1) - (k - ans);\n    arr[p + ti] = w[t];\n    las = t + 1;\n    break;\n  }\n  for (ll j = 0; j &lt; i; j++) {\n    auto [l, m, idx] = info[j];\n    for (auto e : v[idx]) {\n      while (arr[p] != -1 &amp;&amp; p + 1 &lt; tot_len)\n        p++;\n      arr[p++] = e;\n    }\n  }\n  for (ll j = las == -1 ? 0 : las; i &lt; n &amp;&amp; i &gt;= 0 &amp;&amp; j &lt; info[i][1]; j++) {\n    auto [l, m, idx] = info[i];\n    ll e = v[idx][j];\n    while (arr[p] != -1 &amp;&amp; p + 1 &lt; tot_len)\n      p++;\n    arr[p++] = e;\n  }\n \n  for (auto i : arr) {\n    cout &lt;&lt; i &lt;&lt; &#039; &#039;;\n  }\n  cout &lt;&lt; &#039;\\n&#039;;\n}\n代码：冒泡排序\nvoid solve() {\n  ll n, k;\n  cin &gt;&gt; n &gt;&gt; k;\n \n  vector&lt;vector&lt;ll&gt;&gt; v;\n  vector&lt;array&lt;ll, 3&gt;&gt; info;\n \n  ll min_ans = 0, tot = 0;\n  for (ll i = 0; i &lt; n; i++) {\n    ll m, l = inf;\n    cin &gt;&gt; m;\n    tot += m;\n    vector&lt;ll&gt; w(m);\n    for (auto &amp;j : w) {\n      cin &gt;&gt; j;\n      l = min(l, j);\n    }\n    v.push_back(w);\n    ll ni = 0;\n    for (ll t = 0; t &lt; m; t++) {\n      for (ll f = t + 1; f &lt; m; f++) {\n        ni += (w[t] &gt; w[f]);\n      }\n    }\n    min_ans += ni;\n    info.push_back({l, m, i});\n  }\n \n  if (k &lt; min_ans) {\n    cout &lt;&lt; &quot;No\\n&quot;;\n    return;\n  }\n \n  // 进行一定次数的冒泡排序\n  sort(info.begin(), info.end());\n  k -= min_ans;\n \n  vector&lt;pll&gt; arr;\n \n  for (ll i = 0; i &lt; n; i++) {\n    ll idx = info[i][2];\n    for (ll j : v[idx]) {\n      arr.push_back({j, idx});\n    }\n  }\n \n  for (ll i = 0; i &lt; tot &amp;&amp; k &gt; 0; i++) {\n    for (ll j = 0; j &lt; tot - 1; j++) {\n      if (arr[j].first &lt; arr[j + 1].first &amp;&amp;\n          arr[j].second != arr[j + 1].second &amp;&amp; k &gt; 0) {\n        k--;\n        swap(arr[j], arr[j + 1]);\n      } else if (k &lt;= 0) {\n        break;\n      }\n    }\n  }\n \n  if (k &gt; 0) {\n    cout &lt;&lt; &quot;No\\n&quot;;\n    return;\n  }\n \n  cout &lt;&lt; &quot;Yes\\n&quot;;\n  for (auto i : arr) {\n    cout &lt;&lt; i.first &lt;&lt; &#039; &#039;;\n  }\n  cout &lt;&lt; &#039;\\n&#039;;\n}\nL 智乃的三角遍历\n题意\n由三角形构成的平面图，给出层数，找出一条遍历所有边的欧拉回路。\n\n数据范围\n思路\nn比较小，可以打表存答案输出。\n法 2：要找出一种可以在任意层数上复刻的遍历思路，下图是一种思路，每次先向下遍历连到下层的点，再回复到右端点。\n\n法 3：递归搜索，类比汉诺塔，如果想完成 1→2→3→1 的顺序，需要先把以 2 为上顶点的三角形遍历完，指针回复到 2 号位置，继续完成 2→3，遍历 3 为上顶点的三角形，最后回到 1。\n代码：某种顺序\nvoid solve() {\n  ll n;\n  cin &gt;&gt; n;\n  vector&lt;ll&gt; v;\n  ll p = 1;\n  v.push_back(p);\n  for (ll i = 1; i &lt;= n; i++) {\n    p += i;\n    v.push_back(p);\n  }\n  while (p + 1 &lt; 1 + (n + 1 + 1) * (n + 1) / 2) {\n    p++;\n    v.push_back(p);\n  }\n  for (ll x = n + 1; x &gt;= 2; x--) {\n    p -= x;\n    ll pi = p;\n    v.push_back(p);\n    while (p &gt; 1 + (x - 2) * (x - 1) / 2) {\n      v.push_back(p + x - 1);\n      p--;\n      v.push_back(p);\n    }\n    while (p + 1 &lt;= pi) {\n      p++;\n      v.push_back(p);\n    }\n  }\n  cout&lt;&lt;&quot;Yes\\n&quot;;\n  for (auto i : v) {\n    cout &lt;&lt; i &lt;&lt; &#039; &#039;;\n  }\n  cout &lt;&lt; &quot;\\n&quot;;\n}\n代码：递归\nvector&lt;ll&gt; ans;\nvector&lt;vector&lt;pll&gt;&gt; G;\nll tot;\nvoid add_edge(ll p1, ll p2) {\n  vis[tot] = false;\n  G[p1].push_back({p2, tot}); // 终点和这条边的编号\n  G[p2].push_back({p1, tot++});\n}\n \nvoid dfs(ll p) {\n  for (auto i : G[p]) {\n    if (vis[i.second])\n      continue;\n    vis[i.second] = true;\n    dfs(i.first);\n  }\n  ans.push_back(p);\n}\n \nvoid solve() {\n  ll n;\n  cin &gt;&gt; n;\n  G.assign((n + 1) * (n + 2) / 2 + 1, vector&lt;pll&gt;());\n  for (ll i = 1; i &lt;= n; i++) {\n    // 第i层\n    for (ll j = 1; j &lt;= i; j++) {\n      ll p1 = (i - 1) * i / 2 + j;\n      ll p2 = p1 + i, p3 = p1 + i + 1;\n      add_edge(p1, p2);\n      add_edge(p2, p3);\n      add_edge(p3, p1);\n    }\n  }\n  dfs(1);\n  cout &lt;&lt; &quot;Yes\\n&quot;;\n  for (auto i : ans) {\n    cout &lt;&lt; i &lt;&lt; &#039; &#039;;\n  }\n  cout &lt;&lt; &#039;\\n&#039;;\n}\nM 智乃的牛题\n题意\n判断输入的长度为 8 的字符串能不能重组字符顺序组成nowcoder。\n数据范围\n无\n思路\n无\n代码\nvoid solve() {\n  string s;\n  cin &gt;&gt; s;\n  map&lt;char, ll&gt; mp;\n  for (auto c : s) {\n    mp[c]++;\n  }\n  if (mp[&#039;n&#039;] == 1 &amp;&amp; mp[&#039;o&#039;] == 2 &amp;&amp; mp[&#039;w&#039;] == 1 &amp;&amp; mp[&#039;c&#039;] == 1 &amp;&amp;\n      mp[&#039;d&#039;] == 1 &amp;&amp; mp[&#039;e&#039;] == 1 &amp;&amp; mp[&#039;r&#039;] == 1) {\n    cout &lt;&lt; &quot;happy new year\\n&quot;;\n  } else {\n    cout &lt;&lt; &quot;I AK IOI\\n&quot;;\n  }\n}"},"03-algorithm/nc25wd4":{"slug":"03-algorithm/nc25wd4","filePath":"03-algorithm/nc25wd4.md","title":"🎈2025牛客暑寒假多校训练营Day4","links":[],"tags":["2025寒假训练","算法","牛客"],"content":"A\n题意\n数据范围\n思路\n代码\nB Tokitsukaze and Balance String (easy)\n题意\n定义字符串是平衡的：字符串中01的连续子串的数量和10的连续子串的数量相同。\n定义字符串s的val(s)：\n\n将字符串s的某位置i的字符倒置（1变成0，0变成1）后，字符串是平衡的，这样的位置的总数\n\n现在有一个由1、0和?组成的字符串，?可以任意换成1或0，求所有的填写完成的字符串的val(s)的总和，模数是10^9+7。\n数据范围\n\n1\\leq T\\leq 10^4\n1\\leq n\\leq 10\n保证单个测试文件的2^n之和不超过10^5\n\n思路\nEasy版本的数据范围较小，直接dfs统计即可。\n代码\nll val(string t) {\n  ll n = t.size();\n  ll ret = 0ll;\n  for (ll pi = 0; pi &lt; n; pi++) {\n    t[pi] = &#039;1&#039; - t[pi] + &#039;0&#039;;\n    ll cnt1 = 0, cnt2 = 0;\n    for (ll i = 1; i &lt; n; i++) {\n      if (t[i - 1] == &#039;0&#039; &amp;&amp; t[i] == &#039;1&#039;)\n        cnt1++;\n      if (t[i - 1] == &#039;1&#039; &amp;&amp; t[i] == &#039;0&#039;)\n        cnt2++;\n    }\n    ret += (cnt1 == cnt2);\n    t[pi] = &#039;1&#039; - t[pi] + &#039;0&#039;;\n  }\n  return ret;\n}\n \nll ans = 0ll;\nvoid dfs(string s, ll p) {\n  if (s.find(&#039;?&#039;) == -1) {\n    ans += val(s);\n    return;\n  }\n  if (s[p] != &#039;?&#039;) {\n    dfs(s, p + 1);\n    return;\n  }\n  s[p] = &#039;1&#039;;\n  dfs(s, p + 1);\n  s[p] = &#039;0&#039;;\n  dfs(s, p + 1);\n  return;\n}\n \nvoid solve() {\n  ll n;\n  string s;\n  cin &gt;&gt; n &gt;&gt; s;\n  ans = 0ll;\n  dfs(s, 0);\n  cout &lt;&lt; ans &lt;&lt; &#039;\\n&#039;;\n}\nC\n题意\n数据范围\n思路\n代码\nD Tokitsukaze and Concatenate‌ Palindrome\n题意\n有两个字符串a和b。\n第一步：对他们分别进行重新排列（也可以保持原状）；\n第二步：可以进行若干次替换；\n第三步：将a和b链接成一个新字符串s。\n求至少进行多少次第二步的替换，可以让s是一个回文串。\n数据范围\n\n1\\leq n,m\\leq 2\\times 10^5\n\n思路\n如果a和b有共同拥有的字符，那么在回文串中要尽量将这些字符用作对称的位置，在组合串s的中线位置，尽量放满a或b中较长的串的剩余部分中的数量大于 1 的字符，剩余的不对称的部分就是不得不替换的字符。\n代码\nvoid solve() {\n  ll n, m;\n  cin &gt;&gt; n &gt;&gt; m;\n  string a, b;\n  cin &gt;&gt; a &gt;&gt; b;\n  if (n &lt; m) {\n    swap(n, m);\n    swap(a, b);\n  }\n  vector&lt;ll&gt; v1(26, 0), v2(26, 0);\n  for (auto c : a) {\n    v1[c - &#039;a&#039;]++;\n  }\n  for (auto c : b) {\n    v2[c - &#039;a&#039;]++;\n  }\n  ll tot = 0ll, sum1 = 0ll, sum2 = 0ll;\n  for (int i = 0; i &lt; 26; i++) {\n    if (v1[i] &gt; v2[i])\n      v1[i] -= v2[i], v2[i] = 0;\n    else\n      v2[i] -= v1[i], v1[i] = 0;\n    sum1 += v1[i], sum2 += v2[i];\n    tot += v1[i] / 2;\n  }\n  ll ans = sum2;\n  if ((sum1 - sum2) / 2 &gt; tot) {\n    ans += (sum1 - sum2) / 2 - tot;\n  }\n  cout &lt;&lt; ans &lt;&lt; &#039;\\n&#039;;\n}\nE Tokitsukaze and Dragon’s Breath\n题意\n在n\\times m的表格中，每个位置(i,j)有一个数字a_{i,j}代表此地的怪物数量，当龙的位置在(x,y)时，火焰会打败坐标(x,y)的怪物，并向四个斜角方向（左上 ↖，右上 ↗，右下 ↘，左下 ↙）一直拓展，形成一个X形状。\n请在地图上选一个作为龙的坐标，并计算可以打败最多怪物的数量。\n数据范围\n\n1\\leq T\\leq 1e4\n1\\leq n,m\\leq 1e3\n1\\leq a_{i,j}\\leq 1e9\nn\\times m\\leq 1e6\n\n思路\n按题意枚举点，模拟攻击，注意需要记忆化算过的斜线，保证合适的复杂度。\n代码\nll maz[1200][1200];\n \nvector&lt;pll&gt; dxy = {{1, 1}, {-1, 1}, {1, -1}, {-1, -1}};\n \nvoid solve() {\n  ll n, m;\n  cin &gt;&gt; n &gt;&gt; m;\n  for (ll i = 1; i &lt;= n; i++) {\n    for (ll j = 1; j &lt;= m; j++) {\n      cin &gt;&gt; maz[i][j];\n    }\n  }\n  map&lt;ll, ll&gt; mpc, mpr;\n  auto fire = [&amp;](ll x, ll y) {\n    if (mpc.count(x - y) == 0) {\n      ll sum = -maz[x][y];\n      ll dx = 1, dy = 1;\n      ll px = x, py = y;\n      while (px &gt;= 1 &amp;&amp; px &lt;= n &amp;&amp; py &gt;= 1 &amp;&amp; py &lt;= m) {\n        sum += maz[px][py];\n        px += dx, py += dy;\n      }\n      dx = -1, dy = -1;\n      px = x, py = y;\n      while (px &gt;= 1 &amp;&amp; px &lt;= n &amp;&amp; py &gt;= 1 &amp;&amp; py &lt;= m) {\n        sum += maz[px][py];\n        px += dx, py += dy;\n      }\n      mpc[x - y] = sum;\n    }\n    if (mpr.count(x + y) == 0) {\n      ll sum = -maz[x][y];\n      ll dx = 1, dy = -1;\n      ll px = x, py = y;\n      while (px &gt;= 1 &amp;&amp; px &lt;= n &amp;&amp; py &gt;= 1 &amp;&amp; py &lt;= m) {\n        sum += maz[px][py];\n        px += dx, py += dy;\n      }\n      dx = -1, dy = 1;\n      px = x, py = y;\n      while (px &gt;= 1 &amp;&amp; px &lt;= n &amp;&amp; py &gt;= 1 &amp;&amp; py &lt;= m) {\n        sum += maz[px][py];\n        px += dx, py += dy;\n      }\n      mpr[x + y] = sum;\n    }\n    return mpc[x - y] + mpr[x + y] - maz[x][y];\n  };\n  ll ans = 0ll;\n  for (ll x = 1; x &lt;= n; x++) {\n    for (ll y = 1; y &lt;= m; y++) {\n      ll res = fire(x, y);\n      ans = max(ans, res);\n    }\n  }\n  cout &lt;&lt; ans &lt;&lt; &#039;\\n&#039;;\n}\nI Tokitsukaze and Pajama Party\n题意\n歌词模式是u*uwawauwa，必须有一个u开头和一个uwawauwa结尾(连续的)，且中间的*至少匹配 1 个任意字符，给出一个字符串，求字符串中有多少符合上述模式的子串。\n数据范围\n\n1\\leq n\\leq 1e5\n\n思路\n寻找字符串中所有uwawauwa的位置，枚举u的位置，统计总数。\n代码\nvoid solve() {\n  ll n;\n  string s;\n  cin &gt;&gt; n &gt;&gt; s;\n  ll p = 0, ans = 0;\n  vector&lt;ll&gt; pos, v;\n  while (s.find(&quot;uwawauwa&quot;, p) != -1) {\n    p = s.find(&quot;uwawauwa&quot;, p);\n    pos.push_back(p);\n    p += 1;\n  }\n  for (ll i = 0; i &lt; s.size(); i++) {\n    if (s[i] == &#039;u&#039;) {\n      v.push_back(i);\n    }\n  }\n  for (auto i : pos) {\n    ll c = lower_bound(v.begin(), v.end(), i - 1) - v.begin();\n    ans += c;\n  }\n  cout &lt;&lt; ans &lt;&lt; &#039;\\n&#039;;\n}\nK Tokitsukaze and Shawarma\n题意\n客人需要x个沙威玛，y杯可乐，z包薯条。\n制作 1 个沙威玛需要 a 分钟；让饮料机倒可乐，每一杯可乐需要 b 分钟；让炸锅自动炸薯条，每一包薯条需要 c 分钟。这三件事可以同时进行。\n请问客人至少需要等待几分钟。\n数据范围\n\n1\\leq x,y,z,a,b,c\\leq 100\n\n思路\n三者可以同时进行，取耗时最多的时间。\n代码\nvoid solve() {\n  ll x, y, z, a, b, c;\n  cin &gt;&gt; x &gt;&gt; y &gt;&gt; z &gt;&gt; a &gt;&gt; b &gt;&gt; c;\n  ll ans = max(x * a, y * b);\n  ans = max(ans, c * z);\n  cout &lt;&lt; ans &lt;&lt; &#039;\\n&#039;;\n}"},"03-algorithm/nenuoj":{"slug":"03-algorithm/nenuoj","filePath":"03-algorithm/nenuoj.md","title":"NENU2023学年算法2例题","links":["tags/------------","tags/"],"tags":["算法","NENUOJ","------------",""],"content":"有的题还没写完）咕咕咕））\nNENU OJ算法2例题\n这学期写算法2的思路并不都很详细，不过如果有想交流的也可以评论区或者私信，学校oj的题大多比较简单，这里的所有代码或许只保证通过学校的弱测试数据，因为其他地方OJ我还没有试过。\n算法2递归A\n1241: A001 猴子吃桃\n题目描述\n猴子第1天摘下若干个桃子，当即吃了一半，还不过瘾，又多吃了一个。第2天又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下的一半另加一个。到第10天早上想再吃时，就只剩下一个桃子了。求第1天共摘了多少个桃子。\n输入\n输入第一行为正整数n，为测试数据组数。后面n行为测试数据，每组测试数据包括两个整数m，k，分别表示第m（m&gt;1)天后剩余的桃子数k(k&gt;=0)。\n输出\n输出猴子第一天摘的桃子数，每组数据占一行。\n样例输入\n2\n2  2\n3  0\n样例输出\n6\n6\n参考代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint main() {\n    int n;cin &gt;&gt; n;\n    while (n--) {\n        int m, k;cin &gt;&gt; m &gt;&gt; k;\n        int sum = k;\n        for (int i = 0;i &lt; m - 1;i++) {\n            sum++;\n            sum *= 2;\n        }\n        cout &lt;&lt; sum &lt;&lt; endl;\n    }\n \n    return 0;\n}\n1242: A002 最大公约数\n题目描述\n输入两个正整数，求其最大公约数。\n数论中有一个求最大公约数的算法称为辗转相除法，又称欧几里德算法。其基本思想及执行过程为（设m为两正整数中较大者，n为较小者）：\n（1）令u=m,v=n；\n（2）取u对v的余数，即r=u%v，如果r的值为0，则此时v的值就是m和n的最大公约数，否则执行第（3）步；\n（3）u=v，v=r，即u的值为v的值，而v的值为余数r。并转向第（2）步。\n输入\n第1行是测试数据的组数n，后面跟着n行输入。每组测试数据占1行，包括两个正整数m和n。\n输出\nn行，每行输出对应一个输入。输出应是一个正整数，为m和n的最大公约数。\n样例输入\n2\n48 32\n15 5\n样例输出\n16\n5\n参考代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint main() {\n    int t;cin &gt;&gt; t;\n    while (t--) {\n        int m, n;cin &gt;&gt; m &gt;&gt; n;\n        int yu = m % n;\n        while (yu) {\n            m = n;n = yu;\n            yu = m % n;\n        }\n        cout &lt;&lt; n &lt;&lt; endl;\n    }\n \n    return 0;\n}\n1243: A003 经典的Hanoi(汉诺塔)问题\n题目描述\n有一个汉诺塔，塔内有A,B,C三个柱子。起初，A柱上有n个盘子，依次由大到小、从下往上堆放，要求将它们全部移到C柱上；在移动过程中可以利用B柱，但每次只能移到一个盘子，且必须使三个柱子上始终保持大盘在下，小盘在上的状态。要求编程输出移动的步骤。\n输入\n输入文件中包含多行，每行为一个整数n，代表初始A柱子上的盘子的个数。\n输出\n对输入文件中的每个整数n列出具体的汉诺塔移动步骤。两组输出之间有一空行。\n样例输入\n3\n1\n样例输出\nA--&gt;C\nA--&gt;B\nC--&gt;B\nA--&gt;C\nB--&gt;A\nB--&gt;C\nA--&gt;C\n \nA--&gt;C\n参考代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nvoid hanoi(int n, int from, int to) {\n    if (n == 0) return;     // 全部移完，终止递归\n    // 把from位置上的上面的n-1个移到不是from也不是to的位置\n    hanoi(n - 1, from, (3 - from - to));\n    // 移动最底下的最大的那个，并输出记录\n    cout &lt;&lt; char(from + &#039;A&#039;) &lt;&lt; &quot;--&gt;&quot; &lt;&lt; char(to + &#039;A&#039;) &lt;&lt; endl;\n    // 把之前移走的n-1个移到to位置\n    hanoi(n - 1, (3 - from - to), to);\n}\nint main() {\n    int n;\n    while (cin &gt;&gt; n) {\n        hanoi(n, 0, 2);\n        cout &lt;&lt; &quot;\\n&quot;;\n    }\n \n    return 0;\n}\n1244: A004 菲波那契数列\n题目描述\n菲波那契数列是指这样的数列: 数列的第一个和第二个数都为1，接下来每个数都等于前面2个数之和。给出一个正整数a，要求菲波那契数列中第a个数是多少。\n输入\n第1行是测试数据的组数n，后面跟着n行输入。每组测试数据占1行，包括一个正整数a(1 ⇐ a ⇐ 20)。\n输出\n输出有n行，每行输出对应一个输入。输出应是一个正整数，为菲波那契数列中第a个数的大小。\n样例输入\n4\n5\n2\n19\n1\n样例输出\n5\n1\n4181\n1\n参考代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n \nint fib(int n) {\n    if (n == 1 || n == 2)return 1;\n    return fib(n - 1) + fib(n - 2);\n}\n \nint main() {\n    int t;cin &gt;&gt; t;\n    while (t--) {\n        int a;cin &gt;&gt; a;\n        cout &lt;&lt; fib(a) &lt;&lt; endl;\n    }\n \n    return 0;\n}\n1245: A005 另一个Fibonacci数列\n题目描述\n定义另外一个Fibonacci数列：F(0)=7,F(1)=11,F(n)=F(n-1)+F(n-2)，（n≥2）。\n输入\n输入文件中包含多行，每行为一个整数n，n&lt;1000000。\n输出\n对输入文件中的每个整数n，如果F(n)能被3整除，输出yes，否则输出no。\n样例输入\n0\n1\n2\n3\n样例输出\nno\nno\nyes\nno\n参考代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint main() {\n    long long na;\n    while (cin &gt;&gt; na) {\n        if (na % 8 == 2 || na % 8 == 6)cout &lt;&lt; &quot;yes\\n&quot;;\n        else cout &lt;&lt; &quot;no\\n&quot;;\n    }\n \n    return 0;\n}\n1246: A006 分形（Fractal）\n题目描述\n分形是存在“自相似”的一个物体或一种量，从某种技术角度来说，这种“自相似”是全方位的。\n盒形分形定义如下：\n度数为1的分形很简单，为：\nX\n度数为2的分形为：\nX X\nX\nX X\n如果用B(n-1)代表度数为n-1的盒形分形，则度数为n的盒形分形可以递归地定义为：\nB(n-1) B(n-1)\nB(n-1)\nB(n-1) B(n-1)\n你的任务是输出度数为n的盒形分形。\n输入\n输入文件包含多个测试数据，每个测试数据占一行，包含一个正整数n，n ≤ 7。输入文件的最后一行为-1，代表输入结束。\n输出\n对每个测试数据，用符号“X”表示输出盒形分形。在每个测试数据对应的输出之后输出一个短划线符号“-”，在每行的末尾不要输出任何多余的空格，否则得到的是“格式错误”的结果。\n样例输入\n2\n3\n-1\n样例输出\nX X\n X\nX X\n-\nX X   X X\n X     X\nX X   X X\n   X X\n    X\n   X X\nX X   X X\n X     X\nX X   X X\n参考代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxlen = pow(3, 8);\n// string mp[maxlen];\nchar mp[maxlen][maxlen];\nint xpos[maxlen];\n \nvoid tocpyRec(int deg, int tox, int toy,int fillblank) {\n    int len = pow(3, deg - 1);\n    // 左上角标记\n    for (int i = 0;i &lt; len;i++) {\n        for (int j = 0;j &lt; len;j++) {\n            // cout &lt;&lt; mp[i][j] &lt;&lt; &quot;:&quot; &lt;&lt; i &lt;&lt; &quot;-&quot; &lt;&lt; j &lt;&lt; endl;\n            if (fillblank)\n                mp[tox * len + i][toy * len + j] = &#039; &#039;;\n            else\n                mp[tox * len + i][toy * len + j] = mp[i][j];\n        }\n    }\n}\n \nvoid fw(int deg) {\n    if (deg &gt; 1) {\n        fw(deg - 1);\n    }\n    for (int i = 0;i &lt; 3;i++) {\n        for (int j = 0;j &lt; 3;j++) {\n            if ((i + j) % 2 == 0 &amp;&amp; (i || j)) {\n                // 有内容的块坐标\n                tocpyRec(deg - 1, i, j, 0);\n            }\n            else if (i || j) {\n                tocpyRec(deg - 1, i, j, 1);\n            }\n        }\n    }\n}\n \nint main() {\n    mp[0][0] = &#039;X&#039;;\n    int n;\n    int flag = 0;\n    while (cin &gt;&gt; n &amp;&amp; n != -1) {\n        if (flag)cout &lt;&lt; &quot;-\\n&quot;;\n        flag = 1;\n        fw(n);\n        int len = pow(3, n - 1);\n        for (int i = 0;i &lt; len;i++) \n            for (int j = 0;j &lt; len;j++) \n                if (mp[i][j] == &#039;X&#039;)\n                    xpos[i] = j;\n        \n        for (int i = 0;i &lt; len;i++) {\n            for (int j = 0;j &lt;= xpos[i];j++) {\n                cout &lt;&lt; mp[i][j];\n            }\n            cout &lt;&lt; endl;\n        }\n    }\n \n    return 0;\n}\n \n1247: A007 二叉树\n题目描述\n如图所示，由正整数1, 2, 3, …组成了一棵无限大的二叉树。从某一个结点到根结点（编号是1的结点）都有一条唯一的路径，比如从10到根结点的路径是(10, 5, 2, 1)，从4到根结点的路径是(4, 2, 1)，从根结点1到根结点的路径上只包含一个结点1，因此路径就是(1)。对于两个结点x和y，假设他们到根结点的路径分别是(x1, x2, … ,1)和(y1, y2, … ,1)（这里显然有x = x1，y = y1），那么必然存在两个正整数i和j，使得从xi 和 yj开始，有xi = yj , xi + 1 = yj + 1, xi + 2 = yj + 2,… 现在的问题就是，给定x和y，要求xi（也就是yj）。\n\n输入\n输入有多行，每行包括两个正整数x和y，这两个正整数都不大于1000。\n输出\n每行输出只有一个正整数xi。\n样例输入\n10 4\n样例输出\n2\n参考代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 12;\nint ax[N], ay[N];\nint main() {\n    int x, y;\n    // 找重合的路径\n    while (cin &gt;&gt; x &gt;&gt; y) {\n        int kx = 0;\n        while (x) {\n            ax[kx++] = x % 2;\n            x /= 2;\n        }\n        int ky = 0;\n        while (y) {\n            ay[ky++] = y % 2;\n            y /= 2;\n        }\n        int kmii = kx &gt; ky ? ky : kx;\n        int ans = 0;\n        for (int i = 1;i &lt;= kmii;i++) {\n            if (ax[kx - i] == ay[ky - i]) {\n                ans &lt;&lt;= 1;\n                ans += ax[kx - i];\n            }\n            else break;\n        }\n        cout &lt;&lt; ans &lt;&lt; endl;\n    }\n \n    return 0;\n}\n \n1248: A008 波兰表达式\n题目描述\n波兰表达式是一种把运算符前置的算术表达式，例如普通的表达式2 + 3的波兰表示法为+ 2 3。波兰表达式的优点是运算符之间不必有优先级关系，也不必用括号改变运算次序，例如(2 + 3) * 4的波兰表示法为* + 2 3 4。本题求解波兰表达式的值，其中运算符包括+ - * /四个。\n输入\n输入第一行为一个整数n，然后是n行，每行为一组测试数据，其中运算符和运算数之间都用空格分隔，运算数是浮点数。\n输出\n输出n行，每行表达式的值，保留3位小数输出。\n样例输入\n1\n* + 11.0 12.0 + 24.0 35.0\n样例输出\n1357.000\n参考代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n \ndouble dox() {\n    string st;cin &gt;&gt; st;\n    switch (st[0])\n    {\n    case &#039;+&#039;:\n        return dox() + dox();\n    case &#039;-&#039;:\n        return dox() - dox();\n    case &#039;/&#039;:\n        return dox() / dox();\n    case &#039;*&#039;:\n        return dox() * dox();\n    default:break;\n    }\n    return atof(st.c_str());\n}\n \nint main() {\n    int t;cin &gt;&gt; t;\n    while (t--) {\n        cout &lt;&lt; fixed &lt;&lt; setprecision(3) &lt;&lt; dox() &lt;&lt; endl;\n    }\n \n    return 0;\n}\n1249: A009 放苹果\n题目描述\n把M个同样的苹果放在N个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法（用K表示）？注意：5，1，1和1，5，1 是同一种分法。\n输入\n第一行是测试数据的数目t（0 ⇐ t ⇐ 20）。以下每行均包含二个整数M和N，以空格分开。1 ⇐ M，N ⇐ 10。\n输出\n对输入的每组数据M和N，用一行输出相应的K。\n样例输入\n1\n7 3\n样例输出\n8\n参考代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 15;\nint dp[N][N];\n \nint divx(int apl, int pla) {\n    if (apl == 0 || pla == 1)\n        return dp[apl][pla] = 1;\n    if (pla &gt; apl)\n        return dp[apl][pla] = divx(apl, apl);\n    return dp[apl][pla] = divx(apl, pla - 1) + divx(apl - pla, pla);\n}\n \nint main() {\n    int t;cin &gt;&gt; t;\n    int m, n;\n    while (t--) {\n        cin &gt;&gt; m &gt;&gt; n;\n        cout &lt;&lt; divx(m, n) &lt;&lt; endl;\n    }\n \n    return 0;\n}\n1250: A010 递归练习1\n题目描述\n有5个人坐在一起，问第5个人多少岁？他说比第4个人大两岁。问第4个人的岁数，他说比第3个人大两岁。问第3个人的岁数，又说比第2个人大两岁。问第2个人的岁数，说比第1个人大两岁。最后问第1个人的岁数，他说是10岁。请问第5个人多少岁？\n输入\n输入有多行，每行3个整数，依次为m,n,k。m表示一共有几个人，n表示大的岁数，k表示第一个人的岁数。\n输出\n输出第m个人的岁数，每个一行。\n样例输入\n5 2 10\n样例输出\n18\n参考代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n \nint m, n, k;\nint age(int ind) {\n    if (ind == 1)return k;\n    return age(ind - 1) + n;\n}\n \nint main() {\n    while (cin &gt;&gt; m &gt;&gt; n &gt;&gt; k) {\n        cout &lt;&lt; age(m) &lt;&lt; endl;\n    }\n \n    return 0;\n}\n1251: A011 递归练习2\n题目描述\n根据递推式子C(m,n)=C(m-1,n)+C(m-1,n-1)，求组合数C(m,n)。注意递推的终止条件是C(m,1)=m；以及一些m和n取值的一些特殊情况，如m &lt; 0或n &lt; 0或m &lt; n时，C(m,n)值为0，m和n相等时，C(m,n)=1等。\n输入\n第1行是测试数据的组数n，后面跟着n行输入。每组测试数据占1行，包括一个正整数m和一个正整数n。\n输出\n输出组合数C(m,n)。\n样例输入\n2\n1 100\n100 1\n样例输出\n0\n100\n参考代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n \nint C(int m, int n) {\n    if (n == 1)return m;\n    if (m &lt; 0 || n &lt; 0 || m &lt; n)return 0;\n    if (m == n)return 1;\n    return C(m - 1, n) + C(m - 1, n - 1);\n}\n \nint main() {\n    int t;cin &gt;&gt; t;\n    while (t--) {\n        int m, n;cin &gt;&gt; m &gt;&gt; n;\n        cout &lt;&lt; C(m, n) &lt;&lt; endl;\n    }\n \n    return 0;\n}\n1252: A012 递归练习3\n题目描述\n核反应堆中有α和β两种粒子。每秒钟内一个α粒子可以产生3个β粒子，而一个β粒子可以产生1个α粒子和2个β粒子。若在t=0时刻反应堆中有一个α粒子，求t时刻反应堆中分别有多少个α粒子和β粒子。\n输入\n输入有多个整数t，每个一行。\n输出\n输出t时刻反应堆里分别有多少个α粒子和β粒子。\n样例输入\n6\n样例输出\n183 546\n参考代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n \npair&lt;int, int&gt; qut(int n) {\n    if (n == 0)return make_pair(1, 0);\n    int tempa = qut(n - 1).first, tempb = qut(n - 1).second;\n    int a = tempb, b = 3 * tempa + 2 * tempb;\n    return make_pair(a, b);\n}\n \nint main() {\n    int t;\n    while (cin &gt;&gt; t) {\n        cout &lt;&lt; qut(t).first &lt;&lt; &quot; &quot; &lt;&lt; qut(t).second &lt;&lt; endl;\n    }\n \n    return 0;\n}\n插一句：这里用了pair数据类型，或许有同学并没有接触到…一般函数会返回1个值，有时候想返回两个或以上的时候可以试试自定义struct数据类型，再去定义一个struct的函数，不过c++自有一个pair可以用，还是挺方便的。\n1253: A013 红与黑\n题目描述\n有一间长方形的房子，地上铺了红色、黑色两种颜色的正方形瓷砖。你站在其中一块黑色的瓷砖上，只能向相邻的黑色瓷砖移动。请写一个程序，计算你总共能够到达多少块黑色的瓷砖。\n输入\n包括多个数据集合。每个数据集合的第一行是两个整数W和H，分别表示x方向和y方向瓷砖的数量。W和H都不超过20。在接下来的H行中，每行包括W个字符。每个字符表示一块瓷砖的颜色，规则如下\n1）‘.’：黑色的瓷砖；\n2）‘#’：白色的瓷砖；\n3）‘@’：黑色的瓷砖，并且你站在这块瓷砖上。该字符在每个数据集合中唯一出现一次。\n当在一行中读入的是两个零时，表示输入结束。\n输出\n对每个数据集合，分别输出一行，显示你从初始位置出发能到达的瓷砖数(记数时包括初始位置的瓷砖)。\n样例输入\n6 9 \n....#. \n.....# \n...... \n...... \n...... \n...... \n...... \n#@...# \n.#..#. \n0 0\n样例输出\n45\n参考代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxh = 25;\nstring mp[maxh];\nint dx[4] = { -1,0,1,0 }, dy[4] = { 0,1,0,-1 };\n \nint w, h;\nint move(int x, int y, int allstep) {\n    for (int i = 0;i &lt; 4;i++) {\n        int nx = x + dx[i], ny = y + dy[i];\n        if (nx &gt; -1 &amp;&amp; nx&lt;h &amp;&amp; ny&gt;-1 &amp;&amp; ny &lt; w &amp;&amp; mp[nx][ny] == &#039;.&#039;){\n            mp[nx][ny] = &#039;#&#039;;\n            allstep = move(nx, ny, allstep + 1);\n        }\n    }\n    return allstep;\n}\n \nint main() {\n    while (cin &gt;&gt; w &gt;&gt; h &amp;&amp; w != 0 &amp;&amp; h != 0) {\n        int si, se;\n        for (int i = 0;i &lt; h;i++) {\n            cin &gt;&gt; mp[i];\n            if (mp[i].find(&quot;@&quot;) != string::npos) {\n                si = i;se = mp[i].find(&quot;@&quot;);\n            }\n        }\n        int steps = move(si, se, 1);\n        cout &lt;&lt; steps &lt;&lt; endl;\n    }\n \n    return 0;\n}\n1254: A014 城堡问题\n题目描述\n1 2 3 4 5 6 7\n#############################\n1 # | # | # | | #\n------------\n2 # # | # # # # #\n------------\n3 # | | # # # # #\n------------\n4 # # | | | | # #\n\n(图 1)\n‘#’ = Wall\n‘|’ = No wall\n’-’ = No wall\n图1是一个城堡的地形图。请你编写一个程序，计算城堡一共有多少房间，最大的房间有多大。城堡被分割成m*n(m≤50，n≤50)个方块，每个方块可以有0~4面墙。\n输入\n程序从标准输入设备读入数据。第一行是两个整数，分别是南北向、东西向的方块数。在接下来的输入行里，每个方块用一个数字(0≤p≤50)描述。用一个数字表示方块周围的墙，1表示西墙，2表示北墙，4表示东墙，8表示南墙。每个方块用代表其周围墙的数字之和表示。城堡的内墙被计算两次，方块(1,1)的南墙同时也是方块(2,1)的北墙。输入的数据保证城堡至少有两个房间。\n输出\n城堡的房间数、城堡中最大房间所包括的方块数。\n样例输入\n4\n7\n11 6 11 6 3 10 6\n7 9 6 13 5 15 5\n1 10 12 7 13 7 5\n13 11 10 8 10 12 13\n样例输出\n5\n9\n参考代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 60;\nint wall[N][N], fw[N][N];\nint roomnum = 0, sizea = 0;\nvoid dfs(int x, int y) {\n    // 查找点(x,y)的信息\n    if (fw[x][y]) return;\n    sizea++;\n    fw[x][y] = roomnum;\n    if ((wall[x][y] &amp; 1) == 0)dfs(x, y - 1);\n    if ((wall[x][y] &amp; 2) == 0)dfs(x - 1, y);\n    if ((wall[x][y] &amp; 4) == 0)dfs(x, y + 1);\n    if ((wall[x][y] &amp; 8) == 0)dfs(x + 1, y);\n}\n \nint main() {\n    int h, w;cin &gt;&gt; h &gt;&gt; w;\n    for (int i = 1;i &lt;= h;i++){\n        for (int j = 1;j &lt;= w;j++){\n            cin &gt;&gt; wall[i][j];\n        }\n    }\n    int maxroom = 0;\n    for (int i = 1;i &lt;= h;i++) {\n        for (int j = 1;j &lt;= w;j++) {\n            if (!fw[i][j]) {\n                // (i,j)没被找过(新的area)\n                roomnum++;\n                dfs(i, j);\n                maxroom = max(maxroom, sizea);\n                sizea = 0;\n            }\n        }\n    }\n    cout &lt;&lt; roomnum &lt;&lt; endl &lt;&lt; maxroom &lt;&lt; endl;\n \n    return 0;\n}\n \n/*\n  2\n1   4\n  8\n*/\n1255: A015 分解因式\n题目描述\n给出一个正整数a，要求分解成若干个正整数的乘积，即a = a1 * a2 * a3 * … * an，并且1 &lt; a1 ⇐ a2 ⇐ a3 ⇐ … ⇐ an，问这样的分解的种数有多少。注意到a = a也是一种分解。\n输入\n第1行是测试数据的组数n，后面跟着n行输入。每组测试数据占1行，包括一个正整数a (1 &lt; a &lt; 32768)。\n输出\nn行，每行输出对应一个输入。输出应是一个正整数，指明满足要求的分解的种数。\n样例输入\n2\n2\n20\n样例输出\n1\n4\n参考代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint ans = 0;\nvoid dfs(int tar, int now) {\n    if (tar != 1) {\n        for (int i = now;i &lt;= tar;i++)\n            if (tar % i == 0)\n                dfs(tar / i, i);\n    }\n    else {\n        ans++;return;\n    }\n}\n \nint main() {\n    int t;cin &gt;&gt; t;\n    while (t--) {\n        ans = 0;\n        int n;cin &gt;&gt; n;\n        if (n == 2) {\n            cout &lt;&lt; 1 &lt;&lt; endl;\n            continue;\n        }\n        dfs(n, 2);\n        cout &lt;&lt; ans &lt;&lt; endl;\n    }\n    \n \n    return 0;\n}\n1256: A016 数字拼凑\n题目描述\n现在给你这样一个任务，要求找出具有下列性质数的个数（包含输入的正整数 n）。\n先输入一个正整数 n(n ⇐ 500)，然后对此正整数按照如下方法进行处理：\n\n不作任何处理；\n在它的左边拼接一个正整数，但该正整数不能超过原数的一半或者是上一个被拼接数的一半；\n加上数后，继续按此规则进行处理，直到不能再加正整数为止。\n\n输入\n一个正整数n。\n输出\n一个正整数，表示具有该性质数的个数。\n样例输入\n6\n样例输出\n6\n参考代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nint fx[1010];\nint f(int n) {\n    if (n == 1)return 1;\n    if (fx[n])return fx[n];\n \n    int cnt = 0;\n    for (int i = 1;i &lt;= n / 2;i++)\n        cnt += f(i);\n    return fx[n] = cnt + 1;\n}\n \nint main() {\n    int n;\n    cin &gt;&gt; n;\n    cout &lt;&lt; f(n) &lt;&lt; endl;\n \n    return 0;\n}\n算法2排序B\n1257: B001 快乐的蠕虫\n题目描述\n有一只快乐的蠕虫居住在一个m×n大小的网格中。在网格的某些位置放置了k块石头。网格中的每个位置要么是空的，要么放置了一块石头。当蠕虫睡觉时，它在水平方向或垂直方向上躺着，把身体尽可能伸展开来。蠕虫的身躯既不能进入到放有石块的方格中，也不能伸出网格外。而且蠕虫的长度不会短于2个方格的大小。\n本题的任务是给定网格，要计算蠕虫可以在多少个不同的位置躺下睡觉。\n输入\n输入文件的第1行是一个整数t，1⇐t⇐11,表示测试数据的个数。每个测试数据的第1行为3个整数：m,n和k(0⇐m,n,k⇐200000),接下来有k行，每行为2个整数，描述了一块石头的位置（行和列，最左上角位置为（1,1））。\n输出\n对每个测试数据，输出占一行，为一个整数，表示蠕虫可以躺着睡觉的不同位置的数目。\n样例输入\n1\n5 5 6\n1 5\n2 3\n2 4\n4 2 \n4 3\n5 1\n样例输出\n9\n参考代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 1e5 + 50;\nint n, m, k;\n \nstruct node {\n    int x, y;\n    node(int x, int y) : x(x), y(y) {}\n};\nbool cmp1(node a, node b) {\n    if (a.x == b.x)\n        return a.y &lt; b.y;\n    return a.x &lt; b.x;\n}\nbool cmp2(node a, node b) {\n    if (a.y == b.y)\n        return a.x &lt; b.x;\n    return a.y &lt; b.y;\n}\n \nvector&lt;node&gt; a;\nint ans = 0;\nvoid search(bool f) {\n    for (int i = 1;i &lt; a.size();i++) {\n        int nx = a[i].x, ny = a[i].y;\n        int px = a[i - 1].x, py = a[i - 1].y;\n        if (f) {\n            if (nx != px)continue;\n            if (ny - py &gt; 2)ans++;\n        }\n        else {\n            if (ny != py)continue;\n            if (nx - px &gt; 2)ans++;\n        }\n    }\n}\n \nvoid solve() {\n    cin &gt;&gt; m &gt;&gt; n &gt;&gt; k;\n    ans = 0;\n    a.clear();\n    for (int i = 0;i &lt; k;i++) {\n        int x, y;cin &gt;&gt; x &gt;&gt; y;\n        a.push_back(node(x, y));\n    }\n    for (int i = 0;i &lt; m + 2;i++) {\n        a.push_back(node(i, 0));\n        a.push_back(node(i, n + 1));\n    }\n    for (int i = 0;i &lt; n + 2;i++) {\n        a.push_back(node(0, i));\n        a.push_back(node(m + 1, i));\n    }\n    sort(a.begin(), a.end(), cmp1);\n    search(true);\n    sort(a.begin(), a.end(), cmp2);\n    search(false);\n    cout &lt;&lt; ans &lt;&lt; endl;\n}\n \nint main() {\n    int t;cin &gt;&gt; t;\n    while (t--)\n        solve();\n \n    return 0;\n}\n1258: B002 单词重组\n题目描述\n在美国数以百万计的报纸中，有一种单词游戏称为猜词。游戏的目标是猜谜，为了找出答案中缺少的字母，有必要对4个单词的字母顺序重新调整。在本题中，你的任务是编写程序实现对单词中的字母顺序重新调整。\n输入\n输入文件包含4部分：\n（1） 一部字典，包含至少1个单词，至多100个单词，每个单词占一行；\n（2） 字典后是一行字符串“XXXXXX”，表示字典结束；\n（3） 一个或多个被打乱字母顺序的“单词”，每个单词占一行，你必须整理这些字母的顺序；\n（4） 输入文件的最后一样为字符串“XXXXXX”，代表输入文件结束。\n所有单词，包括字典中的单词和被打乱字母顺序的单词，都只包含小写英文字母，并且至少包含一个字母，至多包含6个字母。字典中的单词不一定是按顺序排列的，但保证字典中的单词是唯一的。\n输出\n对输入文件中每个被打乱字母顺序的单词w，按字母顺序输出字典中所有满足以下条件的单词的列表：通过调整单词w中的字母顺序，可以变成字典中的单词。列表中的每个单词占一行。如果列表为空（即单词w不能转换成字典中的任何一个单词），则输出一行字符串“NOT A VALID WORD”。以上两种情形都在列表后，输出一行包含6个星号字符的字符串，表示列表结束。\n样例输入\ntarp\ngiven\nscore\nrefund\nonly\ntrap\nwork\nearn\ncourse\npepper\npart\nXXXXXX\nresco\nnfudre\naptr\nsett\noresuc\nXXXXXX\n样例输出\nscore\n******\nrefund\n******\npart\ntarp\ntrap\n******\nNOT A VALID WORD\n******\ncourse\n******\n参考代码\n \n算法2查找C\n1264: C001 字符串计数\n题目描述\n给出m个字符串，要求输出重复n次的字符串有几个。\n输入\n先给定一个N，N≤100000，接着输入N个字符串。\n输出\n对于每组测试数据，输出若干行，每行两个正整数，第一个数表示重复的次数，第二个数表示在此重复次数下有几种不同的字符串。\n样例输入\n5\nBBA\nBBA\nBEA\nDEC\nCCF\n样例输出\n1 3\n2 1\n参考代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int N = 1e5 + 50;\nint nx[N];\n \nint main() {\n    int n;cin &gt;&gt; n;\n    map&lt;string, int&gt;sts;\n    string st;\n    while (n--) {\n        cin &gt;&gt; st;\n        if (sts.find(st) != sts.end()) {\n            map&lt;string, int&gt;::const_iterator it = sts.find(st);\n            int cnt = (*it).second;\n            sts[st] = ++cnt;\n        }\n        else\n            sts.insert(make_pair(st, 1));\n    }\n    map&lt;string, int&gt;::const_iterator it = sts.begin();\n    for (;it != sts.end();it++) {\n        nx[(*it).second]++;\n    }\n    for (int i = 1;i &lt;= sts.size();i++) {\n        if (nx[i])\n            cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; nx[i] &lt;&lt; endl;\n    }\n \n    return 0;\n}\n1265: C002 赌徒\n题目描述\nN个赌徒一起决定玩一个游戏：\n游戏刚开始的时候，每个赌徒把赌注放在桌上并遮住，侍者要查看每个人的赌注并确保每个人的赌注都不一样。如果一个赌徒没钱了，则他要借一些筹码，因此他的赌注为负数。假定赌注都是整数。\n最后赌徒们揭开盖子，出示他们的赌注。如果谁下的赌注是其他赌徒中某3个人下的赌注之和，则他是胜利者。如果有多于一个胜利者，则下的赌注最大的赌徒才是最终的胜利者。\n例如，假定赌徒为：Tom、Bill、John、Roger和Bush，他们下的赌注分别为：2、3、5、7和12 。因此最终获胜的是Bush（并且没有其他人是胜利者），因为他下的赌注为12，而其他的人下的赌注之和也等于12：2+3+7=12。\n输入\n输入文件中包含了多组赌徒下的赌注。每组赌注的数据第1行是一个整数n,1⇐n⇐1000,代表赌徒的个数，然后是他们下的赌注，每个人的赌注占一行，这些赌注各不相同，并且范围是[-536870912,+536870911]。输入文件的最后一行为0，代表输入结束。\n输出\n对每组赌注，输出胜利者下的赌注，如果没有解，则输出“no solution”。\n样例输入\n5\n2 \n3 \n5 \n7 \n12\n5\n2 \n16 \n64 \n256 \n1024\n0\n\n样例输出\n12\nno solution\n\n参考代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 1050;\n \nint n;\nint gbr[maxn];\nvoid solve() {\n\tfor (int i = 0;i &lt; n;i++) {\n\t\tcin &gt;&gt; gbr[i];\n\t}\n\tsort(gbr, gbr + n);\n\tfor (int pi = n - 1;pi &gt;= 3;pi--) {\n\t\tfor (int i = pi - 1;i &gt;= 2;i--) {\n\t\t\tfor (int j = i - 1;j &gt;= 1;j--) {\n\t\t\t\tfor (int k = j - 1;k &gt;= 0;k--) {\n\t\t\t\t\tint sum = gbr[i] + gbr[j] + gbr[k];\n\t\t\t\t\tif (sum == gbr[pi]) {\n\t\t\t\t\t\tcout &lt;&lt; gbr[pi] &lt;&lt; &quot;\\n&quot;;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout &lt;&lt; &quot;no solution\\n&quot;;\n}\n \nint main() {\n\t// int t;cin &gt;&gt; t;\n\t// while (t--)\n\twhile (cin &gt;&gt; n &amp;&amp; n)\n\t\tsolve();\n \n\treturn 0;\n}\n1266: C003 半素数\n题目描述\n素数的定义：对于一个大于１的正整数，如果除了１和它本身没有其他的正约数了，那么这个数就称为素数。例如，2,11,67,89是素数，8,20,27不是素数。\n半素数的定义：对于一个大于1的正整数，如果它可以被分解成2个素数的乘积，则称该数为半素数，例如6是一个半素数，而12不是。\n你的任务是判断一个数是否是半素数。\n输入\n输入文件中有多个测试数据，每个测试数据包含一个整数N，2⇐N⇐1,000,000。\n输出\n对每个测试数据，如果N是半素数，则输出YES，否则输出NO。\n样例输入\n3\n4\n6\n12\n\n样例输出\nNO\nYES\nYES\nNO\n\n参考代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 1e6 + 100;\nbool isnp[maxn];\nvector&lt;int&gt;primes;\nvoid Prime(int n) {\n    for (int i = 2;i &lt;= n;i++) {\n        if (!isnp[i])\n            primes.push_back(i);\n        for (int p : primes) {\n            if (p * i &gt; n)break;\n            isnp[p * i] = true;\n            if (i % p == 0)\n                break;\n        }\n    }\n}\nint main() {\n    Prime(maxn - 50);\n    int n;\n    while (cin &gt;&gt; n) {\n        bool f = false;\n        for (int i = 2;i * i &lt;= n;i++) {\n            if (n % i == 0 &amp;&amp; !isnp[i] &amp;&amp; !isnp[n / i]){\n                f = true;break;\n            }\n        }\n        f ? cout &lt;&lt; &quot;YES\\n&quot; : cout &lt;&lt; &quot;NO\\n&quot;;\n    }\n \n    return 0;\n}\n1267: C004 棍子的膨胀\n题目描述\n当一根长度为L的细长金属棍子加热n度后，它会膨胀到一个新的长度L’=(1+n*C)*L,其中C为该金属的热膨胀系数。\n当一根细长的金属棍子固定在两堵墙之间，然后加热，则棍子会变成圆弓形，棍子的原始位置为该圆弓形的弦，如图所示。\n![1699328671418](D:\\Tencent&amp;&amp;\\新建文件夹\\WeChat Files\\wxid_j7esazuly79422\\FileStorage\\Temp\\1699328671418.png)\n图 膨胀的金属棍子（上为膨胀前，下为膨胀后）\n你的任务是计算棍子中心的偏离距离。\n输入\n输入文件包含多个测试数据，每个测试数据占一行。每个测试数据包含3个非负整数：棍子的初始长度，单位为毫米；加热前后的温差，单位为度；该金属的热膨胀系数。输入数据保证膨胀的长度不超过棍子本身长度的一半。输入文件的最后一行为3个负数，代表输入结束，该测试数据不需处理。\n输出\n对每个测试数据，输出金属棍子中心加热后偏离的距离，单位为毫米，保留小数点后3位有效数字。\n样例输入\n1000 100 0.0001\n15000 10 0.00006\n10 0 0.001\n-1 -1 -1\n\n样例输出\n61.329\n225.020\n0.000\n\n参考代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst double eps = 1e-12;\nconst double pi = 3.1415926535;\nint main() {\n    double l, t, c;\n    while (cin &gt;&gt; l &gt;&gt; t &gt;&gt; c) {\n        if (l &lt; 0 &amp;&amp; t &lt; 0 &amp;&amp; c &lt; 0)break;\n        double nl = (1.0 + t * c) * l;\n        double dr = pi, dl = 0.0;\n        while (1) {\n            double mid = (dr + dl) / 2;\n            double r = l / (sin(mid / 2) * 2);\n            if (dr - dl &lt; eps) {\n                double ans = r - r * cos(mid / 2.0);\n                printf(&quot;%.3lf\\n&quot;, ans);\n                break;\n            }\n            double bar = mid * r;\n            if (bar &gt; nl)dr = mid;\n            else dl = mid;\n        }\n    }\n \n    return 0;\n}\n1268: C005 电缆主\n题目描述\n奶牛的居民决定举办一场编程区域赛。裁判委员会自告奋勇并宣称要举办有史以来最公正的比赛。队员们的电脑采用“星型”拓扑结构互连（也就是说要把所有电脑都连在一个中央集线器上）。为了让比赛尽可能公正，裁判委员会的头头们决定：将比赛队员们平均地安置在集线器周围，距离集线器有一个相同的距离。\n裁判委员会为了采买网络电缆，联系了一家当地的网络方案提供商，要求他们提供一些登等长的电缆。这些电缆应越长越好，从而使得队员们与其他队员的距离越大。\n这家公司的电缆工来办这件事。他知道仓库里每个电缆的长度（精确到厘米）。他每次切割电缆时的精度也是厘米。但他现在不知切多少，所以完全茫然中。\n你要写个程序计算出一条电缆最多多长使之可以提供一定能够数目的电缆，帮着这位电缆工完成任务。\n输入\n第一行是两个整数N和K，N（1⇐N⇐10000）是仓库里的电缆数，K（1⇐K⇐10000）是所需电缆数。接下来的N行每一行一个数，表示电缆的长度（单位是米）。电缆长度最小为1米，最大为100千米。每个表示长度的数均表示为带两位小数的浮点数（即精确到厘米）。\n输出\n所需的电缆一条最长有多少米（精确到厘米，即保留小数点两位）。如果不能提供K条大于等于1厘米的等长电缆就输出“0.00”。\n样例输入\n4 11\n8.02\n7.43\n4.57\n5.39\n\n样例输出\n2.00\n\n参考代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 10050;\nint len[maxn];\nint n, k;\nint cnt(int l) {\n    int ret = 0;\n    for (int i = 0;i &lt; n;i++) {\n        ret += len[i] / l;\n    }\n    return ret;\n}\nint main() {\n    cin &gt;&gt; n &gt;&gt; k;\n    int left = 1, right = 0;\n    for (int i = 0;i &lt; n;i++) {\n        double ni;cin &gt;&gt; ni;\n        ni *= 100;\n        right = max(right, (int)ni);\n        len[i] = (int)ni;\n    }\n    if (cnt(1) &lt; k) {\n        cout &lt;&lt; &quot;0.00\\n&quot;;\n        return 0;\n    }\n    int ans = 0;\n    while (left &lt;= right) {\n        int mid = (left + right) / 2;\n        if (cnt(mid) &lt; k)right = mid - 1;\n        else {\n            ans = mid;\n            left = mid + 1;\n        }\n    }\n    printf(&quot;%.2lf&quot;, 1.0 * ans / 100);\n \n    return 0;\n}\n1269: C006 宝贝鱼\n题目描述\n你刚刚从奶牛搬到一个大城市里。这里的人说一种让人理解不能的外文方言。万幸，你有本字典可以帮助你理解。\n输入\n输入包含多达100，000个字典词条，然后是一个空行，然后是一条消息，这条消息包含多达100，000个单词。每个词条占一行，先是一个英语单词，然后是一个空格，然后是一个外文方言词。一个方言词在字典中出现不超过一次。消息是一个外文方言词序列，一个词占一行。每个词是一个最长为10的小写字母序列。\n输出\n将消息的外文词翻译成英语，一个词一行。查不到的词应该翻译成“eh”。\n样例输入\ndog ogday\ncat atcay\npig igpay\nfroot ootfray\nloops oopslay\n\natcay\nittenkay\noopslay\n\n样例输出\ncat\neh\nloops\n\n参考代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 10050;\nmap&lt;string, string&gt;mp;\nint main() {\n    string s1, s2;\n    while (1) {\n        char t = getchar();\n        if (t == &#039;\\n&#039;)break;\n        cin &gt;&gt; s1 &gt;&gt; s2;\n        s1.insert(s1.begin(), t);\n        mp.insert(make_pair(s2, s1));\n        cin.get();\n    }\n    string word;\n    while (cin &gt;&gt; word) {\n        auto pos = mp.find(word);\n        if (pos != mp.end()) {\n            cout &lt;&lt; pos-&gt;second &lt;&lt; endl;\n        }\n        else cout &lt;&lt; &quot;eh\\n&quot;;\n    }\n \n    return 0;\n}\n1270: C007 星空\n题目描述\n将夜空抽象成二维平面，每个星星一个(X,Y)坐标。这些点可以形成多少正方形？\n输入\n多组输入。对于每组数据，第一行是n（1⇐n⇐1000）表示已知星星数，然后是n行，每行一个坐标值。坐标绝对值小于20000。n=0表示结束。\n输出\n对于每组数据输出形成正方形的个数。\n样例输入\n4\n1 0\n0 1\n1 1\n0 0\n0\n\n样例输出\n1\n\n参考代码\n \n算法2动态规划D\n1272: D001 数字三角形\n题目描述\n7\n3 8\n8 1 0\n2 7 4 4\n4 5 2 6 5\n上图给出了一个数字三角形。从三角形的顶部到底部有很多条不同的路径。对于每条路径，把路径上面的数加起来可以得到一个和，你的任务就是找到最大的和。\n注意：路径上的每一步只能从一个数走到下一层上和它最近的左边的那个数或者右边的那个数。\n输入\n输入的第一行是一个整数N (1 &lt; N ⇐ 100)，给出三角形的行数。下面的N行给出数字三角形。数字三角形上的数的范围都在0和100之间。\n输出\n输出最大的和。\n样例输入\n5\n7\n3 8\n8 1 0 \n2 7 4 4\n4 5 2 6 5\n样例输出\n30\n参考代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 120;\nll number[maxn][maxn];\nll dp[maxn][maxn]; // 记录走到(i,j)点时最好的和\n \nint main() {\n    int n;\n    while (cin &gt;&gt; n) {\n        for (int i = 1;i &lt;= n;i++)\n            for (int j = 1;j &lt;= i;j++)\n                cin &gt;&gt; number[i][j];\n        for (int i = 1;i &lt; n;i++)\n            dp[n][i] = number[n][i];\n        for (int i = n;i &gt; 1;i--) {\n            for (int j = 1;j &lt;= i;j++) {\n                dp[i - 1][j] = max(dp[i][j], dp[i][j + 1]) + number[i - 1][j];\n            }\n        }\n        cout &lt;&lt; dp[1][1] &lt;&lt; endl;\n    }\n \n    return 0;\n}\n1273: D002 最长上升子序列\n题目描述\n一个数的序列bi，当b1 &lt; b2 &lt; … &lt; bS的时候，我们称这个序列是上升的。对于给定的一个序列(a1, a2, …, aN)，我们可以得到一些上升的子序列(ai1, ai2, …, aiK)，这里1 ⇐ i1 &lt; i2 &lt; … &lt;iK ⇐ N。比如，对于序列(1, 7, 3, 5, 9, 4, 8)，有它的一些上升子序列，如(1, 7), (3, 4, 8)等等。这些子序列中最长的长度是4，比如子序列(1, 3, 5, 8)。\n你的任务，就是对于给定的序列，求出最长上升子序列的长度。\n输入\n输入有很多组，每组输入的第一行是序列的长度N (1 ⇐ N ⇐ 1000)。第二行给出序列中的N个整数，这些整数的取值范围都在0到10000。\n输出\n输出每组的最长上升子序列的长度。\n样例输入\n7\n1 7 3 5 9 4 8\n6\n2 3 4 1 6 5\n样例输出\n4\n4\n参考代码\n#include&lt;iostream&gt;\n#include&lt;vector&gt;\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 1010;\nint a[maxn];\n// int dp[maxn];\nint main() {\n    int n;\n    while (cin &gt;&gt; n) {\n        for (int i = 1;i &lt;= n;i++)cin &gt;&gt; a[i];\n        vector&lt;int&gt; lmax;\n        lmax.push_back(a[1]);\n        for (int i = 2;i &lt;= n;i++) {\n            if (a[i] &gt; lmax.back()) {\n                lmax.push_back(a[i]);\n            }\n            else if (a[i] &lt; lmax.back()) {\n                int l = 0, r = lmax.size() - 1;\n                \n                while (l &lt; r) {\n                    int md = (l + r) / 2;\n                    if (lmax[md] &lt;= a[i])l = md + 1;\n                    else r = md;\n                }\n                lmax[l] = a[i];\n            }\n            // for (int j = 0;j &lt; lmax.size();j++)\n            //     cout &lt;&lt; lmax[j] &lt;&lt; &quot; &quot;;\n            // cout &lt;&lt; endl;\n        }\n        cout &lt;&lt; lmax.size() &lt;&lt; endl;\n    }\n \n    return 0;\n}\n \n1274: D003 Help Jimmy\n题目描述\n“Help Jimmy” 是在下图所示的场景上完成的游戏：\n\n场景中包括多个长度和高度各不相同的平台。地面是最低的平台，高度为零，长度无限。\nJimmy老鼠在时刻0从高于所有平台的某处开始下落，它的下落速度始终为1米/秒。当Jimmy落到某个平台上时，游戏者选择让它向左还是向右跑，它跑动的速度也是1米/秒。当Jimmy跑到平台的边缘时，开始继续下落。Jimmy每次下落的高度不能超过MAX米，不然就会摔死，游戏也会结束。\n设计一个程序，计算Jimmy到地面时可能的最早时间。\n输入\n第一行是测试数据的组数t（0 ⇐ t ⇐ 20）。每组测试数据的第一行是四个整数N，X，Y，MAX，用空格分隔。N是平台的数目（不包括地面），X和Y是Jimmy开始下落的位置的横竖坐标，MAX是一次下落的最大高度。接下来的N行每行描述一个平台，包括三个整数，X1[i]，X2[i]和H[i]。H[i]表示平台的高度，X1[i]和X2[i]表示平台左右端点的横坐标。1⇐ N ⇐ 1000，-20000 ⇐ X, X1[i], X2[i] ⇐ 20000，0 &lt; H[i] &lt; Y ⇐ 20000（i = 1..N）。所有坐标的单位都是米。\nJimmy 的大小和平台的厚度均忽略不计。如果Jimmy 恰好落在某个平台的边缘，被视为落在平台上。所有的平台均不重叠或相连。测试数据保Jimmy一定能安全到达地面。\n输出\n对输入的每组测试数据，输出一个整数，Jimmy到地面时可能的最早时间。\n样例输入\n1\n3 8 17 20\n0 10 8\n0 10 13\n4 14 3\n样例输出\n23\n参考代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 2e4 + 20;\nstruct PT {\n    int x1, x2, h;\n    bool operator&lt;(const PT&amp; P)const {\n        return h &gt; P.h;\n    }\n}pt[maxn];\nint n, x, y, mx;\nint findnext(int id, int x) {\n    // 寻找x下的第一块板\n    for (int i = id + 1;i &lt;= n + 1;i++) {\n        if (pt[i].x1 &lt;= x &amp;&amp; pt[i].x2 &gt;= x) {\n            return i;\n        }\n    }\n    return -1;\n}\nint fun[maxn];\nint dfs(int id, int p, int from) {\n    // cout &lt;&lt; id &lt;&lt; &quot; &quot; &lt;&lt; p &lt;&lt; &quot; &quot; &lt;&lt; from &lt;&lt; endl;\n    int lp = pt[id].x1, rp = pt[id].x2;\n    // 当前是否到达终点\n    if (id == n + 1)\n        return 0;\n    int lenl = -1, lenr = -1;\n    // 左走\n    int lpid = findnext(id, lp);\n    if (lpid != -1 &amp;&amp; pt[id].h - pt[lpid].h &lt;= mx) {\n        // 可走\n        lenl= dfs(lpid, lp, id);\n    }\n    // 右走\n    int rpid = findnext(id, rp);\n    if (rpid != -1 &amp;&amp; pt[id].h - pt[rpid].h &lt;= mx) {\n        // 可走\n        lenr= dfs(rpid, rp, id);\n    }\n    if (lenl != -1 &amp;&amp; lenr != -1)\n        return fun[id] = min(lenl + p - lp, lenr + rp - p);\n    else if (lenl == -1)\n        return fun[id] = lenr + rp - p;\n    else if (lenr == -1)\n        return fun[id] = lenl + p - lp;\n    else\n        return 0;\n}\n \nint main() {\n    int t;cin &gt;&gt; t;\n    while (t--) {\n        cin &gt;&gt; n &gt;&gt; x &gt;&gt; y &gt;&gt; mx;\n        pt[0].x1 = x;pt[0].x2 = x;pt[0].h = y;\n        for (int i = 1;i &lt;= n;i++) {\n            cin &gt;&gt; pt[i].x1 &gt;&gt; pt[i].x2 &gt;&gt; pt[i].h;\n        }\n        pt[n + 1].h = 0;pt[n + 1].x1 = -maxn;pt[n + 1].x2 = maxn;\n        sort(pt, pt + n + 1);\n        // 从高到低排列\n        dfs(0, x, -1);\n        cout &lt;&lt; y + fun[0] &lt;&lt; endl;\n    }\n \n    return 0;\n}\n \n1275: D004 最长公共子序列\n题目描述\n我们称序列Z = &lt; z1, z2, …, zk &gt;是序列X = &lt; x1, x2, …, xm &gt;的子序列当且仅当存在严格上升的序列&lt; i1, i2, …, ik &gt;，使得对j = 1, 2, … ,k, 有xij = zj。比如Z = &lt; a, b, f, c &gt; 是X = &lt; a, b,c, f, b, c &gt;的子序列。\n现在给出两个序列X和Y，你的任务是找到X和Y的最大公共子序列，也就是说要找到一个最长的序列Z，使得Z既是X的子序列也是Y的子序列。\n输入\n输入包括多组测试数据。每组数据包括一行，给出两个长度不超过200的字符串，表示两个序列。两个字符串之间由若干个空格隔开。\n输出\n输入包括多组测试数据。每组数据包括一行，给出两个长度不超过200的字符串，表示两个序列。两个字符串之间由若干个空格隔开。\n样例输入\nabcfbc abfcab\nprogramming contest\nabcd mnp\n样例输出\n4\n2\n0\n参考代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn = 220;\nint dp[maxn][maxn];\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    string s, t;\n    while (cin &gt;&gt; s &gt;&gt; t) {\n        s = &quot; &quot; + s;t = &quot; &quot; + t;\n        memset(dp, 0, sizeof(dp));\n        for (int i = 1;i &lt; s.size();i++) {\n            for (int j = 1;j &lt; t.size();j++) {\n                if (s[i] == t[j])\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                else\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n        cout &lt;&lt; dp[s.size() - 1][t.size() - 1] &lt;&lt; endl;\n    }\n \n    return 0;\n}\n1276: D005 陪审团的人选\n题目描述\n在遥远的国家佛罗布尼亚，嫌犯是否有罪，须由陪审团决定。陪审团是由法官从公众中挑选的。先随机挑选n个人作为陪审团的候选人，然后再从这n个人中选m人组成陪审团。选m人的办法是：\n控方和辩方会根据对候选人的喜欢程度，给所有候选人打分，分值从0到20。为了公平起见，法官选出陪审团的原则是：选出的m个人，必须满足辩方总分和控方总分的差的绝对值最小。如果有多种选择方案的辩方总分和控方总分的之差的绝对值相同，那么选辩控双方总分之和最大的方案即可。最终选出的方案称为陪审团方案。\n输入\n输入包含多组数据。每组数据的第一行是两个整数n和m，n是候选人数目，m是陪审团人数。注意，1⇐n⇐200, 1⇐m⇐20而且m⇐n。接下来的n行，每行表示一个候选人的信息，它包含2个整数，先后是控方和辩方对该候选人的打分。候选人按出现的先后从1开始编号。两组有效数据之间以空行分隔。最后一组数据n=m=0。\n输出\n对每组数据，先输出一行，表示答案所属的组号, 如 ‘Jury #1’, ‘Jury #2’, 等。接下来的一行要象例子那样输出陪审团的控方总分和辩方总分。再下来一行要以升序输出陪审团里每个成员的编号，两个成员编号之间用空格分隔。每组输出数据须以一个空行结束。\n样例输入\n4 2\n1 2\n2 3\n4 1\n6 2\n0 0\n样例输出\nJury #1\nBest jury has value 6 for prosecution and value 4 for defence:\n2 3\n参考代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n \nconst int N = 205;\nconst int inf = 0x3f;\nint dp[N][25][4 * N], a[N], b[N];\nvector&lt;int&gt; mark;\n \nint main()\n{\n    int n, m, T = 1;\n    while (cin &gt;&gt; n &gt;&gt; m &amp;&amp; n) {\n        mark.clear();\n        memset(dp, -inf, sizeof(dp));\n        dp[0][0][400] = 0;\n        for (int i = 1;i &lt;= n;i++) {\n            cin &gt;&gt; a[i] &gt;&gt; b[i];\n        }\n        for (int i = 1;i &lt;= n;i++) {\n            for (int j = 0;j &lt;= m;j++) {\n                for (int k = 0;k &lt;= 800;k++) {\n                    dp[i][j][k] = dp[i - 1][j][k];\n                    int tt = k - a[i] + b[i];\n                    if (tt &lt; 0 || tt &gt;= 800)\n                        continue;\n                    if (j == 0)\n                        continue;\n                    dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][tt] + a[i] + b[i]);\n                }\n            }\n        }\n        int t = 0;\n        while (dp[n][m][t + 400] &lt; 0 &amp;&amp; dp[n][m][-t + 400] &lt; 0) t++;\n        if (dp[n][m][t + 400] &gt; dp[n][m][-t + 400]) t += 400;\n        else t = 400 - t;\n \n        int nn = n, mm = m, cnt = 0;\n        while (mm) {\n            if (dp[nn][mm][t] == dp[nn - 1][mm][t]) {\n                nn--;\n            }\n            else {\n                mark.push_back(nn);\n                t -= a[nn] - b[nn];\n                nn--;mm--;\n                cnt++;\n            }\n        }\n        int sum1 = 0, sum2 = 0;\n        for (int i = 0;i &lt; cnt;i++) {\n            sum1 += a[mark[i]];\n            sum2 += b[mark[i]];\n        }\n        cout &lt;&lt; &quot;Jury #&quot; &lt;&lt; T++ &lt;&lt; &quot;\\nBest jury has value &quot; &lt;&lt; sum1 &lt;&lt; &quot; for prosecution and value &quot; &lt;&lt; sum2 &lt;&lt; &quot; for defence:\\n&quot;;\n        for (int i = cnt - 1;i &gt;= 0;i--)\n            cout &lt;&lt; mark[i] &lt;&lt; &#039; &#039;;\n        cout &lt;&lt; &quot;\\n\\n&quot;;\n    }\n \n    return 0;\n}\n1277: D006 最大和\n题目描述\n给定一个n个整数的集合：A={a1, a2,…, an}，我们如下定义函数d(A)：\nd(A)=\\max\\limits_{1\\leq s_1\\leq t_1\\leq s_2\\leq t_2\\leq n}\n\\begin{aligned}\n\\sum_{i=s_1}^{t_1}a_i+\\sum_{j=s_2}^{t_2}a_j\\\\ \n\\end{aligned}\n你的任务就是计算函数d(A)的函数值。\n提示：对于样例，我们选择{2,2,3,-3,4} 和 {5}，进行想加得到函数d(A)的函数值。\n输入量大，建议使用scanf();\n输入\n输入包含 T(⇐30)个样例，在输入的第一行即是整数T。每个样例包含两行，第一行是整数 n(2⇐n⇐50000)，第二行包含了n个整数： a1, a2, …, an. (|ai| ⇐ 10000)。\n输出\n对于每个输入样例，输出一行，即如上定义函数d(A)的函数值。\n样例输入\n1\n10\n1 -1 2 2 3 -3 4 -4 5 -5\n样例输出\n13\n参考代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn = 2200;\nint a[maxn];\nint leftt[maxn], rightt[maxn];\nint lmax[maxn], rmax[maxn];\nint main() {\n    int t;cin &gt;&gt; t;\n    while (t--) {\n        int n;cin &gt;&gt; n;\n        for (int i = 1;i &lt;= n;i++)\n            cin &gt;&gt; a[i];\n        leftt[1] = a[1];rightt[n] = a[n];\n        lmax[1] = a[1];rmax[n] = a[n];\n        for (int i = 2;i &lt;= n;i++) {\n            leftt[i] = max(leftt[i - 1] + a[i], a[i]);\n            lmax[i] = max(lmax[i - 1], leftt[i]);\n        }\n        for (int i = n - 1;i &gt; 0;i--){\n            rightt[i] = max(rightt[i + 1] + a[i], a[i]);\n            rmax[i] = max(rmax[i + 1], rightt[i]);\n        }\n        int ans = a[1];\n        for (int i = 2;i &lt;= n;i++)\n            ans = max(ans, lmax[i - 1] + rmax[i]);\n        cout &lt;&lt; ans &lt;&lt; endl;\n    }\n \n    return 0;\n}\n1278: D007 最大子矩阵\n题目描述\n给你一个二维矩阵，元素是整数，有正有负。一个子矩阵就是最小1*1最大包含这个矩阵本身的矩阵。一个矩阵的和就是矩阵中所有元素求和，最大子矩阵就是所有子矩阵中和最大的那个字矩阵。下面是一个例子：\n0 -2 -7 0\n9 2 -6 2\n-4 1 -4 1\n-1 8 0 -2\n最大子矩阵在左下角\n9 2\n-4 1\n-1 8\n和值是15。\n输入\n输入的第一行是整数N，即表示要输入一个N * N的整数矩阵。接下来是N^2 个整数，每个整数之间被空格或者空行分开，这些整数即为矩阵中的数，按照列优先的顺序排列，即第一行整数从左至右输入，第二行从左至右输入…. 第n行从左至右输入。N不会大于100，矩阵中的整数范围为 [-127,127]。\n输出\n输出最大矩阵的和。\n样例输入\n4\n0 -2 -7 0 9 2 -6 2\n-4 1 -4  1 -1 8  0 -2\n样例输出\n15\n参考代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn = 120;\nint rec[maxn][maxn];\nint pre[maxn][maxn];\nint dp[maxn][maxn];\nint main() {\n    int n;cin &gt;&gt; n;\n    pre[0][0] = 0;\n    // 二维前缀和\n    for (int i = 1;i &lt;= n;i++) {\n        for (int j = 1;j &lt;= n;j++) {\n            cin &gt;&gt; rec[i][j];\n            pre[i][j] = pre[i - 1][j] + pre[i][j - 1] - pre[i - 1][j - 1] + rec[i][j];\n        }\n    }\n    // for (int i = 1;i &lt;= n;i++) {\n    //     for (int j = 1;j &lt;= n;j++) {\n    //         cout &lt;&lt; pre[i][j] &lt;&lt; &quot; &quot;;\n    //     }\n    //     cout &lt;&lt; endl;\n    // }\n    int ans = -200;\n    for (int xi = 1;xi &lt;= n;xi++) {\n        for (int yi = 1;yi &lt;= n;yi++) {\n            for (int xj = xi;xj &lt;= n;xj++) {\n                for (int yj = yi;yj &lt;= n;yj++) {\n                    int sum = pre[xj][yj] - pre[xi - 1][yj] - pre[xj][yi - 1] + pre[xi - 1][yi - 1];\n                    ans = max(ans, sum);\n                }\n            }\n        }\n    }\n    cout &lt;&lt; ans &lt;&lt; endl;\n \n    return 0;\n}\n算法2搜索E\n1281: E001 数的划分\n题目描述\n将整数n分成k份，且每份不能为空，任意两种分法不能相同（不考虑顺序）。\n例如：n=7，k=3，下面三种分法被认为是相同的。\n1,1,5；1,5,1；5,1,1；\n问有多少种不同的分法。\n输入\n每组数据由一行上的2个整数n，k构成（6&lt;n≤200,2≤k≤6）。\n输出\n对每组测试数据，输出不同的分法整数。\n样例输入\n7 3\n样例输出\n4\n参考代码\n#include&lt;bits/stdc++.h&gt;\n#define AUTHOR &quot;DODOLA&quot;\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 220;\nll dp[maxn][maxn];  // i个小球放入j个盒子没有空盒的方法数\nint main() {\n    int n, k;\n    cin &gt;&gt; n &gt;&gt; k;\n    for (int i = 1;i &lt;= n;i++) {\n        dp[i][1] = 1;dp[i][0] = 1;\n    }\n    for (int i = 2;i &lt;= n;i++) {\n        for (int j = 2;j &lt;= k;j++) {\n            if (i &gt; j)\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - j][j];\n            else\n                dp[i][j] = dp[i - 1][j - 1];\n        }\n    }\n    cout &lt;&lt; dp[n][k] &lt;&lt; endl;\n \n    return 0;\n}\n1282: E002 闪避湖泊\n题目描述\n农夫约翰的农场在最近的一场暴风雨中被水淹没。但保险公司仅根据他得农场中最大的“湖泊”的大小赔偿一个数额。\n农场可表示为N行M列的长方形网格，（1≤N≤100,1≤M≤100）。网格中的每个单元或是干的或是被淹没的，且恰有K个单元被水淹没，（1≤K≤N*M）。正如人们所希望的，湖泊是一个中间单元，它与其他的单元共享一条长边（不是角落）。任何与中间单元共享一条长边或者与连通单元共享一条长边的单元是一个连通单元，是湖泊的一部分。\n输入\n有多组数据。每组的第1行有3个整数N，M和K。第2行到第K+1行，是整数R和C，表示被淹没的位置。\n输出\n对每组测试数据，输出有最大湖泊的单元的数目。\n样例输入\n3 4 5\n3 2\n2 2\n3 1\n2 3\n1 1\n样例输出\n4\n参考代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 150;\n \nint n, m, k;\nbool fd[maxn][maxn];\nint mv[4][2] = { {1, 0}, {-1, 0}, {0, 1}, {0, -1} };\n \nint ans;\nint dfs(int r, int c) {\n    if (r&lt;1 || r&gt;n || c&lt;1 || c&gt;m || !fd[r][c])return 0;\n    fd[r][c] = false;\n    int ret = 1;\n    for (int i = 0;i &lt; 4;i++) {\n        ret += dfs(r + mv[i][0], c + mv[i][1]);\n    }\n    return ret;\n}\n \nvoid solve() {\n    fill(fd[0], fd[0] + maxn * maxn, false);\n    ans = 0;\n    for (int ki = 0;ki &lt; k;ki++) {\n        int r, c;cin &gt;&gt; r &gt;&gt; c;\n        fd[r][c] = true;\n    }\n    for (int i = 1;i &lt;= n;i++) {\n        for (int j = 1;j &lt;= m;j++) {\n            if (fd[i][j]) {\n                ans = max(ans, dfs(i, j));\n            }\n        }\n    }\n    cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;;\n}\n \nint main() {\n    while (cin &gt;&gt; n &gt;&gt; m &gt;&gt; k)\n        solve();\n \n    return 0;\n}\n/*\n0 1 0 0 0\n0 0 1 1 0\n0 1 1 0 0\n*/\n1283: E003 信道分配\n题目描述\n当无线电台在一个非常大的区域上传播信号时，为了每个接收器都能得到较强信号，使用转发器转发信号。然而，需要仔细地选择每个转发器使用的频道，以使附近的转发器不彼此干扰。如果邻近的转发器使用不同的频道，条件就得到满足。\n因为无线电波的频谱是宝贵的资源，转发器所需频道的数量应减到最少。编程任务：读取转发器网络的描述信息，并计算出所需频道的最小使用量。\n输入\n输入包含许多转发器网络图。每幅图的第一行是转发器数目（1~26）。转发器用连续的大写字母表示，从A开始。例如，10个转发器的名称分别是A，B，C，…，I和J。当转发器的个数是0时，表示输入结束。\n转发器数目之后，是其邻近关系的列表。每行的格式为\nA：BCDH\n表示转发器B、C、D和H与转发器A邻近。第一行描述与转发器A邻近的，第二行描述与B邻近的，直到描述完所有的转发器。如果某个转发器不与其他转发器相邻，它的形式为\nA：\n转发器依字母顺序列出。\n注意：相邻是对称的关系；如果A与B相邻，那么B与A也相邻。因为转发器位于水平面内，由相邻的转发器构成的网络图没有相交的线。\n输出\n对于每幅图（除了最后一个没有转发器），输出一行，是转发器不互相干扰所需的最少频道数。输出格式参考样例输出。注意：频道数为1的话，“channel”为单数。\n样例输入\n2\nA:\nB:\n4\nA:BC\nB:ACD\nC:ABD\nD:BC\n0\n样例输出\n1 channel needed.\n3 channels needed.\n参考代码\n#include&lt;iostream&gt;\n#include&lt;stdio.h&gt;\n#include&lt;string.h&gt;\n#include&lt;algorithm&gt;\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 120;\nbool fd[maxn][maxn];\nint ind[30], t;\nbool dfs(int from, int clr) {\n    // 从from着色\n    for (int i = 0;i &lt; clr;i++) {\n        bool f = true;ind[from] = i;\n \n        for (int j = 0;j &lt; from;j++) {\n            if (ind[j] == i &amp;&amp; fd[from][j]) {\n                f = false;\n                break;\n            }\n        }\n \n        if (f &amp;&amp; (from == t - 1 || dfs(from + 1, clr)))\n            return true;\n    }\n    return false;\n}\n \nint main() {\n    while (cin &gt;&gt; t) {\n        cin.get();\n        if (t == 0)break;\n        memset(fd, 0, sizeof(fd));\n        memset(ind, 0, sizeof(ind));\n        bool f = true;\n        for (int i = 0;i &lt; t;i++) {\n            string msg;cin &gt;&gt; msg;\n            if (msg.size() == 2)\n                continue;\n            f = false;\n            int pid = msg[0] - &#039;A&#039;;\n            for (int j = 2;j &lt; msg.size();j++) {\n                fd[pid][msg[j] - &#039;A&#039;] = true;\n                fd[msg[j] - &#039;A&#039;][pid] = true;\n            }\n        }\n        if (f)\n            cout &lt;&lt; &quot;1 channel needed.\\n&quot;;\n        else if (dfs(1, 2))\n            cout &lt;&lt; &quot;2 channels needed.\\n&quot;;\n        else if (dfs(1, 3))\n            cout &lt;&lt; &quot;3 channels needed.\\n&quot;;\n        else\n            cout &lt;&lt; &quot;4 channels needed.\\n&quot;;\n    }\n \n    return 0;\n}\n1284: E004 移动的骑士\n题目描述\n你的一个朋友正在研究骑士旅行问题（TKP）。在一个有n个方格的棋盘上，你得找到一条最短的封闭骑士旅行的路径，使能够遍历每个方格一次。他认为问题的最困难部分在于，对两个给定的方格，确定骑士移动所需的最小步数。所以你帮助他编写一个程序，解决这个“困难的”部分。你的任务是：输入有两个方格a和b，确定骑士在最短路径上从a到b移动的次数。\n国际象棋中的骑士在棋盘上可移动的范围如下图：\n\n输入\n输入包含一组或多组测试例。每个测试例一行，是两个方格，用空格隔开。棋盘上的一个方格用一个字符串表示，字母（a-h）表示列，数字（1-8）表示行。\n输出\n对每个测试例，输出一行：“To get from xx to yy takes n knight moves.”。\n样例输入\ne2 e4\na1 b2\nb2 c3\na1 h8\na1 h7\nh8 a1\nb1 c3\nf6 f6\n样例输出\nTo get from e2 to e4 takes 2 knight moves.\nTo get from a1 to b2 takes 4 knight moves.\nTo get from b2 to c3 takes 2 knight moves.\nTo get from a1 to h8 takes 6 knight moves.\nTo get from a1 to h7 takes 5 knight moves.\nTo get from h8 to a1 takes 6 knight moves.\nTo get from b1 to c3 takes 1 knight moves.\nTo get from f6 to f6 takes 0 knight moves.\n参考代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 150;\n \nstring fs, ts;\nint mv[8][2] = { {-2, -1}, {-2, 1}, {-1, -2}, {-1, 2}, {1, -2}, {1, 2}, {2, -1}, {2, 1} };\n \nvoid bfs(int x1, int y1, int x2, int y2) {\n    if (x1 == x2 &amp;&amp; y1 == y2) {\n        cout &lt;&lt; &quot;To get from &quot; &lt;&lt; fs &lt;&lt; &quot; to &quot; &lt;&lt; ts &lt;&lt; &quot; takes 0 knight moves.\\n&quot;;\n        return;\n    }\n    int stp = 0;\n    queue&lt;pair&lt;int, int&gt;&gt; q;\n    q.push({ x1, y1 });\n    while (!q.empty()) {\n        queue&lt;pair&lt;int, int&gt;&gt; qs;\n        while (!q.empty()) {\n            auto [x, y] = q.front();q.pop();\n            for (int i = 0;i &lt; 8;i++) {\n                int nx = x + mv[i][0], ny = y + mv[i][1];\n                if (nx &lt; 0 || nx &gt;= 8 || ny &lt; 0 || ny &gt;= 8)continue;\n                if (nx == x2 &amp;&amp; ny == y2) {\n                    cout &lt;&lt; &quot;To get from &quot; &lt;&lt; fs &lt;&lt; &quot; to &quot; &lt;&lt; ts &lt;&lt; &quot; takes &quot; &lt;&lt; stp + 1 &lt;&lt; &quot; knight moves.\\n&quot;;\n                    return;\n                }\n                qs.push({ nx, ny });\n            }\n        }\n        stp++;\n        q = qs;\n    }\n \n}\n \nvoid solve() {\n    int x1 = fs[0] - &#039;a&#039;, y1 = fs[1] - &#039;1&#039;, x2 = ts[0] - &#039;a&#039;, y2 = ts[1] - &#039;1&#039;;\n    bfs(x1, y1, x2, y2);\n}\n \nint main() {\n    while (cin &gt;&gt; fs &gt;&gt; ts)\n        solve();\n \n    return 0;\n}\n1285: E005 图像周长\n题目描述\n病理学实验室的技术人员需要分析幻灯片的数字图像。幻灯片上有许多要分析的目标，由鼠标单击确定一个目标。目标边界的周长是一个有用的测量参数。编程任务：确定选中目标的在周长。\n数字化的幻灯片是一个矩形的网格，里面有点’.’，表示空的地方；有大写字母‘X’，表示目标的一部分。简单网格如下所示\n\n方格中的一个X是指一个完整的网络方形区域，包括其边界和目标本身。网格中心的X与其边界上8个方向的X都是相邻的。任何两个相邻的X，其网格方形区域在边界或者拐角处是重叠的，所以他们的网格方形区域是相邻的。\n一个目标是由一系列相邻X的网格方形区域连接起来构成的。在网格1中，一个目标填充了全部网格；在网格2中有两个目标，其中一个目标只占左下角的一个网格方形区域，其余的X属于另一个目标。\n技术人员总是能单击到一个X，以选中包含该X的目标，记录单击时的坐标。行列号是从左上角开始，从1开始编号的。在网格1中，技术人员可以单击行2和列2选择目标；在网格2中，单击行2和列3就可以选中较大目标，单击行4和列3就不能选中任何目标。\n一个有用的统计参数是目标的周长。假定每个X的每条边上有一个方形的单元。在网格1中目标的周长是8（4个边，每个边上有2个方形的单元）；在网格2中，较大目标的周长是18，如下图所示。\n\n目标中不会包含任何完全封闭的孔，所以下面最左边的网格不会出现，应该是右边的网格样式。\n\n输入\n输入有多组网格。对每个网格，第一行是网格的行列数（rows，columns），鼠标单击的行列号（row，column），其整数范围都是1-20.接下来就是rows行，由字符‘.’和‘X’构成。\n当一行是4个0时，标志输入结束。一行中的4个数字之间各有一个空格。网格数据的行之间没有空行。\n输出\n对每个网络输出一行，是选中目标的周长。\n样例输入\n2 2 2 2\nXX\nXX\n6 4 2 3\n.XXX\n.XXX\n.XXX\n...X\n..X.\nX...\n5 6 1 3\n.XXXX.\nX....X\n..XX.X\n.X...X\n..XXX.\n0 0 0 0\n样例输出\n8\n18\n40\n参考代码\n#include&lt;bits/stdc++.h&gt;\n#define AUTHOR &quot;DODOLA&quot;\n// #include&lt;queue&gt;\n// #include&lt;iostream&gt;\n// #include&lt;string&gt;\nusing namespace std;\nconst int maxn = 250;\ntypedef long long ll;\nint r, c, x, y;\nvector&lt;string&gt;mp(maxn);\n \nint mv[8][2] = {\n    {1,0},{0,1},{-1,0},{0,-1},\n    {1,1},{1,-1},{-1,-1},{-1,1},\n};\nint ans;\nbool ck[maxn][maxn];\n \nvoid dfs(int px, int py) {\n    // cout &lt;&lt; px &lt;&lt; &quot; &quot; &lt;&lt; py &lt;&lt; endl;\n    // cout &lt;&lt; ans &lt;&lt; endl;\n    if (mp[px][py] != &#039;X&#039; || ck[px][py])return;\n    ck[px][py] = true;\n \n    for (int j = 0;j &lt; 4;j++) {\n        int xj = px + mv[j][0], yj = py + mv[j][1];\n        if (mp[xj][yj] != &#039;X&#039;)\n            ans++;\n    }\n \n    for (int i = 0;i &lt; 8;i++) {\n        int xi = px + mv[i][0];\n        int yi = py + mv[i][1];\n        dfs(xi, yi);\n    }\n}\n \nstring s0(&#039;.&#039;, maxn - 1);\nvoid solve() {\n    ans = 0;\n    fill(ck[0], ck[0] + sizeof(ck), false);\n    fill(mp.begin(), mp.end(), s0);\n    for (int i = 1;i &lt;= r;i++) {\n        cin &gt;&gt; mp[i];\n        mp[i] = &quot; &quot; + mp[i] + &quot; &quot;;\n    }\n    dfs(x, y);\n    cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;;\n}\n \nint main() {\n    mp[0] = s0;\n    while (cin &gt;&gt; r &gt;&gt; c &gt;&gt; x &gt;&gt; y) {\n        if (!r &amp;&amp; !c &amp;&amp; !x &amp;&amp; !y)break;\n        solve();\n    }\n \n    return 0;\n}\n1286: E006 移动的骑士\n题目描述\nSomurolov先生是一个国际象棋高手，他声称在棋盘上将骑士棋子从一点移动到另外一点，没有人比他快，你敢挑战他吗？\n你的任务是编程计算出将一个骑士棋子从一点移动到另外一点，最少需要移动的步数。显而易见，这样你就有赢得Somurolov先生的机会。国际象棋中的骑士在棋盘上可移动的范围如下图：\n\n输入\n首先输入测试样例的个数n。接下来是n组输入数据，每组测试数据由三行整数组成：第一行是棋盘的边长l (4 ⇐ l ⇐ 300)，整个棋盘的面积也就是 ll；第二行和第三行分别是骑士棋子的初始位置和目标位置，表示为整数对形式{0, …, l-1}{0, …, l-1}。保证棋子的初始和目标位置是棋盘上的合法位置。\n输出\n对于每一个输入的测试样例，请你算出骑士从初始位置移动到目标位置最小移动步数。如果初始位置和目标位置相同，那么骑士移动的距离就是0。最后单独一行输出所求距离。\n样例输入\n1\n8 0 0\n7 0\n样例输出\n5\n参考代码\n#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;cstring&gt;\n#define AUTHOR &quot;DODOLA&quot;\nusing namespace std;\n \nstruct P {\n    int x;\n    int y;\n    int step;\n};\n \nint mv[8][2] = {\n    {1, 2}, {2, 1}, {-1, 2}, {-2, 1},\n    {1, -2}, {2, -1}, {-1, -2}, {-2, -1}\n};\n \nint bfs(int n, int x1, int y1, int x2, int y2)\n{\n    if (x1 == x2 &amp;&amp; y1 == y2)\n    {\n        return 0;\n    }\n    bool gnd[n][n];\n    queue&lt;P&gt; q;\n    memset(gnd, 0, sizeof(gnd));\n    P start, node;\n    start.x = x1;\n    start.y = y1;\n    start.step = 0;\n    q.push(start);\n    while (!q.empty()) {\n        int x0, y0, step;\n        start = q.front();\n        q.pop();\n        x0 = start.x;\n        y0 = start.y;\n        step = start.step;\n        for (int j = 0; j &lt; 8; j++) {\n            int x3 = x0 + mv[j][0];\n            int y3 = y0 + mv[j][1];\n            if (x3 == x2 &amp;&amp; y3 == y2)\n                return step + 1;\n            if (x3 &gt;= 0 &amp;&amp; x3 &lt; n &amp;&amp; y3 &gt;= 0 &amp;&amp; y3 &lt; n &amp;&amp; !gnd[x3][y3]) {\n                node.x = x3;\n                node.y = y3;\n                node.step = step + 1;\n                q.push(node);\n                gnd[x3][y3] = 1;\n            }\n        }\n    }\n    return 0;\n}\n \nint main() {\n    int t;\n    cin &gt;&gt; t;\n    while (t--) {\n        int x1, y1, x2, y2, n;\n        cin &gt;&gt; n &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;\n        cout &lt;&lt; bfs(n, x1, y1, x2, y2) &lt;&lt; endl;\n    }\n    return 0;\n}\n \n \n1287: E007 寻找M\n题目描述\n给出一个整数n，编程求出一个非零整数m，使得m是n的倍数，并且m的十进制表示中只有1和0。给出的n不大于200并且肯定存在对应的m，m是十进制数并且不大于100位。\n输入\n输入包含多组测试数据。每组测试数据只有一个整数n (1 ⇐ n ⇐ 200)。整数0标志输入的结束。\n输出\n对于每个n输出对应的整数m，m的十进制表示不多于100位。如果对于一个n存在多个合法的m，你只需输出一个即可。\n样例输入\n2\n6\n0\n样例输出\n10\n1110\n参考代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 10;\nint n;\n \nbool ck(int x) {\n    while (x) {\n        if (x % 10 == 0 || x % 10 == 1) {\n            x /= 10;\n            continue;\n        }\n        else return false;\n    }\n    return true;\n}\n \nvoid solve() {\n    for (int i = 1;;i++) {\n        int m = i * n;\n        bool f = ck(m);\n        if (f) {\n            cout &lt;&lt; m &lt;&lt; endl;\n            return;\n        }\n    }\n}\n \nint main() {\n    while (cin &gt;&gt; n) {\n        if (n == 0)break;\n        solve();\n    }\n \n    return 0;\n}\n1288: E008 红与黑\n题目描述\n有一个矩形的房间，房间铺着正方形的地砖。每个地砖被涂上红色或者黑色。初始时你站在房间里的某个黑色地砖上，你每次只能移动到相邻的四个地砖之一，即上下左右移动，并且你每次只能移动到黑色的地砖上，不能走到红色地砖。\n编程计算出按照上述要求你能走到的黑色地砖的个数。\n输入\n输入包含多组测试数据。每组测试数据第一行包括2个整数W和H；W和H是房间的宽度和长度，分别表示为房间的x和y坐标轴。W和H不大于20。接下来是H行每行W个地砖的房间，每个地砖表示如下：\n‘.’——黑色地砖\n‘#’——红色地砖\n‘@’ ——你在房间里的初始位置（房间只出现一次）。\n输入的最后一行是两个整数0，不用处理。\n输出\n对每个测试样例，输出一行，即你能走到的黑色地砖的个数（包括你初始站在的黑色地砖）。\n样例输入\n6 9\n....#.\n.....#\n......\n......\n......\n......\n......\n#@...#\n.#..#.\n11 9\n.#.........\n.#.#######.\n.#.#.....#.\n.#.#.###.#.\n.#.#..@#.#.\n.#.#####.#.\n.#.......#.\n.#########.\n...........\n0 0\n样例输出\n45\n59\n参考代码\n#include &lt;iostream&gt;\n#include &lt;queue&gt;\n#include &lt;cstring&gt;\nconst int maxn = 120;\nusing namespace std;\nint r, c;\nchar mp[maxn][maxn];\nint mv[4][2] = {\n    {0,1},{0,-1},{1,0},{-1,0},\n};\n \nint ans;\n \nvoid dfs(int x, int y) {\n    if (x &lt; 0 || x == c || y &lt; 0 || y == r)return;\n    if (mp[x][y] == &#039;#&#039;)return;\n    ans++;\n    mp[x][y] = &#039;#&#039;;\n    for (int i = 0;i &lt; 4;i++) {\n        int xi = x + mv[i][0];\n        int yi = y + mv[i][1];\n        dfs(xi, yi);\n    }\n}\n \nvoid solve() {\n    ans = 0;\n    int px, py;\n    for (int i = 0;i &lt; c;i++) {\n        for (int j = 0;j &lt; r;j++) {\n            cin &gt;&gt; mp[i][j];\n            if (mp[i][j] == &#039;@&#039;) {\n                px = i;py = j;\n            }\n        }\n    }\n    dfs(px, py);\n    cout &lt;&lt; ans &lt;&lt; endl;\n}\n \nint main() {\n    while (cin &gt;&gt; r &gt;&gt; c) {\n        if (!r &amp;&amp; !c)break;\n        solve();\n    }\n \n    return 0;\n}\n1289: E009 小木棒\n题目描述\nGeorge有一些长度相等的木棒，他随意的将这些木棒切成长度最多是50的小木棒。麻烦来了，他现在想将这些杂乱的小木棒恢复到原来的木棒，但是他忘记了原来到木棒的数量和长度。请你帮助他设计一个程序计算出原来木棒可能的最小长度，所有小木棒的长度均表示为大于0的整数。\n输入\n每组输入数据包括两行。第一行是George切后小木棒的个数，最多有64根小木棒；第二行是这些小木棒的长度，这些长度表示为空格分开的整数。输入样例以整数0表示结束。\n输出\n输出一行，即为原始木棒可能的最小长度。\n样例输入\n9\n5 2 1 5 2 1 5 2 1\n4\n1 2 3 4\n0\n样例输出\n6\n5\n参考代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn = 80;\n \nint n, a[maxn], maxv, tot, vis[maxn], k, len;\n \nbool cmp(int a, int b) {\n    return a &gt; b;\n}\nbool dfs(int i, int rest, int p) {\n    if (i &gt; k)\n        return 1;\n    int fail = 0;\n    for (int x = p + 1;x &lt;= n;x++) {\n        if (!vis[x]) {\n            if (a[x] == a[fail]) continue;\n            if (rest &gt; a[x]) {\n                vis[x] = 1;\n                bool w = dfs(i, rest - a[x], x);\n                vis[x] = 0;\n                if (!w) fail = x;\n                if (w) return 1;\n            }\n            else if (rest == a[x]) {\n                vis[x] = 1;\n                bool w = dfs(i + 1, len, 0);\n                vis[x] = 0;\n                return w;\n            }\n            if (p == 0) return 0;\n        }\n    }\n    return 0;\n}\n \nvoid solve() {\n    fill(vis, vis + n + 5, 0);\n    maxv = tot = 0;\n    for (int i = 1;i &lt;= n;i++) {\n        cin &gt;&gt; a[i];\n        maxv = max(maxv, a[i]);\n        tot += a[i];\n    }\n    sort(a + 1, a + 1 + n, cmp);\n    for (len = maxv;len &lt;= tot;len++) {\n        if (tot % len == 0) {\n            k = tot / len;\n            if (dfs(1, len, 0)) {\n                cout &lt;&lt; len &lt;&lt; endl;\n                break;\n            }\n        }\n    }\n}\n \nint main() {\n    while (cin &gt;&gt; n &amp;&amp; n)\n        solve();\n \n    return 0;\n}\n算法2贪心F\n1290: F001 木棒加工问题\n题目描述\n现有n根木棒，已知它们的长度和重量。要用一部木工机一根一根地加工这些木棒。该机器在加工过程中需要一定的准备时间，是用于清洗机器，调整工具和模板的。木工机需要的准备时间如下：\n（1） 第一根木棒需要1min的准备时间；\n（2） 在加工了一根长为l，重为w的木棒之后，接着加工一根长为l’（l≤l’），重为w’（w≤w’）的木棒是不需要任何准备时间的。否则需要一分钟的准备时间。\n给定n根木棒，你要找到最少的准备时间。例如现在有长和重分别为（4,9），（5,2），（2,1），（3,5）和（1,4）的五根木棒，那么所需准备时间最少为2min，顺序为（1,4），（3,5），（4,9），（2,1），（5,2）。\n输入\n输入有多组测试例。输入数据的第一行是测试例的个数（T）。每个测试例两行：第一行是一个整数n（1≤n≤5000），表示有多少根木棒；第二行包括n*2个整数，表示l1,w1,l2,w2,l3,w3,…,ln,wn,全部不大于10000，其中li和wi表示第i根木棒的长度和重量。数据由一个或多个空格分隔。\n输出\n输出是以分钟为单位的最少准备时间，一行一个。\n样例输入\n3 \n5 \n4 9 5 2 2 1 3 5 1 4 \n3 \n2 2 1 1 2 2 \n3 \n1 3 2 2 3 1\n样例输出\n2\n1\n3\n参考代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 1e5 + 50;\n \nint n;\nbool ck[maxn];\nvoid solve() {\n    cin &gt;&gt; n;\n    fill(ck, ck + 5050, false);\n    vector&lt;pair&lt;int, int&gt;&gt; len;\n    for (int i = 0; i &lt; n; i++) {\n        int l, w;cin &gt;&gt; l &gt;&gt; w;\n        len.push_back(make_pair(l, w));\n    }\n    sort(len.begin(), len.end());\n    int cnt = 0, ans = 0;\n    while (cnt &lt; n) {\n        ans++;\n        int ki = 0;\n        int li = 0, wi = 0;\n        for (int i = 0;i &lt; n;i++) {\n            if (!ck[i]) {\n                ki = i;\n                li = len[i].first, wi = len[i].second;\n                ck[i] = true;\n                cnt++;\n                break;\n            }\n        }\n        // cout &lt;&lt; ki &lt;&lt; &quot; &quot; &lt;&lt; li &lt;&lt; &quot; &quot; &lt;&lt; wi &lt;&lt; endl;\n        for (int i = 0;i &lt; n;i++) {\n            if (ck[i])continue;\n            if (li &lt;= len[i].first &amp;&amp; wi &lt;= len[i].second) {\n                ck[i] = true;\n                cnt++;\n                li = len[i].first, wi = len[i].second;\n            }\n        }\n    }\n    cout &lt;&lt; ans &lt;&lt; endl;\n}\nint main() {\n    int t;cin &gt;&gt; t;\n    while (t--)\n        solve();\n \n    return 0;\n}\n1291: F002 装箱\n题目描述\n一个工厂生产的产品形状都是长方体，高度都是h，主要有1x1，2x2，3x3，4x4，5x5，6x6等6种。这些产品在邮寄时被包装在一个6x6xh的长方体包裹中。由于邮费很贵，工厂希望减小每个订单的包裹数量以增加他们的利润。因此他们需要一个好的程序帮他们解决这个问题。你的任务就是设计这个程序。\n输入\n输入包括多组测试数据，每一行代表一个订单。每个订单里的一行包括六个整数，用空格隔开，从小到大分别为这6种产品的数量。6个0表示文件结束。\n输出\n针对每个订单输出一个整数，占一行，代表对应的订单所需的最小包裹数。没有多余的空行。\n样例输入\n0 0 4 0 0 1\n7 5 1 0 0 0\n0 0 0 0 0 0\n样例输出\n2\n1\n参考代码\n// #include&lt;bits/stdc++.h&gt;\n#include&lt;iostream&gt;\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 2e5 + 50;\n \nint n;\nint b1, b2, b3, b4, b5, b6;\nint l3[4] = { 0,7,6,5 };\nint l2[4] = { 0,5,3,1 };\nint l1[9] = { 0,32,28,24,20,16,12,8,4 };\nvoid solve() {\n    int ans = b6 + b5 + b4 + (b3 + 3) / 4;\n    int n2 = 5 * b4 + l2[b3 % 4];;\n    if (n2 &gt;= b2) {\n        int n1 = b5 * (36 - 25) + (n2 - b2) * 4 + l3[b3 % 4];\n        if (n1 &lt; b1)\n            ans += (b1 - n1 + 35) / 36;\n    }\n    else {\n        int m2 = b2 - n2;\n        ans += (m2 + 8) / 9;\n        int n1 = b5 * (36 - 25) + l3[b3 % 4] + l1[m2 % 9];\n        if (n1 &lt; b1)\n            ans += (b1 - n1 + 35) / 36;\n    }\n    cout &lt;&lt; ans &lt;&lt; endl;\n}\n \nint main() {\n    while (cin &gt;&gt; b1 &gt;&gt; b2 &gt;&gt; b3 &gt;&gt; b4 &gt;&gt; b5 &gt;&gt; b6 &amp;&amp; (b1 || b2 || b3 || b4 || b5 || b6))\n        solve();\n}\n1292: F003 移动桌子\n题目描述\n著名的ACM（Advanced Computer Maker）公司租用了一层有400个房间的办公楼，结构如下。\n\n这层楼沿着走廊南北向的两边各有200个房间。最近，公司要做一次装修，需要在各个办公室之间搬运办公桌。由于走廊狭窄，办公桌都很大，走廊里一次只能通过一张办公桌。必须制定计划提高搬运效率。经理制定如下计划：一张办公桌从一个房间移动到另一个房间最多用十分钟。当从房间i移动一张办公桌到房间j，两个办公室之间的走廊都会被占用。所以，每10分钟内，只要不是同一段走廊，都可以在房间之间移动办公桌。为了说得更清楚一些，经理举例说明哪些情况可以同时移动，哪些情况不能同时移动。\n\n每个房间，只有一张办公桌进出。现在，经理想找到一种方案，使移动桌子的事情尽快完成。请编写程序解决经理的难题。\n输入\n输入数据有T组测试例，在第一行给出测试例个数（T）。每个测试例的第一行是一个整数N（1≤N≤200），表示要搬运办公桌的次数。接下来N行，每行两个正整数s和t，表示一张桌子，是从房间号码s移到房间号码t。有多组输入数据，输入第一行为一个表示输入数据总数的整数N，然后是N组输入数据。\n输出\n每组输入都有一行的输出数据，为一整数T，表示完成任务所花费的最少时间。\n样例输入\n2 \n4 \n10 20 \n30 40 \n50 60 \n70 80 \n2 \n1 3 \n2 200\n样例输出\n10\n20\n参考代码\n// #include&lt;bits/stdc++.h&gt;\n#include&lt;iostream&gt;\n#include&lt;algorithm&gt;\n#include&lt;vector&gt;\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 2e5 + 50;\n \nint n;\nvoid solve() {\n    cin &gt;&gt; n;\n    int pass[220] = {};\n    for (int i = 1;i &lt;= n;i++) {\n        int x, y;cin &gt;&gt; x &gt;&gt; y;\n        x = (x + 1) / 2;\n        y = (y + 1) / 2;\n        if (x &gt; y) {\n            x = x ^ y;y = x ^ y;x = x ^ y;\n        }\n        for (int j = x;j &lt;= y;j++) {\n            pass[j]++;\n        }\n    }\n    int ans = *max_element(pass + 1, pass + 201);\n    cout &lt;&lt; 10 * ans &lt;&lt; endl;\n}\n \nint main() {\n    int t;cin &gt;&gt; t;\n    while (t--)\n        solve();\n}\n1293: F004 基因集合\n题目描述\n随着大量的基因组DNA序列数据被获得，它对于了解基因越来越重要（基因组DNA的一部分，是负责蛋白质合成的）。众所周知，在基因组序列中，由于存在垃圾的DNA中断基因的编码区，真核生物（相对于原核生物）的基因链更加复杂。也就是说，一个基因被分成几个编码片段（称为外显子）。虽然在蛋白质的合成过程中，外显子的顺序是固定的，但是外显子的数量和长度可以是任意的。\n大多数基因识别算法分为两步：第一步，寻找可能的外显子；第二步，通过寻找一条拥有尽可能多的外显子的基因链，尽可能大地拼接一个基因。这条链必须遵循外显子出现在基因组序列中的顺序。外显子i在外显子j的前面的条件是i的末尾必须在j开头的前面。\n本题的目标是，给定一组可能的外显子，找出一条拥有尽可能多的外显子链，拼接成一个基因。\n输入\n给出几组输入实例。每个实例的开头是基因组序列中可能的外显子数n(0 &lt; n &lt; 1000)。接着的n行，每行是一对整数，表示外显子在基因组序列中的起始和结束位置。假设基因组序列最长为50000。当一行是0时，表示输入结束。\n输出\n对于每个实例，找出最可能多的外显子链，输出链中的外显子，并占一行。假如有多条链，但外显子数相同，那么可以输出其中任意一条。\n样例输入\n6\n340 500\n220 470\n100 300\n880 943\n525 556\n612 776\n0\n样例输出\n3 1 5 6 4\n参考代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 2e5 + 50;\n \nstruct node {\n    int x;int y;\n    int i;\n    bool operator&lt;(const node&amp; p)const {\n        return x &lt; p.x;\n    }\n}wxz[maxn];\n \nint n;\nvoid solve() {\n    for (int i = 1;i &lt;= n;i++) {\n        cin &gt;&gt; wxz[i].x &gt;&gt; wxz[i].y;\n        wxz[i].i = i;\n    }\n    sort(wxz + 1, wxz + 1 + n);\n    vector&lt;node&gt;ans;\n    ans.push_back(wxz[1]);\n    for (int i = 2;i &lt;= n;i++) {\n        struct node ni = ans.back();\n        if (ni.y &gt; wxz[i].y) {\n            ans.pop_back();ans.push_back(wxz[i]);\n        }\n        else if (ni.y &lt; wxz[i].x) {\n            ans.push_back(wxz[i]);\n        }\n    }\n    for (int i = 0;i &lt; ans.size();i++) {\n        cout &lt;&lt; ans[i].i &lt;&lt; &quot; &quot;;\n    }\n    cout &lt;&lt; &#039;\\n&#039;;\n}\n \nint main() {\n    while (cin &gt;&gt; n &amp;&amp; n)\n        solve();\n}\n1294: F005 主框架\n题目描述\n多纳先生是ACM（Agent on Computing of Mathematics，计算数学代理商）大型计算机的管理员。该代理商为一些公司承担在大型计算机上的计算工作，完成工作后获得报酬，因此大型计算机对这个代理商来说太重要了。多纳先生需要为这些在大型计算机上运行的作业安排顺序。一旦要运行某个作业，他就要检查运行该作业所需要的空闲资源。如果空闲资源足够的话，他就为该作业分配这些资源；否则就将该作业挂起，直至有足够的资源投入运行。\n刚开始他并不熟悉这项工作，把事情搞得很乱。日积月累，他就胜任这项工作了。而且他还总结了一套规则：\n（1）大型计算机有M个CPU和N大小的内存空间可供分配。\n（2）对等待运行的作业有一个等待队列。可以假定这个队列足够长，能够存放所有等待运行的作业。\n（3）假定作业Ji需要Ai个CPU和Bi的内存空间，在时间Ti到达等待队列，需要在时间Ui之前完成。成功运行后，代理商可以获得Vi()的报酬；如果能在规定的时间之前完成，则每小时还可以额外获得Wi()的奖金；如果工期拖延，则每小时赔偿Xi()。例如，假定一个作业的报酬是10，时限8小时，每拖欠一小时罚2。如果该作业在10小时完成，则代理商可以获得10-(10-8)*2=6。\n（4）当一个作业开始后，就独占了分配给它的CPU和内存空间，不能同时再分配给其他作业。当该作业运行结束后，这些资源被释放。如果资源足够多，同时可以运行多个作业。\n（5）为了最大限度地发挥大型计算机的计算能力，每个作业在开始运行后刚好一小时就完成。你可以假定每个作业的运行时间就是一小时。\n（6）没有作业运行时，机器空闲，一直到一个作业进入作业等待队列。\n（7）如果有多个作业进入作业等待队列，则报酬高的作业优先。可以假定这些作业的报酬都不相等。\n（8）如果某个作业的空闲CPU或内存空间不能满足，它就是被挂起一小时，也不占用任何资源。一小时后，再次为该作业检查资源，而不需要考虑等待队列里的其他作业。如果资源仍不满足要求，那就继续挂起一小时，把资源分配给其他在等待队列里的作业。否则，该作业将独占CPU和存储空间并投入运行。\n（9）当多个作业挂起时，采取先来先服务的原则。\n使用这些规则，多纳先生把事情安排得井井有条。现在除了日常公务外，代理商要求他根据作业列表计算收入。给定某个时间F，计算出已经完成的作业和应该被完成的作业。对作业Ji，如果它的时限Ui&gt;F并且仍未完成，就不需要统计收入。对已经完成的作业或Ui≤F的作业都要统计。如果工作没有完成，它不会给代理商带来报酬，但到这个时间F为止的罚款仍要计算。\n他不会程序设计，又不想手工做，现在你帮助他解决这个问题。\n输入\n有多组测试例。每个测试例描述大型计算机的资源和作业列表，第一行是整数F（0≤F≤10000），表示时限。接下来的一行是三个整数M，N和L（M，N，L≥0），M是机器CPU的数量，N是存储空间的大小，L是作业等待队列中作业的数量。最多有10000个作业。\n后面的L行是作业的信息。描述作业Ji的数据是7个整数：Ai，Bi，Ti，Ui，Vi，Wi，Xi。Ai和Bi（Ai，Bi≥0）指出了该作业对CPU和内存的需求。Ti和Ui表示作业的到达时间和时限（0≤Ti≤Ui）。Vi，Wi，Xi分别是工作的报酬、奖励和罚款。\n一个空的测试例（F=0）表示输入结束，该测试点无需处理。\n输出\n根据作业列表计算总收入。对每个测试例，输出测试例编号，一个冒号，一个空格，然后是收入。\n测试例之间有一个空行。\n注意：对尚未投入运行的、且时限超过F的作业，不必统计。\n样例输入\n10\n4 256 3\n1 16 2 3 10 5 6\n2 128 2 4 30 10 5\n2 128 2 4 20 10 5\n0\n样例输出\nCase 1: 74\n参考代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 1e5 + 20;\n \nstruct JOB {\n    int a, b, t, u, v, w, x;\n    bool ok;\n    JOB(int a, int b, int t, int u, int v, int w, int x) :a(a), b(b), t(t), u(u), v(v), w(w), x(x), ok(false) {}\n    bool operator&lt;(const JOB&amp; N)const {\n        if (N.t == t)\n            return v &gt; N.v;\n        return t &lt; N.t;\n    }\n};\nint ind = 1;\nint f;\nint m, n, l;\nint mi, ni;\nvoid solve() {\n    cin &gt;&gt; m &gt;&gt; n &gt;&gt; l;\n    vector&lt;JOB&gt;tot;\n    for (int i = 0;i &lt; l;i++) {\n        int a, b, t, u, v, w, x;\n        cin &gt;&gt; a &gt;&gt; b &gt;&gt; t &gt;&gt; u &gt;&gt; v &gt;&gt; w &gt;&gt; x;\n        tot.push_back(JOB(a, b, t, u, v, w, x));\n    }\n    sort(tot.begin(), tot.end());\n    int ans = 0;\n    for (int i = 1;i &lt;= f;i++) {\n        mi = m;ni = n;\n        for (int j = 0;j &lt; l;j++) {\n            if (tot[j].t &gt;= i)\n                break;\n            if (tot[j].ok || mi &lt; tot[j].a || ni &lt; tot[j].b)\n                continue;\n            tot[j].ok = true;\n            mi -= tot[j].a;\n            ni -= tot[j].b;\n            ans += tot[j].v;\n            if (i &gt; tot[j].u)\n                ans -= (i - tot[j].u) * tot[j].x;\n            else if (i &lt; tot[j].u)\n                ans += (tot[j].u - i) * tot[j].w;\n        }\n    }\n    for (int i = 0;i &lt; l;i++) {\n        if (!tot[i].ok &amp;&amp; tot[i].u &lt;= f)\n            ans -= (f - tot[i].u) * tot[i].x;\n    }\n    printf(&quot;Case %d: %d\\n\\n&quot;, ind, ans);\n    ind++;\n}\n \nint main() {\n    while (cin &gt;&gt; f &amp;&amp; f)\n        solve();\n \n    return 0;\n}\n1295: F006 整数区间\n题目描述\n一个整数区间[a,b] (a &lt; b)，是一个从a到b连续整数的集合。\n现在给你n个整数区间，编程找出一个集合R，使得n个集合中的每个集合都有2个整数出现在R中，并且这个集合R包含的整数个数最少。\n输入\n输入有多组数据，每组第一行包含整数n(1 ⇐ n ⇐ 10000)，表示整数区间的个数。接下来n行，每行包含两个整数a和b(0 ⇐ a &lt; b ⇐ 10000, a &lt; b)。\n输出\n输出符合条件的集合R中元素的个数。\n样例输入\n4\n3 6\n2 4\n0 2\n4 7\n样例输出\n4\n参考代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 1e5 + 50;\n \nint cnt[maxn];\nint n;\nint ck[maxn];\nbool hasi[maxn];\nvoid solve() {\n    while (cin &gt;&gt; n) {\n        fill(hasi, hasi + 10005, false);\n        fill(ck, ck + n + 5, 0);\n        fill(cnt, cnt + 10005, 0);\n        if (!n)return;\n        vector&lt;pair&lt;int, int&gt;&gt; v;\n        for (int i = 0;i &lt; n;i++) {\n            int a, b;\n            cin &gt;&gt; a &gt;&gt; b;\n            v.push_back(make_pair(a, b));\n            for (int j = a;j &lt;= b;j++) {\n                cnt[j]++;\n            }\n        }\n        int ans = 0;\n        while (true) {\n            int mx = max_element(cnt, cnt + 10005) - cnt;\n            // cout &lt;&lt; mx &lt;&lt; endl;\n            if (cnt[mx] == 0)break;\n            hasi[mx] = true;\n            ans++;\n            fill(cnt, cnt + 10005, 0);\n            for (int i = 0;i &lt; n;i++) {\n                if (ck[i] == 2)continue;\n                if (v[i].first &lt;= mx &amp;&amp; v[i].second &gt;= mx) {\n                    ck[i]++;\n                }\n                if (ck[i] == 2)continue;\n \n                for (int j = v[i].first;j &lt;= v[i].second;j++) {\n                    if (hasi[j])\n                        continue;\n                    cnt[j]++;\n                }\n            }\n        }\n        cout &lt;&lt; ans &lt;&lt; endl;\n    }\n}\n \nint main() {\n    // int t;cin &gt;&gt; t;\n    // while (t--)\n    solve();\n \n    return 0;\n}\n1296: F007 安装雷达\n题目描述\n我们假设海岸线是一条无限直线：以海岸线为界，陆地和海洋被分开，在海边分布着很多小岛。现在，我们在海岸线上安装雷达，每个雷达有固定的通讯范围（以d为半径的圆形区域），这样，海边的小岛就可以被某个雷达信号覆盖。\n这里我们使用笛卡尔坐标系，定义海岸线为x轴，x轴上方是海洋，下方是陆地。给出分布在海边每个小岛的坐标位置和雷达信号能覆盖的范围d，你的任务是计算出最小需要安装的雷达数目，使得这些雷达信号能覆盖到所有海边的小岛。每个小岛的坐标格式为(x,y)。\n如下图所示，给出第一个输入样例的坐标表示，这样在(-2,0),(1,0)上分别安装雷达就可以覆盖所有的小岛（p点），所以我们只需要安装2个雷达。\n\n输入\n输入包含多组测试样例。每组测试第一行包含两个整数n(1⇐n⇐1000)和d，n表示小岛的数目，d表示雷达能覆盖的范围的半径。接下来n行，每行由整数x和y组成，表示n个小岛的坐标位置。每两组数据之间有一个空行。\n输入0 0表示输入的结束。\n输出\n对于每一组输入，按照输出样例中的格式输出：包含输出序号和最少需要安装雷达的数目。如果找不到解决方案，即不能找到一种安装方案覆盖所有的小岛，输出”-1”。\n样例输入\n3 2\n1 2\n-3 1\n2 1\n \n1 2\n0 2\n \n0 0\n样例输出\nCase 1: 2\nCase 2: 1\n参考代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\n \nstruct node {\n    double x, y;\n    node(double x, double y) :x(x), y(y) {}\n    bool operator &lt; (const node&amp; a) const {\n        return y &lt; a.y;\n    }\n};\nint n;\nint d;\nint ind;\nvoid solve() {\n    ind = 1;\n    while (cin &gt;&gt; n &gt;&gt; d) {\n        if (n == 0 &amp;&amp; d == 0)return;\n        bool f = true;\n        vector&lt;node&gt; q;\n        for (int i = 0;i &lt; n;i++) {\n            int x, y;cin &gt;&gt; x &gt;&gt; y;\n            if (d &lt; y)\n                f = false;\n            if (!f)continue;\n            double ei = sqrt(1.0 * d * d - 1.0 * y * y);\n            q.push_back(node{ x - ei,x + ei });\n        }\n        if (!f) {\n            printf(&quot;Case %d: -1\\n&quot;, ind);\n            ind++;\n            continue;\n        }\n        sort(q.begin(), q.end());\n        int ans = 1;\n        double yi = q[0].y;\n        for (int i = 1;i &lt; q.size();i++) {\n            if (q[i].x &lt;= yi) {\n                continue;\n            }\n            else {\n                ans++;\n                yi = q[i].y;\n            }\n        }\n        printf(&quot;Case %d: %d\\n&quot;, ind, ans);\n        ind++;\n    }\n}\n \nint main() {\n    // int t;cin &gt;&gt; t;\n    // while (t--) \n    solve();\n \n \n    return 0;\n}\n1297: F008 排队买饭\n题目描述\n周晓晓吃完中午饭后又觉得没吃饱，因此想要再去食堂买点饭，当她走进食堂发现已经有n个人排队了，她知道每个人买饭需要的时间。她想帮助大家尽快的买到饭，即让n个人的平均等待时间最小，周晓晓已经饿的无法想出办法，只想知道他们最小的平均等待时间是多少，你能帮助她吗?\n输入\n输入可能有多组，每组第一行为一个整数n。 第二行 n 个整数，第 i 个整数 Ti 表示第i个人的等待时间Ti。\n输出\n每组输出占一行，为每组最小的平均等待时间（输出结果精确到小数点后两位）。\n样例输入\n10 \n56 12 1 99 1000 234 33 55 99 812\n样例输出\n532.00\n参考代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 1e5 + 20;\nint a[maxn];\n \nint n;\nvoid solve() {\n    for (int i = 0;i &lt; n;i++)cin &gt;&gt; a[i];\n    sort(a, a + n);\n    int ans = 0;\n    int tmp = 0;\n    for (int i = 0;i &lt; n;i++) {\n        tmp += a[i];\n        ans += tmp;\n    }\n    printf(&quot;%.2lf\\n&quot;, 1.0 * ans / n);\n}\n \nint main() {\n    while (cin &gt;&gt; n)\n        solve();\n \n    return 0;\n}\n1298: F009 放书\n题目描述\n周小小最近想为自己的图书室添置一个巨型书架，尽管它是如此的大，但它还是几乎瞬间就被各种各样的书塞满了。现在，只有书架的顶上还留有一点空间。\n所有N(1⇐N⇐2000)把椅子都有一个确定的高度Hi（1⇐Hi⇐1000）。为了够到书架顶，周小小想像演杂技一般，将椅子一个一个的叠在一起，并上去把书架的空间补上。\n显然，椅子叠的越多，就越不稳定，于是小小希望在够到书架顶的前提下，让椅子数量尽量少，作为聪明的你，一定能帮助他计算出这个最小数量吧。\n输入\n第1行: 2个用空格隔开的整数：N和B，表示有N把椅子和书架的高度；\n第2行到N+1行: 第i+1行是1个整数：Hi，表示椅子的高度。\n可能存在多组输入数据。\n输出\n输出1个整数，即最少要多少把椅子。（如果到不了顶端，输出-1）\n样例输入\n6 40\n6\n18\n11\n13\n19\n11\n样例输出\n3\n参考代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 2010;\nint h[maxn];\n \nint n, b;\nvoid solve() {\n    for (int i = 0;i &lt; n;i++)\n        cin &gt;&gt; h[i];\n    sort(h, h + n);\n    int sum = 0, cnt = 0;\n    for (int i = n - 1;i &gt;= 0;i--) {\n        sum += h[i];\n        cnt++;\n        if (sum &gt;= b) {\n            cout &lt;&lt; cnt &lt;&lt; endl;\n            return;\n        }\n    }\n    cout &lt;&lt; -1 &lt;&lt; endl;\n}\n \nint main() {\n    while (cin &gt;&gt; n &gt;&gt; b)\n        solve();\n \n    return 0;\n}"},"03-algorithm/seg_tree":{"slug":"03-algorithm/seg_tree","filePath":"03-algorithm/seg_tree.md","title":"线段树模板","links":[],"tags":["算法","线段树","数据结构","算法模板"],"content":"线段树(segment tree)\n线段树主要用于维护区间信息，与传统的树状数组相比，可以实现O(log n)的区间修改，还可以同时支持多种操作(加、乘)，更具通用性。\n还是一样，为了方便测试，我们引入一个例题中的数据来演示。\n【模板】线段树\n题目链接：[线段树 1](#P3372 【模板】线段树 1 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn))\n\n题目描述\n如题，已知一个数列，你需要进行下面两种操作：\n\n将某区间每一个数加上 k。\n求出某区间每一个数的和。\n\n输入格式\n第一行包含两个整数 n, m，分别表示该数列数字的个数和操作的总个数。\n第二行包含 n 个用空格分隔的整数，其中第 i 个数字表示数列第 i 项的初始值。\n接下来 m 行每行包含 3 或 4 个整数，表示一个操作，具体如下：\n\n1 x y k：将区间 [x, y] 内每个数加上 k。\n2 x y：输出区间 [x, y] 内每个数的和。\n\n输出格式\n输出包含若干行整数，即为所有操作 2 的结果。\n样例 #1\n样例输入 #1\n5 5\n1 5 4 2 3\n2 2 4\n1 2 3 2\n2 3 4\n1 1 5 1\n2 1 4\n样例输出 #1\n11\n8\n20\n提示\n对于 30\\% 的数据：n \\le 8，m \\le 10。\n对于 70\\% 的数据：n \\le {10}^3，m \\le {10}^4。\n对于 100\\% 的数据：1 \\le n, m \\le {10}^5。\n保证任意时刻数列中所有元素的绝对值之和 \\le {10}^{18}。\n【样例解释】\n\n\n线段树的建立\n线段树的每个节点对应一个区间，最小的区间(最底下的叶子)只包含1个数，从node=1(根节点)往下逐渐二分，且每一层的区间并不重合。\n我们如此设置节点（简单概念）：\n每个节点p的左右子节点分别是2p和2p+1，假如节点p储存的是[l, r]的和，我们取mid=(l+r)/2 （一般就是向下取整啦，数组从索引0开始）则其子节点恰是分别储存[l, mid]和[mid+1, r]的和，可以发现这样可以使得做节点对应的区间长度恰好与右节点对应的区间长度相同或恰好多1。\n草履虫都会的递归建图：\n// 简单的建树过程\nvoid buildtree(ll l, ll r, ll p) {\n\tif (l == r)\n\t\t// 二分到终点了，给线段树的叶子节点赋值为a[l]\n\t\ttree[p] = a[l];\n\telse {\n\t\tll mid = (l + r) / 2;\n \n\t\t// 先创造左节点p*2\n\t\tbuildtree(l, mid, p * 2);\n\t\t// 再创造右节点p*2+1\n\t\tbuildtree(mid + 1, r, p * 2 + 1);\n \n\t\t// 左右节点创造完毕之后给他们的父节点，也就是本轮递归中的p节点赋值\n\t\ttree[p] = tree[p * 2] + tree[p * 2 + 1];\n\t}\n}\n如何更新数据？\n朴素的想法或许是在改变数组中的某值之后再次递归来同步线段树，就像建树过程一样，但可以预见的是，这样做的时间复杂度比较高，因为当数组中的某值改变，我们需要update的节点是叶子节点，修改一个点会需要连锁修改上方所有包含该点的父节点、祖节点…etc，所以我们引入懒标记法进行线段树的区间修改。\n懒标记（延迟标记）\n这是线段树的精髓所在qwq，递归的复杂度主要在于一层套一层然后再一层一层出来，有没有一种可能，我们给我们要修改的区间(将会对应一个唯一的节点)做上标记，只需要在将来用到某个节点的时候将变化传递下去就行。这样将会大大减少我们的时间。\n相当于啊，本来某个变化是变动整个树来更新的，现在我们懒一懒，把工作做到确定哪些区间是全部变化了的，给它标记上（带上变化的内容），只有等到需要找它的子区间的时候才把变化落实下去。\n还是看代码来理解吧：\nvoid update(ll l, ll r, ll curl, ll curr, ll addnum, ll curpos) {\n\t// 从目标的区间(要更新的范围)[l, r]开始\n\t// 当前操作的区间是[curl, curr](对应curpos)\n\t// 要做的操作是加一个数addnum(显然同理也可以是其他操作)\n\tif (curl &gt; r || curr &lt; l)\n\t\t// 当前要操作的区间和大区间没有交集，剪枝\n\t\treturn;\n\telse if (curl &gt;= l &amp;&amp; curr &lt;= r) {\n\t\t// 当前区间完全包含在大区间里\n\t\ttree[curpos] += (curr - curl + 1) * addnum;\n\t\t\n\t\tif (curl != curr)\n\t\t\t// 不是叶子节点，则标记它\n\t\t\tmark[curpos] += addnum;\n \n\t\t// 这里就很懒标记了qwq\n\t}\n\telse {\n\t\t// 有交集但不包含，则需要再分出包含的部分和不包含的部分进行update\n \n\t\t// 因为当前区间点已经不能实现代表它下面的所有小弟啦，所以我们把原来有的标记往下传递一层，也就是分开，直到分到区间都是:要么都有变化，要么都不变化\n\t\t\n\t\t// 将标记点向下传递\n\t\tmark[curpos * 2] += mark[curpos];\n\t\tmark[curpos * 2 + 1] += mark[curpos];\n \n\t\t// 接下来往下更新一层\n\t\tll mid = (curl + curr) / 2;\n\t\ttree[curpos * 2] += mark[curpos] * (mid - curl + 1);\n\t\ttree[curpos * 2 + 1] += mark[curpos] * (curr - mid);\n \n\t\t// 清除当前的区间点的标记（因为已经下达了）\n\t\tmark[curpos] = 0;\t// 这里改成0是因为我们假设的操作变化是加法，如果是乘法呢做法相似\n \n\t\t// 将懒标记递归下去\n\t\tupdate(l, r, curl, mid, addnum, curpos * 2);\t// 左\n\t\tupdate(l, r, mid + 1, curr, addnum, curpos * 2 + 1);\t// 右\n \n\t\t// 传递结束之后更新当前节点的值(变化到这)\n\t\ttree[curpos] = tree[curpos * 2] + tree[curpos * 2 + 1];\n\t}\n}\n整个过程看着还是有递归，但是并不像建树时一样递归到底层才结束，我们在中间随时可以结束，只要找到一个可以代表它下面的所有小弟的大哥，然后告诉大哥要这样…那样…然后我们的任务就完成了，意思已经传达到了。\n那么如何把我们的标记翻译下去呢，这个就更简单了，我们上面使用了一个mark[]数组记录变化，我们只需要吧mark里的指令传递到目标即可。\n// 将mark[]里要落实到底的指令落实下去\nvoid impleMarks(ll pos, ll len) {\n\t// 实现目标：把mark[pos]里的指令向下传递一层\n\t// 方便起见我们把pos对应的区间长度也传入，在使用这个函数的时候直接将curr-curl+1传入len即可\n\tmark[pos * 2] += mark[pos];\t// 左\n\tmark[pos * 2 + 1] += mark[pos];\t// 右\n\ttree[pos * 2] += mark[pos] * (len - len / 2);\n\ttree[pos * 2 + 1] += mark[pos] * (len / 2);\n\t// 右边区间可能短一点，这会和最初生成线段树时结余出的地方一致，所以影响不大\n \n\tmark[pos] = 0;\n}\n接下来，我们如果想要更新到所有叶子结点，只要调用这个落实函数就好。\n查询区间\n上面我们已经有了修改区间的方法，其实查询已经讲进去了吧，不会查怎么做修改\n简单的写一个模板函数：\n// 查询区间里的数据（也就是查询节点里的数据）\nll ask(ll l, ll r, ll pos, ll curl, ll curr) {\n\t// 目标区间和已经在查的区间，以及对应在线段树里的坐标\n\tif (curl &gt; r || curr &lt; l)\n\t\t// 现在在查的不在大区间里\n\t\treturn 0;\n\telse if (curl &gt;= l &amp;&amp; curr &lt;= r)\n\t\t// 当前查的区间就在待查区间里，返回值\n\t\treturn tree[pos];\n\telse {\n\t\t// 进行二分\n\t\tll mid = (curl + curr) / 2;\n\t\t// 把当前节点的更新信息往下传递一层\n\t\timpleMarks(pos, curr - curl + 1);\n\t\t// 返回左右查询信息的和\n\t\treturn ask(l, r, pos * 2, curl, mid) + ask(l, r, pos * 2 + 1, mid + 1, curr);\n\t}\n}\n最后给上例题的参考代码：\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 1e5 + 50, maxm = 1e5 + 50;\nll a[maxn];\n \nll tree[maxn * 4];\t// 一般线段树的大小开到原数组范围的4倍应该差不多了\n \n// 简单的建树过程\nvoid buildtree(ll l, ll r, ll p) {\n\tif (l == r)\n\t\t// 二分到终点了，给线段树的叶子节点赋值为a[l]\n\t\ttree[p] = a[l];\n\telse {\n\t\tll mid = (l + r) / 2;\n \n\t\t// 先创造左节点p*2\n\t\tbuildtree(l, mid, p * 2);\n\t\t// 再创造右节点p*2+1\n\t\tbuildtree(mid + 1, r, p * 2 + 1);\n \n\t\t// 左右节点创造完毕之后给他们的父节点，也就是本轮递归中的p节点赋值\n\t\ttree[p] = tree[p * 2] + tree[p * 2 + 1];\n\t}\n}\n \nll mark[maxn * 4];\n \nvoid update(ll l, ll r, ll curl, ll curr, ll addnum, ll curpos) {\n\t// 从目标的区间(要更新的范围)[l, r]开始\n\t// 当前操作的区间是[curl, curr](对应curpos)\n\t// 要做的操作是加一个数addnum(显然同理也可以是其他操作)\n\tif (curl &gt; r || curr &lt; l)\n\t\t// 当前要操作的区间和大区间没有交集，剪枝\n\t\treturn;\n\telse if (curl &gt;= l &amp;&amp; curr &lt;= r) {\n\t\t// 当前区间完全包含在大区间里\n\t\ttree[curpos] += (curr - curl + 1) * addnum;\n\t\t\n\t\tif (curl != curr)\n\t\t\t// 不是叶子节点，则标记它\n\t\t\tmark[curpos] += addnum;\n \n\t\t// 这里就很懒标记了qwq\n\t}\n\telse {\n\t\t// 有交集但不包含，则需要再分出包含的部分和不包含的部分进行update\n \n\t\t// 因为当前区间点已经不能实现代表它下面的所有小弟啦，所以我们把原来有的标记往下传递一层，也就是分开，直到分到区间都是:要么都有变化，要么都不变化\n\t\t\n\t\t// 将标记点向下传递\n\t\tmark[curpos * 2] += mark[curpos];\n\t\tmark[curpos * 2 + 1] += mark[curpos];\n \n\t\t// 接下来往下更新一层\n\t\tll mid = (curl + curr) / 2;\n\t\ttree[curpos * 2] += mark[curpos] * (mid - curl + 1);\n\t\ttree[curpos * 2 + 1] += mark[curpos] * (curr - mid);\n \n\t\t// 清除当前的区间点的标记（因为已经下达了）\n\t\tmark[curpos] = 0;\t// 这里改成0是因为我们假设的操作变化是加法，如果是乘法呢做法相似\n \n\t\t// 将懒标记递归下去\n\t\tupdate(l, r, curl, mid, addnum, curpos * 2);\t// 左\n\t\tupdate(l, r, mid + 1, curr, addnum, curpos * 2 + 1);\t// 右\n \n\t\t// 传递结束之后更新当前节点的值(变化到这)\n\t\ttree[curpos] = tree[curpos * 2] + tree[curpos * 2 + 1];\n\t}\n}\n \n// 将mark[]里要落实到底的指令落实下去\nvoid impleMarks(ll pos, ll len) {\n\t// 实现目标：把mark[pos]里的指令向下传递一层\n\t// 方便起见我们把pos对应的区间长度也传入，在使用这个函数的时候直接将curr-curl+1传入len即可\n\tmark[pos * 2] += mark[pos];\t// 左\n\tmark[pos * 2 + 1] += mark[pos];\t// 右\n\ttree[pos * 2] += mark[pos] * (len - len / 2);\n\ttree[pos * 2 + 1] += mark[pos] * (len / 2);\n\t// 右边区间可能短一点，这会和最初生成线段树时结余出的地方一致，所以影响不大\n \n\tmark[pos] = 0;\n}\n \n// 查询区间里的数据（也就是查询节点里的数据）\nll ask(ll l, ll r, ll pos, ll curl, ll curr) {\n\t// 目标区间和已经在查的区间，以及对应在线段树里的坐标\n\tif (curl &gt; r || curr &lt; l)\n\t\t// 现在在查的不在大区间里\n\t\treturn 0;\n\telse if (curl &gt;= l &amp;&amp; curr &lt;= r)\n\t\t// 当前查的区间就在待查区间里，返回值\n\t\treturn tree[pos];\n\telse {\n\t\t// 进行二分\n\t\tll mid = (curl + curr) / 2;\n\t\t// 把当前节点的更新信息往下传递一层\n\t\timpleMarks(pos, curr - curl + 1);\n\t\t// 返回左右查询信息的和\n\t\treturn ask(l, r, pos * 2, curl, mid) + ask(l, r, pos * 2 + 1, mid + 1, curr);\n\t}\n}\n \nint main() {\n\t// 读入数据\n\tll n, m;cin &gt;&gt; n &gt;&gt; m;\n\tfor (ll i = 1;i &lt;= n;i++)cin &gt;&gt; a[i];\n\t\n\t// 用数据建树，从节点1（也就是根节点）开始递归\n\tbuildtree(1, n, 1);\n \n\twhile (m--) {\n\t\t\n\t\tint how;cin &gt;&gt; how;\n\t\tif (how == 1) {\n\t\t\tll x, y, k;cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;\n\t\t\tupdate(x, y, 1, n, k, 1);\n\t\t}\n\t\telse if (how == 2) {\n\t\t\tll x, y;cin &gt;&gt; x &gt;&gt; y;\n\t\t\tcout &lt;&lt; ask(x, y, 1, 1, n) &lt;&lt; endl;\n\t\t}\n\t}\n \n\treturn 0;\n}"},"03-algorithm/segtree_practice":{"slug":"03-algorithm/segtree_practice","filePath":"03-algorithm/segtree_practice.md","title":"线段树专题练习","links":[],"tags":["算法","线段树","数据结构","算法模板"],"content":"\n\n                  \n                  反思中 \n                  \n                \n\n\n痛定思痛练习线段树QAQ。\n\n\n\n此篇包含尚未写完的题，事实上是一个TODO List。\nTODO List\n\n Atlantis\n P5490 【模板】扫描线 &amp; 矩形面积并 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n I Hate It\n 覆盖的面积\n 敌兵布阵\n P4588 TJOI2018 数学计算 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n 单峰数列 ✅ 2024-09-26\n 树上询问\n P1502 窗口的星星 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n P2471 SCOI2007 降雨量 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n\nAtlantis &amp; P5490 扫描线矩形面积并\nProblem - 1542 (hdu.edu.cn)\n题意\n给出x_1,y_1,x_2,y_2，标志平面内的矩形的左上角坐标(x_1,y_1)和右下角坐标(x_2,y_2)​​，求这些矩形覆盖的总面积。\n输出格式参照样例。\n数据范围\n\n0\\leq n\\leq 100\n0\\leq x_1\\lt x_2\\leq 10^5\n0\\leq y_1\\lt y_2\\leq 10^5\n\n思路\n记录每个矩阵的上下边，并给下边沿标记1，上边沿标记-1，扫描线从下向上扫描。\n记录每条线的左右端点的x坐标，去重后进行离散化，用X[]数组记录出现过的x坐标，并做去重。\n在去重之后的X[]数组上建立线段树（不包含最右侧端点），线段树中的每个节点记录该段节点代表的线段的左右端点在X[]中的下标，之后若该线段被覆盖，该节点代表的长度就是X[posr+1]- X[posl]，初始时每个节点记录的长度都是0（初始时均未被覆盖）。\n扫描线从下到上扫描，每次都是先遇到某个矩阵的下边沿（标记为1的边），然后再遇到上边沿（标记为-1的边）。对于每次加边，更新线段树上的节点，当前被覆盖的长度\\times当前扫描线与下一条扫描线的高度差即为这一部分的面积。\n代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\nconst int maxn = 2050;\n \nstruct line {\n    int typ;\n    double s, t, y;\n    bool operator&lt;(const line&amp; l)const {\n        return y &lt; l.y; // 按照横坐标升序排序\n    }\n}line[maxn * 2];\n \nstruct node {\n    int l, r;\n    int cnt;\n    double len;\n}tree[maxn * 4];\n \ndouble X[maxn * 2];\n \nvoid build(int p, int l, int r) {\n    tree[p] = { l,r,0,0 };\n    if (l == r)return;\n    int mid = l + (r - l) / 2;\n    build(p * 2, l, mid);\n    build(p * 2 + 1, mid + 1, r);\n}\n \nvoid pushup(int p) {\n    int l = tree[p].l, r = tree[p].r;\n    if (tree[p].cnt) { // 有覆盖\n        tree[p].len = X[r + 1] - X[l];\n    }\n    else {\n        tree[p].len = tree[p * 2].len + tree[p * 2 + 1].len;\n    }\n}\n \nvoid editTree(int p, double l, double r, int c) {\n    // 要修改的x区间:[l,r]\n    int pl = tree[p].l, pr = tree[p].r; // 当前节点对应的左右坐标\n    if (X[pl] &gt;= l &amp;&amp; X[pr + 1] &lt;= r) { // 包含\n        tree[p].cnt += c;\n        pushup(p);\n        return;\n    }\n    if (l &gt;= X[pr + 1] || r &lt;= X[pl])\n        return;\n    editTree(p * 2, l, r, c);\n    editTree(p * 2 + 1, l, r, c);\n    pushup(p);\n}\n \nint n;\nint cas;\nvoid solve() {\n    cout &lt;&lt; &quot;Test case #&quot; &lt;&lt; ++cas &lt;&lt; &quot;\\n&quot;;\n    set&lt;double&gt;Xs;\n    for (int i = 1;i &lt;= n;i++) {\n        double x1, y1, x2, y2;\n        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;\n        line[i] = { 1,x1,x2,y1 }; // 下边\n        line[i + n] = { -1,x1,x2,y2 }; // 上边\n        Xs.insert(x1), Xs.insert(x2); // 离散化\n    }\n    sort(line + 1, line + 1 + 2 * n);\n    int t = 0;\n    for (auto p : Xs) {\n        X[++t] = p;\n    }\n    build(1, 1, t - 1); // 对离散化的X轴建树\n    double ans = 0.0;\n    for (int i = 1;i &lt; 2 * n;i++) { // 最后一条扫描线不用计入统计\n        editTree(1, line[i].s, line[i].t, line[i].typ);\n        ans += tree[1].len * (line[i + 1].y - line[i].y);\n    }\n \n    cout &lt;&lt; &quot;Total explored area: &quot; &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; ans &lt;&lt; &quot;\\n&quot;;\n}\n \nint main() {\n    // ios::sync_with_stdio(false);\n    // cin.tie(0);\n    while (cin &gt;&gt; n &amp;&amp; n)\n        solve();\n \n    return 0;\n}\n稍微修改一下上一题的代码就能过这个题：P5490 【模板】扫描线 &amp; 矩形面积并 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n代码：\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\nconst int maxn = 1e6 + 50;\n \nstruct line {\n    int typ;\n    ll s, t, y;\n    bool operator&lt;(const line&amp; l)const {\n        return y &lt; l.y; // 按照横坐标升序排序\n    }\n}line[maxn * 2];\n \nstruct node {\n    int l, r;\n    int cnt;\n    ll len;\n}tree[maxn * 4];\n \nll X[maxn * 2];\n \nvoid build(int p, int l, int r) {\n    tree[p] = { l,r,0,0 };\n    if (l == r)return;\n    int mid = l + (r - l) / 2;\n    build(p * 2, l, mid);\n    build(p * 2 + 1, mid + 1, r);\n}\n \nvoid pushup(int p) {\n    int l = tree[p].l, r = tree[p].r;\n    if (tree[p].cnt) { // 有覆盖\n        tree[p].len = X[r + 1] - X[l];\n    }\n    else {\n        tree[p].len = tree[p * 2].len + tree[p * 2 + 1].len;\n    }\n}\n \nvoid editTree(int p, ll l, ll r, int c) {\n    // 要修改的x区间:[l,r]\n    int pl = tree[p].l, pr = tree[p].r; // 当前节点对应的左右坐标\n    if (X[pl] &gt;= l &amp;&amp; X[pr + 1] &lt;= r) { // 包含\n        tree[p].cnt += c;\n        pushup(p);\n        return;\n    }\n    if (l &gt;= X[pr + 1] || r &lt;= X[pl])\n        return;\n    editTree(p * 2, l, r, c);\n    editTree(p * 2 + 1, l, r, c);\n    pushup(p);\n}\n \n \nvoid solve() {\n    int n;cin &gt;&gt; n;\n    set&lt;ll&gt;Xs;\n    for (int i = 1;i &lt;= n;i++) {\n        ll x1, y1, x2, y2;\n        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;\n        line[i] = { 1,x1,x2,y1 }; // 下边\n        line[i + n] = { -1,x1,x2,y2 }; // 上边\n        Xs.insert(x1), Xs.insert(x2); // 离散化\n    }\n    sort(line + 1, line + 1 + 2 * n);\n    int t = 0;\n    for (auto p : Xs) {\n        X[++t] = p;\n    }\n    build(1, 1, t - 1); // 对离散化的X轴建树\n    ll ans = 0ll;\n    for (int i = 1;i &lt; 2 * n;i++) { // 最后一条扫描线不用计入统计\n        editTree(1, line[i].s, line[i].t, line[i].typ);\n        ans += tree[1].len * (line[i + 1].y - line[i].y);\n    }\n \n    cout &lt;&lt; ans &lt;&lt; &quot;\\n&quot;;\n}\n \nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int t = 1;\n    // cin &gt;&gt; t;cin.tie(0);\n    while (t--)\n        solve();\n \n    return 0;\n}\nI Hate It\nI Hate It\n题意\n老师想询问学生中从某某到某某分数最高的是多少，并支持修改单个学生的成绩。\n数据范围\n0\\lt n\\leq 200000\n0\\lt m\\leq 5000\n思路\n建树，节点记录最大值，单点修改。注意多组读入\n代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 2e5 + 50;\nconst int mo109 = 1000000007;\nconst int mo998 = 998244353;\n \nstruct node {\n    int mxval;\n}tree[maxn &lt;&lt; 2];\n \nint n, m;\nint a[maxn];\n \nvoid build(int l, int r, int p) {\n    if (l == r) {\n        tree[p] = { a[l] };\n        return;\n    }\n    int mid = l + (r - l) / 2;\n    build(l, mid, p * 2);\n    build(mid + 1, r, p * 2 + 1);\n    tree[p].mxval = max(tree[p * 2].mxval, tree[p * 2 + 1].mxval);\n}\n \nvoid pushdown(int p) {\n    tree[p].mxval = max(tree[p * 2].mxval, tree[p * 2 + 1].mxval);\n}\n \nvoid update(int cl, int cr, int p, int lr, int newval) {\n    if (cl == cr &amp;&amp; cl == lr) {\n        a[cl] = newval;\n        tree[p] = { newval };\n        return;\n    }\n    int mid = cl + (cr - cl) / 2;\n    if (lr &lt;= mid) {\n        update(cl, mid, p * 2, lr, newval);\n    }\n    else {\n        update(mid + 1, cr, p * 2 + 1, lr, newval);\n    }\n    pushdown(p);\n}\n \nint query(int cl, int cr, int p, int l, int r) {\n    if (cl &gt;= l &amp;&amp; cr &lt;= r) {\n        return tree[p].mxval;\n    }\n    int mid = cl + (cr - cl) / 2;\n    int mx = -1;\n    if (mid &gt;= l) {\n        int x = query(cl, mid, p * 2, l, r);\n        mx = max(x, mx);\n    }\n    if (mid + 1 &lt;= r) {\n        int x = query(mid + 1, cr, p * 2 + 1, l, r);\n        mx = max(mx, x);\n    }\n    return mx;\n}\n \nvoid solve() {\n    // cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1;i &lt;= n;i++) {\n        cin &gt;&gt; a[i];\n    }\n    build(1, n, 1);\n    while (m--) {\n        char c;cin &gt;&gt; c;\n        int a, b;cin &gt;&gt; a &gt;&gt; b;\n        if (c == &#039;Q&#039;) {\n            cout &lt;&lt; query(1, n, 1, a, b) &lt;&lt; &#039;\\n&#039;;\n        }\n        else {\n            update(1, n, 1, a, b);\n        }\n    }\n}\n \nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    int _ = 1;\n    // cin &gt;&gt; _;cin.get();\n    while (cin &gt;&gt; n &gt;&gt; m)\n        solve();\n \n    return 0;\n}\n覆盖的面积\n覆盖的面积\n题意\n给定平面上的矩阵，求出被这些矩阵覆盖至少两次的区域面积。\n数据范围\n1\\leq N\\leq 1000\n0\\leq x_i,y_i\\leq 100000\n思路\n扫描线求矩形并，在求并时统计更新被覆盖的次数，在pushup的时候，当父节点已有一次覆盖，而子区间已经被包含一次，则子区间已经被包含了2次。\n代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\nconst int maxn = 2050;\n \nstruct line {\n    int typ;\n    ld s, t, y;\n    bool operator&lt;(const line&amp; l)const {\n        return y &lt; l.y; // 按照横坐标升序排序\n    }\n}line[maxn * 2];\n \nstruct node {\n    int l, r;\n    int cnt;\n    ld len, len2;\n}tree[maxn * 4];\n \nld X[maxn * 2];\n \nvoid build(int p, int l, int r) {\n    tree[p] = { l,r,0,0,0 };\n    if (l == r)return;\n    int mid = l + (r - l) / 2;\n    build(p * 2, l, mid);\n    build(p * 2 + 1, mid + 1, r);\n}\n \nvoid pushup(int p) {\n    int l = tree[p].l, r = tree[p].r;\n \n    if (tree[p].cnt) { // 有覆盖\n        tree[p].len = X[r + 1] - X[l];\n    }\n    else if (l != r) {\n        tree[p].len = tree[p * 2].len + tree[p * 2 + 1].len;\n    }\n    else {\n        tree[p].len = 0;\n    }\n \n    if (tree[p].cnt &gt;= 2) {\n        tree[p].len2 = X[r + 1] - X[l];\n    }\n    else if (l != r &amp;&amp; tree[p].cnt == 1) {\n        // cnt=1时,子区间已经被包含过一次，再加上父节点p的一次则子区间被包含了2次\n        tree[p].len2 = tree[p * 2].len + tree[p * 2 + 1].len;\n    }\n    else if (l != r) {\n        tree[p].len2 = tree[p * 2].len2 + tree[p * 2 + 1].len2;\n    }\n    else {\n        tree[p].len2 = 0;\n    }\n}\n \nvoid editTree(int p, ld l, ld r, int c) {\n    // 要修改的x区间:[l,r]\n    int pl = tree[p].l, pr = tree[p].r; // 当前节点对应的左右坐标\n \n    if (l &gt;= X[pr + 1] || r &lt;= X[pl]) {\n        // pushup(p);\n        return;\n    }\n \n    if (X[pl] &gt;= l &amp;&amp; X[pr + 1] &lt;= r) { // 包含\n        tree[p].cnt += c;\n        pushup(p);\n        return;\n    }\n \n \n    editTree(p * 2, l, r, c);\n    editTree(p * 2 + 1, l, r, c);\n    pushup(p);\n}\n \n \nvoid solve() {\n    int n;cin &gt;&gt; n;\n    set&lt;ld&gt;Xs;\n    for (int i = 1;i &lt;= n;i++) {\n        ld x1, y1, x2, y2; // 左下右上\n        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2;\n        line[i] = { 1,x1,x2,y1 }; // 下边\n        line[i + n] = { -1,x1,x2,y2 }; // 上边\n        Xs.insert(x1), Xs.insert(x2); // 离散化\n    }\n    sort(line + 1, line + 1 + 2 * n);\n    int t = 0;\n    for (auto p : Xs) {\n        X[++t] = p;\n    }\n \n    build(1, 1, t - 1); // 对离散化的X轴建树\n \n    ld ans = 0;\n    for (int i = 1;i &lt; 2 * n;i++) { // 最后一条扫描线不用计入统计\n        editTree(1, line[i].s, line[i].t, line[i].typ);\n        ans += tree[1].len2 * (line[i + 1].y - line[i].y);\n    }\n    ans += 0.001; // 样例好像有石\n    cout &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; ans &lt;&lt; &quot;\\n&quot;;\n}\n \nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int t = 1;\n    cin &gt;&gt; t;cin.tie(0);\n    while (t--)\n        solve();\n \n    return 0;\n}\n敌兵布阵\n敌兵布阵\n题意\n有N个营地，初始第i个营地有a_i个人，有4种命令。\n\nAdd i j，表示第i个营地增加j人。\nSub i j，表示第i个营地减少j人。\nQuery i j，查询第i到第j个营地一共有多少人。\nEnd，表示结束。\n\n数据范围\n\nN\\leq 50000\n1\\leq a_i\\leq 50​\n\n思路\n很模板的一个题。\n代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\nconst int maxn = 5e4 + 50;\n \nstruct node {\n    int val;\n}tree[maxn * 4];\n \nint a[maxn];\n \nvoid build(int p, int l, int r) {\n    if (l == r) {\n        tree[p].val = a[l];\n        return;\n    }\n    int mid = l + (r - l) / 2;\n    build(p * 2, l, mid);\n    build(p * 2 + 1, mid + 1, r);\n    tree[p].val = tree[p * 2].val + tree[p * 2 + 1].val;\n}\n \nvoid pushup(int p,int l,int r) {\n    if (l == r)return;\n    tree[p].val = tree[p * 2].val + tree[p * 2 + 1].val;\n}\n \nvoid update(int p, int cl, int cr, int goal,int x) {\n    if (cl &gt; goal || cr &lt; goal)return;\n    if (cl == cr) {\n        tree[p].val += x;\n        pushup(p, cl, cr);\n        return;\n    }\n    int mid = cl + (cr - cl) / 2;\n    update(p * 2, cl, mid, goal, x);\n    update(p * 2 + 1, mid + 1, cr, goal, x);\n    pushup(p, cl, cr);\n}\n \nint query(int p, int cl, int cr, int l, int r) {\n    if (cl &gt; r || cr &lt; l)\n        return 0;\n    if (cl &gt;= l &amp;&amp; cr &lt;= r) {\n        return tree[p].val;\n    }\n    int mid = cl + (cr - cl) / 2;\n    int tot = 0;\n    tot += query(p * 2, cl, mid, l, r);\n    tot += query(p * 2 + 1, mid + 1, cr, l, r);\n    return tot;\n}\n \nint ccnt;\nvoid solve() {\n    int n;cin &gt;&gt; n;\n    for (int i = 1;i &lt;= n;i++) {\n        cin &gt;&gt; a[i];\n    }\n    build(1, 1, n);\n    string s;\n    cout &lt;&lt; &quot;Case &quot; &lt;&lt; ++ccnt &lt;&lt; &quot;:\\n&quot;;\n    while (cin &gt;&gt; s) {\n        if (s == &quot;End&quot;)break;\n        if (s == &quot;Query&quot;) {\n            int l, r;cin &gt;&gt; l &gt;&gt; r;\n            cout &lt;&lt; query(1, 1, n, l, r) &lt;&lt; &#039;\\n&#039;;\n        }\n        else if (s == &quot;Add&quot;) {\n            int i, j;cin &gt;&gt; i &gt;&gt; j;\n            update(1, 1, n, i, j);\n        }\n        else if (s == &quot;Sub&quot;) {\n            int i, j;cin &gt;&gt; i &gt;&gt; j;\n            update(1, 1, n, i, -j);\n        }\n    }\n}\n \nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int t = 1;\n    cin &gt;&gt; t;cin.tie(0);\n    ccnt = 0;\n    while (t--)\n        solve();\n \n    return 0;\n}\n单峰数列\n单峰数列\n题意\n给定长度为n的数列a，支持以下操作：\n\n1 l r x：给区间[l,r]的所有数加上x\n2 l r：查询区间[l,r]中的元素是否全都相同\n3 l r：查询区间[l,r]中的元素是否严格上升，当l==r时认为是严格上升的\n4 l r：查询区间[l,r]中的元素是否严格下降，当l==r时认为是严格下降的\n5 l r：查询区间[l,r]是否是单峰数列，单峰数列符合右侧严格递增，左侧严格递减，并且左右侧的区间不为空，保证r-l+1\\geq 3。\n\n数据范围\n\n3\\leq n \\leq 10^5\n0\\leq a_i\\leq 10^9\n1\\leq q \\leq 2\\times 10^5\n\n对于第一类操作，保证-10^9\\leq x\\leq 10^9\n思路\n用三个变量记录区间左值、右值和懒标记。\n用三个布尔值变量记录当前区间是否是相同、上升、下降、单峰。在判断合并后是否是单峰时，主要满足单峰的区间必须大于等于3，当左右两个区间分别是上升、下降，且某个区间只有一个数时，要注意比较左右值。\n代码\n#include &lt;bits/stdc++.h&gt;\n \nusing namespace std;\n \n#define lson(p) tree[p * 2]\n#define rson(p) tree[p * 2 + 1]\n \ntypedef long long ll;\ntypedef unsigned long long ull;\n \nconst int maxn = 4e5 + 50;\n \nstruct node {\n  int l, r;\n  ll lval, rval, lazy;\n  bool isup, isdown, issame, isheap;\n} tree[maxn &lt;&lt; 2];\n \nll a[maxn];\n \nnode merge(node ret1, node ret2) {\n  node ret;\n \n  ret = {\n    ret1.l,\n    ret2.r,\n    ret1.lval,\n    ret2.rval,\n    0ll,\n    true,\n    true,\n    true,\n    false\n  };\n \n  ret.issame = ret1.issame &amp;&amp; ret2.issame &amp;&amp; ret1.rval == ret2.lval;\n  ret.isup = ret1.isup &amp;&amp; ret2.isup &amp;&amp; ret1.rval &lt; ret2.lval;\n  ret.isdown = ret1.isdown &amp;&amp; ret2.isdown &amp;&amp; ret1.rval &gt; ret2.lval;\n \n  if (ret1.isup &amp;&amp; ret2.isdown) {\n    if (ret1.l == ret1.r &amp;&amp; ret1.rval &lt; ret2.lval &amp;&amp; ret2.l != ret2.r)\n      ret.isheap = true;\n    else if (ret2.l == ret2.r &amp;&amp; ret1.rval &gt; ret2.lval &amp;&amp; ret1.l != ret1.r)\n      ret.isheap = true;\n    else if (ret1.l != ret1.r &amp;&amp; ret2.l != ret2.r)\n      ret.isheap = true;\n  }\n \n  if (ret1.isup &amp;&amp; ret2.isheap &amp;&amp; ret1.rval &lt; ret2.lval)\n    ret.isheap = true;\n  if (ret1.isheap &amp;&amp; ret2.isdown &amp;&amp; ret1.rval &gt; ret2.lval)\n    ret.isheap = true;\n \n  return ret;\n}\n \nvoid build(int p, int l, int r) {\n  if (l == r) {\n    tree[p] = {l, r, a[l], a[r], 0ll, true, true, true, false};\n    return;\n  }\n  int mid = l + (r - l) / 2;\n  build(p * 2, l, mid);\n  build(p * 2 + 1, mid + 1, r);\n  tree[p] = merge(lson(p), rson(p));\n}\n \nvoid pushdown(int p) {\n  int l = tree[p].l, r = tree[p].r;\n  if (l == r) {\n    return;\n  }\n  if (tree[p].lazy) {\n    ll x = tree[p].lazy;\n    lson(p).lazy += x, rson(p).lazy += x;\n    lson(p).lval += x, rson(p).lval += x;\n    lson(p).rval += x, rson(p).rval += x;\n    tree[p].lazy = 0ll;\n  }\n}\n \nvoid pushup(int p) {\n  int l = tree[p].l, r = tree[p].r;\n  if (l == r) {\n    return;\n  }\n  tree[p] = merge(lson(p), rson(p));\n}\n \nvoid update(int p, int cl, int cr, int l, int r, ll num) {\n  if (cl &gt;= l &amp;&amp; cr &lt;= r) {\n    tree[p].lval += num, tree[p].rval += num;\n    tree[p].lazy += num;\n    pushdown(p);\n    pushup(p);\n    return;\n  }\n  pushdown(p);\n  int mid = cl + (cr - cl) / 2;\n  if (l &lt;= mid)\n    update(p * 2, cl, mid, l, r, num);\n  if (mid + 1 &lt;= r)\n    update(p * 2 + 1, mid + 1, cr, l, r, num);\n  pushup(p);\n}\n \nnode query(int p, int cl, int cr, int l, int r) {\n  if (cl &gt;= l &amp;&amp; cr &lt;= r) {\n    return tree[p];\n  }\n \n  pushdown(p);\n  int mid = cl + (cr - cl) / 2;\n \n  node ret, ret1, ret2;\n \n  ret1.l = ret2.l = -1;\n  ret.l = cl, ret.r = cr;\n \n  if (l &lt;= mid) {\n    ret1 = query(p * 2, cl, mid, l, r);\n  }\n  if (mid + 1 &lt;= r) {\n    ret2 = query(p * 2 + 1, mid + 1, cr, l, r);\n  }\n  pushup(p);\n \n  if (ret1.l == -1)\n    return ret2;\n  if (ret2.l == -1)\n    return ret1;\n \n  ret = merge(ret1, ret2);\n  \n  return ret;\n}\n \nvoid solve() {\n  int n;\n  cin &gt;&gt; n;\n  for (int i = 1; i &lt;= n; i++) {\n    cin &gt;&gt; a[i];\n  }\n  build(1, 1, n);\n  int q;\n  cin &gt;&gt; q;\n  while (q--) {\n    int op, l, r;\n    cin &gt;&gt; op &gt;&gt; l &gt;&gt; r;\n    if (op == 1) {\n      ll x;\n      cin &gt;&gt; x;\n      update(1,1,n,l,r,x);\n    } else {\n      node ret = query(1, 1, n, l, r);\n      if (op == 2) {\n        cout &lt;&lt; ret.issame &lt;&lt; &#039;\\n&#039;;\n      } else if (op == 3) {\n        cout &lt;&lt; ret.isup &lt;&lt; &#039;\\n&#039;;\n      } else if (op == 4) {\n        cout &lt;&lt; ret.isdown &lt;&lt; &#039;\\n&#039;;\n      } else if (op == 5) {\n        cout &lt;&lt; ret.isheap &lt;&lt; &#039;\\n&#039;;\n      }\n    }\n  }\n}\n \nvoid init() {\n}\n \nint main(void) {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  init();\n  int t = 1;\n  // cin &gt;&gt; t;\n  // cin.get();\n  while (t--)\n    solve();\n \n  return 0;\n}\n "},"03-algorithm/segtreelecnote":{"slug":"03-algorithm/segtreelecnote","filePath":"03-algorithm/segtreelecnote.md","title":"线段树讲义||寒假","links":[],"tags":["算法","线段树","数据结构","算法模板"],"content":"线段树介绍\n\n线段树是一棵二叉树，每个节点维护一个区间内[l,r]的信息\n左子树区间维护[l,\\lfloor \\frac{l+r}{2} \\rfloor]的信息，右子树维护[\\lfloor \\frac{l+r}{2} \\rfloor+1,r]的信息\n节点信息可以由两个子节点合并得到\n任意一个区间会被分为线段树上O(\\log n)个节点\n\n线段树可以在O(\\log N)的时间复杂度内实现单点修改、区间修改、**区间查询（区间求和/区间最大值/区间最小值）**等操作。\n线段树一般解决类似这样的问题：\n\n已知一个数列，你需要进行下面几种操作：\n\n将某区间每一个数加上 k。（修改）\n求出某区间每一个数的和。（查询）\n将某区间的每个数修改为x。（修改）\n求某区间的最大值/最小值。（查询）\n\n\n建树\n\n实现\n递归实现\nstruct segTreeNode {\n    ll d = 0ll, lazy = 0ll;     // 数据&amp;懒标记\n    bool used;  // 标记是否修改过\n};\n \nvector&lt;ll&gt;a(maxn);  // 原数据\nvector&lt;segTreeNode&gt;tree(maxn * 4);\n \nvoid build(int l, int r, int p) {\n    if (l == r) {\n        tree[p].d = a[l];\n        return;\n    }\n    int m = l + ((r - l) &gt;&gt; 1);\n \n    build(l, m, p &lt;&lt; 1);\t// 左边\n    build(m + 1, r, (p &lt;&lt; 1) | 1);\t// 右边\n \n    tree[p].d = tree[p &lt;&lt; 1].d + tree[(p &lt;&lt; 1) | 1].d;\n}\n查询&amp;修改&amp;求值\n区间查询\n进行区间查询的时候，区间和节点区间的关系有三种可能：\n\n当前要查询的区间与正在询问的区间没有交集，返回空\n当前要查询的区间被某个节点的区间完全包含，直接取该点记录的值\n当前要查询的区间被某个节点部分包含，则将这个节点往下传递一层，直到符合上面两种情况\n\n实现\nll getsum(int l, int r, int cl, int cr, int p) {\n    // if (cr&lt;l || cl&gt;r)return 0ll;     // 操作正确的话不可能会出现这种情况\n    if (cl &gt;= l &amp;&amp; cr &lt;= r)return tree[p].d;\n \n    int m = cl + ((cr - cl) &gt;&gt; 1);\n    ll sum = 0ll;\n    if (m &gt;= l)\n        sum += getsum(l, r, cl, m, p &lt;&lt; 1);\n    if (m &lt; r)\n        sum += getsum(l, r, m + 1, cr, (p &lt;&lt; 1) | 1);\n    return sum;\n}\n区间修改（懒标记）\n区间修改和区间查询的思路是一样的，判断当前节点区间与被修改的区间的关系，对其数据进行修改。\n假如我们在修改区间[l,r]时，把所有与[l,r]有交集的节点都遍历并修改一边，时间复杂度将过高，所以我们引入懒标记。\n思考：\n当我们要修改[l,r]，有一个节点（或者是一些节点的并集）恰好是[l,r]，我们选择节点数最少的那个集合进行修改，并对这些集合进行标记，只有当某次访问需要这些节点的子节点时，才把变化传递下去，这样可以大大减少对更深处的节点的修改次数，降低时间复杂度。\n实现\nvoid update(int l, int r, int cl, int cr, int p, ll x) {\n    // 给区间[l,r]的每个数都加上x\n    // if (cr&lt;l || cl&gt;r)return;\n    if (cl &gt;= l &amp;&amp; cr &lt;= r) {\n        tree[p].d += (cr - cl + 1) * x;\n        tree[p].lazy += x;\n        return;\n    }\n    int m = cl + ((cr - cl) &gt;&gt; 1);\n    if (tree[p].lazy) {\n        tree[p &lt;&lt; 1].d += tree[p].lazy * (m - cl + 1);\n        tree[(p &lt;&lt; 1) | 1].d += tree[p].lazy * (cr - m);\n        tree[p &lt;&lt; 1].lazy += tree[p].lazy;\n        tree[(p &lt;&lt; 1) | 1].lazy += tree[p].lazy;\n        tree[p].lazy = 0ll;\n    }\n    if (m &gt;= l)update(l, r, cl, m, p &lt;&lt; 1, x);\n    if (m &lt; r)update(l, r, m + 1, cr, (p &lt;&lt; 1) | 1, x);\n \n    tree[p].d = tree[p &lt;&lt; 1].d + tree[(p &lt;&lt; 1) | 1].d;\n}\n相应的，引入懒区间之后，我们在区间查询的时候要考虑懒标记是否下达，如果没有下达则要将懒标记传递下去。\nll getsum(int l, int r, int cl, int cr, int p) {\n    // if (cr&lt;l || cl&gt;r)return 0ll;     // 操作正确的话不可能会出现这种情况\n    if (cl &gt;= l &amp;&amp; cr &lt;= r)return tree[p].d;\n \n    int m = cl + ((cr - cl) &gt;&gt; 1);\n \n    if (tree[p].lazy) {\n        tree[p &lt;&lt; 1].lazy += tree[p].lazy, tree[(p &lt;&lt; 1) | 1].lazy += tree[p].lazy;\n        tree[p &lt;&lt; 1].d += tree[p].lazy * (m + 1 - cl), tree[(p &lt;&lt; 1) | 1].d += tree[p].lazy * (cr - m);\n        tree[p].lazy = 0;\n    }\n \n    ll sum = 0ll;\n    if (m &gt;= l)\n        sum += getsum(l, r, cl, m, p &lt;&lt; 1);\n    if (m &lt; r)\n        sum += getsum(l, r, m + 1, cr, (p &lt;&lt; 1) | 1);\n    return sum;\n}\n例题指路：\n区间求和：P3372 【模板】线段树 1 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n参考\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 1e5 + 10;\n/*\n线段树模板1：实现区间加/求和的模板\n洛谷P3372\n*/\nstruct segTreeNode {\n    ll d, lazy;     // 数据&amp;懒标记\n    bool used;  // 标记是否修改过\n};\n \nvector&lt;ll&gt;a(maxn);  // 原数据\nvector&lt;segTreeNode&gt;tree(maxn * 4);\n \nvoid build(int l, int r, int p) {\n    if (l == r) {\n        tree[p].d = a[l];\n        return;\n    }\n    int m = l + ((r - l) &gt;&gt; 1);\n \n    build(l, m, p &lt;&lt; 1);\n    build(m + 1, r, (p &lt;&lt; 1) | 1);\n \n    tree[p].d = tree[p &lt;&lt; 1].d + tree[(p &lt;&lt; 1) | 1].d;\n}\n \nvoid update(int l, int r, int cl, int cr, int p, ll x) {\n    // 给区间[l,r]的每个数都加上x\n    // if (cr&lt;l || cl&gt;r)return;\n    if (cl &gt;= l &amp;&amp; cr &lt;= r) {\n        tree[p].d += (cr - cl + 1) * x;\n        tree[p].lazy += x;\n        return;\n    }\n    int m = cl + ((cr - cl) &gt;&gt; 1);\n    if (tree[p].lazy) {\n        tree[p &lt;&lt; 1].d += tree[p].lazy * (m - cl + 1);\n        tree[(p &lt;&lt; 1) | 1].d += tree[p].lazy * (cr - m);\n        tree[p &lt;&lt; 1].lazy += tree[p].lazy;\n        tree[(p &lt;&lt; 1) | 1].lazy += tree[p].lazy;\n        tree[p].lazy = 0ll;\n    }\n    if (m &gt;= l)update(l, r, cl, m, p &lt;&lt; 1, x);\n    if (m &lt; r)update(l, r, m + 1, cr, (p &lt;&lt; 1) | 1, x);\n \n    tree[p].d = tree[p &lt;&lt; 1].d + tree[(p &lt;&lt; 1) | 1].d;\n}\n \nll getsum(int l, int r, int cl, int cr, int p) {\n    // if (cr&lt;l || cl&gt;r)return 0ll;     // 操作正确的话不可能会出现这种情况\n    if (cl &gt;= l &amp;&amp; cr &lt;= r)return tree[p].d;\n \n    int m = cl + ((cr - cl) &gt;&gt; 1);\n    if (tree[p].lazy) {\n        tree[p &lt;&lt; 1].lazy += tree[p].lazy, tree[(p &lt;&lt; 1) | 1].lazy += tree[p].lazy;\n        tree[p &lt;&lt; 1].d += tree[p].lazy * (m + 1 - cl), tree[(p &lt;&lt; 1) | 1].d += tree[p].lazy * (cr - m);\n        tree[p].lazy = 0;\n    }\n    ll sum = 0ll;\n    if (m &gt;= l)\n        sum += getsum(l, r, cl, m, p &lt;&lt; 1);\n    if (m &lt; r)\n        sum += getsum(l, r, m + 1, cr, (p &lt;&lt; 1) | 1);\n    return sum;\n}\n \nvoid solve() {\n    int n, m;cin &gt;&gt; n &gt;&gt; m;\n    for (int i = 1;i &lt;= n;i++)\n        cin &gt;&gt; a[i];\n    build(1, n, 1);\n    while (m--) {\n        int op;cin &gt;&gt; op;\n        if (op == 1) {\n            int x, y;ll k;\n            cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;\n            update(x, y, 1, n, 1, k);\n        }\n        else {\n            int x, y;cin &gt;&gt; x &gt;&gt; y;\n            cout &lt;&lt; getsum(x, y, 1, n, 1) &lt;&lt; &#039;\\n&#039;;\n        }\n    }\n}\n \nint main() {\n    int _ = 1;\n    // cin &gt;&gt; _;cin.get();\n    while (_--)\n        solve();\n}\n思考\n相似的，如果是将某个区间内的值都修改为某个值，应该如何操作？\n例题 1（两种懒标记）\nP3373 【模板】线段树 2 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n\n操作 1： 格式：1 x y k 含义：将区间[x,y]内每个数乘上 k\n操作 2： 格式：2 x y k 含义：将区间[x,y] 内每个数加上 k\n操作 3： 格式：3 x y 含义：输出区间 [x,y] 内每个数的和对 m 取模所得的结果\n这题需要考虑两种修改值的操作之间的相互影响。\n\n每次对节点加/乘之前，要判断是否需要将当前节点的两种懒标记向下传递\n判断时应该先乘后加\n\n\n参考\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 1e5 + 10;\n/*\n线段树模板2：实现区间加+乘、求和的模板\n洛谷P3372\n*/\nstruct segTreeNode {\n    ll d, lazyPlus, lazyTime;\n    /*TIP:在开结构体vector时已有初始值会使所有初始值塞入程序，会导致编译时间过长+内存溢出*/\n    bool used;  // 标记是否修改过\n};\n \nll mo;\nvector&lt;ll&gt;a(maxn);  // 原数据\nvector&lt;segTreeNode&gt;tree(maxn * 4);\n \nvoid build(int l, int r, int p) {\n    tree[p].lazyTime = 1ll;\n    if (l == r) {\n        tree[p].d = a[l] % mo;\n        return;\n    }\n    int mid = l + ((r - l) &gt;&gt; 1);\n \n    build(l, mid, p &lt;&lt; 1);\n    build(mid + 1, r, (p &lt;&lt; 1) | 1);\n \n    tree[p].d = (tree[p &lt;&lt; 1].d + tree[(p &lt;&lt; 1) | 1].d) % mo;\n}\n \nvoid pd(int cl, int cr, int p) {\n    int l = p &lt;&lt; 1;\n    int r = (p &lt;&lt; 1) | 1;\n    // 先乘后加\n    if (tree[p].lazyTime != 1ll) {\n        tree[l].lazyTime *= tree[p].lazyTime;\n        tree[r].lazyTime *= tree[p].lazyTime;\n        tree[l].lazyTime %= mo;\n        tree[r].lazyTime %= mo;\n \n        // 对子节点懒标记乘\n        tree[l].lazyPlus *= tree[p].lazyTime;\n        tree[r].lazyPlus *= tree[p].lazyTime;\n        tree[l].lazyPlus %= mo;\n        tree[r].lazyPlus %= mo;\n        // 对子节点数值乘\n        tree[l].d *= tree[p].lazyTime;\n        tree[r].d *= tree[p].lazyTime;\n        tree[l].d %= mo;\n        tree[r].d %= mo;\n \n        tree[p].lazyTime = 1ll;\n    }\n \n    int mid = cl + ((cr - cl) &gt;&gt; 1);\n \n    if (tree[p].lazyPlus) {\n        tree[l].d += tree[p].lazyPlus * (mid - cl + 1);\n        tree[l].d %= mo;\n        tree[r].d += tree[p].lazyPlus * (cr - mid);\n        tree[r].d %= mo;\n        tree[l].lazyPlus += tree[p].lazyPlus;\n        tree[l].lazyPlus %= mo;\n        tree[r].lazyPlus += tree[p].lazyPlus;\n        tree[r].lazyPlus %= mo;\n        tree[p].lazyPlus = 0ll;\n    }\n}\n \nvoid updateTime(int l, int r, int cl, int cr, int p, ll x) {\n    // 给区间[l,r]的每个数都乘上x\n    if (cl &gt;= l &amp;&amp; cr &lt;= r) {\n        tree[p].lazyTime *= x;\n        tree[p].lazyTime %= mo;\n        tree[p].lazyPlus *= x;\n        tree[p].lazyPlus %= mo;\n        tree[p].d *= x;\n        tree[p].d %= mo;\n        return;\n    }\n \n    pd(cl, cr, p);\n \n    int mid = cl + ((cr - cl) &gt;&gt; 1);\n    if (mid &gt;= l)updateTime(l, r, cl, mid, p &lt;&lt; 1, x);\n    if (mid &lt; r)updateTime(l, r, mid + 1, cr, (p &lt;&lt; 1) | 1, x);\n \n    tree[p].d = (tree[p &lt;&lt; 1].d + tree[(p &lt;&lt; 1) | 1].d) % mo;\n}\n \nvoid updatePlus(int l, int r, int cl, int cr, int p, ll x) {\n    // 给区间[l,r]的每个数都加上x\n    if (cl &gt;= l &amp;&amp; cr &lt;= r) {\n        tree[p].d += (cr - cl + 1) * x;\n        tree[p].d %= mo;\n        tree[p].lazyPlus += x;\n        tree[p].lazyPlus %= mo;\n        return;\n    }\n \n    pd(cl, cr, p);\n \n    int mid = cl + ((cr - cl) &gt;&gt; 1);\n    if (mid &gt;= l)updatePlus(l, r, cl, mid, p &lt;&lt; 1, x);\n    if (mid &lt; r)updatePlus(l, r, mid + 1, cr, (p &lt;&lt; 1) | 1, x);\n \n    tree[p].d = (tree[p &lt;&lt; 1].d + tree[(p &lt;&lt; 1) | 1].d) % mo;\n}\n \nll getsum(int l, int r, int cl, int cr, int p) {\n    if (cl &gt;= l &amp;&amp; cr &lt;= r)return tree[p].d;\n \n    int mid = cl + ((cr - cl) &gt;&gt; 1);\n \n    pd(cl, cr, p);\n \n    ll sum = 0ll;\n    if (mid &gt;= l)\n        sum += getsum(l, r, cl, mid, p &lt;&lt; 1);\n    sum %= mo;\n    if (mid &lt; r)\n        sum += getsum(l, r, mid + 1, cr, (p &lt;&lt; 1) | 1);\n    return sum % mo;\n}\n \nvoid solve() {\n    int n, q;cin &gt;&gt; n &gt;&gt; q &gt;&gt; mo;\n    for (int i = 1;i &lt;= n;i++)\n        cin &gt;&gt; a[i];\n    build(1, n, 1);\n    while (q--) {\n        int op;cin &gt;&gt; op;\n        if (op == 1) {\n            int x, y;ll k;\n            cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;\n            updateTime(x, y, 1, n, 1, k);\n        }\n        else if (op == 2) {\n            int x, y;ll k;\n            cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;\n            updatePlus(x, y, 1, n, 1, k);\n        }\n        else {\n            int x, y;cin &gt;&gt; x &gt;&gt; y;\n            cout &lt;&lt; getsum(x, y, 1, n, 1) &lt;&lt; &#039;\\n&#039;;\n        }\n    }\n}\n \nint main() {\n    int _ = 1;\n    // cin &gt;&gt; _;cin.get();\n    while (_--)\n        solve();\n}\n动态开点\n一般来说，线段树处理的范围在[1,n]，n一般是1e5的大小。\n如果我们想处理负数的范围，或者是n达到1e9的数量级时，我们就需要可以动态开点的线段树。\n线段树我们一般开到4n的大小是充足的，为了节省空间以及直接建立全树的时间，我们也可以对线段树动态开点，也就是只有当我们需要用到某些节点的时候，才去创造它。\n比如，我们已经一个节点表示[11,16]的相关数据，我们需要修改[13,15]上的信息，我们就创造[11,13]和[14,16]的节点，并继续递归创建节点，直到这个线段树可以完全表示到已被修改的信息。\n实现\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int maxv = 8e6;  // 一般有多大开多大\n \n/*\n线段树模板3：动态开点技巧\n*/\nstruct segTreeNode {\n    ll d, lazy;\n    int lson, rson; // 记录左右子的下标\n};\n \nvector&lt;segTreeNode&gt;tree(maxv);\nint tot = 1;    // 总节点数\n \nvoid update(int cl, int cr, int&amp; p, ll addnum) {\n    if (!p)p = ++tot;\n    tree[p].d += addnum * (cr - cl + 1);\n    tree[p].lazy += addnum;\n}\n \nvoid pushdown(int p, int cl, int cr) {  // 节点p没有左右子时给它开点。\n    if (cr - cl + 1 &lt;= 1)return;\n    int mid = (cr + cl - 1) &gt;&gt; 1;\n    update(cl, mid, tree[p].lson, tree[p].lazy);\n    update(mid + 1, cr, tree[p].rson, tree[p].lazy);\n    tree[p].lazy = 0;\n}\n \nvoid updatePlus(int l, int r, int cl, int cr, int p, ll x) {\n    // 给区间[l,r]里每个数加x\n    if (cl &gt;= l &amp;&amp; cr &lt;= r) {\n        tree[p].d += x * (cr - cl + 1);\n        tree[p].lazy += x;\n        return;\n    }\n    pushdown(p, cl, cr);\n    int mid = (cl + cr - 1) &gt;&gt; 1;\n    if (mid &gt;= l)updatePlus(l, r, cl, mid, tree[p].lson, x);\n    if (mid &lt; r)updatePlus(l, r, mid + 1, cr, tree[p].rson, x);\n \n    int ls = tree[p].lson, rs = tree[p].rs;\n    tree[p].d = tree[ls].d + tree[rs].d;\n}\n \nll getsum(int l, int r, int cl, int cr, int p) {\n    if (cl &gt;= l &amp;&amp; cr &lt;= r)return tree[p].d;\n \n    pushdown(p, cl, cr);\n    int mid = (cl + cr - 1) / 2;  // 可以处理区间两端是负数的情况\n    ll sum = 0ll;\n    sum += getsum(l, r, cl, mid, tree[p].lson);\n    sum += getsum(l, r, mid + 1, cr, tree[p].rson);\n    return sum;\n}\n \nvoid solve() {\n    ll n, q;cin &gt;&gt; n &gt;&gt; q;\n    while (q--) {\n        ll l, r, k;cin &gt;&gt; l &gt;&gt; r &gt;&gt; k;\n        if(k==1){}\n    }\n}\n \nint main() {\n    int _ = 1;\n    // cin &gt;&gt; _;cin.get();\n    while (_--)\n        solve();\n}\n线段树合并与分裂\n线段树合并\n线段树合并通过递归实现，需要有合并操作的线段树需要使用动态开点的技巧。\n将线段树 a 和 b 合并，从 1 号点开始递归，若递归到某个节点为空，直接返回另一个树上的对应节点；若递归到叶子节点，我们合并两棵树上的对应节点。\nvoid pushup(int a) {\n    int ls = tree[a].lson, rs = tree[a].rson;\n    tree[a].d = tree[ls].d + tree[rs].d;\n}\n \nint merge(int a, int b, int l, int r) {\n    if (!a)return b;\n    if (!b)return a;\n    if (l == r) {\n        // do sth\n        return a;\n    }\n \n    int mid = (l + r) &gt;&gt; 1;\n    tree[a].lson = merge(tree[a].lson, tree[b].lson, l, mid);\n    tree[a].rson = merge(tree[a].rson, tree[b].rson, mid + 1, r);\n \n    pushup(a);\n    return a;\n}\n模板题：[P4556 Vani 有约会] 雨天的尾巴 /【模板】线段树合并 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n线段树分裂\n线段树分裂是线段树合并的逆过程。\n线段树分裂只适用于有序的序列，无序的序列是没有意义的，常用在动态开点的权值线段树上。\n当分裂和合并都存在时，要注意回收节点，以免分裂时会出现节点重复/占用的问题。\n\n当[s,t]与[l,r]有交集时开新节点\n当[s,t]包含于[l,r]时，直接将当前节点接到新的树下面，把旧边断开。\n\nvoid pushup(int a) {\n    int ls = tree[a].lson, rs = tree[a].rson;\n    tree[a].d = tree[ls].d + tree[rs].d;\n}\n \nvoid split(int&amp; p, int&amp; q, int s, int t, int l, int r) {\n    // 从[s,t]的线段树中分裂出区间是[l,r]的线段树\n    if (t &lt; l || r &lt; s) return;\n    if (!p) return;\n    if (l &lt;= s &amp;&amp; t &lt;= r) {\n        q = p;\n        p = 0;\n        return;\n    }\n    if (!q) q = ++tot;\n    int m = s + t &gt;&gt; 1;\n    if (l &lt;= m) split(tree[p].lson, tree[p].rson, s, m, l, r);\n    if (m &lt; r) split(tree[p].lson, tree[p].rson, m + 1, t, l, r);\n    pushup(p);\n    pushup(q);\n}\n模板题：P5494 【模板】线段树分裂 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n练习题一览\n一些模板题/测测你的板子(!\nP3372 【模板】线段树 1 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\nP3373 【模板】线段树 2 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\nProblem - 5306 (hdu.edu.cn)\n[P4556 Vani 有约会] 雨天的尾巴 /【模板】线段树合并 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\nP5494 【模板】线段树分裂 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n[P4097 【模板】李超线段树 / HEOI2013] Segment - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\nP3369 【模板】普通平衡树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\nP3391 【模板】文艺平衡树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)"},"03-algorithm/shortest_path":{"slug":"03-algorithm/shortest_path","filePath":"03-algorithm/shortest_path.md","title":"最短路问题（Dijkstra + SPFA + Floyd）","links":[],"tags":["图论","最短路"],"content":"思维先行\n我们要找某点到某点的最短路径(记为点u到点v)，这样的路径只能从两种路径中选择——\n\nu和v之间有边连接时，存在边(u, v)，不存在的话可以视作这两点的距离无限大\nu和v可以通过某些点中转相连，这个(最短的)中转路径\n\n很明显，我们选最短路径肯定是在这两种路径当中选最短的来作为u和v的最短距离，而路径选择2又可以不断拆分，比如我们有u -&gt; P -&gt; v我们再去寻找这条路径的最短时，可以分为u -&gt; P最短+P -&gt; v最短，再去寻找中转点…而且每次取最小值最小的+最小的肯定得最小的（有一点贪心的感觉）。\n那么思维布置到这，我们来看看这个寻找最短路径的几种算法：\nFloyd算法&amp;Bellman-Ford算法\n\nFloyd算法\n\n这个算法就是刚刚思维里的算法的朴素实现了，动态规划思维，不断去尝试增加节点来找最小值。伪代码如下：\n#define INF 0x3f3f3f3f\ndist[maxn][maxn];\n// dist[u][v]记录从点u到点v的距离\n// 初始化时dist[n][n]=0, 两点有边则记录为w&lt;u, v&gt;，其他的就是INF\nvoid Floyd(int n){\n\t// 一共有n个点，我们遍历填充dist[][]数组来计算所有的距离\n\tfor(int p=1 ;p &lt;= n;p++){\n\t\t// 点p是中转点\n\t\tfor(int u=1;u&lt;=n;u++){\n\t\t\tfor(int v=1;v&lt;=n;v++){\n\t\t\t\tdist[u][v] = min(dist[u][v], dist[u][p]+dist[p][v]);\n\t\t\t}\n\t\t}\n\t}\n}\n很明显，这个算法有O(n^3)的复杂度，并不好，而且开的dist[maxn][maxn]数组空间也大，和之前学习存储图时一样，如果图比较稀疏，浪费的空间也大。\n如何优化呢？\n先看算法上，我们在选择中间点p的时候，我们很容易想到——并不是所有的点1~点n和u都有边，所以假如我们按边存储成为邻接表(前向星/链式前向星)，我们在搜索边的时候就能直接在已有的&lt;u, p&gt;边上进行选择。\nTIP：Floyd算法可以获得所有点之间的最短距离，所以在需要处理多源最短路且数据规模比较小的时候会选择它。\n我们更关心单源最短路问题，接下来我们的问题就假定为：找到以点v1为起点的最短路。\n由于是确定起点的单源最短路，我们接下来记录距离的数组只用开一维就行。\n初始化：dist[1]=0, dist[v]=distance[1][v], 其他的置INF。\n在Bellman-Ford算法中，我们假设不存在负权环（有负权环我们就会发现每绕一次dist都在变小，而我们取min（dist[v],weight(p-&gt;v)+dist[v]）肯定会把路径上的这个负权环走超过n遍），那么从v1到任何点的路径上点的个数都不会大于总点数n，所以Bellman-Ford算法就直接暴力搜n次来找最短路,到这里我们先代码实现一下这样的思路：\n给出一个图例like this：\ngraph LR\nv1((v1))-.4.-&gt;v2((v2))\nv1((v1))-.3.-&gt;v3((v3))\nv1((v1))-.8.-&gt;v4((v4))\nv2((v2))-.2.-&gt;v6((v6))\nv7((v7))-.5.-&gt;v6((v6))\nv7((v7))-.1.-&gt;v4((v4))\nv3((v3))-.1.-&gt;v7((v7))\nv4((v4))-.5.-&gt;v3((v3))\nv4((v4))-.5.-&gt;v5((v5))\n\n样例：\n7 9\n1 2 4\n1 3 3\n1 4 8\n2 6 2\n3 7 1\n4 3 5\n4 5 5\n7 6 5\n7 4 1\n \n参考代码like this：\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n#define INF 0x3f3f3f3f\nconst long long maxn = 1e5 + 50, maxm = 1e7 + 50;\n \nstruct EdgeNode {\n\tint from;\n\tint to;\t\t// 终点\n\tint w;\t\t// 权值\n\tint next;\t// 下一位置\n};\nEdgeNode Edge[maxm];\nint head[maxn];\n \nint dist[maxm];\nint n, m;\n \nvoid BellmanFord(int vn) {\n\t// 初始化dist[]\n\tfill(dist + 1, dist + n + 1, INF);\n\tdist[vn] = 0;\n \n\tint turn = n - 1;\n\twhile (turn--)\n\t\t// 下方的遍历重复n-1遍，保证可以更新全部的dist[]\n\t\tfor (int ei = 0;ei &lt; m;ei++)\n\t\t\tdist[Edge[ei].to] = min(dist[Edge[ei].to], dist[Edge[ei].from] + Edge[ei].w);\n\t// 这里为了方便获得查看的边的起点，可以在储存边的起点的时候加一个from的信息(否则就要先去找起点是谁)\n}\n \nint main() {\n\tcin &gt;&gt; n &gt;&gt; m;\n \n\t// 初始化head\n\tmemset(head, -1, sizeof(head));\n\t\n\t// 读入数据\n\tfor (int i = 0;i &lt; m;i++) {\n\t\tint fi, ti, wi;\n\t\tcin &gt;&gt; fi &gt;&gt; ti &gt;&gt; wi;\n\t\tEdge[i].to = ti;\n\t\tEdge[i].w = wi;\n\t\tEdge[i].from = fi;\n \n\t\tEdge[i].next = head[fi];\n\t\thead[fi] = i;\n\t}\n \n\tBellmanFord(1);\n \n\tfor (int i = 1;i &lt;= n;i++)\n\t\tcout &lt;&lt; dist[i] &lt;&lt; &quot; &quot;;\n\tcout &lt;&lt; endl;\n\t// -&gt;0 4 3 5 10 6 4 \n \n\treturn 0;\n}\nIDEA：我们在这个算法中可以发现，我们选边的时候对于它终点于何处并不关心，相反，我们会关心它的起点的信息（我们要算的源起点到该边的起点的距离），所以直接在存边的时候添加起点(from)的记录会方便我们确定起点。\n虽然上文提到我们不考虑负权环的存在，但是我们可以想象，如果存在负权环，该图进入Bellman-Ford算法之后会有神奇的数据产生，我们试试看：\n给我们的测试数据添加一个负权边：\n7 10\n1 2 4\n1 3 3\n1 4 8\n2 6 2\n3 7 1\n4 3 5\n4 5 5\n7 7 -9\n7 6 5\n7 4 1\n \ngraph LR\nv1((v1))-.4.-&gt;v2((v2))\nv1((v1))-.3.-&gt;v3((v3))\nv1((v1))-.8.-&gt;v4((v4))\nv2((v2))-.2.-&gt;v6((v6))\nv7((v7))-.5.-&gt;v6((v6))\nv7((v7))-.1.-&gt;v4((v4))\nv3((v3))-.1.-&gt;v7((v7))\nv4((v4))-.5.-&gt;v3((v3))\nv4((v4))-.5.-&gt;v5((v5))\nv7((v7))-. -9 .-&gt;v7((v7))\n\n同样的程序跑出来的结果是：\n0 4 -35 -49 -35 -45 -50\n原来的结果：\n0 4 3 5 10 6 4 \n思考：不管有没有负权环，我们得到的其实都是合理的最短路径，但是存在负权环会使得到某些点的最短距离一定会减少（加上一个负数肯定变小，而我们选择的是较小的那个路径），所以有负权环时，最短路径(假设路径上的点的数量没有限制)其实可以无限短，我们先前用暴力循环所有的点来保证所有的dist数组能够更新到最佳，那么假如有负权环在其中，dist数组没有最佳状态，所以我们简单的多循环一边，假如没有负权环，再多循环一边并不会改变dist数组里的值，如果有负权环，dist数组里一定有值改变。我们试试看：\n原来保证得到最佳只需要暴力循环n-1遍，得结果：\n0 4 -35 -49 -35 -45 -50\n暴力n次的结果：\n0 4 -44 -58 -44 -54 -59\n符合我们的想法。\n不过啊这个算法还是有暴力的成分，我们先前提到的只要遍历那些起点可直接到达的点等等想法还没实现，Bellman-Ford算法的时间复杂度有O(nm)，我们讨论算法的对于这样的复杂度肯定还是不满意的。\n我们再回忆一下整个搜索过程：其实我们关系的只是可以拓展的可能当中最小的是哪个，为了找到最小的那个，我们上面用了搜索全部的边、点的方法。那么我们的目的还是还是：有没有一种可以维护数据结构的方式，让我们更容易找到最小的那个可能？\n于是队列优化进入思维\nSPFA算法\n我们找u -&gt; p -&gt; v路径时，p点的选择方法会实际影响我们的复杂度。我们的目的肯定是去更新u可以直接到达的点，而下一次就是p可以直接到达的点…\nSPFA算法使用一个队列去记录这些可以直接到达的点(也就是答案可能在的路径上)。\nSPFA是如何做到“只更新可能更新的点”的？\n\n只让当前点能到达的点入队\n如果一个点已经在队列里，便不重复入队\n如果一条边的起点还没被更新，那么它的终点不入队\n\n也就是说：当一个点入队了，代表它还在等待更新，当一个点出队了，那么它一定在当前经过最好的更新了。\n会有一个点入队了更新之后再次入队的情况吗？会有这种可能。\n来看看代码实现吧：\n// 因为queue其实没有查找操作，所以简单用个bool型数组记录点p在队列中?inqueue[p]=true:inque[p]=false\nbool inqueue[maxn];\nvoid SPFA(int vn) {\n\t// 寻找vn到各个点的最短路径，记录在dist[]数组中。\n \n\t// 初始化dist[]\n\tfill(dist + 1, dist + n + 1, INF);\n\tdist[vn] = 0;\n \n\tqueue&lt;int&gt; updates;\n\tupdates.push(vn);\t// 将vn点加入待更新队列\n \n\twhile (!updates.empty()) {\n\t\t// 获得队首点，并把它移除待更新队列\n\t\tint firstp = updates.front();\n\t\tupdates.pop();\n \n\t\tinqueue[firstp] = false;\t// 标记firstp已经不在队列中\n \n\t\tfor (int k = head[firstp], to = Edge[k].to;k != -1;k = Edge[k].next, to = Edge[k].to) {\n\t\t\t// 遍历k可以直接到达的点to\n\t\t\tif (dist[to] &gt; dist[firstp] + Edge[k].w) {\n\t\t\t\tdist[to] = dist[firstp] + Edge[k].w;\n\t\t\t\tif (!inqueue[to]) {\n\t\t\t\t\tupdates.push(to);\n\t\t\t\t\tinqueue[to] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n \nSPFA算法的时间复杂度并不稳定，可以预想，在极端的情况下，SPFA算法的复杂度可以和Bellman-Ford算法一样是O(nm)（不过随机数据模拟的算法复杂度大概是O(m + nlogn)）\nSPFA算法也可以判断负权环的存在：若一个点入队次数超过n次，接下来无论怎么更新队列都不会为空，可以据此判断是否有负权环。\nemmm优化了一点的BellmanFord算法？(思考)\n接下来介绍复杂度稳定的贪心算法：Dijstra算法\n☆☆☆Dijstra算法\nDij假设没有负边\n因为没有负边，我们可以确定，离起点最近的那个顶点的dist一定是那个顶点的最终结果。\n思路：起点u可以直接到达的点中，最近的点p对应的e&lt;u, p&gt;一定是dist[p]的最佳值。假如它已经是最佳值了，我们在后面就可以把它当做起点u一样的点。由此我们只需要不断取出待更新队列里dist最小的点，并向后更新一层，直到没有需要再更新的点为止。\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n#define INF 0x3f3f3f3f\nconst long long maxn = 1e5 + 50, maxm = 1e7 + 50;\n \nstruct EdgeNode {\n\tint from;\n\tint to;\t\t// 终点\n\tint w;\t\t// 权值\n\tint next;\t// 下一位置\n};\nEdgeNode Edge[maxm];\nint head[maxn];\n \nint dist[maxm];\nint n, m;\nint path[maxm];\t// 储存路径(存边)\nstruct Polar {\n\t// 注意每个dist其实是一对一的绑定了它的索引的，直接写什么return dist[a]&gt;dist[b]会破坏堆的结构，可能会让dist[a]和dist[b]的索引变化。\n\tint id, dist;\n \n\tPolar(int dist, int id) :dist(dist), id(id) {}\n\t// 对结构体中传数据，和下面这种写法作用一样：\n\t// Polar(int d, int d_id) {\n\t// \tdist = d;\n\t// \tid = d_id;\n\t// }\n\t// 重载运算符&lt;\n\tbool operator&lt;(const Polar&amp; P)const {\n\t\treturn dist &lt; P.dist;\n\t}\n};\nstruct cmp {\n\t// // 重写仿函数法：\n\tbool operator ()(Polar a, Polar b) {\n\t\t// 重载()运算符，使其成为一个仿函数\n\t\treturn a.dist &gt; b.dist;\t\n\t}\n};\n// priority_queue&lt;Polar, vector&lt;Polar&gt;, cmp&gt; q;\npriority_queue&lt;Polar&gt; q;\nbool visited[maxn];\nvoid Dij(int vn) {\n\tfill(dist + 1, dist + n + 1, INF);\n\tdist[vn] = 0;\n\t\n\tq.push(Polar(0, vn));\n\twhile (!q.empty()) {\n\t\tint pid = q.top().id;\n\t\tq.pop();\n\t\tif (visited[pid]) \n\t\t\t// 若已经在队列中\n\t\t\tcontinue;\n\t\t\n\t\tvisited[pid] = true;\n\t\tfor (int ei = head[pid], to = Edge[ei].to;ei != -1;ei = Edge[ei].next, to = Edge[ei].to) {\n\t\t\tif (dist[pid] + Edge[ei].w &lt; dist[to]){\n\t\t\t\tdist[to] = dist[pid] + Edge[ei].w;\n\t\t\t\tpath[to] = Edge[ei].from;\t// 记录路径的\n               \tif (!visited[to])\n\t\t\t\tq.push(Polar(dist[to], to));\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n}\n \nint main() {\n\tcin &gt;&gt; n &gt;&gt; m;\n \n\t// 初始化head\n\tmemset(head, -1, sizeof(head));\n    \n\t// 读入数据\n\tfor (int i = 0;i &lt; m;i++) {\n\t\tint fi, ti, wi;\n\t\tcin &gt;&gt; fi &gt;&gt; ti &gt;&gt; wi;\n\t\tEdge[i].to = ti;\n\t\tEdge[i].w = wi;\n\t\tEdge[i].from = fi;\n \n\t\tEdge[i].next = head[fi];\n\t\thead[fi] = i;\n\t}\n \n\tint s = 1, t = 5;\n\tDij(s);\n \n\tfor (int i = 1;i &lt;= n;i++)\n\t\tcout &lt;&lt; dist[i] &lt;&lt; &quot; &quot;;\n\tcout &lt;&lt; endl;\n\t// -&gt;0 4 3 5 10 6 4\n \n\twhile (t != s) {\n\t\tcout &lt;&lt; t &lt;&lt; &quot;&lt;-&quot;;\n\t\tt = path[t];\n\t}\n\tcout &lt;&lt; t;\n    // -&gt;5&lt;-4&lt;-7&lt;-3&lt;-1\n \n\treturn 0;\n}\n当然了用pair也行，反正只有id和dist两个数据，多个其实也没关系你也可以pair套pair\n(另外两种简单的写法在STL.md里面写了，这里不写了)\n-如何记录路径？\n把在更新点更新path数组就行。也就是dist[pos]&gt;dist[u]+w(u→pos)的时候把这个更新的来源放在path数组里就行（记录到达某点的最好的路径的上一个来源点）。像这样：\nif (dist[pid] + Edge[ei].w &lt; dist[to]){\n    dist[to] = dist[pid] + Edge[ei].w;\n    path[to] = Edge[ei].from;\n}\n模板题\n\n模板题指路：\nP3371 【模板】单源最短路径（弱化版） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\nP4779 【模板】单源最短路径（标准版） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\nP3371【模板】单源最短路径（弱化版）\n题目背景\n本题测试数据为随机数据，在考试中可能会出现构造数据让SPFA不通过，如有需要请移步 P4779。\n题目描述\n如题，给出一个有向图，请输出从某一点出发到所有点的最短路径长度。\n输入格式\n第一行包含三个整数 n,m,s，分别表示点的个数、有向边的个数、出发点的编号。\n接下来 m 行每行包含三个整数 u,v,w，表示一条 u \\to v 的，长度为 w 的边。\n输出格式\n输出一行 n 个整数，第 i 个表示 s 到第 i 个点的最短路径，若不能到达则输出 2^{31}-1。\n样例\n样例输入 #1\n4 6 1\n1 2 2\n2 3 2\n2 4 1\n1 3 5\n3 4 3\n1 4 4\n样例输出 #1\n0 2 4 3\n提示\n【数据范围】\n对于 20\\% 的数据：1\\le n \\le 5，1\\le m \\le 15；\n对于 40\\% 的数据：1\\le n \\le 100，1\\le m \\le 10^4；\n对于 70\\% 的数据：1\\le n \\le 1000，1\\le m \\le 10^5；\n对于 100\\% 的数据：1 \\le n \\le 10^4，1\\le m \\le 5\\times 10^5，1\\le u,v\\le n，w\\ge 0，\\sum w&lt; 2^{31}，保证数据随机。\nUpdate 2022/07/29：两个点之间可能有多条边，敬请注意。\n对于真正 100\\% 的数据，请移步 P4779。请注意，该题与本题数据范围略有不同。\n样例说明：\n\n图片1到3和1到4的文字位置调换\n\nAC代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n#define INF 0x3f3f3f3f\nconst long long maxn = 1e5 + 50, maxm = 1e7 + 50;\ntypedef long long ll;\nstruct EdgeNode {\n\tint from;\n\tint to;\t\t// 终点\n\tll w;\t\t// 权值\n\tint next;\t// 下一位置\n};\nEdgeNode Edge[maxm];\nint head[maxn];\n \nll dist[maxm];\nll n, m;\nbool inqueue[maxn];\nvoid SPFA(int vn) {\n\tfill(dist + 1, dist + n + 1, INF);\n\tdist[vn] = 0;\n \n\tqueue&lt;int&gt; updates;\n\tupdates.push(vn);\n\twhile (!updates.empty()) {\n\t\tint firstp = updates.front();\n\t\tupdates.pop();\n \n\t\tinqueue[firstp] = false;\n \n\t\tfor (int k = head[firstp], to = Edge[k].to;k != -1;k = Edge[k].next, to = Edge[k].to) {\n\t\t\t// 遍历k可以直接到达的点to\n\t\t\tif (dist[to] &gt; dist[firstp] + Edge[k].w) {\n\t\t\t\tdist[to] = dist[firstp] + Edge[k].w;\n\t\t\t\tif (!inqueue[to]) {\n\t\t\t\t\tupdates.push(to);\n\t\t\t\t\tinqueue[to] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n \n \nint main() {\n\tint s;\n\tcin &gt;&gt; n &gt;&gt; m &gt;&gt; s;\n \n\t// 初始化head\n\tmemset(head, -1, sizeof(head));\n\t\n\t// 读入数据\n\tfor (int i = 0;i &lt; m;i++) {\n\t\tll fi, ti, wi;\n\t\tcin &gt;&gt; fi &gt;&gt; ti &gt;&gt; wi;\n\t\tEdge[i].to = ti;\n\t\tEdge[i].w = wi;\n\t\tEdge[i].from = fi;\n \n\t\tEdge[i].next = head[fi];\n\t\thead[fi] = i;\n\t}\n \n\tSPFA(s);\n \n\tfor (int i = 1;i &lt;= n;i++)\n\t\tcout &lt;&lt; dist[i] &lt;&lt; &quot; &quot;;\n \n\treturn 0;\n}\n这个…没有卡SPFA。看另一个卡SPFA的题：\n\nP4779【模板】单源最短路径（标准版）\n题目背景\n2018 年 7 月 19 日，某位同学在 NOI Day 1 T1 归程 一题里非常熟练地使用了一个广为人知的算法求最短路。\n然后呢？\n100 \\rightarrow 60；\n\\text{Ag} \\rightarrow \\text{Cu}；\n最终，他因此没能与理想的大学达成契约。\n小 F 衷心祝愿大家不再重蹈覆辙。\n题目描述\n给定一个 n 个点，m 条有向边的带非负权图，请你计算从 s 出发，到每个点的距离。\n数据保证你能从 s 出发到任意点。\n输入格式\n第一行为三个正整数 n, m, s。\n第二行起 m 行，每行三个非负整数 u_i, v_i, w_i，表示从 u_i 到 v_i 有一条权值为 w_i 的有向边。\n输出格式\n输出一行 n 个空格分隔的非负整数，表示 s 到每个点的距离。\n样例\n样例输入 #1\n4 6 1\n1 2 2\n2 3 2\n2 4 1\n1 3 5\n3 4 3\n1 4 4\n样例输出 #1\n0 2 4 3\n提示\n样例解释请参考 数据随机的模板题。\n1 \\leq n \\leq 10^5；\n1 \\leq m \\leq 2\\times 10^5；\ns = 1；\n1 \\leq u_i, v_i\\leq n；\n0 \\leq w_i \\leq 10 ^ 9,\n0 \\leq \\sum w_i \\leq 10 ^ 9。\n本题数据可能会持续更新，但不会重测，望周知。\n2018.09.04 数据更新 from @zzq\n\nAC代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\n#define INF 0x3f3f3f3f\ntypedef long long ll;\nconst long long maxn = 1e5 + 50, maxm = 1e7 + 50;\n \nstruct EdgeNode {\n\tint from;\n\tint to;\t\t// 终点\n\tint w;\t\t// 权值\n\tint next;\t// 下一位置\n};\nEdgeNode Edge[maxm];\nint head[maxn];\n \nint dist[maxm];\nint n, m;\n// priority_queue&lt;pair&lt;ll, int&gt;&gt; q;\npriority_queue&lt;pair&lt;ll, int&gt;, vector&lt;pair&lt;ll, int&gt;&gt;, greater&lt;pair&lt;ll, int&gt;&gt;&gt; q;\nbool visited[maxn];\t// 记录已经获得最短路的点\n \nvoid Dij(int vn) {\n\tdist[vn] = 0;\n\t// 初始化\n\tq.push(make_pair(dist[vn], vn));\n\twhile (!q.empty()) {\n\t\t// 取队首元素(最小的)将它移出队列并标记移出\n\t\tint pid = q.top().second;\n\t\tq.pop();\n\t\tif (visited[pid])\n\t\t\tcontinue;\n\t\tvisited[pid] = true;\n\t\tfor (int ei = head[pid], to = Edge[ei].to;ei != -1;ei = Edge[ei].next, to = Edge[ei].to) {\n\t\t\t// 找和pid(被移出的已最佳点)相连的边，更新dist\n\t\t\tif (dist[to] &gt; dist[pid] + Edge[ei].w) {\n\t\t\t\tdist[to] = dist[pid] + Edge[ei].w;\n\t\t\t\tif (!visited[to])\n\t\t\t\t\tq.push(make_pair(dist[to], to));\n\t\t\t}\n\t\t}\n\t}\n}\n \nint main() {\n\tint s;\n\tcin &gt;&gt; n &gt;&gt; m &gt;&gt; s;\n \n\t// 初始化head\n\tmemset(head, -1, sizeof(head));\n    \n\t// 读入数据\n\tfor (int i = 0;i &lt; m;i++) {\n\t\tint fi, ti, wi;\n\t\tcin &gt;&gt; fi &gt;&gt; ti &gt;&gt; wi;\n\t\tEdge[i].to = ti;\n\t\tEdge[i].w = wi;\n\t\tEdge[i].from = fi;\n \n\t\tEdge[i].next = head[fi];\n\t\thead[fi] = i;\n\t}\n \n\tfill(dist + 1, dist + n + 1, INF);\n\tDij(s);\n \n\tfor (int i = 1;i &lt;= n;i++)\n\t\tcout &lt;&lt; dist[i] &lt;&lt; &quot; &quot;;\n\tcout &lt;&lt; endl;\n \n\treturn 0;\n}\n啊总算绕完最短路这几个算法了，时候想通了感觉还挺明白的，不过由于某人的码力好差，老是达不到想要的效果[可恶]，还得多写代码而不是只注重想法。写出来了才算是初步会了！"},"03-algorithm/string_match":{"slug":"03-algorithm/string_match","filePath":"03-algorithm/string_match.md","title":"字符串匹配问题||前缀函数+KMP+字符串哈希","links":[],"tags":["KMP","字符串","算法","哈希"],"content":"字符串匹配算法\n暴力做法(BF)\n简称BF(Brute Force)算法。\n没什么好说的，就是看到描述直接能想到的朴素做法。\nvector&lt;int&gt; BF_match(string s, string p) {\n    // s是主串，p是模式串\n    int n = s.size(), m = p.size();\n    vector&lt;int&gt; res;\n    for (int i = 0; i &lt;= n - m; i++) {\n        int j = 0;\n        for (; j &lt; m; j++) {\n            if (s[i + j] != p[j]) break;\n        }\n        if (j == m) res.push_back(i);\n    }\n    return res;\n}\nBF算法的时间复杂度不稳定。匹配成功时，最好为O(n)，最差为O(mn)；匹配失败时，最好为最好为O(n)，最差为O(mn)。平均时间复杂度为O(n)。\n前缀函数\n定义\n定义字符串S的前缀函数：\\pi [i]为其子串s[0...i]的最长相等真前缀与真后缀的长度。例如对于S=aabaaab，它的前缀函数是[0,1,0,1,2,2,3]。\n计算\n朴素算法枚举子串的长度（其中\\pi [0]=0），然后从大到小尝试枚举子串中真前缀的长度，并与同样长度的真后缀进行匹配，直到找到符合相等条件的最大长度或者长度为0，时间复杂度是O(n^3)​。\nvector&lt;ll&gt; prefix(string s) {\n    vector&lt;ll&gt;pi(s.size());\n    for (int i = 0;i &lt; s.size();i++) {\n        for (int j = i;j &gt;= 0;j--) {\n            string t = s.substr(0, j);\n            string tmp = s.substr(i - j + 1, j);\n            if (t == tmp) {\n                pi[i] = j;\n                break;\n            }\n        }\n    }\n    return pi;\n}\n考虑优化\n容易考虑到，假设有一个长度为i的子串t的前缀函数是\\pi [i]=k，则表示t1 = t[0...k-1]与t2 = t[n-k...n-1]是相同的，那么当他们同时去掉后一位字符，得到的t1&#039; = t[0....k-2]与t2&#039; = t[n-k+1...n-2]也是匹配的。换句话说，当s[k-1]=s[i]时，有\\pi[i-1]+1=\\pi[i]，并且当s[k-1]≠s[i]时，\\pi[i]将变为0或保持一个不大于s[i-1]的数。前缀函数只能在前一个匹配的状态下进行拓展，每次拓展最多只能增加1，否则维持不变或减少。\n其实这时候应该能发现，这是一个动态规划，每次向后拓展一位时，我们需要与拓展前的状态相对比，判断新加的一位是当前状态（当前匹配的前缀/后缀串）的后继（s[\\pi[i]]=s[i+1]）或者是之前的状态\\pi[p]的后继（空匹配\\pi[p]=0也算一种状态）。\n加入这个优化，我们就能优化掉每次匹配前后缀最大长度的枚举。\nvector&lt;ll&gt; prefix(string s) {\n    vector&lt;ll&gt;pi(s.size());\n    for (int i = 0;i &lt; s.size();i++) {\n        for (int j = pi[i - 1] + 1;j &gt;= 0;j--) {\n            // 注意j的最大值被限制在pi[i-1]+1\n            string t = s.substr(0, j);\n            string tmp = s.substr(i - j + 1, j);\n            if (t == tmp) {\n                pi[i] = j;\n                break;\n            }\n        }\n    }\n    return pi;\n}\n复杂度\n考虑某一次匹配，在若s[i+1]=s[\\pi[i]]，则只需要进行一次比较就能成功，而这次成功也是在s[i]=s[\\pi[i-1]]的基础上的累加。考虑：在i=n时，从j=\\pi[n-1]+1到j=1都是不匹配的，那么字符串比较累计了\\pi[n-1]+1次（j=0时是空字符串比较）。若\\pi[n-1]是最大的n-2，则在计算\\pi[n]时进行了n-1次字符串比较。同时代表\\pi[n-1]=\\pi[n-2]+1=\\pi[n-3]+1+1=...=\\pi[1]+n-2都是成立的，这里进行了n-2次加1，也就是说从\\pi[1]累计到\\pi[n-1]每次都进行1次比较，总比较次数共是n-2次匹配。总的字符串比较次数为n-1 + n-2。再考虑字符串比较复杂度是O(s.length)。优化之后的时间复杂度为O(n^2)\n再次优化\n上一步我们将整个计算前缀函数的字符串比较次数优化到O(n)的大小，在上一步的基础上，我们优化当s[i+1]\\neq s[\\pi[i]]时，如何转移到上一个符合s[i+1]=s[\\pi[k]]的状态。\n失配时，我们希望找到长度j=\\pi[k]使得s[i+1]=s[\\pi[k]]成立，也就是将i+1的状态直接从k​的状态进行继承。\n当s[j]\\neq s[i]时，若存在仅次于j的第二长度k，使得s[0...k-1]=s[i-k+1...i]成立，则\\pi[i]=k，对于这样的子串，符合以下性质：\ns[0...k-1]=s[i-k+1...i]=s[\\pi[i]-k...\\pi[i]-1]=s[0...\\pi[i]-1]\ns[0...\\pi[i]-1]的长度\\pi[i]=k，也就是说，k等价于s[0...\\pi[i]-1]的前缀函数值，也就是\\pi[\\pi[i]-1]。\n利用这个性质，每次失配之后，只需要将j更新为\\pi[j-1]即可。\nvector&lt;ll&gt; prefix(string s) {\n    int n = s.size();\n    vector&lt;ll&gt;pi(n);\n    int j = 0;\n    for (int i = 1;i &lt; n;i++) {\n        while (j &gt; 0 &amp;&amp; s[i] != s[j])j = pi[j - 1];\n        if (s[i] == s[j])j++;\n        pi[i] = j;\n    }\n    return pi;\n}\nKMP算法\n观察朴素的BF算法，造成复杂度上升的主要原因在于模式串T中指针的回溯（即匹配失败时j再次从0开始匹配，KMP算法主要优化了回溯这一步，我们为减少回溯的距离，引入了next数组来指示匹配之后回溯的位置。next数组减少回溯的想法正好是结合上面关于生成前缀函数的想法，换句话说，KMP中的next数组就是一个前缀表。\n前缀函数匹配的是前缀和后缀，当我们把待匹配串t拼接到模式串s的后面（用一个不在s和t中的字符分隔），即可按照相同的做法去生成前缀函数。考虑组合出的新字符串的前缀函数，前n+1个函数值是只和主串自身字符有关的一部分前缀函数。接下来，依次在前缀函数中加入t中的一个字符，计算当前位置的前缀函数值，若在某一位置有\\pi[i]=n成立，则代表字符串s在字符串t中的位置i-(n-1)-(n+1)=i-2*n出现（在组合串的i-(n-1)的位置出现，减去前面s和分隔符的长度即为在t中的位置）。\nvector&lt;ll&gt; prefix(string s) {\n    int n = s.size();\n    vector&lt;ll&gt;pi(n);\n    int j = 0;\n    for (int i = 1;i &lt; n;i++) {\n        while (j &gt; 0 &amp;&amp; s[i] != s[j])j = pi[j - 1];\n        if (s[i] == s[j])j++;\n        pi[i] = j;\n    }\n    return pi;\n}\nvector&lt;int&gt;kmp(string s, string t) {\n    ll n = s.size(), m = t.size();\n    string cur = t + &quot;#&quot; + s; // 找s中t的位置\n    prefix(cur);\n    vector&lt;ll&gt;v;\n    for (ll i = m + 1;i &lt;= n + m + 1;i++) {\n        if (pi[i] == m)\n            v.push_back(i - (m + 1) - (m - 1));\n    }\n    return v;\n}\nKMP模板题\n题面：P3375 【模板】KMP - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 1e7 + 50;\n \nll pi[maxn];\n \nvoid prefix(string s) {\n    ll n = s.size() - 1;\n    ll j = 0;\n    for (ll i = 1;i &lt;= n;i++) {\n        while (j &gt; 0 &amp;&amp; s[j] != s[i])j = pi[j - 1];\n        if (s[i] == s[j])j++;\n        pi[i] = j;\n    }\n}\n \nvector&lt;ll&gt;kmp(string s, string t) {\n    ll n = s.size(), m = t.size();\n    string cur = t + &quot;#&quot; + s; // 找s中t的位置\n    prefix(cur);\n    vector&lt;ll&gt;v;\n    for (ll i = m + 1;i &lt;= n + m + 1;i++) {\n        if (pi[i] == m)\n            v.push_back(i - (m + 1) - (m - 1));\n    }\n    return v;\n}\n \nint main() {\n    string s1, s2;\n    cin &gt;&gt; s1 &gt;&gt; s2;\n    vector&lt;ll&gt;v = kmp(s1, s2);\n    for (auto i : v) cout &lt;&lt; i + 1 &lt;&lt; &quot;\\n&quot;;\n    prefix(s2);\n    for (ll i = 0;i &lt; s2.size();i++) cout &lt;&lt; pi[i] &lt;&lt; &quot; &quot;;\n \n    return 0;\n}\n另一个关于KMP的题：[P4824 USACO15FEB] Censoring S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n代码\nvoid solve() {\n    string s, t;cin &gt;&gt; s &gt;&gt; t;\n    ll n = t.size();\n    t = &quot; &quot; + t;\n    ll j = 0; // 前一步匹配的长度\n    for (ll i = 2;i &lt;= n;i++) {\n        while(j &amp;&amp; t[j + 1] != t[i])j = pi[j];\n        if (t[j + 1] == t[i])j++;\n        pi[i] = j;\n    }\n    ll m = s.size();\n    s = &quot; &quot; + s;\n    ll ans[m + 5];\n    ll p = 0;j = 0;\n    for (ll i = 1;i &lt;= m;i++) {\n        while(j &amp;&amp; s[i] != t[j + 1])j = pi[j];\n        if (s[i] == t[j + 1])j++;\n        fi[i] = j;\n        ans[++p] = i;\n        if (j == n) {\n            p -= n;\n            j = fi[ans[p]]; // 跳转到匹配t之前的匹配长度\n        }\n    }\n    for (ll i = 1;i &lt;= p;i++) {\n        cout &lt;&lt; s[ans[i]];\n    }\n    cout &lt;&lt; endl;\n}\n自动机\n在KMP中生成s + &#039;#&#039; + t前缀函数时，前s + &#039;#&#039;的状态于t没有关系，而s + &#039;#&#039; + t可以由s + &#039;#&#039;的状态转移而来，如果t中包含的字符是一定的，比如约定都是小写字母，则可以根据s + &#039;#&#039;来构建一个关于下一位字符的有限状态机，逐个添加字符就是逐建更新状态。\nll pi[maxn];\n \nvoid prefix(string s) {\n    ll n = s.size();\n    s = &quot; &quot; + s;\n    ll j = 0;\n    for (ll i = 2;i &lt;= n;i++) {\n        while (j &amp;&amp; s[j + 1] != s[i])j = pi[j];\n        if (s[i] == s[j + 1])j++;\n        pi[i] = j;\n    }\n}\n \nvoid cmp_auto(string s, vector&lt;vector&lt;ll&gt;&gt;&amp; aut) {\n    s = s + &quot;#&quot;;\n    prefix(s);\n    ll n = s.size();\n    aut.assign(n, vector&lt;ll&gt;(26));\n    s = &quot; &quot; + s;\n    for (ll i = 1;i &lt;= n;i++) {\n        for (ll c = 0;c &lt; 26;c++) {\n            if (i &gt; 1 &amp;&amp; &#039;a&#039; + c != s[i])\n                aut[i][c] = aut[pi[i - 1] + 1][c];\n            else\n                aut[i][c] = i + (&#039;a&#039; + c == s[i]);\n        }\n    }\n}\n数组aut[i][c]表示在前i个字符匹配上的情况下，第i+1的字符是c时要跳转的状态，这样的跳转是O(1)​的。\n试手例题：Problem - 808G - Codeforces\n参考代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 1e6 + 50;\nconst ll inf = 0x3f3f3f3f;\n \nll pi[maxn];\n \nvoid prefix(string s) {\n    ll n = s.size();\n    s = &quot; &quot; + s;\n    ll j = 0;\n    for (ll i = 2;i &lt;= n;i++) {\n        while (j &amp;&amp; s[j + 1] != s[i])j = pi[j];\n        if (s[i] == s[j + 1])j++;\n        pi[i] = j;\n    }\n}\nll aut[maxn][26];\nll dp[2][maxn];\nvoid solve() {\n    string s, t;cin &gt;&gt; s &gt;&gt; t;\n    t = t + &quot;#&quot;;\n    ll n = t.size();\n    ll m = s.size();\n    prefix(t);\n    // aut:前i-1位已经匹配,根据t[i]与c是否相同,更新接下来与c之后的长度\n    s = &quot; &quot; + s;t = &quot; &quot; + t;\n    for (ll i = 1;i &lt;= n;i++) {\n        for (ll c = 0;c &lt; 26;c++) {\n            if (i &gt; 1 &amp;&amp; &#039;a&#039; + c != t[i])\n                aut[i][c] = aut[pi[i - 1] + 1][c];\n            else\n                aut[i][c] = i + (&#039;a&#039; + c == t[i]);\n        }\n    }\n    // 在t+&#039;#&#039;的状态机上在s上继续转移\n    memset(dp, -inf, sizeof(dp));\n    dp[0][1] = 0; // 表示到s的i位,与t匹配长度为j的次数\n    for (ll i = 1;i &lt;= m;i++) {\n        if (s[i] == &#039;?&#039;) {\n            for (ll j = 1;j &lt;= n;j++) {\n                for (ll c = 0;c &lt; 26;c++) {\n                    dp[i &amp; 1ll][aut[j][c]] = max(\n                        dp[i &amp; 1ll][aut[j][c]],\n                        dp[(i + 1ll) &amp; 1][j] + (aut[j][c] == n)\n                    );\n                }\n            }\n        }\n        else {\n            for (ll j = 1;j &lt;= n;j++) {\n                ll c = s[i] - &#039;a&#039;;\n                dp[i &amp; 1ll][aut[j][c]] = max(\n                    dp[i &amp; 1ll][aut[j][c]],\n                    dp[(i + 1ll) &amp; 1][j] + (aut[j][c] == n)\n                );\n            }\n        }\n        for (ll j = 1;j &lt;= n;j++)\n            dp[(i + 1ll) &amp; 1][j] = -inf;\n    }\n \n    ll ans = *max_element(dp[m &amp; 1ll] + 1, dp[m &amp; 1ll] + n + 1);\n    ans = max(0ll, ans);\n    cout &lt;&lt; ans &lt;&lt; endl;\n}\nint main() {\n    int t = 1;\n    // cin &gt;&gt; t;cin.get();\n    while (t--)\n        solve();\n \n    return 0;\n}\n统计所有前缀次数\n统计待匹配串s的所有前缀在t中出现的次数。\n考虑\\pi[i]的生成，依然是参照这里的推导思路，对于位置i的前缀函数值\\pi[i]，可知长度小于\\pi[i]的最长的以s[i]结尾的前缀长度是\\pi[\\pi[i]-1]，之后是\\pi[\\pi[\\pi[i]-1]-1]…，直到长度为0，因此s[0...i]的每个前缀在t中出现的次数可以统计这样的传递的次数。\nvector&lt;int&gt;cnt(n + 1); // 长度为i的前缀出现次数是cnt[i]\nfor (int i = 0;i &lt; n;i++)cnt[pi[i]]++;\nfor (int i = n - 1;i &gt; 0;i--)cnt[pi[i - 1]] += cnt[i];\n// 长度为i的前缀出现了cnt[i]次，则长度为pi[i-1]的前缀要加上cnt[i]次，因为pi[i]是在长度为pi[i-1]的前缀基础上+1而来的\nfor (int i = 0;i &lt;= n;i++)cnt[i]++;\n不同本质子串计数\n给长度为n的字符串s后添加一个新字符c，给原来的s的所有不同子串后加c后，会出现一些以这个字符c结尾的之前没出现过的子串，我们的目的是计数每次在末尾添加新字符之后的字符串的不同本质子串数目。\n举例，原串S是aba，原来的子串集合是：[S]=\\\\{a,b,ab,ba\\\\}，添加字符x之后的新串是abax，由于添加x后没有再之前的子串集合里的任何两个子串s_1,s_2中出现s_1+x=s_2的情况，那么新出现的子串数目就是原集合[S]的元素数目。假如添加的字符是b，新串是abab，那么就会发现，在原子串集合添加含有新加的b出现的新增加的元素集合[S&#039;]=\\\\{b,ab,bab\\\\}​​中\\\\{b,ab\\\\}与原有元素出现了重复。\n思路\n考虑原串cbbcb添加了新字符后是cbbcbx，考虑x加入后cbx是否与cbb相同，我们可以将字符串cbbcbx翻转为xbcbbc，对翻转后的字符串计算前缀函数，记该字符串前缀函数的最大值是\\pi_{max}，假设\\pi_{max}=3，则该最大值对应的前缀是xbc，也就是说xbc=bbc，这是包含x的最长的匹配长度，显然，xbc的子串x、xb、xbc在bbc中对应b、bb、bbc，复原为没有翻转前，正好就是添加新字符之后的包含新字符的元素集合中，与未加新字符前的字符串的子串集合中重复的元素。于是在添加新字符之后，新出现的子串数目即为(|s_{\\text{原} }|+1)-\\pi_{max}​。\n字符串压缩\n字符串压缩指的是找到最短的长度k使得所有s[0...k-1]=s[k...2*k-1]=...=s[n-k...n-1]成立（n\\bmod k=0​）。\n举例字符串abcabc可以被压缩为abc、abababab可以被压缩为ab。显然，假设字符串s可以被压缩至长度k，则该字符串的前缀函数的最后一个值\\pi[n]一定是n-k，（注意前后缀是真子串），\\pi[n]与n相差的长度应当正好是一个最短压缩串的长度。因此，由n-\\pi[n]得到k，若n\\bmod k=0成立，则k即为压缩后的长度。\n字符串Hash\n字符串哈希的主要难点是构造哈希函数。\n哈希的性质：\n\nHash函数值不一样的时候，两个字符串一定不一样。\nHash函数值一样的时候，两个字符串大概率一样。\n\n第二条主要是哈希碰撞引起的，可以尝试用双哈希降低哈希碰撞的概率。\n构造哈希函数\n通常是多项式哈希，对于一个长度为l的字符串s，可以定义它的多项式哈希函数为这样：\nf(s)=\\sum_{i=1}^ls[i]\\times b^{l-i}(\\bmod M)\n比如字符串xyz，它的哈希函数值就是xb^2+yb+z，就像一个b进制的数一样。当然也可以反过来，将哈希函数定义为：\nf(s)=\\sum_{i=1}^l s[i]\\times b^{i-1}(\\bmod M)\n相应的，xyz的哈希函数值就是x+yb+cb^2​。实际使用的时候不要混淆。\n哈希碰撞不想算了我要咕咕咕。\n参考代码（及其朴素）：\nll Hash(string s) {\n    ll ret = 0;\n    ll b = 1, n = s.size();\n    for (ll i = n - 1;i &gt;= 0;i--) {\n        ret += b * (ll)s[i];\n        b *= bas1;\n        ret %= mo;\n    }\n    return ret;\n}\n考虑到更多时候需要配合字符串子串的哈希值，所以我们需要预处理出每个前缀的哈希值，这样就能快速求得子串的哈希值了。\nfor (ll i = 0;i &lt; ls;i++) {\n    h[i + 1] = h[i] * bas1 + s[i] - &#039;a&#039;;\n}\n// 获得子串s[p - len +1...p]的哈希值\nf(s[p - len + 1...p]) = h[p] - h[p - len] * pow(bas1, len);\n还是这个题：[P4824 USACO15FEB] Censoring S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n利用哈希解决：\n代码\nll h[maxn];\n \nvoid solve() {\n    string s, t;cin &gt;&gt; s &gt;&gt; t;\n \n    ll ls = s.size(), lt = t.size();\n    ll hb = 0ll, b = 1ll;\n    for (ll i = 0;i &lt; lt;i++) {\n        hb = hb * bas1 + t[i] - &#039;a&#039;;\n        b *= bas1;\n    }\n \n \n    ll p = 0;\n    ll ans[ls + 5];\n    for (ll i = 0;i &lt; ls;i++) {\n        p++;\n        h[p] = h[p - 1] * bas1 + s[i] - &#039;a&#039;;\n        ans[p] = i;\n        if (p - lt &gt;= 0 &amp;&amp; h[p] - h[p - lt] * b == hb) {\n            p -= lt;\n        }\n    }\n    for (ll i = 1;i &lt;= p;i++) {\n        cout &lt;&lt; s[ans[i]];\n    }\n}"},"03-algorithm/topo":{"slug":"03-algorithm/topo","filePath":"03-algorithm/topo.md","title":"拓扑排序","links":[],"tags":["图论","拓扑排序"],"content":"拓扑排序\n前提：拓扑排序是对有向无环图来说的，无向图、有环图都不存在拓扑排序。\n拓扑排序是将图G中的所有顶点排成一个线性序列，使得对于任意一堆有边顶点&lt;u, v&gt;，在线性序列中，u都出现在v之前。\n拓扑排序可以反应某种方案是否是切实可行的。\n一般一个图是否是有向图我们分析题意要求就能知道，但是究竟有没有环存在，就不是瞄一眼就能发现的了，所以，虽然拓扑排序是针对有向无环图而言的一种性质，但是反过来，一个有向图是否有拓扑排序，也可以反过来解决该图是否存在环、以及存在多少环等等问题，也就是某种方案可不可行。\n接下来我们通过代码学习如何获得一个有向图的拓扑排序：\n算法思路\n拓扑排序一定是从入度为0的顶点开始的（假如入度不为0不就是有点要排在它的前面了嘛qwq），所以，我们通过删除点(及由该点出发的所有边)的方法可以不断更新制作拓扑排序时当前图的状态，这样的步骤不断执行，直到图中能删的点(入度为0的点)都删光了，我们的程序就执行到了终点。\n程序实现\n我们还是用链式前向星来存储图\n使用队列来记录我们的拓扑序列（说是队列不过其实还是个每次只读末尾的数组啦，也没用到queue容器qwq）\n寻找拓扑序列样例代码：\n// 要先用一个数组记录各个顶点最初的入度，这个数组可以在读入边数据的时候进行++记录\n \nint queue[maxn];\nint iq = 0;\t// 表示当前队列长度，起始当然是0啦(懒得iq++也可以直接懒人向量法)\n \n// 先将图里入度为0的顶点加入队列\n// 第一层入度为0的点，其顺序就只是存储顺序决定哩，而且不重要(除非想找所有的拓扑排序qwq)\nfor (int i = 1;i &lt;= n;i++)\n    if (indegree[i] == 0)\n        queue[iq++] = i;\n \n// 删点，对队列做更新\nfor (int i = 0;i &lt; iq;i++) {\n    // 按队列顺序删点删边(终点的入度--就算删掉这条边了)\n    for (int k = head[queue[i]];k != 0;k = Edge[k].next) {\n        indegree[Edge[k].to]--;\n        if (indegree[Edge[k].to] == 0)\n            queue[iq++] = Edge[k].to;\n    }\n}\n这时候我们得到了一个序列，其实这个序列无论如何都能得到（空序列也是序列！），所以接下来需要判断一下是否是拓扑序列，同时也就判断出当前的图是不是有向无环图啦。\n判断样例代码：\ncout &lt;&lt; &quot;iq=&quot; &lt;&lt; iq &lt;&lt; &quot; n=&quot; &lt;&lt; n &lt;&lt; endl;\n\tif (iq == n) {\n\t\tcout &lt;&lt; &quot;有拓扑序列：&quot; &lt;&lt; endl;\n\t\t\n\t\t// 输出拓扑排序序列\n\t\tfor (int i = 0;i &lt; iq;i++)\n\t\t\tcout &lt;&lt; queue[i] &lt;&lt; &quot; &quot;;\n\t\tcout &lt;&lt; endl;\n\t}\n\telse {\n\t\tcout &lt;&lt; &quot;没有拓扑序列&quot; &lt;&lt; endl;\n\t}\n前面的输入样例是个有向有环图，这里添加一组有向无环图的样例用于学习：\ngraph LR\nv1((v1))--5--&gt;v2((v2))\nv1((v1))--6--&gt;v3((v3))\nv2((v2))--9--&gt;v4((v4))\nv3((v3))--10--&gt;v5((v5))\nv3((v3))--4--&gt;v6((v6))\nv4((v4))--12--&gt;v6((v6))\nv5((v5))--6--&gt;v7((v7))\nv6((v6))--9--&gt;v7((v7))\nv7((v7))--24--&gt;v8((v8))\nv6((v6))--3--&gt;v8((v8))\n\n8 10\n1 2 5\n1 3 6\n2 4 9\n3 5 10\n3 6 4\n4 6 12\n5 7 6\n6 7 9\n6 8 3\n7 8 24\n完整代码：\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst long long maxn = 1e5 + 50, maxm = 1e7 + 50;\n \nstruct EdgeNode {\n\tint to;\t\t// 终点\n\tint w;\t\t// 权值\n\tint next;\t// 下一位置\n};\n \nEdgeNode Edge[maxm];\nint head[maxn];\nint indegree[maxn];\n \nint main() {\n\tint n, m;\n\tcin &gt;&gt; n &gt;&gt; m;\n \n\t// 初始化head\n\tmemset(head, -1, sizeof(head));\t\t// 初始化为0应该也冇问题，反正只是方便我们判断终点啦，想用向量也行qwq\n \n\t// 读入数据\n\tfor (int i = 0;i &lt; m;i++) {\n\t\tint fi, ti, wi;\n\t\tcin &gt;&gt; fi &gt;&gt; ti &gt;&gt; wi;\n\t\tEdge[i].to = ti;\n\t\tEdge[i].w = wi;\n\t\t\n\t\tEdge[i].next = head[fi];\n\t\thead[fi] = i;\n \n\t\t// 记录各个顶点的入度(当该点是终点的时候++qwq)\n\t\tindegree[ti]++;\n\t}\n \n\t// 要先用一个数组记录各个顶点最初的入度，这个数组可以在读入边数据的时候进行++记录\n \n\tint queue[maxn];\n\tint iq = 0;\t// 表示当前队列长度，起始当然是0啦(懒得iq++也可以直接懒人向量法)\n \n\t// 先将图里入度为0的顶点加入队列\n\t// 第一层入度为0的点，其顺序就只是存储顺序决定哩，而且不重要(除非想找所有的拓扑排序qwq)\n\tfor (int i = 1;i &lt;= n;i++)\n\t\tif (indegree[i] == 0)\n\t\t\tqueue[iq++] = i;\n \n\t// 删点，对队列做更新\n\tfor (int i = 0;i &lt; iq;i++) {\n\t\t// 按队列顺序删点删边(终点的入度--就算删掉这条边了)\n\t\tfor (int k = head[queue[i]];k != -1;k = Edge[k].next) {\n\t\t\tindegree[Edge[k].to]--;\n\t\t\tif (indegree[Edge[k].to] == 0)\n\t\t\t\tqueue[iq++] = Edge[k].to;\n\t\t}\n\t}\n \n\t// 这里可以判断是否有环啦，假如此时iq的值小于顶点的数量n，不就是说明接下来没法删边了嘛，也就是说最后剩下了环。\n\tcout &lt;&lt; &quot;iq=&quot; &lt;&lt; iq &lt;&lt; &quot; n=&quot; &lt;&lt; n &lt;&lt; endl;\n\tif (iq == n) {\n\t\tcout &lt;&lt; &quot;有拓扑序列：&quot; &lt;&lt; endl;\n\t\t\n\t\t// 输出拓扑排序序列\n\t\tfor (int i = 0;i &lt; iq;i++)\n\t\t\tcout &lt;&lt; queue[i] &lt;&lt; &quot; &quot;;\n\t\tcout &lt;&lt; endl;\n\t}\n\telse {\n\t\tcout &lt;&lt; &quot;没有拓扑序列&quot; &lt;&lt; endl;\n\t}\n \n\treturn 0;\n}\n \n该算法在O(m)的时间内对indegree数组进行初始化，在O(n)时间内对queue进行初始化，后面的部分虽然看起来是两层循环，但实际上是m条边各遍历一次，所以时间复杂度只有O(m)而已，所以一共也就O(m+n)的复杂度。还是很友好滴。"},"03-algorithm/training0":{"slug":"03-algorithm/training0","filePath":"03-algorithm/training0.md","title":"队内拉题记录||23.11.29","links":[],"tags":["算法"],"content":"前言点评：本次题目难度不高\nA 跳石头\n\n[NOIP2015 提高组] 跳石头\n题目背景\nNOIP2015 Day2T1\n题目描述\n一年一度的“跳石头”比赛又要开始了！\n这项比赛将在一条笔直的河道中进行，河道中分布着一些巨大岩石。组委会已经选择好了两块岩石作为比赛起点和终点。在起点和终点之间，有 N 块岩石（不含起点和终点的岩石）。在比赛过程中，选手们将从起点出发，每一步跳向相邻的岩石，直至到达终点。\n为了提高比赛难度，组委会计划移走一些岩石，使得选手们在比赛过程中的最短跳跃距离尽可能长。由于预算限制，组委会至多从起点和终点之间移走 M 块岩石（不能移走起点和终点的岩石）。\n输入格式\n第一行包含三个整数 L,N,M，分别表示起点到终点的距离，起点和终点之间的岩石数，以及组委会至多移走的岩石数。保证 L \\geq 1 且 N \\geq M \\geq 0。\n接下来 N 行，每行一个整数，第 i 行的整数 D_i\\,( 0 &lt; D_i &lt; L)， 表示第 i 块岩石与起点的距离。这些岩石按与起点距离从小到大的顺序给出，且不会有两个岩石出现在同一个位置。\n输出格式\n一个整数，即最短跳跃距离的最大值。\n样例 #1\n样例输入 #1\n25 5 2\n2\n11\n14\n17\n21\n样例输出 #1\n4\n提示\n输入输出样例 1 说明\n将与起点距离为 2 和 14 的两个岩石移走后，最短的跳跃距离为 4（从与起点距离 17 的岩石跳到距离 21 的岩石，或者从距离 21 的岩石跳到终点）。\n数据规模与约定\n对于 20\\%的数据，0 \\le M \\le N \\le 10。\n对于 50\\% 的数据，0 \\le M \\le N \\le 100。\n对于 100\\% 的数据，0 \\le M \\le N \\le 50000,1 \\le L \n\\le 10^9。\n\n分析\n参考代码\n \nB Secret Sport\n\nSecret Sport\n题面翻译\n题目大意\nA,B 两人玩游戏，游戏规则如下：\n整场游戏有多轮，每轮游戏先胜 X 局的人获胜，每场游戏先胜 Y 局的人获胜。\n你在场边观看了比赛，但是你忘记了 X 和 Y ，只记得总共比了 1 \\le n \\le 20 局，和每局获胜的人，请判断谁获胜了。如果 A 获胜，输出 A ，如果 B 获胜，输出 B ，如果都有可能，输出 ? 。\n题目描述\nLet’s consider a game in which two players, A and B, participate. This game is characterized by two positive integers, X and Y .\nThe game consists of sets, and each set consists of plays. In each play, exactly one of the players, either A or B, wins. A set ends exactly when one of the players reaches X wins in the plays of that set. This player is declared the winner of the set. The players play sets until one of them reaches Y wins in the sets. After that, the game ends, and this player is declared the winner of the entire game.\nYou have just watched a game but didn’t notice who was declared the winner. You remember that during the game, n plays were played, and you know which player won each play. However, you do not know the values of X and Y . Based on the available information, determine who won the entire game — A or B. If there is not enough information to determine the winner, you should also report it.\n输入格式\nEach test contains multiple test cases. The first line contains a single integer t (1 \\leq t \\leq 10^4) - the number of test cases. The description of the test cases follows.\nThe first line of each test case contains an integer n (1 \\leq n \\leq 20) - the number of plays played during the game.\nThe second line of each test case contains a string s of length n , consisting of characters \\texttt{A} and \\texttt{B} . If s_i = \\texttt{A} , it means that player A won the i -th play. If s_i = \\texttt{B} , it means that player B won the i -th play.\nIt is guaranteed that the given sequence of plays corresponds to at least one valid game scenario, for some values of X and Y .\n输出格式\nFor each test case, output:\n\n\\texttt{A} — if player A is guaranteed to be the winner of the game.\n\\texttt{B} — if player B is guaranteed to be the winner of the game.\n\\texttt{?} — if it is impossible to determine the winner of the game.\n\n样例 #1\n样例输入 #1\n7\n5\nABBAA\n3\nBBB\n7\nBBAAABA\n20\nAAAAAAAABBBAABBBBBAB\n1\nA\n13\nAAAABABBABBAB\n7\nBBBAAAA\n样例输出 #1\nA\nB\nA\nB\nA\nB\nA\n提示\nIn the first test case, the game could have been played with parameters X = 3 , Y = 1 . The game consisted of 1 set, in which player A won, as they won the first 3 plays. In this scenario, player A is the winner. The game could also have been played with parameters X = 1 , Y = 3 . It can be shown that there are no such X and Y values for which player B would be the winner.\nIn the second test case, player B won all the plays. It can be easily shown that in this case, player B is guaranteed to be the winner of the game.\nIn the fourth test case, the game could have been played with parameters X = 3 , Y = 3 :\n\nIn the first set, 3 plays were played: AAA. Player A is declared the winner of the set.\nIn the second set, 3 plays were played: AAA. Player A is declared the winner of the set.\nIn the third set, 5 plays were played: AABBB. Player B is declared the winner of the set.\nIn the fourth set, 5 plays were played: AABBB. Player B is declared the winner of the set.\nIn the fifth set, 4 plays were played: BBAB. Player B is declared the winner of the set.\n\nIn total, player B was the first player to win 3 sets. They are declared the winner of the game.\n\n分析\n根据题意，其实每次都是赛到出现结果了才结束，所以每次的最后一局的胜负其实就是整场游戏的胜负。\n参考代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 3e4 + 20;\nint p[maxn];\n \nint n;\nstring s;\nvoid solve() {\n    cin &gt;&gt; n &gt;&gt; s;\n    cout &lt;&lt; s.back() &lt;&lt; endl;\n}\n \nint main() {\n    int t;cin &gt;&gt; t;\n    while(t--)\n        solve();\n \n    return 0;\n}\nC 众数\n\n[THUPC 2023 初赛] 众数\n题目描述\n你有若干个 [1,n] 内的正整数：对于 1 \\le i \\le n，你有 a_i 个整数 i。设 S = \\sum_{i=1}^n a_i。\n对于一个序列 p_1,p_2,\\cdots,p_l，定义其众数 \\text{maj}(p_1,p_2,\\cdots,p_l) 为出现次数最多的数。若有多个数出现次数最多，则其中最大的数为其众数。\n现在你需要把这 S 个数排成一个序列 b_1,b_2,\\cdots,b_S，使得 \\sum_{i=1}^S \\text{maj}(b_1,b_2,\\cdots,b_i) 最大。输出该最大值。\n输入格式\n第一行一个整数 n，表示值域。\n接下来一行 n 个正整数 a_1,a_2,\\cdots,a_n，表示每种数的个数。\n输出格式\n输出一行一个正整数表示 \\sum_{i=1}^S \\text{maj}(b_1,b_2,\\cdots,b_i) 的最大值。\n样例 #1\n样例输入 #1\n3\n1 3 2\n样例输出 #1\n17\n提示\n样例解释 1\n一个达到最大值的序列为 (3,2,3,1,2,2)。\n数据范围\n对于所有测试数据，1 \\le n \\leq 10^5，1 \\le a_1,a_2,\\cdots,a_n \\le 10^5。\n题目来源\n来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）初赛。\n题解等资源可在 github.com/THUSAAC/THUPC2023-Pre 查看。\n\n分析\n贪心，要让较大的数作为众数的次数最多。\n构造排列时按照 n~1 的顺序排下去，每次先排列尽量满足上述想法的数。\n参考代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 1e5 + 20;\nll a[maxn], prea[maxn];\nint main() {\n    int n;cin &gt;&gt; n;\n    for (int i = 1;i &lt;= n;i++) {\n        cin &gt;&gt; a[i];\n    }\n    ll num = 1;\n    ll ans = 0;\n    // prea[a[i]]:众数数量为a[i]时，当前众数i作为众数对结果的贡献\n    for (int i = n;i &gt; 0;i--) {\n        while (num &lt;= a[i]) {\n            prea[num] = prea[num - 1] + i;\n            num++;\n        }\n        ans += prea[a[i]];\n    }\n    cout &lt;&lt; ans &lt;&lt; endl;\n \n    return 0;\n}\n \nD 大纲\n\n[THUPC 2023 决赛] 大纲\n题目描述\n小 I、小 O 和小 N 是 ION 大纲的编写者，小 I 负责给每个知识点定难度。\nION 大纲计划列入 n 个知识点，其中小 I 按照自己的认识给其中部分知识点定好了难度，还有部分知识点没有定难度。\n知识点之间有依赖关系，这个依赖关系恰好构成了一棵以 1 为根的外向树，知识点 x 指向知识点 y 表示 x 依赖 y。依赖关系不具有传递性。\n你需要告诉小 I 目前确定下来的难度是否合理。我们认为确定下来的难度是合理的当且仅当存在一个给所有未确定难度的知识点确定难度的方式，使得以下所有条件成立：\n\n每个知识点的难度都是非负整数；\n对于每个依赖其他知识点的知识点 x，设 \\max_x 为 x 依赖的知识点中难度的最大值，则如果 x 恰依赖一个难度为 \\max_x 的知识点，那么知识点 x 的难度为 \\max_x，否则为 \\max_x+1。对于不依赖其他知识点的知识点，没有其他限制。\n\n输入格式\n本题有多组测试数据。第一行一个整数 T 表示测试数据组数，接下来依次读入每组测试数据。\n对于每组测试数据，\n\n第一行一个整数 n 表示知识点数量。\n第二行 n 个整数 a_1,a_2,\\cdots,a_n，描述每个知识点的难度。若 a_i = -1 表示知识点 i 未确定难度，否则知识点 i 的难度确定为 a_i。\n接下来 n-1 行每行两个整数 u,v，表示依赖关系构成的外向树中的一条有向边。\n\n输出格式\n对于每组测试数据输出一行：若难度是合理的，输出 Reasonable，否则输出 Unreasonable。\n样例 #1\n样例输入 #1\n2\n3\n0 -1 0\n1 2\n2 3\n3\n0 -1 0\n1 2\n1 3\n样例输出 #1\nReasonable\nUnreasonable\n提示\n样例 1 解释\n对于第一组测试数据，将知识点 2 的难度定为 0 即满足条件。\n对于第二组测试数据，无论如何指定知识点 2 的难度，知识点 1 的难度会产生矛盾。\n数据规模与约定\n对于所有测试数据，1 \\le T \\le 10^5，2 \\le n \\le 10^5，-1 \\le a_i \\le 10^9，1 \\le u,v \\le n。\n保证单个测试点中所有测试数据的 n 的和不超过 2 \\times 10^5，每组测试数据输入的所有边构成一棵以 1 为根的外向树。\n后记\n大纲发表了。若干天后，小 I 给 ION 比赛投题，却发现有人偷偷改了一笔难度表，导致他的题目超纲。于是小 I 只能把题投给 CPUHT。\n题目来源\n来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）决赛。\n题解等资源可在 github.com/THUSAAC/THUPC2023 查看。\n\n分析\n参考代码\n \nE Chip and Ribbon\n\nChip and Ribbon\n题面翻译\n每次可以在一段长度为 n，初始值都为 0 的序列中选取一段连续区间，并将区间内所有元素加 1，求最少操作数使得该序列与题目所给的序列所有元素相同，输出最少操作数减 1。\n题目描述\nThere is a ribbon divided into n cells, numbered from 1 to n from left to right. Initially, an integer 0 is written in each cell.\nMonocarp plays a game with a chip. The game consists of several turns. During the first turn, Monocarp places the chip in the 1 -st cell of the ribbon. During each turn except for the first turn, Monocarp does exactly one of the two following actions:\n\nmove the chip to the next cell (i. e. if the chip is in the cell i , it is moved to the cell i+1 ). This action is impossible if the chip is in the last cell;\nchoose any cell x and teleport the chip into that cell. It is possible to choose the cell where the chip is currently located.\n\nAt the end of each turn, the integer written in the cell with the chip is increased by 1 .\nMonocarp’s goal is to make some turns so that the 1 -st cell contains the integer c_1 , the 2 -nd cell contains the integer c_2 , …, the n -th cell contains the integer c_n . He wants to teleport the chip as few times as possible.\nHelp Monocarp calculate the minimum number of times he has to teleport the chip.\n输入格式\nThe first line contains one integer t ( 1 \\le t \\le 10^4 ) — the number of test cases.\nEach test case consists of two lines:\n\nthe first line contains one integer n ( 1 \\le n \\le 2 \\cdot 10^5 );\nthe second line contains n integers c_1, c_2, \\dots, c_n ( 0 \\le c_i \\le 10^9 ; c_1 \\ge 1 ).\n\nIt can be shown that under these constraints, it is always possible to make a finite amount of turns so that the integers in the cells match the sequence c_1, c_2, \\dots, c_n .\nAdditional constraint on the input: the sum of values of n over all test cases does not exceed 2 \\cdot 10^5 .\n输出格式\nFor each test case, print one integer — the minimum number of times Monocarp has to teleport the chip.\n样例 #1\n样例输入 #1\n4\n4\n1 2 2 1\n5\n1 0 1 0 1\n5\n5 4 3 2 1\n1\n12\n样例输出 #1\n1\n2\n4\n11\n提示\nIn the first test case of the example, Monocarp can perform the turns as follows:\n\nplace the chip in the 1 -st cell; the numbers in the cells are [1, 0, 0, 0] ;\nmove the chip to the next ( 2 -nd) cell; the numbers in the cells are [1, 1, 0, 0] ;\nmove the chip to the next ( 3 -rd) cell; the numbers in the cells are [1, 1, 1, 0] ;\nteleport the chip to the 2 -nd cell; the numbers in the cells are [1, 2, 1, 0] ;\nmove the chip to the next ( 3 -rd) cell; the numbers in the cells are [1, 2, 2, 0] ;\nmove the chip to the next ( 4 -th) cell; the numbers in the cells are [1, 2, 2, 1] .\n\n\n分析\n令连续的下一 cell 内数字加一的操作数是不限的，那么我们的目的就变成了画多少条这样的连续的“线”，能达到最终的目的，示意图如下：\n\n在代码实现的时候，只要后一位的高度高于前一位，那么就需要增加：后一位高度-前一位高度 这么多的线，参考代码如下：\n参考代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 2e5 + 20;\nll a[maxn];\nint main() {\n    int t;cin &gt;&gt; t;\n    while (t--) {\n        int n;cin &gt;&gt; n;\n        ll ans = 0;\n        for (int i = 1;i &lt;= n;i++) {\n            cin &gt;&gt; a[i];\n            if (a[i] &gt; a[i - 1])\n                ans += a[i] - a[i - 1];\n        }\n        cout &lt;&lt; ans - 1 &lt;&lt; endl;\n    }\n \n    return 0;\n}\n \nF 着色\n\n[THUPC 2023 决赛] 着色\n题目背景\n远古的笔迹，远古的乐音，远古的历史，远古的 K_{1000}，若无人问津，便悄然褪色……\n题目描述\n给出一个 n 个节点的无向完全图，你需要给每条边标上一个 0 \\sim 9 的数字，使得图上不存在一个三元环或五元环满足：其上所有边的数字相同。\n输入格式\n输入仅一行一个整数 n 表示图的节点数。\n输出格式\n如果不存在方案，输出一行一个整数 -1。否则输出 (n-1) 行，第 i 行 (n-i) 个字符，第 i 行的第 j 个字符表示 (i,i+j) 的标号。若有多个方案，输出任意一个即可。\n样例 #1\n样例输入 #1\n4\n样例输出 #1\n012\n34\n5\n提示\n数据规模与约定\n对于所有测试数据，2 \\le n \\le 1000。\n题目来源\n来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）决赛。\n题解等资源可在 github.com/THUSAAC/THUPC2023 查看。\n\n分析\n参考代码\n \nG Treasure Chest\n\nTreasure Chest\n题面翻译\n题目描述\n给你一个数轴，一开始你的位置为 0，箱子在 x 处，钥匙在 y 处，x\\neq y。你需要通过一些操作打开宝箱。\n当位置为 i 时，你能执行以下操作：\n\n花费 1 秒，走向 i+1 或 i-1；\n花费 0 秒，拿起 i 处的钥匙或箱子，如果此处有的话；\n花费 0 秒，在 i 处放下箱子；\n花费 0 秒，打开宝箱，如果箱子在 i 处且你拿着钥匙的话。\n\n另外给出限制：因为箱子很重，所以在整个过程中，扛着箱子的时间不得超过 k 秒（放下再拿起箱子不会使其重置）。\n现在给定 x,y,k，请问你打开箱子的最短用时为多少？\n每个测试点采用多组数据测试。\n输入格式\n第一行一个整数 t\\space(1\\le t\\le 100)，表示数据组数。\n对于每组数据：唯一一行三个整数 x,y,k\\space(1\\le x,y\\le 100,x\\neq y,0\\le k\\le 100)，分别表示初始时箱子的位置，钥匙的位置和你扛着箱子的最大时长。\n输出格式\n共 t 行，第 i 行一个整数表示第 i 组数据的答案。\n说明/提示\n数据范围与约定\n\\begin{aligned}\n1\\le t\\le 100;\\\\\n1\\le x,y\\le 100,x\\neq y;\\\\\n1\\le k\\le 100.\n\\end{aligned}\n样例解释\n对于样例的第 1 组数据，可以通过以下一系列动作在第 7 秒打开箱子。\n\n花费 5 秒走到 5,\n花费 0 秒拿起箱子，\n花费 2 秒走到 7，\n拿起钥匙、放下箱子并打开箱子，共花费 0 秒。\n\n全过程共花费 7 秒，拿着箱子的时间仅有 2 秒，不超过给定的限制 k=2。可以证明不存在更优解。\n对于样例的第 2 组数据，你可以花费 5 秒走到 5 并捡起钥匙，再花费 5 秒走到 10 并打开箱子。共花费 10 秒，其中没有扛过箱子，不超过给定的限制 k=0。可以证明不存在更优解。\n对于样例的第 3 组数据，你无法像数据 1 那样将箱子直接搬到钥匙处，而必须：\n\n花费 5 秒走到 5 并扛起箱子；\n花费 2 秒走到 7；\n此时你已经力竭，达到了限制 k=2，所以必须花费 0 秒在 7 处放下箱子；\n花费 1 秒走到 8 并捡起钥匙；\n花费 1 秒再走到 7 并打开箱子。\n\n全过程共花费 9 秒且刚好没有超过限制。可以证明不存在更优解。\n题目描述\nMonocarp has found a treasure map. The map represents the treasure location as an OX axis. Monocarp is at 0 , the treasure chest is at x , the key to the chest is at y .\nObviously, Monocarp wants to open the chest. He can perform the following actions:\n\ngo 1 to the left or 1 to the right (spending 1 second);\npick the key or the chest up if he is in the same point as that object (spending 0 seconds);\nput the chest down in his current point (spending 0 seconds);\nopen the chest if he’s in the same point as the chest and has picked the key up (spending 0 seconds).\n\nMonocarp can carry the chest, but the chest is pretty heavy. He knows that he can carry it for at most k seconds in total (putting it down and picking it back up doesn’t reset his stamina).\nWhat’s the smallest time required for Monocarp to open the chest?\n输入格式\nThe first line contains a single integer t ( 1 \\le t \\le 100 ) — the number of testcases.\nThe only line of each testcase contains three integers x, y and k ( 1 \\le x, y \\le 100 ; x \\neq y ; 0 \\le k \\le 100 ) — the initial point of the chest, the point where the key is located, and the maximum time Monocarp can carry the chest for.\n输出格式\nFor each testcase, print a single integer — the smallest time required for Monocarp to open the chest.\n样例 #1\n样例输入 #1\n3\n5 7 2\n10 5 0\n5 8 2\n样例输出 #1\n7\n10\n9\n提示\nIn the first testcase, Monocarp can open the chest in 7 seconds with the following sequence of moves:\n\ngo 5 times to the right ( 5 seconds);\npick up the chest ( 0 seconds);\ngo 2 times to the right ( 2 seconds);\npick up the key ( 0 seconds);\nput the chest down ( 0 seconds);\nopen the chest ( 0 seconds).\n\nHe only carries the chest for 2 seconds, which he has the stamina for.\nIn the second testcase, Monocarp can pick up the key on his way to the chest.\nIn the third testcase, Monocarp can’t use the strategy from the first testcase because he would have to carry the chest for 3 seconds, while he only has the stamina for 2 seconds. Thus, he carries the chest to 7 , puts it down, moves 1 to the right to pick up the key and returns 1 left to open the chest.\n\n分析\n分类讨论，要么在向右移动的时候就能把 key 带到 chest 的位置或者把 chest 带到 key 的位置，要么就把 chest 向右移动 k 个位置(离 key 最近)，然后拿 key 再折返回到 chest 位置。\n参考代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 120;\n \nint main() {\n    int t;cin &gt;&gt; t;\n    while (t--) {\n        int x, y, k;cin &gt;&gt; x &gt;&gt; y &gt;&gt; k;\n        int ans;\n        if (y &lt;= x)ans = x;\n        else {\n            if (y &lt;= x + k)ans = y;\n            else {\n                x += k;\n                ans = y + (y - x);\n            }\n        }\n        cout &lt;&lt; ans &lt;&lt; endl;\n    }\n \n    return 0;\n}\nH 烂柯杯\n\n[THUPC 2023 决赛] 烂柯杯\n题目背景\n却说庞统迤逦前进，抬头见两山逼窄，树木丛杂；又值夏末秋初，枝叶茂盛。庞统心下甚疑，勒住马问：“此处是何地？”数内有新降军士，指道：“此处地名落凤坡。”庞统惊曰：“吾道号凤雏，此处名落凤坡，不利于吾。”令后军疾退。只听山坡前一声炮响，箭如飞蝗，只望骑白马者射来。可怜庞统竟死于乱箭之下。时年止三十六岁。后人有诗叹曰：“古岘相连紫翠堆，士元有宅傍山隈。儿童惯识呼鸠曲，闾巷曾闻展骥才。预计三分平刻削，长驱万里独徘徊。谁知天狗流星坠，不使将军衣锦回。”先是东南有童谣云：“一凤并一龙，相将到蜀中。才到半路里，凤死落坡东。风送雨，雨随风，隆汉兴时蜀道通，蜀道通时只有龙。”\n——《三国演义》第六十三回：诸葛亮痛哭庞统 张翼德义释严颜\n题目描述\n2023 年 5 月 4 日  \\sim 9 日，第一届“衢州烂柯杯”世界围棋公开赛本赛第一阶段的赛程在衢州顺利进行。作为疫情后第一场全程线下进行的世界围棋大赛，也是目前中国主办的唯一一项每年一届的世界围棋大赛，无疑引起了国内外广大围棋爱好者的广泛关注。\n“羽客一枰无复见，青山留得烂柯名。”衢州是围棋圣地，流传着“王质遇仙”的故事，境内的烂柯山也因此闻名于天下。正因为此，“烂柯”也是围棋的别称之一，从古至今的许多围棋故事、书籍、弈谱等，也有不少化用了“烂柯”的典故，或以“烂柯”定名。\n此次“烂柯杯”世界围棋大赛，是在保留原有的“烂柯杯”中国围棋冠军赛的基础上，创办的一项崭新的世界性围棋赛事，吸引了全世界围棋高手前来参加。其中，中国队派出了柯洁、辜梓豪、王星昊、丁浩、李钦诚等 15 员大将参赛，韩国队 8 人，日本队 5 人，还有 2 位棋手来自中国台湾、 2 位棋手来自欧美地区。可以说，全世界最顶尖的围棋高手悉数相聚于此。\n随着科技的发展，人工智能的巨大技术进步和网络传媒的全面普及，围棋这项来自中国的传统运动正在焕发出新的活力。在网络上，人们随时可以看到最新的赛事直播，以及人工智能的精准分析和各大围棋高手的细致解读。资源获取的便捷性使得人们对围棋的关注度空前上升，围棋不再是只有少部分懂棋的爱好者才能欣赏的“小众游戏”；围棋高手也不再只是一个神秘的身份，越来越多的围棋高手开始在网络上与棋迷近距离互动，普及围棋知识，讲解最新对局，赢得了一致好评。正如这次参赛的选手中，有一位棋手同时也是粉丝数达 150 多万的网红主播，甚至还有一位棋手是一家网红餐厅的老板。\n我们今天故事的主角正是这样一位有着传奇色彩的人物。作为一名清华大学本科在读的学生，同时也是一名顶尖围棋高手，他的一举一动无疑都会引起巨大的关注。此次他参加“烂柯杯”比赛，众人无一例外看好他的比赛前景，尤其是现在韩国围棋”第一人“申真谞九段的巅峰时期，他也被无数中国棋迷寄托以”狙击‘小申’“的重任。5 月 4 日抽签过后，没有任何人会怀疑他能不能赢下 5 日的第一轮比赛，一些围棋高手更是直接放出了”大胜，不可能失败“的预言。\n然而，5 月 5 日的比赛还是爆出了惊天大冷门。他在已经胜券在握，AI 胜率达到 99\\% 的关头，接连选择了“弹幕最多的下法”，最终因为几招致命的失误葬送好局，落败于中国台湾棋手赖均辅八段。赛后，人们在震惊的同时，纷纷猜测本局失利的原因。有人说，他的状态低迷在前些年早已有所体现，“当你在 XX 的时候，小申在下棋”成了调侃他与申真谞战绩差距的一句名言；有人说，他在比赛之前的 12 连胜战绩反而使他心态紧张，从而犯了优势下容易大意的老毛病；也有人拿出了“落凤坡”的典故，以证明他或许命中注定与“烂柯杯”八字不合……但或许，这样的变幻莫测和不可预料性，正是围棋的魅力所在。\n请你根据以上所有信息，猜测本文的主角是谁。\n输入格式\n无输入。\n输出格式\n输出一个由小写字母组成的字符串，表示上文中提到的主角的名字全拼。如若答案是马云，应当输出 mayun。\n提示\n提示\n主角的名字在题面中已经有所提及。\n题面中一些看似无厘头的信息实际上是有价值的。\n题目来源\n来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）决赛。\n题解等资源可在 github.com/THUSAAC/THUPC2023 查看。\n\n分析\n是签到题，输出”kejie”即可。\n参考代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 120;\n \nint main() {\n    cout &lt;&lt; &quot;kejie&quot;;\n \n    return 0;\n}\nI 总投票数\n\n[THUPC 2023 决赛] 总投票数\n题目背景\n各位亲爱的《La Lumière: Scarlet Intense Flame - Adventurous Scarlet -》玩家：\n非常荣幸能与您携手度过了这四年的美好时光，衷心感谢大家的支持与陪伴！\n现在，我们非常遗憾的宣布，《La Lumière: Scarlet Intense Flame - Adventurous Scarlet -》将于 2023 年 5 月 28 日 15:00 停止运营服务。\n停止运营相关时间表如下：\n……\n题目描述\n在关服前，运营发起了一系列投票，调查哪些游戏内容给玩家带来了更深的印象。\n作为系列的忠实玩家，你想知道有多少人参加了关服前的投票，但是运营只公开了最终的投票结果：对于一项包含 N 个选项的投票，选择第 i 个选项的玩家比例为 P_i（1\\le i\\le N）。运营在公布结果时进行了四舍五入，所有的 P_i 仅保留到小数点后第 L 位。假设实际有 K 位玩家参加了投票，其中有 D_i 位玩家选择了第 i 个选项，则应该有\nP_i-\\frac{1}{2}\\times 10^{-L}\\le\\frac{D_i}{K}&lt; P_i+\\frac{1}{2}\\times 10^{-L}\n显然，所有的 D_i 必须是非负整数，而 K=\\sum_{i=1}^N D_i 则必须是正整数。现在，给定 N 和 P_i，请你求出满足 D_i 有非负整数解的最小的总投票数 K。\n输入格式\n输入的第一行包含一个正整数 N，表示投票的选项总数。保证 1\\le N\\le 100。\n接下来 N 行，每行包括一个 [0, 1] 中的实数 P_i，表示选择第 i 个选项的玩家比例。保证 \\sum_{i=1}^N P_i =1，所有 P_i 均保留到小数点后第 L 位，且 1\\le L\\le 6。\n输出格式\n输出一个正整数，表示满足要求的最小总投票数 K。\n样例 #1\n样例输入 #1\n3\n0.166667\n0.333333\n0.500000\n样例输出 #1\n6\n样例 #2\n样例输入 #2\n7\n0.041096\n0.109589\n0.109589\n0.164384\n0.301370\n0.068493\n0.205479\n样例输出 #2\n73\n样例 #3\n样例输入 #3\n13\n0.00155\n0.03876\n0.01584\n0.05189\n0.08099\n0.06825\n0.15658\n0.10404\n0.02640\n0.14332\n0.12941\n0.15529\n0.02768\n样例输出 #3\n7766\n提示\n【样例解释 # 1】\n最小的总投票数为 6，对应每个选项的投票数为 1, 2, 3。\n【样例解释 # 2】\n最小的总投票数为 73，对应每个选项的投票数为 3, 8, 8, 12, 22, 5, 15。\n【样例解释 # 3】\n最小的总投票数为 7766，对应每个选项的投票数为 12, 301, 123, 403, 629, 530, 1216, 808, 205, 1113, 1005, 1206, 215。\n【数据范围】\n对于所有测试数据，1\\le N\\le 100，0\\le P_i\\le 1，\\sum_{i=1}^N P_i=1，且 P_i 最多统一保留到小数点后 6 位。\n【题目来源】\n来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）决赛。\n题解等资源可在 github.com/THUSAAC/THUPC2023 查看。\n\n分析\n参考代码\n \nJ Points and Minimum Distance\n\nPoints and Minimum Distance\n题面翻译\n给定长度为 2n 的序列 a，你需要把这些数分为 n 对，得到 n 个坐标轴上的点。a 中的每个数都要是某一个点的 x 或 y 坐标。注意有些点可能会重合。\n之后，你可以选择从一个点出发，选择一条路径走过所有 n 个点至少一次，在某个点处停下。\n你需要求出路径总长度的最小值。本题中两点间距离为曼哈顿距离，即 (x_1,y_1) 和 (x_2,y_2) 间距离为 |x_1-x_2|+|y_1-y_2|。\n题目描述\nYou are given a sequence of integers a of length 2n . You have to split these 2n integers into n pairs; each pair will represent the coordinates of a point on a plane. Each number from the sequence a should become the x or y coordinate of exactly one point. Note that some points can be equal.\nAfter the points are formed, you have to choose a path s that starts from one of these points, ends at one of these points, and visits all n points at least once.\nThe length of path s is the sum of distances between all adjacent points on the path. In this problem, the distance between two points (x_1, y_1) and (x_2, y_2) is defined as |x_1-x_2| + |y_1-y_2| .\nYour task is to form n points and choose a path s in such a way that the length of path s is minimized.\n输入格式\nThe first line contains a single integer t ( 1 \\le t \\le 100 ) — the number of testcases.\nThe first line of each testcase contains a single integer n ( 2 \\le n \\le 100 ) — the number of points to be formed.\nThe next line contains 2n integers a*1, a_2, \\dots, a*{2n} ( 0 \\le a_i \\le 1\\,000 ) — the description of the sequence a .\n输出格式\nFor each testcase, print the minimum possible length of path s in the first line.\nIn the i -th of the following n lines, print two integers x_i and y_i — the coordinates of the point that needs to be visited at the i -th position.\nIf there are multiple answers, print any of them.\n样例 #1\n样例输入 #1\n2\n2\n15 1 10 5\n3\n10 30 20 20 30 10\n样例输出 #1\n9\n10 1\n15 5\n20\n20 20\n10 30\n10 30\n提示\nIn the first testcase, for instance, you can form points (10, 1) and (15, 5) and start the path s from the first point and end it at the second point. Then the length of the path will be |10 - 15| + |1 - 5| = 5 + 4 = 9 .\nIn the second testcase, you can form points (20, 20) , (10, 30) , and (10, 30) , and visit them in that exact order. Then the length of the path will be |20 - 10| + |20 - 30| + |10 - 10| + |30 - 30| = 10 + 10 + 0 + 0 = 20 .\n\n分析\n构造题，根据题意可以推断，ans 只分别与 x 集合的差值和、y 集合差值和有关。显然，（大数-小数）+（大数-小数）的结果劣于（大数-大数）+（小数-小数）。\n故此题，在进行排列后按序先分配 x 再分配 y，直接统计 x 有序集合与 y 有序集合的差值即可（注意结果除去 x，y 交界的一对差）。\n参考代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 120;\nint a[maxn];\nint main() {\n    int t;cin &gt;&gt; t;\n    while (t--) {\n        int n;cin &gt;&gt; n;\n        for (int i = 1;i &lt;= 2 * n;i++)\n            cin &gt;&gt; a[i];\n        sort(a + 1, a + 2 * n + 1);\n        int ans = 0;\n        for (int i = 2;i &lt;= 2 * n;i++) {\n            ans += a[i] - a[i - 1];\n        }\n        ans -= a[n + 1] - a[n];\n        cout &lt;&lt; ans &lt;&lt; endl;\n        for (int i = 1;i &lt;= n;i++)\n            cout &lt;&lt; a[i] &lt;&lt; &quot; &quot; &lt;&lt; a[2 * n + 1 - i] &lt;&lt; endl;\n    }\n \n    return 0;\n}\nK 速战速决\n\n[THUPC 2023 初赛] 速战速决\n题目描述\n小 I 与小 J 正在玩一个叫做“开火车”，又称作“拖板车”和“小猫钓鱼”的扑克游戏。游戏规则如下，注意其与一般玩法可能有不同：\n\n有 2n 张牌，其中对于整数 1 \\le i \\le n，牌面为 i 的牌恰好有 2 张。\n游戏开始时，小 I 和小 J 各拿其中 n 张牌组成双方的初始手牌。\n维护一个公共牌堆（可以将其看作一个栈），初始没有牌。小 I 与小 J 依次行动，小 I 先手。一次行动时，行动方依次进行以下操作：\n\n将手牌中的一张牌放在公共牌堆顶；\n若此时公共牌堆中有两张相同的牌，则这两张相同的牌以及在这两张牌之间的所有牌从公共牌堆移到当前行动方手牌中；\n若此时当前行动方没有手牌，则当前行动方失败，另一方胜利。\n\n\n\n小 J 是扑克萌新，所以会按照以下策略行动：\n\n维护一个队列，初始将 n 张手牌按照一定顺序放入队列中；\n每次行动时，将队列开头的牌放在公共牌堆顶；\n若小 J 放入某张牌后公共牌堆中有两张相同的牌，则按照在公共牌堆中自顶到底的顺序将获得的牌放入队列尾。\n\n小 I 通过偷看得到了小 J 的策略以及队列中牌的顺序。现在小 I 不仅想获胜，还想速战速决，用最少的行动次数获胜，但他也是扑克萌新。所以给定小 J 队列中的 n 张牌以及它们的顺序，你需要给出小 I 的策略，使得小 I 能够获胜，同时行动次数最少，或者告诉他这是不可能的。\n输入格式\n每组数据的第一行一个整数 n 表示牌面的种数。\n第二行 n 个整数 a_1,a_2,\\cdots,a_n，从队头到队尾的顺序依次描述小 J 队列中的牌。\n得到小 J 的 n 张手牌也就得到了小 I 的 n 张手牌，因此不会输入小 I 的手牌。\n输出格式\n如果小 I 不可能获胜，只需要输出一个整数 -1；否则第一行输出一个整数 s，表示你给出的策略中小 I 的行动次数。接下来一行 s 个整数，依次描述每次行动时小 I 从手牌中放入公共牌堆的牌的牌面，两个数之间以一个空格分隔。注意你给出的策略要满足 s 最小。\n样例 #1\n样例输入 #1\n3\n1 3 3\n样例输出 #1\n3\n2 1 2\n样例 #2\n样例输入 #2\n1\n1\n样例输出 #2\n-1\n提示\n样例解释 1\n\n\n子任务\n对于所有测试数据，1 \\le n \\le 3 \\times 10^5，1 \\le a_1,a_2,\\cdots, a_n \\le n，且每个整数在序列 a 中至多出现两次。\n题目来源\n来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）初赛。\n题解等资源可在 github.com/THUSAAC/THUPC2023-Pre 查看。\n\n分析\n参考代码\n \nL 滑雪\n\n[SHOI2002] 滑雪\n题目描述\nMichael 喜欢滑雪。这并不奇怪，因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael 想知道在一个区域中最长的滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子：\n1   2   3   4   5\n16  17  18  19  6\n15  24  25  20  7\n14  23  22  21  8\n13  12  11  10  9\n一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度会减小。在上面的例子中，一条可行的滑坡为 24-17-16-1（从 24 开始，在 1 结束）。当然 25－24－23－\\ldots－3－2－1 更长。事实上，这是最长的一条。\n输入格式\n输入的第一行为表示区域的二维数组的行数 R 和列数 C。下面是 R 行，每行有 C 个数，代表高度(两个数字之间用 1 个空格间隔)。\n输出格式\n输出区域中最长滑坡的长度。\n样例 #1\n样例输入 #1\n5 5\n1 2 3 4 5\n16 17 18 19 6\n15 24 25 20 7\n14 23 22 21 8\n13 12 11 10 9\n样例输出 #1\n25\n提示\n对于 100\\% 的数据，1\\leq R,C\\leq 100。\n\n分析\n优先队列+线性 dp\n优先队列内排序按照高度从小到大，依次取出队首的点（高度最低的点），记为 pos，更新从低处到 pos 的最长路径。\n状态转移：\ndp[xi][yi]=max(dp[xi][yi],dp[xi+1][yi]+1)\n同时记录最长的路径即可。\n参考代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 120;\nll rec[maxn][maxn];\nll dp[maxn][maxn];\nstruct POS {\n    ll height;\n    int x, y;\n    POS(int hi, int xi, int yi) :height(hi), x(xi), y(yi) {}\n    bool operator&lt;(const POS&amp; P)const {\n        return P.height &lt; height;\n    }\n};\nint main() {\n    int r, c;cin &gt;&gt; r &gt;&gt; c;\n    priority_queue&lt;POS&gt;pos;\n    for (int i = 1;i &lt;= r;i++) {\n        for (int j = 1;j &lt;= c;j++) {\n            ll h;cin &gt;&gt; h;\n            rec[i][j] = h;\n            pos.push(POS(h, i, j));\n            dp[i][j] = 1;\n        }\n    }\n    ll ans = 1;\n    while (!pos.empty()) {\n        auto tp = pos.top();\n        int xi = tp.x, yi = tp.y;ll hi = tp.height;pos.pop();\n        if (rec[xi + 1][yi] &lt; hi) {\n            dp[xi][yi] = max(dp[xi + 1][yi] + 1, dp[xi][yi]);\n        }\n        if (rec[xi - 1][yi] &lt; hi) {\n            dp[xi][yi] = max(dp[xi - 1][yi] + 1, dp[xi][yi]);\n        }\n        if (rec[xi][yi + 1] &lt; hi) {\n            dp[xi][yi] = max(dp[xi][yi + 1] + 1, dp[xi][yi]);\n        }\n        if (rec[xi][yi - 1] &lt; hi) {\n            dp[xi][yi] = max(dp[xi][yi - 1] + 1, dp[xi][yi]);\n        }\n        ans = max(ans, dp[xi][yi]);\n    }\n    cout &lt;&lt; ans &lt;&lt; endl;\n \n    return 0;\n}\nM Two Out of Three\n\nTwo Out of Three\n题面翻译\n题目描述\n给定一个数组 a_1, a_2, ..., a_n。你需要找到一个数组 b_1, b_2, …, b_n，其中包含数字 1, 2, 3，使得以下三个条件中恰好有两个条件被满足：\n\n存在 1\\le i, j\\le n，使得 a_i=a_j,b_i=1,b_j=2。\n存在 1\\le i, j\\le n，使得 a_i=a_j,b_i=1,b_j=3。\n存在 1\\le i, j\\le n，使得 a_i=a_j,b_i=2,b_j=3。\n\n如果不存在这样的数组 b，请报告不可以。\n输入格式\n每个测试点多测。第一行输入一个整数 t，表示数据组数。对于每一组数据：\n第一行输入一个整数 n (1\\le n\\le 100)，表示数组 a 的长度。\n第二行读入 n 个整数 a_1,a_2,...,a_n (1\\le a_i\\le 100)，代表数组 a。\n输出格式\n对于每组数据输出一行。若无解，则输出 -1。否则输出一个由 1,2,3 组成的数组 b，恰好满足两条性质。如果有多个合法数组，输出任一即可。\n说明/提示\n第一个数组 a，合法数组可以是 b=[1,2,3,1,1,1]。当 i = 4,j = 2 时，满足性质一。当i = 6,j = 3 时满足性质二。数组 b 无法满足性质三，所以恰好满足两条，合法。\n题目描述\nYou are given an array a_1, a_2, \\ldots, a_n . You need to find an array b_1, b_2, \\ldots, b_n consisting of numbers 1 , 2 , 3 such that exactly two out of the following three conditions are satisfied:\n\nThere exist indices 1 \\leq i, j \\leq n such that a_i = a_j , b_i = 1 , b_j = 2 .\nThere exist indices 1 \\leq i, j \\leq n such that a_i = a_j , b_i = 1 , b_j = 3 .\nThere exist indices 1 \\leq i, j \\leq n such that a_i = a_j , b_i = 2 , b_j = 3 .\n\nIf such an array does not exist, you should report it.\n输入格式\nEach test contains multiple test cases. The first line contains a single integer t (1 \\leq t \\leq 500) — the number of test cases. Each test case is described as follows.\nThe first line of each test case contains an integer n (1 \\leq n \\leq 100) — the length of the array a .\nThe second line of each test case contains n integers a_1, a_2, \\ldots, a_n (1 \\leq a_i \\leq 100) — the elements of the array a .\n输出格式\nFor each test case, print -1 if there is no solution. Otherwise, print b_1, b_2, \\ldots, b_n — an array consisting of numbers 1 , 2 , 3 that satisfies exactly two out of three conditions. If there are multiple possible answers, you can print any of them.\n样例 #1\n样例输入 #1\n9\n6\n1 2 3 2 2 3\n7\n7 7 7 7 7 7 7\n4\n1 1 2 2\n7\n1 2 3 4 5 6 7\n5\n2 3 3 3 2\n3\n1 2 1\n9\n1 1 1 7 7 7 9 9 9\n1\n1\n18\n93 84 50 21 88 52 16 50 63 1 30 85 29 67 63 58 37 69\n样例输出 #1\n1 2 3 1 1 1\n-1\n3 2 2 1\n-1\n2 1 2 1 3\n-1\n1 1 2 2 1 2 2 3 3\n-1\n3 2 1 3 3 3 3 2 2 1 1 2 3 1 3 1 1 2\n提示\nIn the first test case, b = [1, 2, 3, 1, 1, 1] satisfies condition 1 because for i = 4 , j = 2 : a_i = a_j , b_i = 1 , and b_j = 2 . It also satisfies condition 2 because for i = 6 , j = 3 : a_i = a_j , b_i = 1 , and b_j = 3 . However, it does not satisfy condition 3 . In total, exactly two out of three conditions are satisfied.\n\n分析\n构造题，根据分析，只有当数量超过 2 个的数的种数大于等于 2，才有可能构造出符合要求的 b 数组。\n参考代码\n#include&lt;bits/stdc++.h&gt;\nusing namespace std;\nconst int maxn = 120;\nint a[maxn];\n// int cnt[maxn];\n \nint n;\nvoid solve() {\n    cin &gt;&gt; n;\n    // fill(cnt, cnt + sizeof(cnt), 0);\n    int cnt[maxn] = {};\n    for (int i = 0;i &lt; n;i++) {\n        cin &gt;&gt; a[i];\n        cnt[a[i]]++;\n    }\n \n    int cntn = 0;\n    for (int i = 1;i &lt;= 101;i++) {\n        if (cnt[i] &gt;= 2)\n            cntn++;\n    }\n    if (cntn &lt; 2) {\n        cout &lt;&lt; -1 &lt;&lt; endl;\n        return;\n    }\n    bool ck[maxn] = { false };\n    bool f = true;\n    for (int i = 0;i &lt; n;i++) {\n        int x = a[i];\n        if (cnt[x] &gt;= 2 &amp;&amp; !ck[x]) {\n            if (f) {\n                cout &lt;&lt; 2 &lt;&lt; &quot; &quot;;\n                f = false;\n            }\n            else {\n                cout &lt;&lt; 3 &lt;&lt; &quot; &quot;;\n            }\n            ck[x] = true;\n        }\n        else {\n            cout &lt;&lt; 1 &lt;&lt; &quot; &quot;;\n        }\n    }\n    cout &lt;&lt; &quot;\\n&quot;;\n}\n \nint main()\n{\n    int t;cin &gt;&gt; t;\n    while (t--)\n        solve();\n \n    return 0;\n}"},"04-tools/index":{"slug":"04-tools/index","filePath":"04-tools/_index.md","title":"🛠️工具箱","links":[],"tags":["intro"],"content":"一些杂七杂八的笔记/草稿纸。"},"04-tools/git_settings":{"slug":"04-tools/git_settings","filePath":"04-tools/git_settings.md","title":"🔑Git环境配置和SSH公钥设置","links":[],"tags":["Git","SSH"],"content":"一般远程仓库都支持使用 ssh 访问和读写数据，提供 ssh 进行连接时，会使用本地的私钥文件进行身份验证，配置 ssh 密钥的步骤即：\n\n在本地生成 ssh 密钥对\n上传公钥到远程存储库\n\n配置密钥\n1. 生成 ssh 密钥对\n`windows` 用户建议使用PowerShell\n\nssh-keygen -t ed25519 -C &quot;SSH Key&quot;\n\n-t：key 类型\n-C：注释\n\n在命令行一路回车（三次）即可，将把密钥放在默认路径下。\n2. 查看生成的 SSH 公钥和私钥\nls ~/.ssh/\n默认会将 ssh 密钥放在~路径下的隐藏文件夹.ssh中。输出：、\nid_ed25519  id_ed25519.pub\n\n私钥文件  id_ed25519\n公钥文件  id_ed25519.pub\n\n3. 读取公钥\n使用 cat 命令，或者直接使用记事本打开文件进行复制：\ncat ~/.ssh/id_ed25519.pub\n复制公钥内容后，将其上传到远程存储库中，一般在个人账号设置中会有 ssh 设置栏。\n4.测试 ssh 连接\n使用ssh -T命令进行测试，其后加在远程存储库的用户名。\nssh -T git@github.com\n正确响应：\nHi your_username! You&#039;ve successfully authenticated, but GitHub does not provide shell access.\nGit config 信息配置\nGit 的配置信息分为三个级别，分别为：\n\n--local：仓库级别\n--global：用户级别\n--syustem：系统级别\n\n1. 设置全局用户信息\ngit config --global user.name &quot;你的用户名&quot;\ngit config --global user.email &quot;你的邮箱&quot;\n2. 常用全局配置\n# 设置默认文本编辑器（VSCode为例）\ngit config --global core.editor &quot;code --wait&quot;\n \n# 设置换行符处理（Windows推荐）\ngit config --global core.autocrlf true\n \n# 设置换行符处理（Linux/Mac推荐）\ngit config --global core.autocrlf input\n \n# 启用彩色输出\ngit config --global color.ui true\n \n# 设置默认分支名称（新版本Git默认是main）\ngit config --global init.defaultBranch main\n3. 查看配置信息\n# 查看所有配置\ngit config --list\n \n# 查看全局配置\ngit config --global --list\n \n# 查看特定配置项\ngit config user.name\ngit config user.email\n4. 仓库特定配置\n如果想将某个特定仓库设置不同的配置（比如将工作邮箱和个人邮箱分开）：\ncd /path/to/repo\ngit config user.name &quot;工作用户名&quot;\ngit config user.email &quot;工作邮箱&quot;\n5. 配置别名\n配置别名相当于给 git 命令创建“快捷方式”，可以提高工作效率，比如：\n\n把  git checkout  简化为  git co\n把  git branch  简化为  git br\n把  git commit  简化为  git ci\n\n配置命令格式：\ngit config --global alias.新名称 &#039;原命令&#039;\n常用别名：\ngit config --global alias.co checkout\ngit config --global alias.br branch\ngit config --global alias.ci commit\ngit config --global alias.st status\noh-my-zsh git plugin\n如果你使用oh-my-zsh，zsh 中会支持一套 git 别名，详细信息可以在这里查看：git plugin\n列举一部分常用的：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAliasCommandggitgaagit add --allgcmsggit commit --messageggpushgit push origin &quot;$(git_current_branch)&quot;ggpullgit pull origin $(current_branch)gcbgit checkout -bgfgit fetchgfogit fetch origingrbagit rebase --abortgrbcgit rebase --continuegrbsgit rebase --skip"},"04-tools/github_action":{"slug":"04-tools/github_action","filePath":"04-tools/github_action.md","title":"🙆‍♀️Github Action实践","links":[],"tags":["Github","Action","自动化部署","Git"],"content":"前言\n本篇记录利用 github action 实现自动化构建和部署的过程。\n本站除了部署在 github page 上，还部署在本人的服务器上，懒惰的 ddl 直到现在才去上手实验，因此利用在 github action 中实现两种部署方式。\nGithub Action\nGithub Action 是 Github 提供的持续集成服务，可以在代码仓库中配置 workflow，实现自动化构建、测试、部署等功能。\n有一些术语需要了解：\n\nWorkflow：一个 workflow 由一个或多个 job 组成，可以在不同的操作系统环境中运行。\nJob：一个 job 由一系列 step 组成，可以在同一个 runner 上运行。\nStep：一个 step 由一个或多个 action 组成，可以在同一个 runner 上运行。\nAction：一个 action 是一个独立的任务，可以在不同的 runner 上运行。\n\n配置\n这里我使用的是 github action 自带的SSH Deploy action，使用 ssh 链接远程服务器，将代码部署到服务器上。使用方法可以参考这里。\n1. 创建 SSH Key 并添加到 github secrets\n首先需要在服务器上生成一个 SSH Key，用于 github action 登录服务器。\nssh-keygen -m PEM -t rsa -b 4096\nkey 的生成过程中会提示输入密码，可以不输入，直接回车，默认保存在/root/.ssh目录下（这个可能不同的服务器环境会有区别，具体的默认位置在生成ssh-key的时候命令行有提示。\n生成的 key 包含一个私钥id_rsa和一个公钥id_rsa.pub，私钥保存在本地，我们需要将公钥添加到服务器的/root/.ssh/authorized_keys文件中。\ncat ./id_rsa.pub &gt;&gt; /root/.ssh/authorized_keys\n考虑到我们并不想把私钥暴露在 github 公开仓库上，我们需要将私钥id_rsa添加到 github 的 secrets 中。\n在仓库的Settings→Security→Secrets and variables→Actions中，选择New repository secret，添加一个SSH_PRIVATE_KEY，将私钥内容粘贴进去。\n再新建三个 secrets，分别是REMOTE_HOST、REMOTE_USER、REMOTE_TARGET，分别对应服务器的地址、用户名、目标路径。\n2. 创建 workflow\n在代码仓库的.github/workflows目录下创建一个.yml文件，文件名可以自定义，如deploy.yml。\n一个库可以有多个 workflow，github 只要发现.github/workflows目录下有.yml文件，就会自动运行 workflow。\n内容可以参考如下：\nname: Deploy\n \n# 触发条件\non:\n  push:\n    branches: [main]\n  workflow_dispatch: # 手动触发\n \njobs:\n  deploy:\n    runs-on: ubuntu-latest\n \n    steps:\n      - uses: actions/checkout@v3\n      - name: Install Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: &quot;16.x&quot;\n      - name: ssh deploy\n        uses: easingthemes/ssh-deploy@v5.0.3\n        with:\n          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}\n          ARGS: &quot;-rlgoDzvc -i&quot;\n          SOURCE: &quot;&quot;\n          REMOTE_HOST: ${{ secrets.REMOTE_HOST }}\n          REMOTE_USER: ${{ secrets.REMOTE_USER }}\n          TARGET: ${{ secrets.REMOTE_TARGET }}\n向 github 仓库 push 代码之后，我们在Actions选项卡中可以看到 workflow 的运行情况。假如运行失败，可以点进去查看具体的错误信息，进行调试。\n之后每次 push 到 main 分支或者手动触发 workflow，github action 就会自动运行 workflow，将代码部署到服务器上。\n更新 2024-09-22\n之前部署的时候只上传了public/文件夹，最近有同步源码的需求，但是源码包含一些隐私信息，并不适合上传到 github 的公开仓库，所以现在的需求是：\n\n将源码上传到一个私有仓库\n从私有仓库中将public/文件夹同步到&lt;username&gt;.github.io公开仓库中，并部署到github page\n\n因此新增了一个在源码仓库根目录下的 workflow，将源码上传到私有仓库，通过 hugo 官方提供的 action，将生产的站点文件同步到&lt;username&gt;.github.io公开仓库中。\n创建私有仓库\n首先在 github 上创建一个私有仓库，用于存放源码。\n创建 personal access token\n在 github 的Settings→Developer settings→Personal access tokens中，点击Generate new token，勾选repo权限，生成一个 token，将 token 复制下来。\n添加 secrets\n在源码仓库的Settings→Security→Secrets and variables→Actions中，添加一个ACTION_ACCESS_TOKEN，将刚刚生成的 token 粘贴进去，这个命名要和 workflow 文件中的一致。\n创建 workflow\n在私有仓库的.github/workflows目录下创建一个gh-page.yml文件。\n文件内容如下：\nname: github pages deploy\n \non:\n  push:\n    branches:\n      - main\n \npermissions:\n  contents: read\n \njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3 # 引用actions/checkout这个action，与所在的github仓库同名\n        with:\n          submodules: flase # 是否获取子模块\n          fetch-depth: 0\n \n      - name: Install Node.js\n        uses: actions/setup-node@v3\n \n      - name: Setup Hugo # 步骤名自取\n        uses: peaceiris/actions-hugo@v3 # hugo官方提供的action，用于在任务环境中获取hugo\n        with:\n          hugo-version: &quot;latest&quot; # 获取最新版本的hugo\n          extended: true\n \n      - name: Build\n        run: hugo --minify # 使用hugo构建静态网页\n \n      - name: Deploy\n        uses: peaceiris/actions-gh-pages@v4 # 一个自动发布github pages的action\n        with:\n          # github_token: ${{ secrets.GITHUB_TOKEN }} 该项适用于发布到源码相同repo的情况，不能用于发布到其他repo\n          external_repository: dodolalorc/dodolalorc.github.io # 发布到哪个repo\n          personal_token: ${{ secrets.ACTION_ACCESS_TOKEN }} # 发布到其他repo需要提供上面生成的personal access token\n          publish_dir: ./public/ # 注意这里指的是要发布哪个文件夹的内容，而不是指发布到目的仓库的什么位置，因为hugo默认生成静态网页到public文件夹，所以这里发布public文件夹里的内容\n          keep_files: true # 是否保留其他文件\n          publish_branch: main # 发布到哪个branch\n          commit_message: ${{ github.event.head_commit.message }} # 提交信息\n由于现在的xxx.github.io对应的仓库是在 GitHub action 中构建站点后直接 commit 同步的，故原来在公开仓库中的 workflows 并不方便添加到这个 commit 里，我这里的解决思路是将原来 ssh 连接云服务器进行 deploy 的代码进行修改，添加自动构建内容，再直接用 ssh 连接到云服务器，完成云服务器的内容更新。修改后的remote-deploy.yml参考如下：\nname: Deploy to remote server\n \n# 触发条件\non:\n  push:\n    branches: [main]\n  workflow_dispatch:\n \njobs:\n  deploy:\n    runs-on: ubuntu-latest\n \n    steps:\n      - uses: actions/checkout@v3\n      - name: Install Node.js\n        uses: actions/setup-node@v3\n        with:\n          node-version: &quot;16.x&quot;\n \n      - name: Setup Hugo\n        uses: peaceiris/actions-hugo@v2\n        with:\n          hugo-version: &quot;latest&quot;\n          extended: true\n \n      - name: Build\n        run: hugo --minify\n \n      - name: ssh deploy\n        uses: easingthemes/ssh-deploy@v5.1.0\n        with:\n          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}\n          ARGS: &quot;-rlgoDzvc -i&quot;\n          REMOTE_HOST: ${{ secrets.REMOTE_HOST }}\n          REMOTE_USER: ${{ secrets.REMOTE_USER }}\n          TARGET: ${{ secrets.REMOTE_TARGET }}\n          SOURCE: &quot;public/&quot;\n          # SCRIPT_BEFORE: |\n          #   whoami\n          #   ls -al\n          # SCRIPT_AFTER: |\n          #   cd ${{ secrets.REMOTE_TARGET }}\n          #   ls -al\n          #   pwd\n          #   echo &quot;Deployed successfully&quot;"},"04-tools/mac_start":{"slug":"04-tools/mac_start","filePath":"04-tools/mac_start.md","title":"🍎我的 mac 开荒手册","links":["04-tools/git_settings","04-tools/xcode_commands"],"tags":["Mac","Git","HomeBrew","Item2","zsh","oh-my-zsh"],"content":"HomeBrew\nHomeBrew是一款包管理工具，支持 Mac OS 和 Linux 系统，首先安装好 HomeBrew 可以方便我们获取其他所需要的软件。\n官网访问：Homebrew\n/bin/bash -c &quot;$(curl -fsSL raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;\n换源\n如果官网的安装脚本总是失败，可以尝试换源（以清华源为例）：\nexport HOMEBREW_BREW_GIT_REMOTE=&quot;mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git&quot;\nexport HOMEBREW_CORE_GIT_REMOTE=&quot;mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git&quot;\nexport HOMEBREW_API_DOMAIN=&quot;mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/api&quot;\nexport HOMEBREW_BOTTLE_DOMAIN=&quot;mirrors.tuna.tsinghua.edu.cn/homebrew-bottles/bottles&quot;\n \n/bin/bash -c &quot;$(curl -fsSL gitee.com/ineo6/homebrew-install/raw/master/install.sh)&quot;\n更多选择可以在这里查询：镜像助手\n更新\nbrew update\noh-my-zsh\noh-my-zsh 是 zsh 的拓展工具集，安装 oh-my-zsh 的前提条件是安装使用 zsh。\nzsh\n查询zsh版本：zsh --version\n列出可用终端：\ncat /etc/shells\n当前使用的终端：\necho $SHELL\n将默认终端设置成zsh，调整后需要重启生效：\nchsh -s /bin/zsh\n安装 oh-my-zsh\n官网：oh-my-zsh，提供了curl和wget两种方式：\nsh -c &quot;$(curl -fsSL raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;\nsh -c &quot;$(wget raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)&quot;\n设置主题\n安装成功后，打开配置文件，设置主题：\n# 记事本打开\nopen ~/.zshrc\n# vim打开\nvim ~/.zshrc\n显示内容：\n# If you come from bash you might have to change your $PATH.\n# export PATH=$HOME/bin:$HOME/.local/bin:/usr/local/bin:$PATH\n \n# Path to your Oh My Zsh installation.\nexport ZSH=&quot;$HOME/.oh-my-zsh&quot;\n \n# Set name of the theme to load --- if set to &quot;random&quot;, it will\n# load a random theme each time Oh My Zsh is loaded, in which case,\n# to know which specific one was loaded, run: echo $RANDOM_THEME\n# See github.com/ohmyzsh/ohmyzsh/wiki/Themes\nZSH_THEME=&quot;robbyrussell&quot;\n \n......\n其中ZSH_THEME=&quot;robbyrussell&quot;是主题参数的，可以在：ohmyzsh/ohmyzsh/wiki/Themes查看所有主题的效果，将选择使用的主题的名称填入这个参数即可。\n字符支持\n有一些主题依赖额外的字符，从 GitHub 下载并安装：\ngit clone github.com/powerline/fonts.git --depth=1\n \ncd fonts\n./install.sh\n \ncd ..\nrm -rf fonts\noh-my-zsh 插件\n除了漂亮的主题，oh-my-zsh 还拥有丰富的插件系统：ohmyzsh/ohmyzsh/wiki/plugins\n还是打开~/.zshrc，其中有这样的内容：\n# Would you like to use another custom folder than $ZSH/custom?\n# ZSH_CUSTOM=/path/to/new-custom-folder\n \n# Which plugins would you like to load?\n# Standard plugins can be found in $ZSH/plugins/\n# Custom plugins may be added to $ZSH_CUSTOM/plugins/\n# Example format: plugins=(rails git textmate ruby lighthouse)\n# Add wisely, as too many plugins slow down shell startup.\nplugins=(git)\n默认在安装时已经配备了 git 的别名插件，其中常用的别名可以在这篇中查看：git 配置别名。\n在插件系统中挑选喜欢的插件，推荐的插件有：\n命令行高亮、补全\n来源：Oh my ZSH with zsh-autosuggestions zsh-syntax-highlighting zsh-fast-syntax-highlighting and zsh-autocomplete.md\n安装如下插件：\n\nautosuggesions plugin\n\ngit clone github.com/zsh-users/zsh-autosuggestions.git $ZSH_CUSTOM/plugins/zsh-autosuggestions\n\n\nzsh-syntax-highlighting plugin\n\ngit clone github.com/zsh-users/zsh-syntax-highlighting.git $ZSH_CUSTOM/plugins/zsh-syntax-highlighting\n\n\nzsh-fast-syntax-highlighting plugin\n\ngit clone github.com/zdharma-continuum/fast-syntax-highlighting.git ${ZSH_CUSTOM:-$HOME/.oh-my-zsh/custom}/plugins/fast-syntax-highlighting\n\n\nzsh-autocomplete plugin\n\ngit clone --depth 1 -- github.com/marlonrichert/zsh-autocomplete.git $ZSH_CUSTOM/plugins/zsh-autocomplete\n\n\n\n在配置文件中使用：\nplugins=(git zsh-autosuggestions zsh-syntax-highlighting fast-syntax-highlighting zsh-autocomplete)\n其他推荐\n\nz：记录历史路径，提供快速跳转。使用z、z p。\ncopypath：复制当前的路径到剪切板。使用：copypath &lt;文件或目录&gt;，不加参数就是复制当前路径，相比pwd再光标选中更快捷。\ncopyfile：复制文件内容到剪切板。使用：copyfile filename.txt，即可将文件的内容复制，省略打开文件的后全选复制的步骤。\n\niTerm2\n安装\nbrew install --cask iterm2\n设置主题\n\ncommand ,唤出 settings 菜单。\nProfiles→colors→color Presets下选择颜色和主题、进行微调。\n更多颜色主题：Iterm2-color-schemes\n挑选喜欢的主题后，下载对应的文件。\n在第 2 步的color Presets下选择import，选择下载的主题文件，后缀.itermcolors。\n再次打开color Presets就会发现主题已经加载，点击使用即可。\n\nddl 喜欢的主题：tokyonight\n最后将 item2 保留在程序坞上方便使用即可～\nXcode-select 安装命令行工具\n在安装 Homebrew 时，也会附带下载 Xcode 命令行工具，如果没有安装 Xcode 命令行工具，可以运行：\nxcode-select --install\n这是一个轻量级的工具包，包含开发所需的基础命令行工具，但不需要安装完整的 Xcode（节省空间，约 1-2GB）\n\n\n                  \n                  部分列举 \n                  \n                \n\n\n\n核心编译工具\n\nclangd：xcode 默认编译器\nswift和swiftc：swift 语言编译器\nld（链接器）和ar（静态库打包工具）\nmake和cmake：项目构建工具\n\n\n调试与分析工具\n\nlldb：xcode 调试器的命令行版本\n\n\n版本控制工具\n\ngit：代码版本管理工具（macOS 自带  git  但版本较旧，CLT 会更新到最新版）。\nsvn：Subversion 版本控制工具。\n\n\n文档工具\n\nheader 文件：C/C++ 标准库、系统框架的头文件（如  stdio.h、Foundation.framework）\nman文档：命令行工具的手册页（如  man clang）。\n\n\n其他实用工具\n\nxcrun：Xcode 工具链的调度命令（用于调用其他工具）。\nsdkmanager：管理 SDK 路径（如  xcrun --show-sdk-path）。\npkgutil：软件包管理工具。\n\n\n\n\n\n\n或许你也对💻 常用 xcode 使用命令感兴趣。\nGit 环境设置\nMac 系统自带了 Git，或者在安装 XCode 时，也已经安装了 Git。\n可以参考此文章获得更详细的配置：🔑Git 环境配置和 SSH 公钥设置\nMac 上给 VS code 设置命令行打开目录\nVS code 官网\n\n打开 VS code，shift + command + p调出命令面板\n输入shell Command，选择在PATH中安装code命令\n点击弹出框，确认操作\n"},"04-tools/my_win_shell":{"slug":"04-tools/my_win_shell","filePath":"04-tools/my_win_shell.md","title":"我的 oh-my-posh 上都有哪些配置","links":["tags/oh-my-zsh"],"tags":["oh-my-posh","windows","shell","oh-my-zsh"],"content":"What\n在 Windows 上使用的是 WSL2(fish)+power shell 组合，使用的是 oh-my-posh。\n可以通过这个命令得知当前的 shell 是什么：\n如果这个命令有输出，代表在 power shell 中，这会返回一些 power shell 的详细信息：\n$PSVersionTable.PSVersion\n这个命令在 bash、zsh、fish 等中有效：\necho $SHELL\nPowerShell 有一个或多个配置文件（Profile），查看当前使用的配置文件：\n$PROFILE.CurrentUserCurrentHost\n一些 Power Shell 中的 Module 命令\n\nPS：用管理员身份打开终端。\n\n查看当前安装的 Module\nGet-InstalledModule\n安装 Module\nInstall-Module &lt;Module-Name&gt;\n卸载 Module\nUninstall-Module &lt;Module-Name&gt;\n查看可用模块\n# 查看所有可用模块\nGet-Module -ListAvailable\n \n# 查看特定模块\nGet-Module -ListAvailable -Name &lt;Module-Name&gt;\n \n# 使用通配符搜索\nGet-Module -ListAvailable *git*\n必备模块\nOh My Posh\n提供美观的提示符和主题（包括 Git 状态信息）。\n安装方式较多，可以在官方文档中查看安装方法：oh-my-posh\n自定义 git 别名和函数\n可以在这里查看 oh-my-zsh 的 Git 别名：ohmyzsh-git\n将需要用的别名内容向下方这样写在 Power Shell 的 Profile 中，可以使用命令：\n$PROFILE.CurrentUserCurrentHost\n查看 Profile 文件的位置。\n整理的内容可以参考：\n# ==================== 使用函数定义 Git 命令 ====================\nfunction g { git $args }\nfunction gst { git status $args }\nfunction gd { git diff $args }\nfunction gco { git checkout $args }\nfunction gl { git pull $args }\nfunction gp { git push $args }\nfunction ga { git add $args }\nfunction gaa { git add --all $args }\nfunction gc { git commit -v $args }\nfunction gcmsg { git commit -m $args }\nfunction gcam { git commit -a -m $args }\nfunction gcob { git checkout -b $args }\nfunction gb { git branch $args }\nfunction gba { git branch -a $args }\nfunction glg { git log --stat --color $args }\nfunction glgg { git log --graph --decorate --oneline $args }\nfunction glo { git log --oneline --decorate --color $args }\nfunction grb { git rebase $args }\nfunction grba { git rebase --abort $args }\nfunction grbc { git rebase --continue $args }\nfunction grbs { git rebase --skip $args }\nfunction gpr { git pull --rebase $args }\nfunction gpf { git push --force $args }\nfunction git_current_branch { git rev-parse --abbrev-ref HEAD }\nfunction ggpush { git push origin &quot;$(git_current_branch)&quot; }\nfunction ggpull { git pull origin &quot;$(git_current_branch)&quot; }\n \n# 快速提交所有更改并推送\nfunction gap() {\n    git add .\n    git commit -m &quot;$args&quot;\n    git push\n}\n \n# (可选) 如果你想念 &#039;ll&#039; 命令\nfunction ll { Get-ChildItem -Force | Format-Wide -AutoSize }\n直接将整理好的内容粘贴在文件尾部，并保存文件，就能在新打开的终端在使用这些命令了。"},"04-tools/url_rewrite_rule":{"slug":"04-tools/url_rewrite_rule","filePath":"04-tools/url_rewrite_rule.md","title":"🌐URL 重写规则和静态资源解析逻辑","links":[],"tags":["友好URL规则","GitHubPage","Nginx","服务器"],"content":"问题背景\n最近部署博客页面时遇到这样的问题：同样的页面结构，部署到我的两个域名下：dodolalorc.cn 和 dodolalorc.github.io，对应的网页内容是相同的，但是 dodolalorc.cn 需要写成dodolalorc.cn/links.html才能显示内容，否则会报404，dodolalorc.github.io就不需要这样。\n原因记录\n这种差异主要源于两个域名所对应的服务器配置不同，本质原因是服务器如何解析 “无后缀 URL”。\n我的 dodolalorc.cn 配置在服务器上，而 dodolalorc.github.io 将走 github page 的代理。\n当访问一个 URL（如a.github.io/about或a.cn/about）时，服务器需要判断这个请求对应的实际文件是什么。\n\n对于a.github.io/about：服务器被配置为 “自动补全.html后缀”，即自动将about解析为about.html，因此能找到对应的文件并返回内容。\n对于a.cn/about：服务器没有配置自动补全后缀，它会严格按照请求的路径查找文件（即寻找about这个 “无后缀文件”），但实际文件是about.html，因此找不到，返回 404；只有手动加上.html（即a.cn/about.html），才能匹配到实际文件。\n\na.github.io通常是托管在GitHub Pages上的静态网站，而 GitHub Pages 默认配置了 “友好 URL 规则”，会自动处理无后缀的 URL 请求。具体逻辑包括：\n\n自动补全.html后缀：当请求/about时，服务器会先检查是否存在about.html文件，若存在则直接返回。\n支持目录索引：如果about是一个文件夹，服务器会自动查找about/index.html（即默认索引文件）。\n\n这种配置是 GitHub Pages 为了简化静态网站访问而预设的，目的是让 URL 更简洁（如xxx/about比xxx/about.html更易读）。\na.cn对应的服务器没有配置 “自动补全.html” 的规则，因此遵循 “严格匹配” 逻辑：\n\n当请求a.cn/about时，服务器会直接查找名为about的 “无后缀文件”（而非about.html）。\n由于实际文件是about.html（而非about），服务器找不到对应资源，就会返回 404 错误。\n只有手动指定完整文件名about.html，才能匹配到实际文件，因此a.cn/about.html能正常访问。\n\n解决方法\n我的服务器使用 Nginx 服务器，于是选择在 Nginx 的站点配置中添加：\nlocation / {\n    # 当请求的文件不存在时，尝试补全.html\n    if (!-e $request_filename) {\n        rewrite ^(.*)$ $1.html last;\n    }\n}\n配置后，a.cn/about会被自动解析为a.cn/about.html，无需手动加后缀。"},"04-tools/xcode_commands":{"slug":"04-tools/xcode_commands","filePath":"04-tools/xcode_commands.md","title":"💻常用 xcode 使用命令","links":[],"tags":["xcode"],"content":"\n\n                  \n                  Xcode 介绍 \n                  \n                \n\n\nXcode 是苹果官方推出的集成开发环境（IDE），专为苹果的 Mac OS、iOS、iPad OS、watch OS 等应用开发设计，在 Mac 系统上作用是否广泛。使用 Mac 作为开发工具时必不可少的东西。\n\n\n\nXCode 安装\n1. App Store 安装\n在 App Store 可以直接搜索获得最新的 XCode 版本\n2.安装各种版本的 Xcode\n获取所需版本 Xcode 压缩包\nXcode Releases 可以搜索安装各个版本的 Xcode，所有的可获得版本均来自官方下载连接。\n重命名 Xcode 并移动到应用程序文件夹中\n解压后将 Xcode 重命名为 Xcode_{版本号} ，如 Xcode_16.2 ，将其从 Downloads 文件夹下移动到/Applications 下。\ncd Downloads\nmv Xcode.app Xcode_16.2.app\nmv Xcode_16.2.app /Applications\n \n# 查看\ncd /Applications\nls\n同意 License\n从上面的链接下载的 Xcode 还没有同意使用许可，命令行运行：\nsudo xcodebuild -license\n按照提示输入密码即可。\nxcode-select\nxcode-select  是 macOS 上管理  Xcode 和命令行工具  的核心命令，主要用于切换、查询和配置 Xcode 的默认路径。\n安装命令行工具\nxcode-select --install\n查询当前 Xcode 路径\nxcode-select --print-path\nOR\nxcode-select -p\n输出示例：\n/Applications/Xcode.app/Contents/Developer\n切换版本\n如果系统安装了多个 Xcode 版本，可以切换默认版本sudo xcode-select --switch &lt;路径&gt;，举例：\nsudo xcode-select --switch /Applications/Xcode-beta.app/Contents/Developer\n\n路径必须指向  Contents/Developer，而非  .app  根目录。\n所有修改路径的操作均需  sudo  权限。\n\n手动设置工具路径\nsudo xcode-select --set &lt;路径&gt;\n验证配置有效性\nxcode-select --check"},"05-projects/index":{"slug":"05-projects/index","filePath":"05-projects/_index.md","title":"🪀玩具箱","links":[],"tags":["项目","intro"],"content":"记录一些摸鱼摸出来的低质量项目。"},"05-projects/block_chain":{"slug":"05-projects/block_chain","filePath":"05-projects/block_chain.md","title":"🦀Rust编程区块链项目 BlockChain in Rust","links":[],"tags":["Rust","区块链"],"content":"\n\n                  \n                  GitHub仓库地址 \n                  \n                \n\n\nGitHub 仓库地址：BlockChain\n\n\n\n一、产品方案\n项目目标\n实现一个轻量的简单高效的区块链系统项目，用于学习和研究。\n\n学习区块链的相关知识，实现一个由 Rust 实现的简单区块链系统。\n能够生成创世区块，支持区块的创建、验证和链式储存，实现工作量证明算法。\n利用本机端口构建服务系统，实现交易的广播、挖矿功能、简单的交易校验功能。\n\n用户需求分析\n\n用户可以通过命令行启动本地服务，在main.rs中配置路由，参考下方的使用手册，进行创建交易、挖矿、查看信息等。\n通过时间戳、lock_time、签名校验等完成简单的对交易信息的核对。\n系统具有一定的可扩展性，用户可以通过调整 API 接口快速调试。\n\n主要功能\n本产品主要由src/下的.rs文件实现主要功能。\n设计了区块链和区块的数据结构，并完成了简单的新建区块、新建区块链以及设置创世区块、添加交易到交易池、挖矿打包交易、交易广播、计算 Merkle 树根哈希等功能。\n设计了一条交易信息的各种数据结构，包括其交易输入、交易输出、锁定时间，还实现了签名交易和广播行为。\n二、技术方案\n技术选型\n\n编程语言：Rust（高性能、内存安全、适合区块链开发）。\n数据序列化：使用  serde  和  serde_json  进行完成序列化。\n时间戳：使用chrono获取当前时间。\n哈希算法：通过sha2库的 SHA-256 计算哈希值。\n加密算法：使用 Rust 的加密库ring实现哈希、签名等功能。\n共识算法：实现 PoW（工作量证明）共识机制。\n网络通信：使用 Rust 的异步网络库Tokio实现 P2P 通信。\n\n模块划分\n\n区块模块：区块的创建、验证和链式存储。\n交易模块：交易的创建、签名和验证。\n网络模块：节点发现、消息广播和数据同步。\n共识模块：实现共识算法。\n存储模块：数据持久化存储。\n\nmain.rs：定义了创建节点、消息广播等功能的网络模块。\nblock_chain.rs：定义了区块链和区块的数据结构，并完成了简单的新建区块、新建区块链以及设置创世区块、添加交易到交易池、挖矿打包交易、交易广播、计算 Merkle 树根哈希等功能。\nhash_function.rs：主要定义了常用的哈希函数。\nserialization.rs：定义了序列化和反序列化的方法。\ntransaction.rs：定义了一条交易信息的各种数据结构，包括其交易输入、交易输出、锁定时间，还实现了签名交易和广播行为。\n系统结构\n区块链结构\n区块链的核心是由一系列按顺序链接的区块组成的链式结构。每个区块包含以下关键信息：\n\n时间戳（timestamp）：区块创建的时间。\n哈希值（merkle_root）：当前区块的唯一标识，通过加密算法生成。\n前一区块哈希（prev_block_hash）：指向前一个区块的哈希值，用于维护链的连续性。\n\n在实现中，区块链可以通过一个动态数组（ Vec&lt;Block&gt;）来存储所有区块，确保区块的顺序和完整性。\n创世区块\n创世区块是区块链中的第一个区块，它的生成标志着区块链的初始化。创世区块的特点包括：\n\n前一区块哈希为空：由于没有前驱区块，其前一区块哈希值通常设置为空或特定标识（如 “0”）。\n哈希值计算：根据区块的内容（索引、时间戳、前一区块哈希和数据）生成唯一的哈希值，并存储到区块中。\n\n创世区块的生成是区块链启动的必要步骤，为后续区块的添加奠定基础。\n挖矿算法\n挖矿是区块链中生成新区块的关键过程，其核心是通过计算找到一个满足特定条件的哈希值。具体实现如下：\n\n难度目标：设定一个哈希值的难度条件（例如，哈希值的前几位必须为 “0”）。\n随机数（Nonce）：通过不断尝试不同的随机数，结合区块的其他信息（索引、时间戳、前一区块哈希和数据），计算哈希值。\n哈希验证：检查生成的哈希值是否满足难度条件。如果满足，则挖矿成功；否则，继续尝试新的随机数。\n\n挖矿算法的实现确保了区块链的安全性和去中心化特性，同时也为新区块的生成提供了动力。\n以上设计使得区块链系统能够实现基础的区块的创建、链接和验证，同时通过挖矿算法保证网络的共识和安全。\n三、使用手册\n拉取本项目\ngit clone git@github.com:dodolalorc/BlockChain.git\n启动项目，开启本地服务器\ncargo run\n本地服务器接口使用：\n\n添加交易\n\ncurl -X POST http://127.0.0.1:3030/transaction -H &quot;Content-Type: application/json&quot; -d &#039;{&quot;value&quot;:100,&quot;lock_time&quot;:0}&#039;\n\n查看交易池\n\ncurl http://127.0.0.1:3030/pool\n\n查看区块链区块部分\n\ncurl http://127.0.0.1:3030/blocks\n\n挖矿\n\n curl -X POST http://127.0.0.1:3030/mine\n实验截图\n建立交易及交易池状态\n\n挖矿\n\n四、项目要求\n一：计划\n\n完成概念学习：区块链\n完成需求设计：产品方案、技术方案\n完成项目实现：Rust 实现，至少输出创世区块\n\n二：要求\n\n结合下面给的和自己搜索到的参考资料、书籍、视频等学习区块链基础知识\n结合个人兴趣和所学内容，自己确定一个区块链领域的项目目标（如，实现基本的挖矿）\n有了目标，自己学习怎么写产品方案、技术方案、可以多人组队研究\n基于产品方案和技术方案实现你的需求，要结合之前讲的数据结构和算法内容\n\n注意：至少是实现一个简单的区块链，运行并输出创世区块\n三：参考资料\n\n区块链教程 liaoxuefeng.com/books/blockchain/introduction/index.html\n区块链学习路线 zjubca.github.io/roadmap/\ngo 实现的 demo github.com/Jeiwan/blockchain_go\nB 站区块链项目实战 www.bilibili.com/video/BV145411t7qp/\n\n"},"05-projects/quartz/index":{"slug":"05-projects/quartz/index","filePath":"05-projects/quartz/_index.md","title":"🏙️ Quartz 设置","links":[],"tags":["intro"],"content":"记录博客主题的一些自定义设置。"},"05-projects/quartz/add_featured_image":{"slug":"05-projects/quartz/add_featured_image","filePath":"05-projects/quartz/add_featured_image.md","title":"在 quartz 主题中给博客添加封面首图","links":[],"tags":["博客主题","tsx","quartz主题"],"content":"上一个主题可以在博客首部设置一张自定义的图片，也一直觉得这样的设计很漂亮，在 quartz 中没有这样的默认主题，所以在这里手动添加了这样的设计~\n步骤\nplugins 结构\n在quartz/plugins中，定义了文章中各种内容转换的工具（transformers）、生成资源的工具（Emitters）以及发布逻辑（Fliters）。\n在本次实现中，我们需要从markdown文章中读取传参featuredImage，然后将参数内容作为加载图片的 url，将图片渲染在页面上，所以我们需要像这样先给原frontmatter.ts添加一个可以识别的参数：\n/* existing codes */\ndeclare module &quot;vfile&quot; {\n  interface DataMap {\n    aliases: FullSlug[]\n    frontmatter: { [key: string]: unknown } &amp; {\n      title: string\n    } &amp; Partial&lt;{\n      tags: string[]\n      aliases: string[]\n      modified: string\n      created: string\n      published: string\n      description: string\n      socialDescription: string\n      publish: boolean | string\n      draft: boolean | string\n      lang: string\n      enableToc: string\n      cssclasses: string[]\n      socialImage: string\n      featuredImage: string\n      comments: boolean | string\n    }&gt;\n  }\n}\n/* existing codes */\ncomponents 结构\nquartz 的所有主题都在quartz/components下，以此为根目录，index.ts中总结了导出的所有组件的类型，将在quartz.layout.ts中以import * as Component from &quot;./quartz/components&quot;的形式导入，并以Component.ArticleTitle()这样的形式使用。\n所以，我们模仿相同的文件结构，在quartz/components下新建一个tsx文件FeaturedImage.tsx，内容像这样：\nFeaturedImageimport { QuartzComponent, QuartzComponentConstructor, QuartzComponentProps } from &quot;./types&quot;\nimport { classNames } from &quot;../util/lang&quot;\n \nconst FeaturedImage: QuartzComponent = ({ fileData, displayClass }: QuartzComponentProps) =&gt; {\n  const featuredImage = fileData.frontmatter\n  if (featuredImage) {\n    return (\n      &lt;div class={classNames(displayClass, &quot;featured-image&quot;)}&gt;\n        &lt;img src={featuredImage} alt=&quot;Featured&quot; /&gt;\n      &lt;/div&gt;\n    )\n  } else {\n    return null\n  }\n}\n \nFeaturedImage.css = `\n.featured-image {\n  margin: 0.5rem 0;\n  height: 200px;\n  overflow: hidden;\n}\n.featured-image img {\n  width: 100%;\n  height: 100%;\n  object-fit: cover;\n  border-radius: 8px;\n  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);\n}\n`\n \nexport default (() =&gt; FeaturedImage) satisfies QuartzComponentConstructor\n \n再在index.ts中将FeaturedImage导入，之后在quartz.layout.ts中添加即可：\nquartz.layout.tsexport const defaultContentPageLayout: PageLayout = {\n  beforeBody: [\n    Component.ConditionalRender({\n      component: Component.Breadcrumbs({\n        rootName: &quot;主页&quot;,\n      }),\n      condition: (page) =&gt; page.fileData.slug !== &quot;_index&quot;,\n    }),\n    Component.ArticleTitle(),\n    Component.ContentMeta(),\n    Component.FeaturedImage(),\n    Component.TagList(),\n之后重新构建页面，即可查看样式效果啦。\n效果展示：\n\n☆: .｡. o(≧▽≦)o .｡.:☆"},"05-projects/quartz/favicon_link":{"slug":"05-projects/quartz/favicon_link","filePath":"05-projects/quartz/favicon_link.md","title":"🧩带图标的 Blog 跳转链接","links":[],"tags":["quartz主题","favicon","google服务"],"content":"将在线链接升级成可以预览网页图标的样子~\nquartz 主题中，展示链接的插件是Plugin.CrawlLinks()，文档中介绍了现有的几种常用的设置，本文尝试将其拓展，增加一个showLinkFavicon属性：\nPlugin.CrawlLinks({\n\tmarkdownLinkResolution: &quot;shortest&quot;,\n\topenLinksInNewTab: true,\n\tlazyLoad: true,\n\texternalLinkIcon: true,\n\tshowLinkFavicon: true,\n}),\n定义字段\n在quartz\\plugins\\transformers\\links.ts中，添加字段定义：\nconst defaultOptions: Options = {\n  markdownLinkResolution: &quot;absolute&quot;,\n  prettyLinks: true,\n  openLinksInNewTab: false,\n  lazyLoad: false,\n  externalLinkIcon: true,\n  showLinkFavicon: true,\n}\n在CrawlLinks定义中添加实现：\nexport const CrawlLinks: QuartzTransformerPlugin&lt;Partial&lt;Options&gt;&gt; = (userOpts) =&gt; {\n  const opts = { ...defaultOptions, ...userOpts }\n  return {\n    name: &quot;LinkProcessing&quot;,\n    htmlPlugins(ctx) {\n      return [\n        () =&gt; {\n          return (tree: Root, file) =&gt; {\n            const curSlug = simplifySlug(file.data.slug!)\n            const outgoing: Set&lt;SimpleSlug&gt; = new Set()\n \n            const transformOptions: TransformOptions = {\n              strategy: opts.markdownLinkResolution,\n              allSlugs: ctx.allSlugs,\n            }\n \n            visit(tree, &quot;element&quot;, (node, _index, _parent) =&gt; {\n \n            // ...\n \n                if (isExternal &amp;&amp; opts.showLinkFavicon) {\n                  const domain = new URL(node.properties.href).hostname\n                  if (domain) {\n                    node.children.unshift({\n                      type: &quot;element&quot;,\n                      tagName: &quot;img&quot;,\n                      properties: {\n                        src: `s2.googleusercontent.com/s2/favicons${domain}`,\n                        alt: &quot;&quot;,\n                        style: &quot;width: 1em; height: auto; margin-left: 4px; margin-right: 4px; vertical-align: middle;&quot;,\n                      },\n                      children: [],\n                    })\n                  }\n                }\n            // ...\n \n实现思路\n直接使用 favicon 默认路径\n大多数网站在根目录下有 favicon.ico 文件，可以通过示例中的方法捕获：\nfunction getDefaultFaviconUrl(url: string): string {\n  const domain = new URL(url).origin;\n  return `${domain}/favicon.ico`;\n}\n \n// 使用示例\nconst faviconUrl = getDefaultFaviconUrl(&#039;example.com&#039;);\nconsole.log(&#039;Default favicon URL:&#039;, faviconUrl);\n但是 favicon.ico 并不是每个网站都设置在同样的路径下，其格式也不一定都是.ico。\n使用 Google Favicon 服务\n调用 Google favicon API，这个 api 可以仅通过网站域名即可抓取网站的 favicon，使用方法如下：\ns2.googleusercontent.com/s2/favicons目标网站域名\n还可以通过sz属性指定获取的 icon 的大小（如果访问的网站有这样的尺寸），sz属性的单位是px，默认值是 16：\ns2.googleusercontent.com/s2/favicons大小\nasync function getFaviconUrl(url: string): Promise&lt;string | null&gt; {\n  try {\n    // 提取域名\n    const domain = new URL(url).hostname;\n    return `s2.googleusercontent.com/s2/favicons${domain}`;\n  } catch (error) {\n    console.error(&#039;Error getting favicon:&#039;, error);\n    return null;\n  }\n}\n \n// 使用示例\ngetFaviconUrl(&#039;example.com&#039;).then(faviconUrl =&gt; {\n  console.log(&#039;Favicon URL:&#039;, faviconUrl);\n});"},"05-projects/quartz/use_filter_and_sort":{"slug":"05-projects/quartz/use_filter_and_sort","filePath":"05-projects/quartz/use_filter_and_sort.md","title":"为最近笔记添加排序和筛选","links":[],"tags":["tsx","博客主题","quartz主题"],"content":"有时候会更新一些目录页说明，更新说明时会出现博客左上角的“最近笔记”模块显示成这些目录页的更新，于是在自定义设置中记录一下Component.RecentNotes({})的使用。\nquartz 主题官方有一篇介绍：最近笔记\n设置配置\n\n自定义筛选：传递额外参数  Component.RecentNotes({ filter: someFilterFunction })。筛选函数应具有签名  (f: QuartzPluginData) =&gt; boolean。\n自定义排序：传递额外参数  Component.RecentNotes({ sort: someSortFunction })。默认情况下，Quartz 会按日期排序并在有相同日期时按字母顺序排序。排序函数应具有签名  (f1: QuartzPluginData, f2: QuartzPluginData) =&gt; number。可参考  quartz/components/PageList.tsx  中的  byDateAndAlphabetical  示例。\n\nquartz.layout.tsimport { QuartzPluginData } from &quot;./quartz/plugins/vfile&quot;\n \n// ...\n \nComponent.DesktopOnly(Component.RecentNotes({\n  limit: 3,\n  showTags: false,\n  filter: (f) =&gt; f.frontmatter?.includes(&#039;intro&#039;) ? false : true,\n  sort: (f1: QuartzPluginData, f2: QuartzPluginData) =&gt; {\n\tif (f1.frontmatter &amp;&amp; f2.frontmatter) {\n\t  // Sort by date\n\t  if (f1.frontmatter &amp;&amp; f2.frontmatter) {\n\t\treturn f1.frontmatter.date &lt; f2.frontmatter.date ? 1 : -1\n\t  } else if (f1.frontmatter &amp;&amp; !f2.frontmatter) {\n\t\treturn -1\n\t  } else if (!f1.frontmatter &amp;&amp; f2.frontmatter) {\n\t\treturn 1\n\t  }\n \n\t  const f1Title = f1.frontmatter() ?? &quot;&quot;\n\t  const f2Title = f2.frontmatter() ?? &quot;&quot;\n\t  return f1Title.localeCompare(f2Title)\n\t}\n\treturn 0\n  }\n})),\n在frontmatter.ts中添加页面参数：\nfrontmatter.tsdeclare module &quot;vfile&quot; {\n  interface DataMap {\n    aliases: FullSlug[]\n    frontmatter: { [key: string]: unknown } &amp; {\n      title: string\n    } &amp; Partial&lt;{\n      tags: string[]\n      aliases: string[]\n      modified: string\n      created: string\n      date: string\n      lastmod: string\n      published: string\n      description: string\n      socialDescription: string\n      publish: boolean | string\n      draft: boolean | string\n      lang: string\n      enableToc: string\n      cssclasses: string[]\n      socialImage: string\n      featuredImage: string\n      comments: boolean | string\n    }&gt;\n  }\n}"},"index":{"slug":"index","filePath":"_index.md","title":"👋Hi from dodola!","links":[],"tags":["intro"],"content":"\n\n🎐 个人信息：\n昵称：哆哆啦(dodola)，也可以缩写 ddl\n刷新地点：杭州(实习+假期)/长春(上学)\n废话：INTJer，跟其他 INTJ 一样有一些不顾人死活的人机感。\n\nI Navigate The Journey.\n\n本科 2026 届东师计科专业，不太打算读研，目前在字节跳动当实习生，正在努力学习进军互联网。\n平时喜欢打点电子游戏，动森/星露谷/splatoon/雀魂。喜欢做点拼豆、钩织之类的手工。\n喜欢看点音乐剧（没错你怎么知道 2025.10 我要去看法红黑了），看点番看点电影看点日剧韩剧，还有看点小说（但是最近看书越来越少了 T-T）\n目前正在字节跳动实习，正在学习 Electron 和 Chromium 内核相关的部分。\n联系方式：\n\n📮 第一个长期使用的 gmail\n📮 和域名一致的 gmail\n🐧QQ Mail 如果 gmail 发送失败可以联系的 qq 邮箱\n⭐dodola 的 github\n\n\n💡 最近 TODO\nTODO Blogs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n状态标题描述【PENDING】Electron 简单项目起步系列随便记录 Electron 客户端开发学习【PENDING】Git Commit 钩子探索 Git Commit 格式化和其他脚本的工作流【PENDING】windows shell 别名为我的 oh-my-bash 实现添加好用的别名\nTODO Projects\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n当前状态名称功能简述项目地址【PENDING】拼豆图纸生成工具内嵌 AI，可以根据描述生成图案；支持更好的对像素图的分析和生成图纸；支持自定义修改和绘制。【PENDING】多标签页浏览器模型开发一个简易的可以支持多 Tab 页面的 Electron 客户端，主要关注 Tab 页的实现和管理，探索学习和体验多进程架构。multi-tab-browser【PENDING】屏幕录制工具可以实现对电脑上任意区域的录制，录制时提供工具栏，可以添加标注。【PENDING】Blog 友链卡片或许会作为 quartz 的一个社区 plugin，提供多主题的漂亮友链。\n\n🪁 本站信息：\n建站日期：2023/11/28\n本站简介：本站会用来保存 ddl 的电子笔记，涉及各种笔记和 bug 日记，但目前算法笔记含量很高（你这辈子就是被算竞害了），就是个杂七杂八的电子小仓库，欢迎您的访问！非常欢迎友链互链，相互交流！很高兴认识你~\n框架：\n\n博客框架：\n\n2023/11 Hugo\n2025/05 更换为Rspress\n2025/06 更换为Quartz *当前使用\n\n\n主题：\n\n2023/11 PaperMod\n2024/07 DoIt\n2025/05 Rspress 默认主题 + 修改了一些样式和组件\n2025/06 Quartz 默认主题 + 修改一些样式和组件 *当前使用\n\n\n仓库：GitHub\n\n线路信息\n\n初始域名：dodolalorc.github.io\n主域名：dodolalorc.cn\n"},"links":{"slug":"links","filePath":"links.md","title":"💛友達です！","links":["tags/名称","tags/链接","tags/头像","tags/站点描述"],"tags":["intro","名称","链接","头像","站点描述"],"content":"✨️✨️ 友链列表：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n名称链接简介dodoladodolalorc.cn/要是人生能像星露谷就好了。✨思想犯virgiling.github.io/一个活的相对失败的 CSer 😢Windlinxywindlinxy.github.io/测试岗牛马的失败生活 🐴YorkWu’s Blogwyy.ink/ddl:一个很强的学长QwQ！！👍无双blog.wushuang233.com/ddl:是很强的陈老师！👨‍🏫Rosesrossqaq.github.io/NENU 唯一懂 C++ 的人 💻Steve Paulgsteve-paul.github.io/唯一史诗神 👑Ling_1ling101w.github.io/网安爷✌️Oyiso’s Blogoyiso.cn/The shortest answer is doing. ✨Echo 的小窝www.liveout.cn/漂泊于互联网中的小窝 🏠KAMIASUKA’s Blogkamiasuka.top/index.htmlPatience is key in life ⏳松種小窝pineseed.cn/花开又花落，时节暗中迁 🌸幻雪的博客huanxueblog.top/腐烂于花海，致死于所爱 🌹\n✨️✨️ 本站友链信息：\n\nname: dodola\nurl: dodolalorc.cn/\navatar: dodolalorc.cn/img/dodola.png\nbio: 要是人生能像星露谷就好了。\n\n✨️✨️ 申请友链信息格式：\n\nname: 名称\nurl: 链接\navatar: 头像\nbio: 站点描述\n\n🎇🎇 友链申请要求 QwQ\n🎉 本站支持交换友链，在您提出申请之前，请将本站添加至友链\n🏵️ 为了保障本站用户，本站仅支持个人网站的友链申请\n💐 友链中的链接信息需要保证可以正常访问哦\n🍖 站内文章能持续更新，没有太多广告\n🎴 感谢您对本站的支持，如果您已经满足上述要求，请在下方评论区提交友链申请~~~"}}