"use strict";(self.webpackChunkblogsite_rspress=self.webpackChunkblogsite_rspress||[]).push([["2538"],{9163:function(e,n,s){s.r(n),s.d(n,{default:()=>d});var r=s(2676),i=s(453),t=s(5523);function l(e){let n=Object.assign({h2:"h2",a:"a",h3:"h3",pre:"pre",code:"code",p:"p",strong:"strong",ul:"ul",li:"li",h4:"h4",ol:"ol",h5:"h5",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td"},(0,i.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.h2,{id:"vue-从-createapp-开始的链式调用",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#vue-从-createapp-开始的链式调用",children:"#"}),"Vue :从 createApp 开始的链式调用"]}),"\n",(0,r.jsx)(t.Z,{defaultLocale:"zh-CN"}),"\n",(0,r.jsxs)(n.h3,{id:"代码示例",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#代码示例",children:"#"}),"代码示例"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import { createApp } from 'vue';\n\n// 创建一个 Vue 应用实例\nconst app = createApp({\n  data() {\n    return {\n      message: 'Hello, Vue!'\n    };\n  },\n  methods: {\n    handleClick() {\n      alert('Button clicked!');\n    }\n  }\n});\n\n// 链式调用：配置应用并绑定事件\napp\n  .component('MyButton', {\n    template: `<button @click=\"handleClick\">Click Me</button>`,\n    methods: {\n      handleClick() {\n        this.$emit('custom-click');\n      }\n    }\n  })\n  .directive('highlight', {\n    mounted(el) {\n      el.style.backgroundColor = 'yellow';\n    }\n  })\n  .mixin({\n    created() {\n      console.log('Mixin created hook');\n    }\n  })\n  .mount('#app'); // 挂载到 DOM\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"解释",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#解释",children:"#"}),"解释"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"createApp"}),":创建一个 Vue 应用实例。传入一个根组件配置对象，包含 data 和 methods。"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"链式调用"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:".component()"}),": 注册一个全局组件 MyButton，组件中定义了一个按钮，点击按钮时会触发 custom-click 事件。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:".directive()"}),": 注册一个全局指令 highlight，当元素挂载时，背景颜色会变为黄色。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:".mixin()"}),": 添加一个全局混入，在组件的 created 生命周期钩子中输出日志。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:".mount()"}),": 将应用挂载到 DOM 中，挂载点为 ",(0,r.jsx)(n.code,{children:"#app"}),"。"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"事件绑定"})}),"\n",(0,r.jsxs)(n.p,{children:["在 ",(0,r.jsx)(n.code,{children:"MyButton"})," 组件中，通过 ",(0,r.jsx)(n.code,{children:"@click"})," 绑定了一个点击事件，触发时会调用 ",(0,r.jsx)(n.code,{children:"handleClick"})," 方法，并通过",(0,r.jsx)(n.code,{children:" $emit"})," 触发 ",(0,r.jsx)(n.code,{children:"custom-click"})," 事件。"]}),"\n",(0,r.jsx)(n.p,{children:"在父组件中，可以通过监听 custom-click 事件来处理按钮点击逻辑。"}),"\n",(0,r.jsxs)(n.h3,{id:"use-方法",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#use-方法",children:"#"}),"use 方法"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"use"}),"\xa0 方法是 Vue 应用实例的一个方法，用于安装插件。插件可以是一个对象（必须提供 \xa0",(0,r.jsx)(n.code,{children:"install"}),"\xa0 方法），也可以是一个函数（会被直接调用）。Vue 会调用插件的 \xa0",(0,r.jsx)(n.code,{children:"install"}),"\xa0 方法，并将 Vue 应用实例作为参数传递给它。"]}),"\n",(0,r.jsxs)(n.h4,{id:"语法",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#语法",children:"#"}),"语法"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"app.use(plugin, options)\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"plugin"})}),": 要安装的插件，可以是一个对象或函数。"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.code,{children:"options"})}),": 可选的配置对象，传递给插件的 \xa0",(0,r.jsx)(n.code,{children:"install"}),"\xa0 方法。"]}),"\n"]}),"\n",(0,r.jsxs)(n.h4,{id:"实现-use",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实现-use",children:"#"}),"实现 use"]}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"use 的逻辑"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"function use(plugin, options) {\n  if (typeof plugin.install === 'function') {\n    // 如果插件是一个对象，并且提供了 install 方法\n    plugin.install(this, options);\n  } else if (typeof plugin === 'function') {\n    // 如果插件是一个函数\n    plugin(this, options);\n  } else {\n    throw new Error('Plugin must be a function or an object with an install method.');\n  }\n  return this; // 返回应用实例，支持链式调用\n}\n"})}),"\n",(0,r.jsxs)(n.ol,{start:"2",children:["\n",(0,r.jsx)(n.li,{children:"使用"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"// 自定义插件\nconst myPlugin = {\n  install(app, options) {\n    console.log('My plugin is installed with options:', options);\n    // 添加全局方法或属性\n    app.config.globalProperties.$myMethod = () => {\n      console.log('Hello from my plugin!');\n    };\n    // 注册全局组件\n    app.component('my-component', {\n      template: '<div>My Custom Component</div>'\n    });\n  }\n};\n\n// 使用插件\ncreateApp(App)\n  .use(myPlugin, { someOption: true }) // 安装自定义插件\n  .mount('#app');\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"promise-中的链式调用",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#promise-中的链式调用",children:"#"}),"Promise 中的链式调用"]}),"\n",(0,r.jsxs)(n.h3,{id:"手写-promise-方法",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#手写-promise-方法",children:"#"}),"手写 Promise 方法"]}),"\n",(0,r.jsxs)(n.h4,{id:"promise-a规范",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#promise-a规范",children:"#"}),"Promise A+规范"]}),"\n",(0,r.jsx)(n.p,{children:"PromiseA+规范详细描述了 JavaScript 中 Promise 的行为标准，确保不同的 Promise 实现可以相互兼容。"}),"\n",(0,r.jsxs)(n.h5,{id:"术语",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#术语",children:"#"}),(0,r.jsx)(n.strong,{children:"术语"})]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"promise"}),"：先是一个对象或函数，其具有，然后是方法，其行为符合本规范。\n",(0,r.jsx)(n.code,{children:"thenable"}),"：先用一个具有，再用方法的对象或函数。\n",(0,r.jsx)(n.code,{children:"value"}),"：任何合法的脚本值(包括未定义，一个已启用，或一个 Promise)。\n",(0,r.jsx)(n.code,{children:"exception"}),"：一个使用抛出语句抛出的值。\n",(0,r.jsx)(n.code,{children:"reason"}),"：一个表示 Promise 被拒绝的原因"]}),"\n",(0,r.jsxs)(n.h5,{id:"要求",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#要求",children:"#"}),(0,r.jsx)(n.strong,{children:"要求"})]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Promise 状态"})}),"\n",(0,r.jsx)(n.p,{children:"一个 promise 必须处于以下三种状态之一：pending(等待态），fulfilled(执行态)，或 rejected(拒绝态)。"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"pending"}),"：可以迁移到 fulfilled 或 rejected 状态。\n",(0,r.jsx)(n.code,{children:"fulfilled"}),"：不可迁移到其他状态，必须有一个 value。\n",(0,r.jsx)(n.code,{children:"rejected"}),"：不可迁移到其他状态，必须有一个 reason。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"then 方法"}),"\n一个 promise 必须提供一个 then 方法来访问其当前或最终的 value 或 reason。\npromise.then(onFulfilled, onRejected)"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"onFulfilled 和 onRejected 都是可选参数。"}),"\n",(0,r.jsx)(n.li,{children:"如果 onFulfilled 不是函数，必须忽略它。"}),"\n",(0,r.jsx)(n.li,{children:"如果 onRejected 不是函数，必须忽略它。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"onFulfilled 的执行"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"onFulfilled 必须在 promise 完成后被调用，且 promise 的 value 作为其第一个参数。"}),"\n",(0,r.jsx)(n.li,{children:"onFulfilled 不得在 promise 完成前被调用。"}),"\n",(0,r.jsx)(n.li,{children:"onFulfilled 必须只被调用一次。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"onRejected 的执行"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"onRejected 必须在 promise 被拒绝后被调用，且 promise 的 reason 作为其第一个参数。"}),"\n",(0,r.jsx)(n.li,{children:"onRejected 不得在 promise 被拒绝前被调用。"}),"\n",(0,r.jsx)(n.li,{children:"onRejected 必须只被调用一次。"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"then 方法必须返回一个 promise"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"promise2 = promise1.then(onFulfilled, onRejected);\n"})}),"\n",(0,r.jsx)(n.p,{children:"promise2 必须是一个新的 promise。"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"处理返回的值"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["如果 onFulfilled 或 onRejected 返回一个值，则运行 Promise 解决程序",(0,r.jsx)(n.code,{children:"Resolve(promise2, x)"}),"。"]}),"\n",(0,r.jsx)(n.li,{children:"如果 onFulfilled 或 onRejected 抛出一个异常，则 promise2 必须以作为拒绝原因。"}),"\n",(0,r.jsx)(n.li,{children:"如果 onFulfilled 不是一个函数且 promise1 完成，promise2 必须以 promise1 的 value 作为其 value。"}),"\n",(0,r.jsx)(n.li,{children:"如果 onRejected 不是一个函数且 promise1 被拒绝，promise2 必须以 promise1 的 reason 作为其 reason。"}),"\n"]}),"\n",(0,r.jsxs)(n.h4,{id:"代码示例-1",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#代码示例-1",children:"#"}),"代码示例"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"const PENDING = 'pending';\nconst FULFILLED = 'fulfilled';\nconst REJECTED = 'rejected';\n\nfunction isFunction(fn) {\n  return Object.prototype.toString.call(fn) === '[object Function]';\n}\n\nfunction myPromise(fn) {\n  if (!this || this.constructor !== myPromise) {\n    throw new TypeError('Promise must be called with new');\n  }\n  if (!isFunction(fn)) {\n    throw new TypeError('Promise resolver undefined is not a function');\n  }\n\n  this.status = PENDING;\n  this.value = void 0;\n  this.reason = void 0;\n  this.onFulfilledCallbacks = [];\n  this.onRejectedCallbacks = [];\n\n  const resolve = value => {\n    if (this.status === PENDING) {\n      this.status = FULFILLED;\n      this.value = value;\n\n      // 发布\n      this.onFulfilledCallbacks.forEach(fn => fn());\n    }\n  };\n\n  const reject = reason => {\n    if (this.status === PENDING) {\n      this.status = REJECTED;\n      this.reason = reason;\n\n      // 发布\n      this.onRejectedCallbacks.forEach(fn => fn());\n    }\n  };\n\n  try {\n    fn(resolve, reject);\n  } catch (e) {\n    reject(e);\n  }\n}\n\n// 添加 then 原型方法\nmyPromise.prototype.then = function (onFulfilled, onRejected) {\n  // 处理边界\n  onFulfilled = isFunction(onFulfilled) ? onFulfilled : value => value;\n  onRejected = isFunction(onRejected) ? onRejected : reason => { throw reason };\n\n  // 返回一个新的 Promise\n  const promise2 = new myPromise((resolve, reject) => {\n    if (this.status === FULFILLED) {\n      setTimeout(() => {\n        try {\n          const x = onFulfilled(this.value);\n          resolve(x);\n        } catch (e) {\n          reject(e);\n        }\n      }, 0);\n    } else if (this.status === REJECTED) {\n      setTimeout(() => {\n        try {\n          const x = onRejected(this.reason);\n          resolve(x);\n        } catch (e) {\n          reject(e);\n        }\n      }, 0);\n    } else if (this.status === PENDING) {\n      // 订阅\n      this.onFulfilledCallbacks.push(() => {\n        setTimeout(() => {\n          try {\n            const x = onFulfilled(this.value);\n            resolve(x);\n          } catch (e) {\n            reject(e);\n          }\n        }, 0);\n      });\n\n      this.onRejectedCallbacks.push(() => {\n        setTimeout(() => {\n          try {\n            const x = onRejected(this.reason);\n            resolve(x);\n          } catch (e) {\n            reject(e);\n          }\n        }, 0);\n      });\n    }\n  });\n\n  return promise2;\n};\n\n\n// 测试\nconst promise = new myPromise((resolve, reject) => {\n  setTimeout(() => {\n    resolve('success');\n  }, 1000);\n\n});\n\npromise.then(value => {\n  console.log(value);\n  return 'msg from then1';\n}).then(value => {\n  console.log(value);\n  return 'msg from then2';\n}).then(value => {\n  console.log(value);\n});\n"})}),"\n",(0,r.jsxs)(n.h2,{id:"实现链式调用",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实现链式调用",children:"#"}),"实现链式调用"]}),"\n",(0,r.jsxs)(n.h3,{id:"例题",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#例题",children:"#"}),"例题"]}),"\n",(0,r.jsx)(n.p,{children:"限制用 JavaScript 实现："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'Student("Alice"); // 输出 I am Alice\n\nStudent("Alice").rest(10).learn("computer");\n/* 输出\nI am Alice\n经过10秒后\nAfter 10 seconds\nLearning computer\n*/\n\nStudent("Alice").restFirst(5).learn("Math");\n/* 输出\nI am Alice\n经过5秒后\nAfter 5 seconds\nLearning Math\n*/\n'})}),"\n",(0,r.jsxs)(n.h3,{id:"代码",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#代码",children:"#"}),"代码"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'class Student {\n    constructor(name) {\n        this.name = name;\n        this.tasks = []; // 任务队列\n        this.tasks.push(() => {\n            console.log(`I am ${this.name}`);\n            this.next(); // 执行下一个任务\n        });\n        setTimeout(() => this.next(), 0); // 异步启动任务队列\n    }\n\n    next() {\n        const task = this.tasks.shift(); // 取出队列中的第一个任务\n        task && task(); // 如果任务存在，则执行\n    }\n\n    rest(seconds) {\n        this.tasks.push(() => {\n            setTimeout(() => {\n                console.log(`After ${seconds} seconds`);\n                this.next(); // 执行下一个任务\n            }, seconds * 1000);\n        });\n        return this; // 返回this以支持链式调用\n    }\n\n    restFirst(seconds) {\n        this.tasks.unshift(() => {\n            setTimeout(() => {\n                console.log(`After ${seconds} seconds`);\n                this.next(); // 执行下一个任务\n            }, seconds * 1000);\n        });\n        return this; // 返回this以支持链式调用\n    }\n\n    learn(subject) {\n        this.tasks.push(() => {\n            console.log(`Learning ${subject}`);\n            this.next(); // 执行下一个任务\n        });\n        return this; // 返回this以支持链式调用\n    }\n}\n\n// 测试用例\nnew Student("Alice"); // 输出 I am Alice\n\nnew Student("Alice").rest(10).learn("computer");\n/* 输出\nI am Alice\n经过10秒后\nAfter 10 seconds\nLearning computer\n*/\n\nnew Student("Alice").restFirst(5).learn("Math");\n/* 输出\nI am Alice\n经过5秒后\nAfter 5 seconds\nLearning Math\n*/\n'})}),"\n",(0,r.jsxs)(n.h2,{id:"发布订阅模式-vs-观察者模式",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#发布订阅模式-vs-观察者模式",children:"#"}),"发布订阅模式 vs 观察者模式"]}),"\n",(0,r.jsx)(n.p,{children:"发布-订阅模式（Pub-Sub）和观察者模式（Observer）是两种常见的设计模式，它们都用于处理对象之间的通信和事件处理。"}),"\n",(0,r.jsxs)(n.h3,{id:"观察者模式observer-pattern",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#观察者模式observer-pattern",children:"#"}),(0,r.jsx)(n.strong,{children:"观察者模式（Observer Pattern）"})]}),"\n",(0,r.jsxs)(n.p,{children:["观察者模式定义了一种一对多的依赖关系，当一个对象（称为",(0,r.jsx)(n.strong,{children:"Subject"}),"，主题）的状态发生变化时，所有依赖于它的对象（称为",(0,r.jsx)(n.strong,{children:"Observers"}),"，观察者）都会收到通知并自动更新。"]}),"\n",(0,r.jsx)(n.p,{children:"Subject"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"维护一个观察者列表。"}),"\n",(0,r.jsxs)(n.li,{children:["提供注册（",(0,r.jsx)(n.code,{children:"attach"}),"）和注销（",(0,r.jsx)(n.code,{children:"detach"}),"）观察者的方法。"]}),"\n",(0,r.jsxs)(n.li,{children:["在状态变化时通知所有观察者（",(0,r.jsx)(n.code,{children:"notify"}),"）。"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Observer（观察者）"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["定义一个更新接口（",(0,r.jsx)(n.code,{children:"update"}),"），用于接收主题的通知。"]}),"\n"]}),"\n",(0,r.jsxs)(n.h4,{id:"代码示例-2",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#代码示例-2",children:"#"}),"代码示例"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"class Subject {\n    constructor() {\n        this.observers = [];\n    }\n\n    attach(observer) {\n        this.observers.push(observer);\n    }\n\n    detach(observer) {\n        this.observers = this.observers.filter(obs => obs !== observer);\n    }\n\n    notify() {\n        this.observers.forEach(observer => observer.update());\n    }\n}\n\nclass Observer {\n    constructor(name) {\n        this.name = name;\n    }\n\n    update() {\n        console.log(`${this.name} received an update!`);\n    }\n}\n\n// 使用\nconst subject = new Subject();\nconst observer1 = new Observer('Observer 1');\nconst observer2 = new Observer('Observer 2');\n\nsubject.attach(observer1);\nsubject.attach(observer2);\n\nsubject.notify(); // Observer 1 received an update! Observer 2 received an update!\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"发布-订阅模式pub-sub-pattern",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#发布-订阅模式pub-sub-pattern",children:"#"}),(0,r.jsx)(n.strong,{children:"发布-订阅模式（Pub-Sub Pattern）"})]}),"\n",(0,r.jsxs)(n.p,{children:["发布-订阅模式通过一个",(0,r.jsx)(n.strong,{children:"事件中心"}),"（Event Bus）来解耦发布者和订阅者。发布者将消息发布到事件中心，订阅者从事件中心订阅感兴趣的消息。发布者和订阅者之间没有直接的依赖关系。"]}),"\n",(0,r.jsxs)(n.h4,{id:"关键角色",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#关键角色",children:"#"}),"关键角色"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Publisher（发布者）"}),"： 负责发布消息到事件中心。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Subscriber（订阅者）"}),"： 向事件中心订阅感兴趣的消息。"]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.strong,{children:"Event Bus（事件中心）"}),"：维护一个消息队列和订阅者列表；负责将消息分发给订阅者。"]}),"\n",(0,r.jsxs)(n.h4,{id:"代码示例-3",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#代码示例-3",children:"#"}),"代码示例"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"class EventBus {\n  constructor() {\n    this.events = {};\n  }\n\n  subscribe(event, callback) {\n    if (!this.events[event]) {\n      this.events[event] = [];  // 初始化事件队列\n    }\n    this.events[event].push(callback);\n  }\n\n  publish(event, data) {\n    // 边界检查\n    if (!this.events[event]) {\n      return;\n    }\n    if (this.events[event]) {\n      this.events[event].forEach(callback => callback(data));\n    }\n  }\n}\n\n// 使用\nconst eventBus = new EventBus();\n\n// 订阅者\neventBus.subscribe('news', data => {\n  console.log(`Subscriber 1 received news: ${data}`);\n});\n\neventBus.subscribe('news', data => {\n  console.log(`Subscriber 2 received news: ${data}`);\n});\n\n// 发布者\neventBus.publish('news', 'Breaking news!');\n// 输出：\n// Subscriber 1 received news: Breaking news!\n// Subscriber 2 received news: Breaking news!\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"主要区别",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#主要区别",children:"#"}),"主要区别"]}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{align:"center",children:"特性"}),(0,r.jsx)(n.th,{align:"center",children:"观察者模式"}),(0,r.jsx)(n.th,{align:"center",children:"发布-订阅模式"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{align:"center",children:(0,r.jsx)(n.strong,{children:"通信方式"})}),(0,r.jsx)(n.td,{align:"center",children:"直接通信（主题直接通知观察者）"}),(0,r.jsx)(n.td,{align:"center",children:"间接通信（通过事件中心）"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{align:"center",children:(0,r.jsx)(n.strong,{children:"耦合度"})}),(0,r.jsx)(n.td,{align:"center",children:"强耦合（观察者和主题直接关联）"}),(0,r.jsx)(n.td,{align:"center",children:"松耦合（发布者和订阅者解耦）"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{align:"center",children:(0,r.jsx)(n.strong,{children:"角色"})}),(0,r.jsx)(n.td,{align:"center",children:"主题（Subject）和观察者（Observer）"}),(0,r.jsx)(n.td,{align:"center",children:"发布者（Publisher）、订阅者（Subscriber）、事件中心（Event Bus）"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{align:"center",children:(0,r.jsx)(n.strong,{children:"适用场景"})}),(0,r.jsx)(n.td,{align:"center",children:"简单的对象间通信"}),(0,r.jsx)(n.td,{align:"center",children:"复杂的系统，需要解耦的场景"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{align:"center",children:(0,r.jsx)(n.strong,{children:"实现复杂度"})}),(0,r.jsx)(n.td,{align:"center",children:"简单"}),(0,r.jsx)(n.td,{align:"center",children:"相对复杂"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{align:"center",children:(0,r.jsx)(n.strong,{children:"同步/异步"})}),(0,r.jsx)(n.td,{align:"center",children:"通常是同步的"}),(0,r.jsx)(n.td,{align:"center",children:"可以是异步的"})]})]})]}),"\n",(0,r.jsxs)(n.h4,{id:"应用",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#应用",children:"#"}),"应用"]}),"\n",(0,r.jsxs)(n.h5,{id:"观察者模式",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#观察者模式",children:"#"}),"观察者模式"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"GUI 框架中的事件处理（如按钮点击事件）。"}),"\n",(0,r.jsx)(n.li,{children:"数据模型和视图之间的绑定（如 MVC 模式）。"}),"\n",(0,r.jsx)(n.li,{children:"简单的对象间通信场景。"}),"\n"]}),"\n",(0,r.jsxs)(n.h5,{id:"发布-订阅模式",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#发布-订阅模式",children:"#"}),"发布-订阅模式"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"消息队列系统（如 RabbitMQ、Kafka）。"}),"\n",(0,r.jsx)(n.li,{children:"事件驱动架构（如 Node.js 的 EventEmitter）。"}),"\n",(0,r.jsx)(n.li,{children:"需要解耦的复杂系统（如微服务之间的通信）。"}),"\n"]})]})}function c(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,i.ah)(),e.components);return n?(0,r.jsx)(n,Object.assign({},e,{children:(0,r.jsx)(l,e)})):l(e)}let d=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["posts%2Ffront_end%2Fmethod_chaining.md"]={toc:[{id:"vue-从-createapp-开始的链式调用",text:"Vue :从 createApp 开始的链式调用",depth:2},{id:"代码示例",text:"代码示例",depth:3},{id:"解释",text:"解释",depth:3},{id:"use-方法",text:"use 方法",depth:3},{id:"语法",text:"语法",depth:4},{id:"实现-use",text:"实现 use",depth:4},{id:"promise-中的链式调用",text:"Promise 中的链式调用",depth:2},{id:"手写-promise-方法",text:"手写 Promise 方法",depth:3},{id:"promise-a规范",text:"Promise A+规范",depth:4},{id:"代码示例-1",text:"代码示例",depth:4},{id:"实现链式调用",text:"实现链式调用",depth:2},{id:"例题",text:"例题",depth:3},{id:"代码",text:"代码",depth:3},{id:"发布订阅模式-vs-观察者模式",text:"发布订阅模式 vs 观察者模式",depth:2},{id:"观察者模式observer-pattern",text:"**观察者模式（Observer Pattern）**",depth:3},{id:"代码示例-2",text:"代码示例",depth:4},{id:"发布-订阅模式pub-sub-pattern",text:"**发布-订阅模式（Pub-Sub Pattern）**",depth:3},{id:"关键角色",text:"关键角色",depth:4},{id:"代码示例-3",text:"代码示例",depth:4},{id:"主要区别",text:"主要区别",depth:3},{id:"应用",text:"应用",depth:4}],title:"JavaScript 链式调用 | 设计模式 笔记",headingTitle:"",frontmatter:{title:"JavaScript 链式调用 | 设计模式 笔记",subtitle:"",date:"2025-03-17T01:26:02.000Z",lastmod:"2025-03-17T01:26:02.000Z",draft:!1,authors:null,description:null,tags:["前端","链式调用","JavaScript"],categories:["在前端搬砖的日子里"],series:["前端八股文基础"],hiddenFromHomePage:!1,hiddenFromSearch:!1,featuredImage:"https://img.dodolalorc.cn/i/2025/03/03/67c55994138f8.jpg",featuredImagePreview:"https://img.dodolalorc.cn/i/2025/03/03/67c55994138f8.jpg",toc:{enable:!0},math:{enable:!0},lightgallery:!1,license:""}}},5523:function(e,n,s){s.d(n,{Z:()=>d});var r=s(2676),i=s(5271),t=s(2815);s(7995);let l={"zh-CN":e=>`\u{9884}\u{8BA1}\u{9605}\u{8BFB}\u{65F6}\u{95F4}: ${e.minutes>=1?`${Math.ceil(e.minutes)} \u{5206}\u{949F}`:"小于 1 分钟"}`,"en-US":e=>`Estimated reading time: ${e.minutes>=1?`${Math.ceil(e.minutes)} minutes`:"less than 1 minute"}`};function c(e,n,s){let r=Object.keys(l).includes(n)?n:s;return l[r](e)}let d=e=>{let{defaultLocale:n="en-US"}=e,s=(0,t.Vi)().page.readingTimeData,l=(0,t.Jr)(),d=(0,t.e7)(),[h,a]=(0,i.useState)(c(s,l,n));return(0,i.useEffect)(()=>{a(c(s,l,n))},[l,s]),(0,r.jsx)("span",{"data-dark":String(d),className:"rp-reading-time",children:h})}}}]);