"use strict";(self.webpackChunkblogsite_rspress=self.webpackChunkblogsite_rspress||[]).push([["31"],{4240:function(e,n,d){d.r(n),d.d(n,{default:()=>c});var r=d(2676),s=d(453),i=d(5523);function t(e){let n=Object.assign({blockquote:"blockquote",p:"p",h2:"h2",a:"a",code:"code",h3:"h3",pre:"pre"},(0,s.ah)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"一篇学习 MutationObserver 的文章"}),"\n"]}),"\n",(0,r.jsxs)(n.h2,{id:"背景",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#背景",children:"#"}),"背景"]}),"\n",(0,r.jsx)(i.Z,{defaultLocale:"zh-CN"}),"\n",(0,r.jsx)(n.p,{children:"今天调整新主题的时候，在重新设计友链样式的时候想保留原本的随机背景颜色，之前数量少的时候似乎不太明显，现在本地测试发觉加载太慢了。于是上网寻找解决思路，找到了 MutationObserver 这个 API，于是就学习了一下//此处记录一下学习过程。"}),"\n",(0,r.jsxs)(n.h2,{id:"需求分析",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#需求分析",children:"#"}),"需求分析"]}),"\n",(0,r.jsxs)(n.p,{children:["我有不知数量的div元素，每个div元素都有一个class名为",(0,r.jsx)(n.code,{children:"friend-link-div"}),"，我需要在每个单个的div元素被加载完成的同时，对它设置一个随机的背景颜色。而不是等待整个页面或窗口加载完毕"]}),"\n",(0,r.jsxs)(n.h2,{id:"想法分析",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#想法分析",children:"#"}),"想法分析"]}),"\n",(0,r.jsxs)(n.h3,{id:"windowonload和domcontentloaded的问题",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#windowonload和domcontentloaded的问题",children:"#"}),(0,r.jsx)(n.code,{children:"window.onload"}),"和",(0,r.jsx)(n.code,{children:"'DOMContentLoaded'"}),"的问题"]}),"\n",(0,r.jsx)(n.p,{children:"原本的实现代码："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:'  window.onload=function () {\n    const randomHex = () => `rgba(${Math.round(Math.random()*255)}, ${Math.round(Math.random()*255)}, ${Math.round(Math.random()*255)}, 0.5)`;\n    var friendArr=document.getElementsByClassName("friend-div"),temp=[];\n    for(var i=0;i<friendArr.length;i++){\n        friendArr[i].style.background=randomHex();\n    }\n  }\n'})}),"\n",(0,r.jsx)(n.p,{children:"原本的思路就是简单的在页面加载完成后，获取所有的友链元素，然后给每个元素设置一个随机的背景颜色。但是这样的实现方式有一个问题，就是当友链数量较多的时候，会导致页面加载变慢，因为每次都要重新计算随机颜色，并且在等待本页面加载的时候，友链的背景颜色是白色的，这样会导致页面的视觉体验不好。"}),"\n",(0,r.jsxs)(n.p,{children:["在网上询问得到的另一个思路是用",(0,r.jsx)(n.code,{children:"document.addEventListener('DOMContentLoaded', function() {})"}),"，但是这个方法也是等待整个页面加载完毕后才会执行，观察发现还是挺慢的...所以也不适合。"]}),"\n",(0,r.jsxs)(n.h3,{id:"仅利用css实现随机色彩的思路",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#仅利用css实现随机色彩的思路",children:"#"}),"仅利用CSS实现随机色彩的思路"]}),"\n",(0,r.jsxs)(n.p,{children:["还有一个仅利用CSS实现随机色彩的思路，该思路是在CSS中定义一个颜色数组，然后通过",(0,r.jsx)(n.code,{children:"nth-child"}),"选择器来实现，但是这样的实现方式有一个问题，就是颜色的数量是固定的，而且颜色的选择是有规律的，不是真正的随机颜色。"]}),"\n",(0,r.jsx)(n.p,{children:"不过还是展示一下如何伪随机实现："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-css",children:"  .friend-link-div:nth-child(1) {\n    background: #f00;\n  }\n  .friend-link-div:nth-child(2) {\n    background: #0f0;\n  }\n  .friend-link-div:nth-child(3) {\n    background: #00f;\n  }\n  .friend-link-div:nth-child(4) {\n    background: #ff0;\n  }\n  ...\n"})}),"\n",(0,r.jsx)(n.p,{children:"搭配scss的话可以这样写："}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-scss",children:"  $colors: #f00, #0f0, #00f, #ff0, #f0f, #0ff, #000, #fff;\n  @for $i from 1 through length($colors) {\n    .friend-link-div:nth-child(#{$i}) {\n      background: nth($colors, $i);\n    }\n  }\n"})}),"\n",(0,r.jsxs)(n.p,{children:["于是放弃",(0,r.jsx)(n.code,{children:"window.onload"}),"和",(0,r.jsx)(n.code,{children:"'DOMContentLoaded'"}),"，以及CSS的伪随机实现方法。改用 ",(0,r.jsx)(n.code,{children:"MutationObserver"})," 来实现。"]}),"\n",(0,r.jsxs)(n.h2,{id:"解决思路",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#解决思路",children:"#"}),"解决思路"]}),"\n",(0,r.jsxs)(n.p,{children:["使用",(0,r.jsx)(n.code,{children:"MutationObserver API"}),"来观察DOM的变化，并在新的盒子被添加到DOM中时应用背景色更改。这样，每当有新的盒子被添加到页面上时，你就可以立即更改它的背景，而不需要等待其他内容加载完成。"]}),"\n",(0,r.jsxs)(n.h3,{id:"代码",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#代码",children:"#"}),"代码"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-js",children:"\n  // 定义一个生成随机背景色的函数\n  const randomHex = () => `rgba(${Math.round(Math.random() * 255)}, ${Math.round(Math.random() * 255)}, ${Math.round(Math.random() * 255)}, 0.5)`;\n\n  // 遍历所有已经存在的盒子，为每个盒子设置随机背景色\n  document.querySelectorAll('.friend-link-div').forEach(div => {\n    div.style.background = randomHex();\n  });\n\n  // 定义一个回调函数，用于处理每当DOM树中添加新节点时的操作\n  const callback = function (mutationsList, observer) {\n    for (const mutation of mutationsList) {\n      if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {\n        mutation.addedNodes.forEach(node => {\n          // 检查是否为目标盒子节点\n          if (node.nodeType === 1 && node.classList.contains('friend-link-div')) {\n            // 更改背景色\n            node.style.background = randomHex();\n          }\n        });\n      }\n    }\n  };\n\n  // 创建MutationObserver实例\n  const observer = new MutationObserver(callback);\n\n  // 配置观察选项：观察子节点的添加\n  const config = { childList: true, subtree: true };\n\n  // 选择要观察变化的DOM节点（在这个例子中，是body，但你可以根据需要更改）\n  const targetNode = document.body;\n\n  // 启动观察\n  observer.observe(targetNode, config);\n"})}),"\n",(0,r.jsxs)(n.h3,{id:"关于用于hugo主题的一些tips",children:[(0,r.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#关于用于hugo主题的一些tips",children:"#"}),"关于用于hugo主题的一些Tips"]}),"\n",(0,r.jsxs)(n.p,{children:["有的时候DOM初始化时已经存在一些盒子，因此我们需要在初始化时为这些盒子设置随机背景色。然后，我们创建一个",(0,r.jsx)(n.code,{children:"MutationObserver"}),"实例，并配置它以观察DOM树中的子节点添加。最后，我们选择要观察变化的DOM节点（在这个例子中是",(0,r.jsx)(n.code,{children:"body"}),"，但你可以根据需要更改），并启动观察。"]}),"\n",(0,r.jsxs)(n.p,{children:["假如直接将js插入到",(0,r.jsx)(n.code,{children:"friend.html"}),"中，打开控制台会发现该段js被渲染了好多次，这是因为hugo的模板渲染机制导致的，所以我们需要将js放在整个大页面的js中，这样就不会出现重复渲染的问题了。"]}),"\n",(0,r.jsxs)(n.p,{children:["一个合适的地方是在",(0,r.jsx)(n.code,{children:"layouts/partials/footer.html"}),"中，这样就可以保证在整个页面加载完毯后再执行这段js。"]}),"\n",(0,r.jsxs)(n.p,{children:["不过直接放在",(0,r.jsx)(n.code,{children:"footer.html"}),"中也会有一个问题，就是我们只需要在友链页面加载这段js，而不是每个页面都加载，所以我们可以在",(0,r.jsx)(n.code,{children:"footer.html"}),"中加入一个判断条件，判断当前页面是否是友链页面，如果是则加载这段js。"]}),"\n",(0,r.jsxs)(n.p,{children:["可以在",(0,r.jsx)(n.code,{children:"content/links.md"}),"中加入一个",(0,r.jsx)(n.code,{children:"isLink"}),"字段，然后在",(0,r.jsx)(n.code,{children:"footer.html"}),"中判断是否为友链页面，如果是则加载这段js。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-html",children:"  {{ if .Params.isLink }}\n    <script>\n      // 代码\n    <\/script>\n  {{ end }}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["假如不想每次都把新增的js直接写在",(0,r.jsx)(n.code,{children:"footer.html"}),"等地方中，可以在",(0,r.jsx)(n.code,{children:"static/js/"}),"文件夹下新建一个js文件，然后在",(0,r.jsx)(n.code,{children:"footer.html"}),"中引入这个js文件。"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-html",children:'  {{ if .Params.isLink }}\n    <script src="/js/_extended/friend-link.js"><\/script>\n  {{ end }}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["另注：githubPage是jekyll模板似乎不能识别下划线开头的文件，所以有需要的话可以把",(0,r.jsx)(n.code,{children:"_extended"}),"改成其他名字。"]}),"\n",(0,r.jsxs)(n.p,{children:["完成！现在，每当新的",(0,r.jsx)(n.code,{children:"friend-link-div"}),"盒子被添加到DOM中时，它的背景颜色将立即更改为随机颜色。\n可以在本站的友链页面查看效果：",(0,r.jsx)(n.a,{href:"/links/index.html",children:"友链"})]})]})}function a(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,s.ah)(),e.components);return n?(0,r.jsx)(n,Object.assign({},e,{children:(0,r.jsx)(t,e)})):t(e)}let c=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["posts%2Ffront_end%2FmutationObserver.md"]={toc:[{id:"背景",text:"背景",depth:2},{id:"需求分析",text:"需求分析",depth:2},{id:"想法分析",text:"想法分析",depth:2},{id:"windowonload和domcontentloaded的问题",text:"`window.onload`和`'DOMContentLoaded'`的问题",depth:3},{id:"仅利用css实现随机色彩的思路",text:"仅利用CSS实现随机色彩的思路",depth:3},{id:"解决思路",text:"解决思路",depth:2},{id:"代码",text:"代码",depth:3},{id:"关于用于hugo主题的一些tips",text:"关于用于hugo主题的一些Tips",depth:3}],title:"MutationObserver学习+实践",headingTitle:"",frontmatter:{title:"MutationObserver学习+实践",subtitle:"",date:"2024-07-04T08:31:24.000Z",lastmod:"2024-07-04T08:31:24.000Z",draft:!1,authors:[],description:"",tags:["前端","JavaScript"],categories:["在前端搬砖的日子里","关于Hugo的一些设置"],series:[],hiddenFromHomePage:!1,hiddenFromSearch:!1,featuredImage:"",featuredImagePreview:"",toc:{enable:!0},math:{enable:!1},lightgallery:!1,license:""}}},5523:function(e,n,d){d.d(n,{Z:()=>c});var r=d(2676),s=d(5271),i=d(2815);d(7995);let t={"zh-CN":e=>`\u{9884}\u{8BA1}\u{9605}\u{8BFB}\u{65F6}\u{95F4}: ${e.minutes>=1?`${Math.ceil(e.minutes)} \u{5206}\u{949F}`:"小于 1 分钟"}`,"en-US":e=>`Estimated reading time: ${e.minutes>=1?`${Math.ceil(e.minutes)} minutes`:"less than 1 minute"}`};function a(e,n,d){let r=Object.keys(t).includes(n)?n:d;return t[r](e)}let c=e=>{let{defaultLocale:n="en-US"}=e,d=(0,i.Vi)().page.readingTimeData,t=(0,i.Jr)(),c=(0,i.e7)(),[o,h]=(0,s.useState)(a(d,t,n));return(0,s.useEffect)(()=>{h(a(d,t,n))},[t,d]),(0,r.jsx)("span",{"data-dark":String(c),className:"rp-reading-time",children:o})}}}]);