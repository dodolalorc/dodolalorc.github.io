"use strict";(self.webpackChunkblogsite_rspress=self.webpackChunkblogsite_rspress||[]).push([["3988"],{2695:function(n,e,r){r.r(e),r.d(e,{default:()=>d});var s=r(2676),i=r(453),t=r(3208);function l(n){let e=Object.assign({h3:"h3",a:"a",p:"p",strong:"strong",ul:"ul",li:"li",code:"code",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td",pre:"pre",h4:"h4"},(0,i.ah)(),n.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(e.h3,{id:"vue2-和-vue3-区别",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#vue2-和-vue3-区别",children:"#"}),"Vue2 和 Vue3 区别"]}),"\n",(0,s.jsx)(t.Z,{defaultLocale:"zh-CN"}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"性能优化"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Vue 3"}),"：通过重写虚拟 DOM 和优化编译器，性能显著提升，渲染速度更快，内存占用更少。"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Vue 2"}),"：性能较好，但不如 Vue 3。"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Composition API"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Vue 3"}),"：引入了 Composition API，允许开发者按逻辑组织代码，提升复杂组件的可维护性。"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Vue 2"}),"：主要使用 Options API，代码组织方式相对固定。"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"响应式系统"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Vue 3"}),"：使用 ",(0,s.jsx)(e.code,{children:"Proxy"})," 实现响应式系统，支持更多数据类型，性能更好。"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Vue 2"}),"：使用 ",(0,s.jsx)(e.code,{children:"Object.defineProperty"}),"，存在一些局限性，如无法检测数组和对象的变化。"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"TypeScript 支持"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Vue 3"}),"：内置 TypeScript 支持，类型推断更完善。"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Vue 2"}),"：对 TypeScript 的支持较弱，类型推断不够完善。"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Fragment 和 Teleport"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Vue 3"}),"：支持 Fragment（多根节点组件）和 Teleport（将组件渲染到 DOM 其他位置）。"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Vue 2"}),"：不支持这些特性。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"全局 API 更改"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Vue 3"}),"：全局 API 改为按需导入，减少打包体积。"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Vue 2"}),"：全局 API 通过 ",(0,s.jsx)(e.code,{children:"Vue"})," 对象访问。"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"生命周期钩子"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Vue 3"}),"：部分生命周期钩子更名（如 ",(0,s.jsx)(e.code,{children:"beforeDestroy"})," 改为 ",(0,s.jsx)(e.code,{children:"beforeUnmount"}),"），并新增了 ",(0,s.jsx)(e.code,{children:"setup"})," 函数。"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Vue 2"}),"：使用传统的生命周期钩子。"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"自定义渲染器"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Vue 3"}),"：支持自定义渲染器，适用于非 DOM 环境（如小程序、Canvas）。"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Vue 2"}),"：不支持自定义渲染器。"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Suspense"})}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Vue 3"}),"：支持 Suspense，用于处理异步组件加载。"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Vue 2"}),"：不支持 Suspense。"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"打包体积"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Vue 3"}),"：通过 Tree-shaking 优化，打包体积更小。"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Vue 2"}),"：打包体积相对较大。"]}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:"Vue 3 在性能、开发体验和灵活性上都有显著提升，尤其是 Composition API 和响应式系统的改进。对于新项目，推荐使用 Vue 3；对于现有 Vue 2 项目，可以根据需求逐步迁移。"}),"\n",(0,s.jsxs)(e.h3,{id:"javascript-和-typescript",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#javascript-和-typescript",children:"#"}),"JavaScript 和 TypeScript"]}),"\n",(0,s.jsx)(e.p,{children:"TypeScript 和 JavaScript 是两种常用的编程语言，它们的主要区别和优点如下："}),"\n",(0,s.jsxs)(e.table,{children:[(0,s.jsx)(e.thead,{children:(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.th,{align:"left",children:"对比项"}),(0,s.jsx)(e.th,{align:"left",children:"JavaScript"}),(0,s.jsx)(e.th,{align:"left",children:"TypeScript"})]})}),(0,s.jsxs)(e.tbody,{children:[(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{align:"left",children:(0,s.jsx)(e.strong,{children:"类型系统"})}),(0,s.jsxs)(e.td,{align:"left",children:["动态类型语言，变量在",(0,s.jsx)(e.strong,{children:"运行"}),"时确定"]}),(0,s.jsxs)(e.td,{align:"left",children:["静态类型语言，支持类型注解，类型检查在",(0,s.jsx)(e.strong,{children:"编译"}),"时进行。"]})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{align:"left",children:(0,s.jsx)(e.strong,{children:"编译"})}),(0,s.jsx)(e.td,{align:"left",children:"直接由浏览器或 Node.js 执行，无需编译。"}),(0,s.jsx)(e.td,{align:"left",children:"需要编译为 JavaScript 后才能运行。"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{align:"left",children:(0,s.jsx)(e.strong,{children:"工具支持"})}),(0,s.jsx)(e.td,{align:"left",children:"工具支持较少，尤其在大型项目中。"}),(0,s.jsx)(e.td,{align:"left",children:"提供更好的开发工具支持，如代码补全、类型检查、重构等。"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{align:"left",children:"兼容性"}),(0,s.jsx)(e.td,{align:"left",children:"所有 JavaScript 代码都可在 TypeScript 中运行。"}),(0,s.jsx)(e.td,{align:"left",children:"编译后的代码与 JavaScript 完全兼容。"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{align:"left",children:(0,s.jsx)(e.strong,{children:"学习曲线"})}),(0,s.jsx)(e.td,{align:"left",children:"学习曲线较平缓，适合初学者。"}),(0,s.jsx)(e.td,{align:"left",children:"需要掌握类型系统等额外概念，学习曲线稍陡。"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{align:"left",children:(0,s.jsx)(e.strong,{children:"社区生态"})}),(0,s.jsx)(e.td,{align:"left",children:"社区庞大，资源丰富。"}),(0,s.jsx)(e.td,{align:"left",children:"社区增长迅速，尤其在大型项目中应用广泛。"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{align:"left",children:(0,s.jsx)(e.strong,{children:"适用场景"})}),(0,s.jsx)(e.td,{align:"left",children:"适合小型项目或快速原型开发。"}),(0,s.jsx)(e.td,{align:"left",children:"适合大型项目，尤其是需要长期维护的复杂应用。"})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{align:"left",children:(0,s.jsx)(e.strong,{children:"优点"})}),(0,s.jsxs)(e.td,{align:"left",children:["无需编译，开发流程简单。","学习门槛低，适合初学者。","社区资源丰富，生态成熟。"]}),(0,s.jsxs)(e.td,{align:"left",children:["静态类型检查减少运行时错误。","更好的工具支持提升开发效率。","增强代码可读性和可维护性。","支持最新的 JavaScript 特性。"]})]}),(0,s.jsxs)(e.tr,{children:[(0,s.jsx)(e.td,{align:"left",children:(0,s.jsx)(e.strong,{children:"总结"})}),(0,s.jsx)(e.td,{align:"left",children:"适合大型项目，提供更强的类型检查和工具支持。"}),(0,s.jsx)(e.td,{align:"left",children:"适合小型项目或快速开发，学习成本低。"})]})]})]}),"\n",(0,s.jsxs)(e.h3,{id:"代码千分位逗号",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#代码千分位逗号",children:"#"}),"代码：千分位逗号"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"let num = 1234567.89; \xa0\nlet formattedNum = num.toLocaleString('en-US'); \xa0\nconsole.log(formattedNum); \xa0// 输出 \"1,234,567.89\"\n"})}),"\n",(0,s.jsxs)(e.h3,{id:"代码手写深浅拷贝",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#代码手写深浅拷贝",children:"#"}),"代码：手写深浅拷贝"]}),"\n",(0,s.jsxs)(e.p,{children:["浅拷贝只会复制对象的顶层属性和值，如果属性值是",(0,s.jsx)(e.strong,{children:"对象"}),"或",(0,s.jsx)(e.strong,{children:"数组"}),"，那么它实际上只是",(0,s.jsx)(e.strong,{children:"复制了引用"}),"，而不是真正的对象。"]}),"\n",(0,s.jsx)(e.p,{children:"而深拷贝则会递归地复制对象的所有层级，确保所有的对象或数组都被真正复制，而不是仅复制引用。"}),"\n",(0,s.jsxs)(e.h4,{id:"浅拷贝",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#浅拷贝",children:"#"}),"浅拷贝"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function shallowCopy(obj) {\n    if (typeof obj !== 'object' || obj === null) {\n        return obj;\n    }\n    return Object.assign({}, obj);  // Object浅拷贝\n}\n\nconst original = { a: 1, b: { c: 2 } };\nconst copied = shallowCopy(original);\nconsole.log(copied);\n"})}),"\n",(0,s.jsxs)(e.h4,{id:"深拷贝",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#深拷贝",children:"#"}),"深拷贝"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-javascript",children:"function deepCopy(obj, hash = new WeakMap()) {\n	// 使用了`WeakMap`来存储已经复制过的对象\n    if (typeof obj !== 'object' || obj === null) {\n        return obj;\n    }\n\n    // 日期\n    if (obj instanceof Date) {\n        return new Date(obj);\n    }\n    // 正则\n    if (obj instanceof RegExp) {\n        return new RegExp(obj);\n    }\n\n    let newObj = Array.isArray(obj) ? [] : {};\n    hash.set(obj, newObj);\n\n    for (let key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            newObj[key] = deepCopy(obj[key], hash); // 递归进行拷贝\n        }\n    }\n\n    return newObj;\n}\n"})}),"\n",(0,s.jsxs)(e.h3,{id:"代码手写-new-方法",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#代码手写-new-方法",children:"#"}),"代码：手写 New 方法"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"function myNew(constructor, ...args) {\n    const obj = {};\n    obj.__proto__ = constructor.prototype;\n    const result = constructor.apply(obj, args);\n    // 如果构造函数返回一个对象，则返回，否则返回新创建的对象\n    return result instanceof Object ? result : obj;\n}\n\nfunction Person(name, age) {\n    this.name = name;\n    this.age = age;\n}\n\nPerson.prototype.greet = function () {\n    console.log(`Hello, I'm ${this.name} and I'm ${this.age} years old.`);\n}\n\nconst person = myNew(Person, 'Alice', 12);\nconsole.log(person.name);\nconsole.log(person.age);\nperson.greet();\n"})}),"\n",(0,s.jsxs)(e.h3,{id:"代码手写函数柯里化",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#代码手写函数柯里化",children:"#"}),"代码：手写函数柯里化"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"function curry(fn) {\n    if (typeof fn !== 'function') {\n        return new Error('Type Error');\n    }\n    return function curried(...args) {\n        if (args.length >= fn.length) {    // 如果参数数量足够，则执行\n            return fn.apply(this, args);\n        }\n        return function (...args2) {\n            return curried.apply(this, args.concat(args2));\n        }\n    }\n}\n\nfunction sum(a, b, c) {\n    return a + b + c;\n}\n\nconst curriedSum = curry(sum);\n\nconsole.log(curriedSum(1)(2)(3));\nconsole.log(curriedSum(1, 2)(3));\n"})}),"\n",(0,s.jsxs)(e.h3,{id:"代码实现-ajax-请求使用-promise-封装-ajax-请求",children:[(0,s.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#代码实现-ajax-请求使用-promise-封装-ajax-请求",children:"#"}),"代码：实现 AJAX 请求，使用 Promise 封装 AJAX 请求"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-js",children:"function ajaxRequest(url, method = 'GET', data = null) {\n    return new Promise((resolve, reject) => {\n        const xhr = new XMLHttpRequest();\n        xhr.open(method, url, true);\n        if (method == 'POST') {\n            xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n        }\n\n        xhr.onload = function () {\n            if (this.status === 200) {\n                resolve(this.responseText);\n            } else {\n                reject(new Error(this.statusText));\n            }\n        };\n\n        xhr.onerror = function () {\n            reject(new Error('Network Error'));\n        }\n\n        if (data) {\n            xhr.send(data);\n        } else {\n            xhr.send();\n        }\n    })\n}\n\najaxRequest(\n    'https://api.example.com/data', 'GET').then(response => {\n        console.log(response);\n    }).catch(error => {\n        console.error('Error:', error);\n    });\n"})})]})}function c(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,i.ah)(),n.components);return e?(0,s.jsx)(e,Object.assign({},n,{children:(0,s.jsx)(l,n)})):l(n)}let d=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["posts%2Ffront_end%2F8part_essay.md"]={toc:[{id:"vue2-和-vue3-区别",text:"Vue2 和 Vue3 区别",depth:3},{id:"javascript-和-typescript",text:"JavaScript 和 TypeScript",depth:3},{id:"代码千分位逗号",text:"代码：千分位逗号",depth:3},{id:"代码手写深浅拷贝",text:"代码：手写深浅拷贝",depth:3},{id:"浅拷贝",text:"浅拷贝",depth:4},{id:"深拷贝",text:"深拷贝",depth:4},{id:"代码手写-new-方法",text:"代码：手写 New 方法",depth:3},{id:"代码手写函数柯里化",text:"代码：手写函数柯里化",depth:3},{id:"代码实现-ajax-请求使用-promise-封装-ajax-请求",text:"代码：实现 AJAX 请求，使用 Promise 封装 AJAX 请求",depth:3}],title:"前端八股文小题集合",headingTitle:"",frontmatter:{title:"前端八股文小题集合",subtitle:"",date:"2025-03-13T06:08:19.000Z",lastmod:"2025-03-13T06:08:19.000Z",draft:!0,authors:null,description:"",tags:null,categories:null,series:null,hiddenFromHomePage:!1,hiddenFromSearch:!1,featuredImage:"",featuredImagePreview:"",toc:{enable:!0},math:{enable:!0},lightgallery:!1,license:""}}},3208:function(n,e,r){r.d(e,{Z:()=>d});var s=r(2676),i=r(5271),t=r(2815);r(2791);let l={"zh-CN":n=>`\u{9884}\u{8BA1}\u{9605}\u{8BFB}\u{65F6}\u{95F4}: ${n.minutes>=1?`${Math.ceil(n.minutes)} \u{5206}\u{949F}`:"小于 1 分钟"}`,"en-US":n=>`Estimated reading time: ${n.minutes>=1?`${Math.ceil(n.minutes)} minutes`:"less than 1 minute"}`};function c(n,e,r){let s=Object.keys(l).includes(e)?e:r;return l[s](n)}let d=n=>{let{defaultLocale:e="en-US"}=n,r=(0,t.Vi)().page.readingTimeData,l=(0,t.Jr)(),d=(0,t.e7)(),[h,a]=(0,i.useState)(c(r,l,e));return(0,i.useEffect)(()=>{a(c(r,l,e))},[l,r]),(0,s.jsx)("span",{"data-dark":String(d),className:"rp-reading-time",children:h})}}}]);