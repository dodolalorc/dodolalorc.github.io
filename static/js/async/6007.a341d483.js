"use strict";(self.webpackChunkblogsite_rspress=self.webpackChunkblogsite_rspress||[]).push([["6007"],{1183:function(e,n,r){r.r(n),r.d(n,{default:()=>d});var s=r(2676),t=r(453),i=r(3208);function l(e){let n=Object.assign({p:"p",h2:"h2",a:"a",h3:"h3",h4:"h4",pre:"pre",code:"code",ol:"ol",li:"li",strong:"strong",ul:"ul",em:"em"},(0,t.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.p,{children:'{{< admonition abstract "问题预设" true>}}'}),"\n",(0,s.jsx)(n.p,{children:"如何解决页面请求接口的大规模并发问题？"}),"\n",(0,s.jsx)(n.p,{children:"{{< /admonition >}}"}),"\n",(0,s.jsx)(n.p,{children:"在需要处理大规模请求的情境中，做好流量控制可以提升系统稳定性和性能。"}),"\n",(0,s.jsxs)(n.h2,{id:"防抖节流",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#防抖节流",children:"#"}),"防抖/节流"]}),"\n",(0,s.jsx)(i.Z,{defaultLocale:"zh-CN"}),"\n",(0,s.jsxs)(n.h3,{id:"防抖debounce",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#防抖debounce",children:"#"}),"防抖（Debounce）"]}),"\n",(0,s.jsx)(n.p,{children:"在事件触发后，延迟执行函数，若在延迟期间再次出发，则重新计时，如在搜索框输入、调整窗口大小时。"}),"\n",(0,s.jsxs)(n.h4,{id:"实现",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实现",children:"#"}),"实现"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function debounce(fn, wait) {\n    let timeout;\n    return function () {\n        let context = this;\n        let args = arguments;\n        clearTimeout(timeout);\n        timeout = setTimeout(function () {\n            fn.apply(context, args);\n        }, wait);\n    }\n}\n\nconst sample = function () {\n    console.log(\"xxx\");\n}\n\nwindow.addEventListener('resize', debounce(sample, 300));\n"})}),"\n",(0,s.jsxs)(n.h4,{id:"为什么在debounce-函数中使用let",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#为什么在debounce-函数中使用let",children:"#"}),"为什么在",(0,s.jsx)(n.code,{children:"debounce"}),"\xa0 函数中使用",(0,s.jsx)(n.code,{children:"let"}),"？"]}),"\n",(0,s.jsxs)(n.p,{children:["在 \xa0",(0,s.jsx)(n.code,{children:"debounce"}),"\xa0 函数中，",(0,s.jsx)(n.code,{children:"timeout"}),"\xa0 变量需要满足以下条件："]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"块级作用域"}),"：",(0,s.jsx)(n.code,{children:"timeout"}),"\xa0 只需要在 \xa0",(0,s.jsx)(n.code,{children:"debounce"}),"\xa0 函数内部有效，不需要泄漏到外部作用域。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"可重新赋值"}),"：每次调用返回的函数时，",(0,s.jsx)(n.code,{children:"timeout"}),"\xa0 需要被重新赋值（通过 \xa0",(0,s.jsx)(n.code,{children:"clearTimeout"}),"\xa0 和 \xa0",(0,s.jsx)(n.code,{children:"setTimeout"}),"）。"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"不需要提升"}),"：",(0,s.jsx)(n.code,{children:"timeout"}),"\xa0 不需要在声明前访问，因此不需要 \xa0",(0,s.jsx)(n.code,{children:"var"}),"\xa0 的提升行为。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"let"}),"\xa0 完美符合这些需求："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"它提供了块级作用域，避免变量泄漏。"}),"\n",(0,s.jsx)(n.li,{children:"它允许重新赋值，适合存储定时器 ID。"}),"\n",(0,s.jsx)(n.li,{children:"它不会提升，避免了潜在的逻辑错误。"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["如果使用 \xa0",(0,s.jsx)(n.code,{children:"var"}),"："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"timeout"}),"\xa0 会泄漏到外部作用域，可能导致意外行为。"]}),"\n",(0,s.jsxs)(n.li,{children:["虽然可以重新赋值，但作用域规则不如 \xa0",(0,s.jsx)(n.code,{children:"let"}),"\xa0 清晰。"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["如果使用 \xa0",(0,s.jsx)(n.code,{children:"const"}),"："]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"timeout"}),"\xa0 不能被重新赋值，无法满足 \xa0",(0,s.jsx)(n.code,{children:"debounce"}),"\xa0 的逻辑需求。"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:'{{< admonition tip "var、let和const" true>}}'}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"作用域区别"}),"：",(0,s.jsx)(n.code,{children:"var"}),"是函数作用域，",(0,s.jsx)(n.code,{children:"let"}),"和",(0,s.jsx)(n.code,{children:"const"}),"是块级作用域。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"变量升级"}),"：",(0,s.jsx)(n.code,{children:"var"}),"可以升级（初始值是",(0,s.jsx)(n.code,{children:"undefined"}),"），",(0,s.jsx)(n.code,{children:"let"}),"和",(0,s.jsx)(n.code,{children:"const"}),"不能变量升级，是暂时性死区。"]}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"变量提升指的是在代码执行前，js 引擎将变量和函数的声明提示到作用域的顶部，也就是说可以在声明之前使用变量或函数，但赋值操作会保留在原位置。"})}),"\n",(0,s.jsx)(n.p,{children:"Example：变量"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"console.log(a); // 输出: undefined\nvar a = 10;\nconsole.log(a); // 输出: 10\n"})}),"\n",(0,s.jsx)(n.p,{children:"实际执行顺序："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"var a;\nconsole.log(a); // 输出: undefined\na = 10;\nconsole.log(a); // 输出: 10\n"})}),"\n",(0,s.jsx)(n.p,{children:"Example：函数"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'foo(); // 输出: "Hello"\nfunction foo() {\n    console.log("Hello");\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"实际执行顺序："}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'function foo() {\n    console.log("Hello");\n}\nfoo(); // 输出: "Hello"\n'})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"重新赋值"}),"：",(0,s.jsx)(n.code,{children:"var"}),"和",(0,s.jsx)(n.code,{children:"let"}),"可以重新赋值，",(0,s.jsx)(n.code,{children:"const"}),"不可以。"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"适用场景"}),"："]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"var"}),"：旧代码、全局变量"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"let"}),"：块级作用域、需要重新赋值"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"const"}),"：常量、不需要重新赋值"]}),"\n",(0,s.jsx)(n.p,{children:"{{< /admonition >}}"}),"\n",(0,s.jsxs)(n.h3,{id:"节流throttle",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#节流throttle",children:"#"}),"节流（Throttle）"]}),"\n",(0,s.jsx)(n.p,{children:"在规定时间内，函数只执行一次，多余触发被忽略，适用于滚动事件、按钮点击等情景。"}),"\n",(0,s.jsxs)(n.h4,{id:"实现-1",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实现-1",children:"#"}),"实现"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function throttle(fn, limit) {\n    let inthrottle;\n    return function () {\n        let context = this;\n        let args = arguments;\n        if (!inthrottle) {\n            fn.apply(context, args);\n            inthrottle = true;\n            setTimeout(() => {\n                inthrottle = false;\n            }, limit);\n        }\n    }\n}\n\nconst sample = function () { };\n\nwindow.addEventListener('scroll', throttle(sample, 2000));\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"注意事项",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#注意事项",children:"#"}),"注意事项"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"这两个函数都返回一个新的函数，这个新函数会包装传入的原始函数，并根据防抖或节流的逻辑来调用它。"}),"\n",(0,s.jsx)(n.li,{children:"防抖和节流的区别在于，防抖是在事件触发后等待一段时间再执行，而节流是确保事件触发后的一段时间内只执行一次。"}),"\n",(0,s.jsx)(n.li,{children:"这两个函数都可以接受任意数量的参数，并将它们传递给原始函数。"}),"\n"]}),"\n",(0,s.jsxs)(n.h2,{id:"请求队列",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#请求队列",children:"#"}),"请求队列"]}),"\n",(0,s.jsxs)(n.p,{children:["所用算法：",(0,s.jsx)(n.strong,{children:"滑动窗口"})]}),"\n",(0,s.jsxs)(n.p,{children:["每次只处理长度为",(0,s.jsx)(n.code,{children:"maxConcurrent"}),"的窗口内的事件。"]}),"\n",(0,s.jsxs)(n.h3,{id:"实现-2",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实现-2",children:"#"}),"实现"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"class RequestQueue {\n  constructor(maxConcurrent) {\n    this.maxConcurrent = maxConcurrent; // 最大并发数\n    this.queue = [];  // 请求队列\n    this.currentlyRunning = 0;  // 当前正在运行的请求数\n  }\n\n  add(request) {\n    return new Promise((resolve, reject) => {\n      this.queue.push({ request, resolve, reject });\n      this.processQueue();\n    });\n  };\n\n  processQueue() {\n    if (this.queue.length > 0 && this.currentlyRunning < this.maxConcurrent) {\n      const { request, resolve, reject } = this.queue.shift();\n      this.currentlyRunning++;\n      request().then(resolve).catch(reject).finally(() => {\n        this.currentlyRunning--;\n        this.processQueue();\n      });\n    };\n  };\n}\n\n\nfunction fetchData(url) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      resolve(`Data from ${url}`);\n    }, 1000);\n  });\n}\n\nconst urls = ['url1', 'url2', 'url3', 'url4', 'url5'];\n\nconst requests = urls.map(url => () => fetchData(url));\nconst myRequestQueue = new RequestQueue(2);\n\nPromise.all(requests.map(request => myRequestQueue.add(request)))\n  .then(data => console.log(data))\n  .catch(err => console.error(err));\n\n// 1s 后输出\n// [ 'Data from url1', 'Data from url2', 'Data from url3', 'Data from url4', 'Data from url5' ]\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"分页加载",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#分页加载",children:"#"}),"分页加载"]}),"\n",(0,s.jsx)(n.p,{children:"分批加载数据，减少单次请求量，应用于长列表、分页数据。"}),"\n",(0,s.jsxs)(n.h3,{id:"示例",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#示例",children:"#"}),"示例"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"let currentPage = 1;\nconst pageSize = 20;\nlet isLoading = false;\n\nfunction loadMoreData() {\n  if (isLoading) {\n    return;\n  }\n  isLoading = true;\n  fetch(`/aoi/items?page=${currentPage}&limit=${pageSize}`)\n    .then((response) => response.json())\n    .then((data) => {\n      // 处理数据并更新页面\n      const container = document.getElementById('container');\n      data.forEach((item) => {\n        const div = document.createElement('div');\n        div.innerHTML = item.name;\n        container.appendChild(div);\n      });\n      currentPage++;\n      isLoading = false;\n    }).catch((error) => {\n      console.error(error);\n      isLoading = false;\n    });\n}\n\n// 监听滚动事件\nwindow.addEventListener('scroll', () => {\n  const { scrollTop, scrollHeight, clientHeight } = document.documentElement;\n  if (scrollTop + clientHeight >= scrollHeight) {\n    loadMoreData();\n  }\n});\n\n// 初始化加载\nloadMoreData();\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"懒加载lazy-load",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#懒加载lazy-load",children:"#"}),"懒加载（lazy Load）"]}),"\n",(0,s.jsx)(n.p,{children:"延迟加载非关键资源，减少初始负载，如图片、视频、长列表。"}),"\n",(0,s.jsxs)(n.h3,{id:"实现-3",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实现-3",children:"#"}),"实现"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'document.addEventListener("DOMContentLoaded", function() {\n  const lazyImages = document.querySelectorAll("img.lazy");\n\n  const lazyLoad = function() {\n    lazyImages.forEach(img => {\n      if (img.getBoundingClientRect().top < window.innerHeight && img.getBoundingClientRect().bottom > 0 && getComputedStyle(img).display !== "none") {\n        img.src = img.dataset.src;\n        img.classList.remove("lazy");\n      }\n    });\n  };\n\n  lazyLoad();\n  window.addEventListener("scroll", lazyLoad);\n});\n'})}),"\n",(0,s.jsxs)(n.h2,{id:"请求重试",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#请求重试",children:"#"}),"请求重试"]}),"\n",(0,s.jsx)(n.p,{children:"请求失败后，按策略重试，应用于网络不稳定、服务端错误等情景。"}),"\n",(0,s.jsxs)(n.h3,{id:"实现-4",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实现-4",children:"#"}),"实现"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"function fetchWithRetry(url, options, retries = 3) {\n  return fetch(url, options)\n    .catch(err => retries > 0 ? fetchWithRetry(url, options, retries - 1) : Promise.reject(err));\n}\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"缓存",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#缓存",children:"#"}),"缓存"]}),"\n",(0,s.jsx)(n.p,{children:"缓存请求结果，减少重复请求，应用于静态资源、频繁请求的数据。"}),"\n",(0,s.jsxs)(n.h3,{id:"实现-5",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实现-5",children:"#"}),"实现"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const cache = new Map();\n\nasync function fetchWithCache(url) {\n  if (cache.has(url)) {\n    return cache.get(url);\n  }\n  const response = await fetch(url);\n  cache.set(url, response);\n  return response;\n}\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"限流",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#限流",children:"#"}),"限流"]}),"\n",(0,s.jsx)(n.p,{children:"限制单位时间内的请求次数，应用于 API 调用、资源加载等场景。"}),"\n",(0,s.jsxs)(n.h3,{id:"实现-6",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#实现-6",children:"#"}),"实现"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"class RateLimiter {\n  constructor(limit, interval) {\n    this.limit = limit;\n    this.interval = interval;\n    this.queue = [];\n    this.times = [];\n  }\n\n  add(request) {\n    this.queue.push(request);\n    this.run();\n  }\n\n  run() {\n    const now = Date.now();\n    this.times = this.times.filter(time => now - time < this.interval);\n\n    if (this.times.length < this.limit && this.queue.length) {\n      const request = this.queue.shift();\n      this.times.push(now);\n      request();\n    }\n\n    if (this.queue.length) {\n      setTimeout(() => this.run(), this.interval - (now - this.times[0]));\n    }\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"反思",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#反思",children:"#"}),"反思"]}),"\n",(0,s.jsx)(n.p,{children:"封装请求队列属于前端开发主导的限制请求行为。"}),"\n",(0,s.jsxs)(n.p,{children:["防抖、节流属于用户交互层面上的设计。可以查阅",(0,s.jsx)(n.a,{href:"https://lodash.com/",rel:"noopener noreferrer",target:"_blank",children:"Lodash"}),"的实现思路。"]}),"\n",(0,s.jsx)(n.p,{children:"此外还有分页、滚动加载、可视区绘制等措施。"}),"\n",(0,s.jsx)(n.p,{children:"再再此外还可以从服务器端有一些限制流量的措施，缓解高并发压力，如 Nginx 分流等。"})]})}function c(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?(0,s.jsx)(n,Object.assign({},e,{children:(0,s.jsx)(l,e)})):l(e)}let d=c;c.__RSPRESS_PAGE_META={},c.__RSPRESS_PAGE_META["posts%2Ffront_end%2Fflow_control.md"]={toc:[{id:"防抖节流",text:"防抖/节流",depth:2},{id:"防抖debounce",text:"防抖（Debounce）",depth:3},{id:"实现",text:"实现",depth:4},{id:"为什么在debounce-函数中使用let",text:"为什么在`debounce`\xa0 函数中使用`let`？",depth:4},{id:"节流throttle",text:"节流（Throttle）",depth:3},{id:"实现-1",text:"实现",depth:4},{id:"注意事项",text:"注意事项",depth:3},{id:"请求队列",text:"请求队列",depth:2},{id:"实现-2",text:"实现",depth:3},{id:"分页加载",text:"分页加载",depth:2},{id:"示例",text:"示例",depth:3},{id:"懒加载lazy-load",text:"懒加载（lazy Load）",depth:2},{id:"实现-3",text:"实现",depth:3},{id:"请求重试",text:"请求重试",depth:2},{id:"实现-4",text:"实现",depth:3},{id:"缓存",text:"缓存",depth:2},{id:"实现-5",text:"实现",depth:3},{id:"限流",text:"限流",depth:2},{id:"实现-6",text:"实现",depth:3},{id:"反思",text:"反思",depth:2}],title:"前端流量控制常用手段",headingTitle:"",frontmatter:{title:"前端流量控制常用手段",subtitle:"",date:"2025-03-17T03:40:19.000Z",lastmod:"2025-03-17T03:40:19.000Z",draft:!1,authors:null,description:null,tags:["前端","JavaScript"],categories:["在前端搬砖的日子里"],series:["前端八股文基础"],hiddenFromHomePage:!1,hiddenFromSearch:!1,featuredImage:"https://img.dodolalorc.cn/i/2025/03/03/67c5599367fe0.jpg",featuredImagePreview:"https://img.dodolalorc.cn/i/2025/03/03/67c5599367fe0.jpg",toc:{enable:!0},math:{enable:!0},lightgallery:!1,license:""}}},3208:function(e,n,r){r.d(n,{Z:()=>d});var s=r(2676),t=r(5271),i=r(2815);r(2791);let l={"zh-CN":e=>`\u{9884}\u{8BA1}\u{9605}\u{8BFB}\u{65F6}\u{95F4}: ${e.minutes>=1?`${Math.ceil(e.minutes)} \u{5206}\u{949F}`:"小于 1 分钟"}`,"en-US":e=>`Estimated reading time: ${e.minutes>=1?`${Math.ceil(e.minutes)} minutes`:"less than 1 minute"}`};function c(e,n,r){let s=Object.keys(l).includes(n)?n:r;return l[s](e)}let d=e=>{let{defaultLocale:n="en-US"}=e,r=(0,i.Vi)().page.readingTimeData,l=(0,i.Jr)(),d=(0,i.e7)(),[a,h]=(0,t.useState)(c(r,l,n));return(0,t.useEffect)(()=>{h(c(r,l,n))},[l,r]),(0,s.jsx)("span",{"data-dark":String(d),className:"rp-reading-time",children:a})}}}]);