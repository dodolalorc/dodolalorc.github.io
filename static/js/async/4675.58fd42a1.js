"use strict";(self.webpackChunkblogsite_rspress=self.webpackChunkblogsite_rspress||[]).push([["4675"],{2726:function(n,e,i){i.r(e),i.d(e,{default:()=>h});var d=i(2676),t=i(453),r=i(7622),s=i(3208);function c(n){let e=Object.assign({h2:"h2",a:"a",p:"p",h3:"h3",pre:"pre",code:"code"},(0,t.ah)(),n.components);return(0,d.jsxs)(d.Fragment,{children:[(0,d.jsxs)(e.h2,{id:"拓扑排序",children:[(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#拓扑排序",children:"#"}),"拓扑排序"]}),"\n",(0,d.jsx)(s.Z,{defaultLocale:"zh-CN"}),"\n",(0,d.jsxs)(e.p,{children:["前提：拓扑排序是对","有向无环图","来说的，无向图、有环图都不存在拓扑排序。"]}),"\n",(0,d.jsx)(e.p,{children:"拓扑排序是将图G中的所有顶点排成一个线性序列，使得对于任意一堆有边顶点<u, v>，在线性序列中，u都出现在v之前。"}),"\n",(0,d.jsx)(e.p,{children:"拓扑排序可以反应某种方案是否是切实可行的。"}),"\n",(0,d.jsx)(e.p,{children:"一般一个图是否是有向图我们分析题意要求就能知道，但是究竟有没有环存在，就不是瞄一眼就能发现的了，所以，虽然拓扑排序是针对有向无环图而言的一种性质，但是反过来，一个有向图是否有拓扑排序，也可以反过来解决该图是否存在环、以及存在多少环等等问题，也就是某种方案可不可行。"}),"\n",(0,d.jsx)(e.p,{children:"接下来我们通过代码学习如何获得一个有向图的拓扑排序："}),"\n",(0,d.jsxs)(e.h3,{id:"算法思路",children:[(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#算法思路",children:"#"}),"算法思路"]}),"\n",(0,d.jsx)(e.p,{children:"拓扑排序一定是从入度为0的顶点开始的（假如入度不为0不就是有点要排在它的前面了嘛qwq），所以，我们通过删除点(及由该点出发的所有边)的方法可以不断更新制作拓扑排序时当前图的状态，这样的步骤不断执行，直到图中能删的点(入度为0的点)都删光了，我们的程序就执行到了终点。"}),"\n",(0,d.jsxs)(e.h3,{id:"程序实现",children:[(0,d.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#程序实现",children:"#"}),"程序实现"]}),"\n",(0,d.jsx)(e.p,{children:"我们还是用链式前向星来存储图"}),"\n",(0,d.jsx)(e.p,{children:"使用队列来记录我们的拓扑序列（说是队列不过其实还是个每次只读末尾的数组啦，也没用到queue容器qwq）"}),"\n",(0,d.jsx)(e.p,{children:"寻找拓扑序列样例代码："}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-cpp",children:"// 要先用一个数组记录各个顶点最初的入度，这个数组可以在读入边数据的时候进行++记录\n\nint queue[maxn];\nint iq = 0;	// 表示当前队列长度，起始当然是0啦(懒得iq++也可以直接懒人向量法)\n\n// 先将图里入度为0的顶点加入队列\n// 第一层入度为0的点，其顺序就只是存储顺序决定哩，而且不重要(除非想找所有的拓扑排序qwq)\nfor (int i = 1;i <= n;i++)\n    if (indegree[i] == 0)\n        queue[iq++] = i;\n\n// 删点，对队列做更新\nfor (int i = 0;i < iq;i++) {\n    // 按队列顺序删点删边(终点的入度--就算删掉这条边了)\n    for (int k = head[queue[i]];k != 0;k = Edge[k].next) {\n        indegree[Edge[k].to]--;\n        if (indegree[Edge[k].to] == 0)\n            queue[iq++] = Edge[k].to;\n    }\n}\n"})}),"\n",(0,d.jsx)(e.p,{children:"这时候我们得到了一个序列，其实这个序列无论如何都能得到（空序列也是序列！），所以接下来需要判断一下是否是拓扑序列，同时也就判断出当前的图是不是有向无环图啦。"}),"\n",(0,d.jsx)(e.p,{children:"判断样例代码："}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-cpp",children:'cout << "iq=" << iq << " n=" << n << endl;\n	if (iq == n) {\n		cout << "有拓扑序列：" << endl;\n		\n		// 输出拓扑排序序列\n		for (int i = 0;i < iq;i++)\n			cout << queue[i] << " ";\n		cout << endl;\n	}\n	else {\n		cout << "没有拓扑序列" << endl;\n	}\n'})}),"\n",(0,d.jsx)(e.p,{children:"前面的输入样例是个有向有环图，这里添加一组有向无环图的样例用于学习："}),"\n",(0,d.jsx)(r.Z,Object.assign({code:"graph LR\nv1((v1))--5--\x3ev2((v2))\nv1((v1))--6--\x3ev3((v3))\nv2((v2))--9--\x3ev4((v4))\nv3((v3))--10--\x3ev5((v5))\nv3((v3))--4--\x3ev6((v6))\nv4((v4))--12--\x3ev6((v6))\nv5((v5))--6--\x3ev7((v7))\nv6((v6))--9--\x3ev7((v7))\nv7((v7))--24--\x3ev8((v8))\nv6((v6))--3--\x3ev8((v8))"},{config:{theme:"forest"}})),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-plaintext",children:"8 10\n1 2 5\n1 3 6\n2 4 9\n3 5 10\n3 6 4\n4 6 12\n5 7 6\n6 7 9\n6 8 3\n7 8 24\n"})}),"\n",(0,d.jsx)(e.p,{children:"完整代码："}),"\n",(0,d.jsx)(e.pre,{children:(0,d.jsx)(e.code,{className:"language-cpp",children:'#include<bits/stdc++.h>\nusing namespace std;\nconst long long maxn = 1e5 + 50, maxm = 1e7 + 50;\n\nstruct EdgeNode {\n	int to;		// 终点\n	int w;		// 权值\n	int next;	// 下一位置\n};\n\nEdgeNode Edge[maxm];\nint head[maxn];\nint indegree[maxn];\n\nint main() {\n	int n, m;\n	cin >> n >> m;\n\n	// 初始化head\n	memset(head, -1, sizeof(head));		// 初始化为0应该也冇问题，反正只是方便我们判断终点啦，想用向量也行qwq\n\n	// 读入数据\n	for (int i = 0;i < m;i++) {\n		int fi, ti, wi;\n		cin >> fi >> ti >> wi;\n		Edge[i].to = ti;\n		Edge[i].w = wi;\n		\n		Edge[i].next = head[fi];\n		head[fi] = i;\n\n		// 记录各个顶点的入度(当该点是终点的时候++qwq)\n		indegree[ti]++;\n	}\n\n	// 要先用一个数组记录各个顶点最初的入度，这个数组可以在读入边数据的时候进行++记录\n\n	int queue[maxn];\n	int iq = 0;	// 表示当前队列长度，起始当然是0啦(懒得iq++也可以直接懒人向量法)\n\n	// 先将图里入度为0的顶点加入队列\n	// 第一层入度为0的点，其顺序就只是存储顺序决定哩，而且不重要(除非想找所有的拓扑排序qwq)\n	for (int i = 1;i <= n;i++)\n		if (indegree[i] == 0)\n			queue[iq++] = i;\n\n	// 删点，对队列做更新\n	for (int i = 0;i < iq;i++) {\n		// 按队列顺序删点删边(终点的入度--就算删掉这条边了)\n		for (int k = head[queue[i]];k != -1;k = Edge[k].next) {\n			indegree[Edge[k].to]--;\n			if (indegree[Edge[k].to] == 0)\n				queue[iq++] = Edge[k].to;\n		}\n	}\n\n	// 这里可以判断是否有环啦，假如此时iq的值小于顶点的数量n，不就是说明接下来没法删边了嘛，也就是说最后剩下了环。\n	cout << "iq=" << iq << " n=" << n << endl;\n	if (iq == n) {\n		cout << "有拓扑序列：" << endl;\n		\n		// 输出拓扑排序序列\n		for (int i = 0;i < iq;i++)\n			cout << queue[i] << " ";\n		cout << endl;\n	}\n	else {\n		cout << "没有拓扑序列" << endl;\n	}\n\n	return 0;\n}\n\n'})}),"\n",(0,d.jsxs)(e.p,{children:["该算法在",(0,d.jsx)(e.code,{children:"O(m)"}),"的时间内对indegree数组进行初始化，在",(0,d.jsx)(e.code,{children:"O(n)"}),"时间内对queue进行初始化，后面的部分虽然看起来是两层循环，但实际上是m条边各遍历一次，所以时间复杂度只有",(0,d.jsx)(e.code,{children:"O(m)"}),"而已，所以一共也就",(0,d.jsx)(e.code,{children:"O(m+n)"}),"的复杂度。还是很友好滴。"]})]})}function a(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,t.ah)(),n.components);return e?(0,d.jsx)(e,Object.assign({},n,{children:(0,d.jsx)(c,n)})):c(n)}let h=a;a.__RSPRESS_PAGE_META={},a.__RSPRESS_PAGE_META["posts%2Falgorithm%2Ftopo.md"]={toc:[{id:"拓扑排序",text:"拓扑排序",depth:2},{id:"算法思路",text:"算法思路",depth:3},{id:"程序实现",text:"程序实现",depth:3}],title:"拓扑排序",headingTitle:"",frontmatter:{title:"拓扑排序",date:"2024-01-05T06:20:41.000Z",draft:!1,authors:[],description:"",tags:["图论","拓扑排序"],categories:["在学算法的日子里"],series:["算法模板笔记"],hiddenFromHomePage:!1,hiddenFromSearch:!1,featuredImage:"",featuredImagePreview:"",toc:{enable:!0},math:{enable:!0},lightgallery:!1,license:""}}}}]);