[{"id":0,"title":"关于我","content":"#\n\n很高兴认识你，这里是 Doごみ箱。\n\n--------------------------------------------------------------------------------\n\n\n🎐作者信息：#\n\n昵称：哆哆啦(DODOLA)\n\n刷新地点：杭州/长春\n\n废话：INTJer，跟其他INTJ一样有一些不顾人死活的人机感。\n\n> I Navigate The Journey.\n> \n> Ideals Never Tolerate Jeers.\n> \n> I Negate Tainted Joys.\n> \n> In Night, Truths Judge.\n> \n> ...... and, int j; 嘻嘻:)\n\n本科2026届东师计科专业，不太打算读研，正在当实习生努力学习进军互联网。\n\n平时喜欢打点电子游戏，动森/星露谷/splatoon/雀魂。喜欢做点钩织之类的手工。\n\n喜欢看点音乐剧（没错你怎么知道2025.10我要去看法红黑了），看点番看点电影看点日剧韩剧，还有看点小说（但是最近看书越来越少了T-T）\n\n目前正在准备字节跳动的暑期实习，正在学习 Electron 和 Chromium 内核。\n\n联系方式：gmail\n\n--------------------------------------------------------------------------------\n\n\n🪁本站信息：#\n\n建站日期：2023/11/28\n\n本站简介：本站会用来保存站长的电子笔记，涉及各种笔记和bug日记，但目前算法笔记含量很高（你这辈子就是被算竞害了），就是个杂七杂八的电子小仓库，欢迎您的访问！非\n常欢迎友链互链，相互交流！很高兴认识你~\n\n框架：\n\n * 博客框架：\n   * 2023/11 Hugo\n   * 2025/05 更换为Rspress\n * 主题：\n   * 2023/11 PaperMod\n   * 2024/07 DoIt\n   * 2025/05 Rspress 默认主题 + 修改了一些样式和组件\n * 仓库：GitHub\n\n线路信息\n\n * 初始域名：dodolalorc.github.io\n\n * 主域名：dodolalorc.cn","routePath":"/about","lang":"","toc":[{"text":"🎐作者信息：","id":"作者信息","depth":3,"charIndex":104},{"text":"🪁本站信息：","id":"本站信息","depth":3,"charIndex":617}],"domain":"","frontmatter":{"title":"关于我","subtitle":"","date":"2023-11-28T11:11:55.000Z","lastmod":"2024-07-04T12:21:44.000Z","draft":false,"authors":[],"description":"","tags":["关于"],"categories":[],"series":[],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"","featuredImagePreview":"","toc":{"enable":false},"math":{"enable":false},"lightgallery":false,"license":""},"version":""},{"id":1,"title":"Markdown & MDX","content":"#\n\nRspress supports not only Markdown but also MDX, a powerful way to develop\ncontent.\n\n\nMarkdown#\n\nMDX is a superset of Markdown, which means you can write Markdown files as\nusual. For example:\n\n\n\n\nUse component#\n\nWhen you want to use React components in Markdown files, you should name your\nfiles with .mdx extension. For example:\n\n\n\n\nFront matter#\n\nYou can add Front Matter at the beginning of your Markdown file, which is a\nYAML-formatted object that defines some metadata. For example:\n\n\n\n> Note: By default, Rspress uses h1 headings as html headings.\n\nYou can also access properties defined in Front Matter in the body, for example:\n\n\n\nThe previously defined properties will be passed to the component as frontmatter\nproperties. So the final output will be:\n\n\n\n\nCustom container#\n\nYou can use the ::: syntax to create custom containers and support custom\ntitles. For example:\n\nInput:\n\n\n\nOutput:\n\nTIP\n\nThis is a block of type tip\n\nINFO\n\nThis is a block of type info\n\nWARNING\n\nThis is a block of type warning\n\nDANGER\n\nThis is a block of type danger\n\nDETAILS\n\nThis is a block of type details\n\nCustom Title\n\nThis is a block of Custom Title\n\nCustom Title\n\nThis is a block of Custom Title\n\n\nCode block#\n\n\nBasic usage#\n\nYou can use the ``` syntax to create code blocks and support custom titles. For\nexample:\n\nInput:\n\n\n\nOutput:\n\n\n\n\n\n\nShow line numbers#\n\nIf you want to display line numbers, you can enable the showLineNumbers option\nin the config file:\n\n\n\n\nWrap code#\n\nIf you want to wrap long code line by default, you can enable the\ndefaultWrapCode option in the config file:\n\n\n\n\nLine highlighting#\n\nYou can also apply line highlighting and code block title at the same time, for\nexample:\n\nInput:\n\n\n\nOutput:\n\n\n\n\nRustify MDX compiler#\n\nYou can enable Rustify MDX compiler by following config:","routePath":"/guide/","lang":"","toc":[{"text":"Markdown","id":"markdown","depth":2,"charIndex":88},{"text":"Use component","id":"use-component","depth":2,"charIndex":198},{"text":"Front matter","id":"front-matter","depth":2,"charIndex":336},{"text":"Custom container","id":"custom-container","depth":2,"charIndex":767},{"text":"Code block","id":"code-block","depth":2,"charIndex":1190},{"text":"Basic usage","id":"basic-usage","depth":3,"charIndex":1204},{"text":"Show line numbers","id":"show-line-numbers","depth":3,"charIndex":1332},{"text":"Wrap code","id":"wrap-code","depth":3,"charIndex":1455},{"text":"Line highlighting","id":"line-highlighting","depth":3,"charIndex":1580},{"text":"Rustify MDX compiler","id":"rustify-mdx-compiler","depth":2,"charIndex":1712}],"domain":"","frontmatter":{},"version":""},{"id":2,"title":"Hello world!","content":"#\n\n\nStart#\n\nWrite something to build your own docs! 🎁","routePath":"/hello","lang":"","toc":[{"text":"Start","id":"start","depth":2,"charIndex":3}],"domain":"","frontmatter":{},"version":""},{"id":4,"title":"友達です！","content":"✨️✨️ 友链列表：#\n\n\n✨️✨️ 本站友链信息：#\n\n> name: dodola\n> \n> url: https://dodolalorc.cn/\n> \n> avatar: https://dodolalorc.cn/img/dodola.png\n> \n> bio: Wit beyond measure is man’s greatest treasure.\n\n\n✨️✨️ 申请友链信息格式：#\n\n> name: #名称\n> \n> url: #链接\n> \n> avatar: #头像\n> \n> bio: #站点描述\n\n🎇🎇 友链申请要求 QwQ\n\n🎉 本站支持交换友链，在您提出申请之前，请将本站添加至友链\n\n🏵️ 为了保障本站用户，本站仅支持个人网站的友链申请\n\n💐 友链中的链接信息需要保证可以正常访问哦\n\n🍖 站内文章能持续更新，没有太多广告\n\n🎴 感谢您对本站的支持，如果您已经满足上述要求，请在下方评论区提交友链申请~~~","routePath":"/links","lang":"","toc":[{"text":"✨️✨️ 友链列表：","id":"️️-友链列表","depth":2,"charIndex":-1},{"text":"✨️✨️ 本站友链信息：","id":"️️-本站友链信息","depth":2,"charIndex":13},{"text":"✨️✨️ 申请友链信息格式：","id":"️️-申请友链信息格式","depth":2,"charIndex":185}],"domain":"","frontmatter":{"title":"友達です！","subtitle":"","date":"2024-07-04T12:24:20.000Z","lastmod":"2024-07-04T12:24:20.000Z","draft":false,"authors":[],"description":"友链 挂挂","tags":[],"categories":[],"series":[],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"","featuredImagePreview":"","toc":{"enable":false},"math":{"enable":false},"lightgallery":false,"license":"","isLink":true},"version":""},{"id":5,"title":"2023杭州ICPC区域赛","content":"G. Snake Move#\n\n\n题意#\n\n$n\\times m$的网格中有一条长度为$k$的贪吃蛇，贪吃蛇支持上下左右移动 1 格的操作，以及缩短 1 个身体长度的操作。\n\n设$f(i,j)$为从蛇头从初始位置到达网格中点$(i,j)$所需要的最少的操作数，网格中不可到达的格子操作数设为$0$，求解输出：\n\n$$ \\sum_{i=1}^{i=n}\\sum_{j=1}^{j=m}f(i,j) $$\n\n\n思路#\n\n初始时蛇身压住的格子有一个最早释放的时间，可以通过预处理获得。\n\n当蛇头开始移动时，蛇头经过的格子不会有更早的到达时刻，如果下一步可以到达蛇身压住的格子，绕行不可能优于直接缩短长度的操作数。\n\n正常从蛇头进行 BFS，如果遇到初始时不被蛇身压住的格子则正常加入队列，如果遇到被压住的格子，对释放时间和当前步数取max。\n\n\n代码#\n\n\n\n\nJ. Mysterious Tree#\n\n\n题意#\n\n交互题。\n\n有一棵节点数$n\\ge 4$的树，树的形状是链状或者星状，每次询问两个点$u$和$v$，会返回$(u,v)$之间是否有边，需要在$\\lceil\n\\frac{n}{2} \\rceil + 3$的询问次数之内确定树的形状。\n\n\n思路#\n\n每次询问2个没有问过的节点$(1,2),(3,4),...$如果到结束都没有问出边，此时节点数是偶数，则说明是链状，否则用三次询问确定节点$n$是否是星状的中心\n（询问中要有两个点之间是没有边的），若是则为星，否则为链。\n\n问出一条边后，抉择确定这条边的两个点是否是星的中心。\n\n\n代码#\n\n\n\n\nM. V-Diagram#\n\n\n题意#\n\n在 V 型数组，找一个平均值最大的连续子数组，要求子数组也成 V 型，输出平均值。\n\n\n思路#\n\n从最低点（pi）分别向左向右找到平均值最大的位置（lp，rp），选择区间$[lp,pi+1]$、$[pi-1,rp]$、$[lp,rp]$之中平均值最大的一个。\n\n\n代码#\n\n","routePath":"/posts/algorithm/23HangZhouICPC","lang":"","toc":[{"text":"G. Snake Move","id":"g-snake-move","depth":2,"charIndex":-1},{"text":"题意","id":"题意","depth":3,"charIndex":16},{"text":"思路","id":"思路","depth":3,"charIndex":202},{"text":"代码","id":"代码","depth":3,"charIndex":369},{"text":"J. Mysterious Tree","id":"j-mysterious-tree","depth":2,"charIndex":377},{"text":"题意","id":"题意-1","depth":3,"charIndex":399},{"text":"思路","id":"思路-1","depth":3,"charIndex":522},{"text":"代码","id":"代码-1","depth":3,"charIndex":668},{"text":"M. V-Diagram","id":"m-v-diagram","depth":2,"charIndex":676},{"text":"题意","id":"题意-2","depth":3,"charIndex":692},{"text":"思路","id":"思路-2","depth":3,"charIndex":741},{"text":"代码","id":"代码-2","depth":3,"charIndex":829}],"domain":"","frontmatter":{"title":"2023杭州ICPC区域赛","subtitle":"","date":"2024-11-23T10:51:44.000Z","lastmod":"2024-11-23T10:51:44.000Z","draft":false,"authors":null,"description":"","tags":["算法"],"categories":["在学算法的日子里"],"series":["题解记录"],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"https://img.dodolalorc.cn/i/2024/12/10/67580b0b426f5.jpg","featuredImagePreview":"https://img.dodolalorc.cn/i/2024/12/10/67580b0b426f5.jpg","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":6,"title":"2024吉林省赛补题记录","content":"GYM地址：2024吉林省赛\n\n题目顺序按照从易到难排序。\n\n\nI. The Easiest Problem#\n\n\n题意#\n\n数一数\n\n\n代码#\n\n\n\n\nL. Recharge#\n\n\n题意#\n\n有$x$次获得$1$格能量的机会，$y$次获得$2$格能量的机会，充满一个电池需要$k$格能量，溢出的能量会被浪费，问最多能充满多少电池。\n\n\n代码#\n\n\n\n\nG. Platform Game#\n\n\n题意#\n\n在二维平面中有$n$个平台，每个平台有一个高度$h_i$，以及一个左端点$l_i$和右端点$r_i$。机器人从$(x,y)$出发，保持向右前进，如果遇到平台端点\n则会垂直下落，问机器人最终的落点。\n\n\n思路#\n\n排序题，按照高度从高到低、左端点从小到大排序，遍历平台，如果机器人在平台上则更新机器人的位置。\n\n\n代码#\n\n\n\n\nD. Parallel Lines#\n\n\n题意#\n\n二维平面上有$k$条平行线，这些直线上有$n$个点，已知每条直线上至少有$2$个点。现在给出$n$个点，找出这$k$条平行线（用点表示）。\n\n\n数据范围#\n\n$2 \\leq n \\leq 10^4$\n\n$1 \\leq k \\leq \\min(50, \\frac{n}{2})$\n\n\n思路#\n\n注意$k$的范围，$k$最多为$50$，可以枚举$k$来选择平行线的斜率，对于$k$条平行线，当我选择了$k+1$个点时，这$k+1$个点中必然至少有两个点之间\n的斜率是$k$条平行线的斜率。\n\n确定斜率$k_i$之后，我们分别计算过每个点斜率为$k_i$的直线在$y$轴上的截距，并计数相同截距的点的数目，注意垂直于$x$轴的情况。\n\n只有同时符产生截距数目恰好为$k$，且每个截距的点数目至少为$2$时，我们才找到了所要的$k$条平行线。\n\n\n代码#\n\n\n\n\nE. Connected Components#\n\n\n题意#\n\n有$n$个王国，编号从$1$到$n$，每个王国有两个属性值$a_i$和$b_i$，如果两个王国的属性值满足$a_i - a_j \\leq i - j \\leq\nb_i - b_j$或$a_j - a_i \\leq j - i \\leq b_j - b_i$，则这两个王国是相连的。问有多少个连通块。\n\n\n数据范围#\n\n$1 \\leq n \\leq 10^6$\n\n\n思路#","routePath":"/posts/algorithm/24JilinCCPC","lang":"","toc":[{"text":"I. The Easiest Problem","id":"i-the-easiest-problem","depth":2,"charIndex":31},{"text":"题意","id":"题意","depth":3,"charIndex":57},{"text":"代码","id":"代码","depth":3,"charIndex":68},{"text":"L. Recharge","id":"l-recharge","depth":2,"charIndex":76},{"text":"题意","id":"题意-1","depth":3,"charIndex":91},{"text":"代码","id":"代码-1","depth":3,"charIndex":168},{"text":"G. Platform Game","id":"g-platform-game","depth":2,"charIndex":176},{"text":"题意","id":"题意-2","depth":3,"charIndex":196},{"text":"思路","id":"思路","depth":3,"charIndex":302},{"text":"代码","id":"代码-2","depth":3,"charIndex":357},{"text":"D. Parallel Lines","id":"d-parallel-lines","depth":2,"charIndex":365},{"text":"题意","id":"题意-3","depth":3,"charIndex":386},{"text":"数据范围","id":"数据范围","depth":3,"charIndex":463},{"text":"思路","id":"思路-1","depth":3,"charIndex":532},{"text":"代码","id":"代码-3","depth":3,"charIndex":761},{"text":"E. Connected Components","id":"e-connected-components","depth":2,"charIndex":769},{"text":"题意","id":"题意-4","depth":3,"charIndex":796},{"text":"数据范围","id":"数据范围-1","depth":3,"charIndex":953},{"text":"思路","id":"思路-2","depth":3,"charIndex":-1}],"domain":"","frontmatter":{"title":"2024吉林省赛补题记录","subtitle":"","date":"2024-07-05T06:30:27.000Z","lastmod":"2024-07-05T06:30:27.000Z","draft":false,"authors":[],"description":"","tags":["算法"],"categories":["在学算法的日子里"],"series":["题解记录"],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"","featuredImagePreview":"","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":7,"title":"一些回溯相关的刷题记录","content":"背景#\n\n今天复习算法课的题目时在琢磨这题：\n\n(2024年1月3日15:52:13更新：正好考到了，押题！)\n\n\n> 1283: E003 信道分配\n> \n> 题目描述\n> \n> 当无线电台在一个非常大的区域上传播信号时，为了每个接收器都能得到较强信号，使用转发器转发信号。然而，需要仔细地选择每个转发器使用的频道，以使附近的转发器不彼\n> 此干扰。如果邻近的转发器使用不同的频道，条件就得到满足。\n> 因为无线电波的频谱是宝贵的资源，转发器所需频道的数量应减到最少。编程任务：读取转发器网络的描述信息，并计算出所需频道的最小使用量。\n> \n> ==输入==\n> \n> 输入包含许多转发器网络图。每幅图的第一行是转发器数目（1~26）。转发器用连续的大写字母表示，从A开始。例如，10个转发器的名称分别是A，B，C，…，I和J\n> 。当转发器的个数是0时，表示输入结束。 转发器数目之后，是其邻近关系的列表。每行的格式为 A：BCDH\n> 表示转发器B、C、D和H与转发器A邻近。第一行描述与转发器A邻近的，第二行描述与B邻近的，直到描述完所有的转发器。如果某个转发器不与其他转发器相邻，它的形式\n> 为 A： 转发器依字母顺序列出。 注意：相邻是对称的关系；如果A与B相邻，那么B与A也相邻。因为转发器位于水平面内，由相邻的转发器构成的网络图没有相交的线。\n> \n> ==输出==\n> \n> 对于每幅图（除了最后一个没有转发器），输出一行，是转发器不互相干扰所需的最少频道数。输出格式参考样例输出。注意：频道数为1的话，“channel”为单数。\n> \n> ==样例输入==\n> \n> \n> \n> ==样例输出==\n\n找到的题解提到，这是一个可以在四个频道数内解决的问题，所以引起了ddl的好奇。这里记录一下学习这个四色定理。\n\n本题题意很简单，就是通过算法查找至少需要多少个频道才能保证相邻电台不会互相干扰（频率不同）\n\n\n引四色定理证明#\n\n四色定理的证明至今也没有纯粹的数学证明，但是已有在计算机辅助下的证明。\n\n参考：古典着色问题的新时代算法 - IT之家 (ithome.com)\n\nwiki百科：Four_color_theorem\n\n和一篇[在计算机软件 Coq 的帮助下找到形式证明论文](tx081101382p.pdf (ams.org))\n\n\n回溯法(back tracking)#\n\n\n回溯法介绍#\n\n一种选优搜索法，或称“试探法”，按选优条件向前搜索，当搜索到某一步时，发现无法达到目标（即满足回溯条件），就退一步重新选择，这种走不通就退回来重走的技术称为回溯\n法。\n\n\n例题实训#\n\n八皇后问题#\n\n洛谷链接：[P1219 USACO1.5] 八皇后 Checker Challenge - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n\n\n> [USACO1.5] 八皇后 Checker Challenge\n> \n> \n> 题目描述\n> \n> 一个如下的 $6 \\times 6$\n> 的跳棋棋盘，有六个棋子被放置在棋盘上，使得每行、每列有且只有一个，每条对角线（包括两条主对角线的所有平行线）上至多有一个棋子。\n> \n> \n> \n> 上面的布局可以用序列 $2\\ 4\\ 6\\ 1\\ 3\\ 5$ 来描述，第 $i$ 个数字表示在第 $i$ 行的相应位置有一个棋子，如下：\n> \n> 行号 $1\\ 2\\ 3\\ 4\\ 5\\ 6$\n> \n> 列号 $2\\ 4\\ 6\\ 1\\ 3\\ 5$\n> \n> 这只是棋子放置的一个解。请编一个程序找出所有棋子放置的解。\n> \n> 并把它们以上面的序列方法输出，解按字典顺序排列。\n> \n> 请输出前 $3$ 个解。最后一行是解的总个数。\n> \n> \n> 输入格式\n> \n> 一行一个正整数 $n$，表示棋盘是 $n \\times n$ 大小的。\n> \n> \n> 输出格式\n> \n> 前三行为前三个解，每个解的两个数字之间用一个空格隔开。第四行只有一个数字，表示解的总数。\n> \n> \n> 样例 #1\n> \n> \n> 样例输入 #1\n> \n> \n> \n> \n> 样例输出 #1\n> \n> \n> \n> \n> 提示\n> \n> 【数据范围】\n> \n> 对于 $100%$ 的数据，$6 \\le n \\le 13$。\n> \n> 题目翻译来自NOCOW。\n> \n> USACO Training Section 1.5\n\n回溯法数独#\n\n洛谷链接：P1784 数独 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n\n\n> 数独\n> \n> \n> 题目描述\n> \n> 数独是根据 $9 \\times 9$ 盘面上的已知数字，推理出所有剩余空格的数字，并满足每一行、每一列、每一个粗线宫内的数字均含 $1 - 9$\n> ，不重复。每一道合格的数独谜题都有且仅有唯一答案，推理方法也以此为基础，任何无解或多解的题目都是不合格的。\n> \n> 芬兰一位数学家号称设计出全球最难的“数独游戏”，并刊登在报纸上，让大家去挑战。\n> \n> 这位数学家说，他相信只有“智慧最顶尖”的人才有可能破解这个“数独之谜”。\n> \n> 据介绍，目前数独游戏的难度的等级有一到五级，一是入门等级，五则比较难。不过这位数学家说，他所设计的数独游戏难度等级是十一，可以说是所以数独游戏中，难度最高的\n> 等级。他还表示，他目前还没遇到解不出来的数独游戏，因此他认为“最具挑战性”的数独游戏并没有出现。\n> \n> \n> 输入格式\n> \n> 一个未填的数独。\n> \n> \n> 输出格式\n> \n> 填好的数独。\n> \n> \n> 样例 #1\n> \n> \n> 样例输入 #1\n> \n> \n> \n> \n> 样例输出 #1\n> \n> \n> \n> \n> 提示\n> \n> 2022-04-17 @farteryhr 贡献了三组 hack\n> 数据。加入了其中两组。第三组过强（来源：https://www.dcc.fc.up.pt/~acm/sudoku.pdf），放在下边供自测。\n> \n> \n> \n> 输出\n\n子集#\n\n力扣链接：78. 子集 - 力扣（LeetCode）\n\n\n> [78. 子集]\n> \n> \n> 题目描述\n> \n> 给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。\n> \n> 解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。\n> \n> \n> 示例 1：\n> \n> \n> \n> \n> 示例 2：\n> \n> \n> \n> \n> 提示：\n> \n>  * 1 <= nums.length <= 10\n>  * -10 <= nums[i] <= 10\n>  * nums 中的所有元素 互不相同\n\n字母大小写全排列#\n\n力扣链接：784. 字母大小写全排列 - 力扣（LeetCode）\n\n\n> 题目描述\n> \n> 给定一个字符串 s ，通过将字符串 s 中的每个字母转变大小写，我们可以获得一个新的字符串。\n> \n> 返回 所有可能得到的字符串集合 。以 任意顺序 返回输出。\n> \n> \n> 示例 1：\n> \n> \n> \n> \n> 示例 2:\n> \n> \n> \n> \n> 提示:\n> \n>  * 1 <= s.length <= 12\n>  * s 由小写英文字母、大写英文字母和数字组成\n\n背包问题一#\n\n洛谷链接：[P4095 HEOI2013] Eden 的新背包问题 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n\n\n> [HEOI2013] Eden 的新背包问题\n> \n> \n> 题目背景\n> \n> “ 寄 没 有 地 址 的 信 ，这 样 的 情 绪 有 种 距 离 ，你 放 着 谁 的 歌 曲 ，是 怎 样 的 心 情 。 能 不 能 说 给 我 听\n> 。”\n> \n> \n> 题目描述\n> \n> 失忆的 Eden 总想努力地回忆起过去，然而总是只能清晰地记得那种思念的感觉，却不能回忆起她的音容笑貌。\n> \n> 记忆中，她总是喜欢给 Eden 出谜题：在 valentine's day 的夜晚，两人在闹市中闲逛时，望着礼品店里精巧玲珑的各式玩偶，她突发奇想，问了\n> Eden 这样的一个问题：有 $n$ 个玩偶，每个玩偶有对应的价值、价钱，每个玩偶都可以被买有限次，在携带的价钱 $m$\n> 固定的情况下，如何选择买哪些玩偶以及每个玩偶买多少个，才能使得选择的玩偶总价钱不超过 $m$，且价值和最大。\n> \n> 众所周知的，这是一个很经典的多重背包问题，Eden\n> 很快解决了，不过她似乎因为自己的问题被飞快解决感到了一丝不高兴，于是她希望把问题加难：多次询问，每次询问都将给出新的总价钱，并且会去掉某个玩偶（即这个玩偶不\n> 能被选择），再问此时的多重背包的答案（即前一段所叙述的问题）。\n> \n> 这下 Eden 犯难了，不过 Eden 不希望自己被难住，你能帮帮他么？\n> \n> \n> 输入格式\n> \n> 第一行有一个整数，代表玩偶的个数 $n$，玩偶从 $0$ 开始编号。\n> \n> 第二行开始后面的 $n$ 行，每行三个整数，第 $(i + 2)$ 行的整数 $a_i, b_i, c_i$，分别表示买一个第 $i$\n> 个玩偶需要的价钱，获得的价值以及第 $i$ 个玩偶的限购次数。\n> \n> 接下来的一行有一个整数 $q$，表示询问次数。\n> \n> 接下来 $q$ 行，每行两个整数 $d_i, e_i$，表示每个询问去掉的是哪个玩偶（注意玩偶从 $0$\n> 开始编号）以及该询问对应的新的总价钱数。（去掉操作不保留，即不同询问互相独立）。\n> \n> \n> 输出格式\n> \n> 输出 $q$ 行，第 $i$ 行输出对于第 $i$ 个询问的答案。\n> \n> \n> 样例 #1\n> \n> \n> 样例输入 #1\n> \n> \n> \n> \n> 样例输出 #1\n> \n> \n> \n> \n> 提示\n> \n> 样例解释\n> \n> 一共五种玩偶，分别的价钱价值和限购次数为 $(2,3,4)$， $(1,2,1)$， $(4,1,2)$， $(2,1,1)$， $(3,2,3)$。\n> \n> 五个询问，以第一个询问为例。\n> \n> 第一个询问表示的是去掉编号为 $1$ 的玩偶， 且拥有的钱数为 $10$ 时可以获得的最大价值，则此时剩余玩偶为 $(2,3,4$)，$(4,1,2)$，\n> $(2,1,1)$，$(3,2,3)$，若把编号为 $0$ 的玩偶买 $4$ 个（即全买了），然后编号为 $3$ 的玩偶 买一个，则刚好把 $10$\n> 元全部花完，且总价值为 $13$。可以证明没有更优的方案了。\n> \n> 注意买某种玩偶不一定要买光。\n> \n> ------------------------------------------------------------------------------\n> --\n> \n> 数据规模与约定\n> \n>  * 对于 $10%$ 的数据，保证 $n \\leq 10$。\n>  * 另外存在 $20%$ 的数据，保证 $n \\leq 100$，$c_i = 1$，$q \\leq 100$。\n>  * 另外存在 $20%$ 的数据，保证 $n \\leq 100$，$q \\leq 100$。\n>  * 另外存在 $30%$ 的数据，保证 $c_i = 1$。\n>  * 对于 $100%$ 的数据，保证 $1 \\leq n \\leq 1000$，$1 \\leq q \\leq 3\\times 10^5$， $1 \\leq\n>    a_i,b_i,c_i \\leq 100$，$0 \\leq d_i < n$，$0 \\leq e_i \\leq 1000$。\n\n背包问题二#\n\n洛谷链接：P1757 通天之分组背包 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n\n\n> 通天之分组背包\n> \n> \n> 题目背景\n> \n> 直达通天路·小 A 历险记第二篇\n> \n> \n> 题目描述\n> \n> 自 $01$ 背包问世之后，小 A 对此深感兴趣。一天，小 A 去远游，却发现他的背包不同于 $01$ 背包，他的物品大致可分为 $k$\n> 组，每组中的物品相互冲突，现在，他想知道最大的利用价值是多少。\n> \n> \n> 输入格式\n> \n> 两个数 $m,n$，表示一共有 $n$ 件物品，总重量为 $m$。\n> \n> 接下来 $n$ 行，每行 $3$ 个数 $a_i,b_i,c_i$，表示物品的重量，利用价值，所属组数。\n> \n> \n> 输出格式\n> \n> 一个数，最大的利用价值。\n> \n> \n> 样例 #1\n> \n> \n> 样例输入 #1\n> \n> \n> \n> \n> 样例输出 #1\n> \n> \n> \n> \n> 提示\n> \n> $0 \\leq m \\leq 1000$，$1 \\leq n \\leq 1000$，$1\\leq k\\leq 100$，$a_i, b_i, c_i$ 在\n> int 范围内。\n\n背包问题三#\n\n洛谷链接：[P1064 NOIP2006 提高组] 金明的预算方案 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n\n\n> [NOIP2006 提高组] 金明的预算方案\n> \n> \n> 题目描述\n> \n> 金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你\n> 说了算，只要不超过 $n$\n> 元钱就行”。今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：\n> \n> 主件    附件\n> 电脑    打印机，扫描仪\n> 书柜    图书\n> 书桌    台灯，文具\n> 工作椅   无\n> \n> 如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有 $0$ 个、$1$ 个或 $2$\n> 个附件。每个附件对应一个主件，附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的 $n$ 元。于是，他把每件物品规定了一个重要度，分为\n> $5$ 等：用整数 $1 \\sim 5$ 表示，第 $5$ 等最重要。他还从因特网上查到了每件物品的价格（都是 $10$ 元的整数倍）。他希望在不超过\n> $n$ 元的前提下，使每件物品的价格与重要度的乘积的总和最大。\n> \n> 设第 $j$ 件物品的价格为 $v_j$，重要度为$w_j$，共选中了 $k$ 件物品，编号依次为 $j_1,j_2,\\dots,j_k$，则所求的总和为：\n> \n> $v_{j_1} \\times w_{j_1}+v_{j_2} \\times w_{j_2}+ \\dots +v_{j_k} \\times\n> w_{j_k}$。\n> \n> 请你帮助金明设计一个满足要求的购物单。\n> \n> \n> 输入格式\n> \n> 第一行有两个整数，分别表示总钱数 $n$ 和希望购买的物品个数 $m$。\n> \n> 第 $2$ 到第 $(m + 1)$ 行，每行三个整数，第 $(i + 1)$ 行的整数 $v_i$，$p_i$，$q_i$ 分别表示第 $i$\n> 件物品的价格、重要度以及它对应的的主件。如果 $q_i=0$，表示该物品本身是主件。\n> \n> \n> 输出格式\n> \n> 输出一行一个整数表示答案。\n> \n> \n> 样例 #1\n> \n> \n> 样例输入 #1\n> \n> \n> \n> \n> 样例输出 #1\n> \n> \n> \n> \n> 提示\n> \n> 数据规模与约定\n> \n> 对于全部的测试点，保证 $1 \\leq n \\leq 3.2 \\times 10^4$，$1 \\leq m \\leq 60$，$0 \\leq v_i\n> \\leq 10^4$，$1 \\leq p_i \\leq 5$，$0 \\leq q_i \\leq m$，答案不超过 $2 \\times 10^5$。\n> \n> NOIP 2006 提高组 第二题","routePath":"/posts/algorithm/back_tracing","lang":"","toc":[{"text":"背景","id":"背景","depth":2,"charIndex":-1},{"text":"引四色定理证明","id":"引四色定理证明","depth":2,"charIndex":814},{"text":"回溯法(back tracking)","id":"回溯法back-tracking","depth":2,"charIndex":984},{"text":"回溯法介绍","id":"回溯法介绍","depth":3,"charIndex":1006},{"text":"例题实训","id":"例题实训","depth":3,"charIndex":1100},{"text":"八皇后问题","id":"八皇后问题","depth":4,"charIndex":1107},{"text":"回溯法数独","id":"回溯法数独","depth":4,"charIndex":1845},{"text":"子集","id":"子集","depth":4,"charIndex":2523},{"text":"字母大小写全排列","id":"字母大小写全排列","depth":4,"charIndex":2799},{"text":"背包问题一","id":"背包问题一","depth":4,"charIndex":3048},{"text":"背包问题二","id":"背包问题二","depth":4,"charIndex":4881},{"text":"背包问题三","id":"背包问题三","depth":4,"charIndex":5414}],"domain":"","frontmatter":{"title":"一些回溯相关的刷题记录","date":"2024-01-03T03:45:58.000Z","draft":true,"authors":[],"description":"","tags":["算法","回溯法"],"categories":["在学算法的日子里"],"series":["题解记录"],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"","featuredImagePreview":"","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":8,"title":"Educational Codeforces Round 162(div2)","content":"A-Moving Chips#\n\n\n题意#\n\n每个单元格为空闲或有一个芯片，芯片可以向左移动到最近的空闲处（如果存在空闲格）。\n\n现在有一排单元格，求问进行多少次移动，才能使得所有芯片集中在一起（中间没有空格）。\n\n数据范围#\n\n$t(1≤t≤1000)$\n\n$n(2≤n≤50)$\n\n$a_i(a_i∈{1,0})$\n\n\n思路#\n\n统计数组中第一个1和最后一个1之间的0的数目。\n\n\n参考代码#\n\n\n\n\nB-Monsters Attack!#\n\n\n题意#\n\n玩家位于一维坐标0点处，开始游戏后，每一回合玩家可以向任意两个方向发射总共不多于$k$颗子弹，每个子弹可以造成怪物的血量$a_i$下降1点，降为0后怪物将倒下并\n从坐标上移除。之后，所有怪物超玩家移动一格。如果怪物到达了玩家的位置(即坐标0点)，则游戏失败。\n\n询问是否可能使玩家消灭所有$n$只怪物，不让任何一只怪物靠近玩家。\n\n数据范围#\n\n$t(1≤t≤3\\times 10^4)$\n\n$n,k(1≤n≤3\\times 10^5,1\\le k\\le 2\\times 10^9)$\n\n$a_i(1\\le a_i\\le 10^9)$\n\n$x_i(-n\\le x_1\\lt x_2\\lt\\dots\\lt x_n\\le n;x_i≠0)$\n\n\n思路#\n\n将所有怪物折合成同一个方向，每次玩家向怪物移动一格，每次都使用完所有的$k$颗子弹。遍历模拟，判断是否能在到达最远坐标之前消灭所有怪物。\n\n\n参考代码#\n\n\n\n\nC-Find B#\n\n\n题意#\n\n给一个数组$a$，每次截取一段$[l,r]$的子数组$b$，判断该数组是否可以变化成一个数组$c$，满足：\n\n 1. $\\sum_{i=1}^m b_i=\\sum_{i=1}^m c_i$\n 2. 任意$i∈[l,r]$，都满足$b_i≠c_i$\n 3. 任意$c_i\\gt 0$\n\n数据范围#\n\n$t(1≤t≤10^4)$\n\n$n,q(1≤n,q≤3\\times 10^5)$\n\n$a_i(1\\le a_i\\le 10^9)$\n\n$l_i,r_i(1\\le l_i\\le r_i\\le n)$\n\n\n思路#\n\n预处理数组$a$。\n\n对于子数组$b$，考虑：将所有不为1的数变成1，将所有的1至少再加1。\n\n这样生成的数组$c$是符合要求的。\n\n如果上述操作可以实现总和不变，则可行。\n\n\n参考代码#\n\n","routePath":"/posts/algorithm/cfedu162div2","lang":"","toc":[{"text":"题意","id":"题意","depth":2,"charIndex":17},{"text":"数据范围","id":"数据范围","depth":4,"charIndex":107},{"text":"思路","id":"思路","depth":2,"charIndex":161},{"text":"参考代码","id":"参考代码","depth":2,"charIndex":192},{"text":"题意","id":"题意-1","depth":2,"charIndex":224},{"text":"数据范围","id":"数据范围-1","depth":4,"charIndex":395},{"text":"思路","id":"思路-1","depth":2,"charIndex":550},{"text":"参考代码","id":"参考代码-1","depth":2,"charIndex":626},{"text":"题意","id":"题意-2","depth":2,"charIndex":648},{"text":"数据范围","id":"数据范围-2","depth":4,"charIndex":795},{"text":"思路","id":"思路-2","depth":2,"charIndex":903},{"text":"参考代码","id":"参考代码-2","depth":2,"charIndex":997}],"domain":"","frontmatter":{"title":"Educational Codeforces Round 162(div2)","date":"2024-02-29T06:57:07.000Z","draft":false,"authors":[],"description":"","tags":["算法"],"categories":["在学算法的日子里"],"series":["题解记录"],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"","featuredImagePreview":"","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":9,"title":"Codeforces Round 927(div3)","content":"A-Thorns and Coins#\n\n\n题意#\n\n长度为$n$的单元格路径，每个单元格有空、有金币、荆棘三种可能，人物从最左边开始向右移动，每次步长不多于2格，求能获得的最多金币数。\n\n数据范围#\n\n$t(1≤t≤1000)$\n\n$n(1≤n≤50)$\n\n.代表空，*代表荆棘，@代表金币\n\n\n思路#\n\n从左往右，寻找第一个含有2个以上*的*连通块，其前的金币都可以达到。\n\n\n参考代码#\n\n\n\n\nB-Chaya Calendar#\n\n\n题意#\n\n查亚部落相信世界末日有$n$个征兆，第$i$个征兆每隔$a_i$年出现一次，当观测到第$i-1$个征兆后才会等待第$i$个征兆。给出每个征兆的出现间隔，询问观测\n到所有$n$个征兆所需要的年数。\n\nps:当第$i$个征兆在第$x$年被观测，部落会从第$x+1$年开始等待第$i+1$个征兆。\n\n数据范围#\n\n$t(1≤t≤1000)$\n\n$n(1≤n≤100)$\n\n$a_i(1\\le a_i\\le 10^6)$\n\n\n思路#\n\n第$i$个征兆间隔$a_i$年出现，若上一个征兆在第$x$年被观测，则下一个征兆将在第$y=k\\times a_i$年出现（$x\\lt y\\le\nx+a_i$）。等待的时间是$y-x$，也就是$a_i-x\\text{ }mod\\text{ }a_i$年。\n\n\n参考代码#\n\n\n\n\nC-LR-remainders#\n\n\n题意#\n\n有一个数组$a$，一个正整数$m$和长度为$n$的命令（由L和R组成的字符串），每次求数组中剩余数的积模$m$的余数并输出，然后按照命令删数（L删去最左边的数，\nR删去最右边的数）。\n\n数据范围#\n\n$t(1≤t≤10^4)$\n\n$n,m(1≤n≤2\\times 10^5,1\\le m\\le 10^4)$\n\n$a_i(1\\le a_i\\le 10^4)$\n\n\n思路#\n\n反过来考虑，从最后一个删去的数开始，每次对积乘上上一次被删去的数，记录模m的值，逆序输出。\n\n\n参考代码#\n\n\n\n\nD-Card Game#\n\n\n题意#\n\n纸牌比大小游戏，有四种花色C、D、H、S，同一种花色之间比较数字，数字大的胜出。同时，每局有一个王牌花色，该花色的牌可以比剩余三种花色的牌都大，王牌花色和王牌花\n色之间比较数字大小。\n\n给出所有已经打出的牌，尝试复现对局情况（第二位玩家击败第一位玩家）；如果不能复现，输出IMPOSSIBLE。\n\n数据范围#\n\n$t(1≤t≤100)$\n\n$n(1\\le n \\le 16)$\n\n\n思路#\n\n模拟。\n\n先对不同花色的牌分类，然后遍历同花色的牌，排序后，将非王牌花色放入一个序列，王牌花色单独一个序列。\n\n从非王牌花色序列开始遍历，如果当前牌和其后一牌是同一种花色，凑成一对局；如果不是，用一张王牌花色和它凑成一个对局。假如可以凑成所有的对局，输出这些对局，否则不能\n构成对局。\n\n\n参考代码#\n\n\n\n\nE-Final Countdown#\n\n\n题意#\n\n倒计时，但是每次变化数所需要的秒数等于要变化的数位的数量。\n\n求实际上需要多少秒完成倒计时。\n\n数据范围#\n\n$t(1≤t≤10^4)$\n\n$n(1≤n≤4\\times 10^5)$\n\n$a_i(1\\le a_i\\le 10^4)$\n\n\n思路#\n\n计数模拟：\n\n\n\n则对从第一位开始做前缀和，对(前缀和+进位)倒着取模，最后输出即可。\n\n\n参考代码#\n\n","routePath":"/posts/algorithm/cfround927div3","lang":"","toc":[{"text":"题意","id":"题意","depth":2,"charIndex":21},{"text":"数据范围","id":"数据范围","depth":4,"charIndex":94},{"text":"思路","id":"思路","depth":2,"charIndex":148},{"text":"参考代码","id":"参考代码","depth":2,"charIndex":190},{"text":"题意","id":"题意-1","depth":2,"charIndex":220},{"text":"数据范围","id":"数据范围-1","depth":4,"charIndex":372},{"text":"思路","id":"思路-1","depth":2,"charIndex":434},{"text":"参考代码","id":"参考代码-1","depth":2,"charIndex":569},{"text":"题意","id":"题意-2","depth":2,"charIndex":598},{"text":"数据范围","id":"数据范围-2","depth":4,"charIndex":696},{"text":"思路","id":"思路-2","depth":2,"charIndex":784},{"text":"参考代码","id":"参考代码-2","depth":2,"charIndex":837},{"text":"题意","id":"题意-3","depth":2,"charIndex":862},{"text":"数据范围","id":"数据范围-3","depth":4,"charIndex":1016},{"text":"思路","id":"思路-3","depth":2,"charIndex":1058},{"text":"参考代码","id":"参考代码-3","depth":2,"charIndex":1208},{"text":"题意","id":"题意-4","depth":2,"charIndex":1239},{"text":"数据范围","id":"数据范围-4","depth":4,"charIndex":1292},{"text":"思路","id":"思路-4","depth":2,"charIndex":1363},{"text":"参考代码","id":"参考代码-4","depth":2,"charIndex":1414}],"domain":"","frontmatter":{"title":"Codeforces Round 927(div3)","date":"2024-02-29T06:47:05.000Z","draft":false,"authors":[],"description":"","tags":["算法","CF"],"categories":["在学算法的日子里"],"series":["题解记录"],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"","featuredImagePreview":"","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":10,"title":"Codeforces Round 929(div3)","content":"A-Turtle Puzzle: Rearrange and Negate#\n\n\n题意#\n\n对一个数组执行两个操作：\n\n 1. 对数组进行重新排序或保持元素顺序不变\n 2. 选择连续的一段，对该段中的元素取相反数，也可以不选择任何一段，即保持所有的元素符号不变。\n\n求进行上述操作之后数组的最大和是多少。\n\n数据范围#\n\n$t(1≤t≤1000)$\n\n$n(1≤n≤50)$\n\n$a_i(-100\\le a_i\\le 100)$\n\n\n思路#\n\n遍历数组，对所有的数取非负后相加。\n\n\n参考代码#\n\n\n\n\nB-Turtle Math: Fast Three Task#\n\n\n题意#\n\n有一个数组，可以对数组中的数进行任意次下方两种操作：\n\n 1. 将数移除\n 2. 将该数的数值加1\n\n求至少进行多少次上述操作，可以使数组所有元素之和是3的倍数？\n\n数据范围#\n\n$t(1≤t≤10^4)$\n\n$n(1≤n≤10^5)$\n\n$a_i(1\\le a_i\\le 10^4)$\n\n\n思路#\n\n统计数组$a$中模3为0、1、2的数量和余数总和。记总和为$sum$，余1的数量为$x$，余2的数量为$y$。考虑：\n\n 1. 若$sum$模3为0，则不需要操作\n 2. 若$sum$模3为2，则给任意一个数加1即可，操作1次。\n 3. 若$sum$模3为1，若有余1的数，则去掉这个数即可，否则进行两次加1操作。\n\n\n参考代码#\n\n\n\n\nC-Turtle Fingers: Count the Values of k#\n\n\n题意#\n\n给3个正整数$a,b,l$，找出满足$l=k\\times a^x\\times b^y$的$k$的个数，$k,x,y$均为非负整数。\n\n数据范围#\n\n$t(1≤t≤10^4)$\n\n$a,b,l(2\\le a,b\\le 100,1\\le l\\le 10^6)$\n\n\n思路#\n\n$2^{20}\\gt 10^6$，可知，$x,y$的范围不超过20。\n\n预处理$a^x$和$b^y$，然后暴力遍历即可。\n\n\n参考代码#\n\n\n\n\nD-Turtle Tenacity: Continual Mods#\n\n\n题意#\n\n给数组$a$重新排序，判断是否存在排序使得$a_1 \\text{ }mod\\text{ } a_2 \\text{ }mod\\text{ } a_3\\dots\na_{n-1}\\text{ }mod\\text{ }a_n=0$。\n\n数据范围#\n\n$t(1≤t≤10^4)$\n\n$n(2≤n≤10^5)$\n\n$a_i(1\\le a_i\\le 10^9)$\n\n\n思路#\n\n思考$x\\text{ }mod\\text{ }y$\n\n 1. 如果$x\\lt y$，则结果还是$x$\n 2. 如果$x=y$ ，则结果是0\n\n如果最小的数是唯一的，则一定有解；如果最小的数不唯一，考虑是否有较大的数$z$使得$z\\text{ }mod\\text{\n}x≠0$，如果存在，则有更小的唯一最小值，可以有解，否则无解。\n\n\n参考代码#\n\n\n\n\nE-Turtle vs. Rabbit Race: Optimal Trainings#\n\n\n题意#\n\n训练量$k$是连续一段时间的每天的训练量的总和，每次训练的提高值$u$按照训练次数递减（第1次$u$，第2次$u-1$，第3次$u-2$，...，第$k$次$u\n-k+1$，，提高值可以是负数），每次给定一个起始日$l$和提高值$u$，寻找一个最佳的结束日$r$，使得训练提高值总和最高，如果有多个$r$的结果提供最高训练\n值，选$r$较小的那个。\n\n数据范围#\n\n$t(1≤t≤10^4)$\n\n$n(1≤n≤10^5)$\n\n$a_i(1\\le a_i\\le 10^4)$\n\n$q(1\\le q\\le 10^5)$\n\n$l,u(1\\le l\\le n,1\\le u \\le 10^9)$\n\n\n思路#\n\n训练提高值总量$S$与训练量$k$之间的关系是$S(k)=u\\times k-\\frac{k\\times\n(k-1)}{2}$，是一个关于$k$先增后减的函数，最高值在$k=u+0.5$处取到，由于$k$为整数，$S(k)$的最高值应该在$u$和$u+1$处取到。\n\n 1. 在对称轴左边，二分查找在$[l,u]$的范围内最靠近$u$的$k$的取值，即小于等于$u$的最后一个$k$值。\n 2. 在对称轴右边，二分查找$[u+1,n]$的范围内最靠近$u+1$的$k$值，即大于等于$u+1$的第一个$k$值。\n\n$k$值可以通过前缀和进行筛选，$k=pre[r]-pre[l-1]$，则对$pre$数组进行二分查找$u+pre[l-1]$和$u+1+pre[l-1]$即可\n。\n\n对比这两个值对应的$S(k)$和$r$，以及只在$l$那天训练的效果，择优选择。\n\n\n参考代码#\n\n","routePath":"/posts/algorithm/cfround929div3","lang":"","toc":[{"text":"题意","id":"题意","depth":2,"charIndex":40},{"text":"数据范围","id":"数据范围","depth":4,"charIndex":153},{"text":"思路","id":"思路","depth":2,"charIndex":216},{"text":"参考代码","id":"参考代码","depth":2,"charIndex":241},{"text":"题意","id":"题意-1","depth":2,"charIndex":285},{"text":"数据范围","id":"数据范围-1","depth":4,"charIndex":373},{"text":"思路","id":"思路-1","depth":2,"charIndex":436},{"text":"参考代码","id":"参考代码-1","depth":2,"charIndex":601},{"text":"题意","id":"题意-2","depth":2,"charIndex":654},{"text":"数据范围","id":"数据范围-2","depth":4,"charIndex":726},{"text":"思路","id":"思路-2","depth":2,"charIndex":790},{"text":"参考代码","id":"参考代码-2","depth":2,"charIndex":858},{"text":"题意","id":"题意-3","depth":2,"charIndex":905},{"text":"数据范围","id":"数据范围-3","depth":4,"charIndex":1024},{"text":"思路","id":"思路-3","depth":2,"charIndex":1087},{"text":"参考代码","id":"参考代码-3","depth":2,"charIndex":1259},{"text":"题意","id":"题意-4","depth":2,"charIndex":1316},{"text":"数据范围","id":"数据范围-4","depth":4,"charIndex":1497},{"text":"思路","id":"思路-4","depth":2,"charIndex":1617},{"text":"参考代码","id":"参考代码-4","depth":2,"charIndex":2006}],"domain":"","frontmatter":{"title":"Codeforces Round 929(div3)","date":"2024-02-29T06:56:16.000Z","draft":false,"authors":[],"description":"","tags":["算法","CF"],"categories":["在学算法的日子里"],"series":["题解记录"],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"","featuredImagePreview":"","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":11,"title":"Codeforces Round 930(div2)","content":"A-Shuffle Party#\n\n\n题意#\n\n对一个数组，起初是$a_i=i$\n\n对操作swap(k)：\n\n设$d$是不等于$k$本身的$k$的最大除数，然后交换元素$a_d$和$a_k$。\n\n按顺序对每一个$i=2,3,..,n$进行$swap(i)$之后，找出$1$在数组中的位置。\n\n数据范围#\n\n$t(1≤t≤10^4)$\n\n$n(1≤n≤10^9)$\n\n\n思路#\n\n简单模拟之后可以发现，$a_1=1$最后会挪到不大于$n$的最大2的次幂处。\n\n\n参考代码#\n\n\n\n\nB-Binary Path#\n\n\n题意#\n\n一个$2\\times n$网格，网格充满$0,1$，找一条从$(1,1)$走到$(2,n)$的路径，要求找到字典序最小的路径并找到这个最小路径的路径数。\n\n数据范围#\n\n$t(1≤t≤10^4)$\n\n$n(2≤n≤2\\times 10^5)$\n\n\n思路#\n\n路径的组成是第一行的前部分+第二行的后部分，长度是$n+1$。对从第一行到第二行的转折的位置进行枚举，假设往后一位可以获得字典序更小的则重新计数，若相同则累计路\n径数，若不同则代表没有更好的路径。\n\n\n参考代码#\n\n\n\n\nC-Bitwise Operation Wizard#\n\n\n题意#\n\n交互题。\n\n对一个神秘序列$p_0,p_1,...,p_{n-1}$（是${0,1,...,n-1}$的排列组合）。我们通过询问需要获得$p_i\\oplus\np_j$最大的一个$(i,j)$对。\n\n每次询问任意索引$(a,b,c,d)$评审团计算$x=(p_a|p_b)$和$y=(p_c|p_d)$，并告知是$x\\lt y,x\\gt\ny$还是$x=y$。最多使用$3n$个查询。\n\n数据范围#\n\n$t(1≤t≤1000)$\n\n$n(2≤n≤10^4)$\n\n\n思路#\n\n先两两比较找到最大的数，再找到与最大的数异或的结果最大的另一个数。\n\n\n参考代码#\n\n","routePath":"/posts/algorithm/cfround930div2","lang":"","toc":[{"text":"题意","id":"题意","depth":2,"charIndex":18},{"text":"数据范围","id":"数据范围","depth":4,"charIndex":145},{"text":"思路","id":"思路","depth":2,"charIndex":183},{"text":"参考代码","id":"参考代码","depth":2,"charIndex":229},{"text":"题意","id":"题意-1","depth":2,"charIndex":256},{"text":"数据范围","id":"数据范围-1","depth":4,"charIndex":339},{"text":"思路","id":"思路-1","depth":2,"charIndex":385},{"text":"参考代码","id":"参考代码-1","depth":2,"charIndex":491},{"text":"题意","id":"题意-2","depth":2,"charIndex":531},{"text":"数据范围","id":"数据范围-2","depth":4,"charIndex":728},{"text":"思路","id":"思路-2","depth":2,"charIndex":766},{"text":"参考代码","id":"参考代码-2","depth":2,"charIndex":807}],"domain":"","frontmatter":{"title":"Codeforces Round 930(div2)","date":"2024-03-13T04:26:38.000Z","draft":false,"authors":[],"description":"","tags":["算法","CF"],"categories":["在学算法的日子里"],"series":["题解记录"],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"","featuredImagePreview":"","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":12,"title":"Codeforces Round 931(div2)","content":"A-Too Min Too Max#\n\n\n题意#\n\n对一个数组，找到索引$(i,j,k,l)$使得$|a_i-a_j|+|a_j-a_k|+|a_k-a_l|+|a_l-a_i|$最大的值。\n\n数据范围#\n\n$t(1≤t≤500)$\n\n$n(4≤n≤100)$\n\n$a_i(-10^6\\le a_i\\le 10^6)$\n\n\n思路#\n\n选则最大的两个数和最小的两个数，结果为最大-最小+次大-最小+最大-次小+次大-次小。\n\n\n参考代码#\n\n\n\n\nB-Yet Another Coin Problem#\n\n\n题意#\n\n有一些5种不同面值的金币，面值有：$1,3,6,10,15$。找到使用金币数目最少的组合方式达到数值为$n$的组合。\n\n数据范围#\n\n$t(1≤t≤10^4)$\n\n$n(1≤n≤10^9)$\n\n\n思路#\n\n打表。\n\n\n参考代码#\n\n\n\n\nC-Find a Mine#\n\n\n题意#\n\n交互题。\n\n$n\\times m$的地图有两个地雷，每次询问一个坐标点，评审机会返回距离询问点最近的地雷的与询问点的曼哈顿距离。\n\n数据范围#\n\n$t(1≤t≤3\\times 10^3)$\n\n$n,m (2≤n≤10^8,2\\le m\\le 10^8)$\n\n\n思路#\n\n第一次询问可以获得一条斜线，斜线上至少有一个地雷。\n\n第二次询问可能可以找到正好一个交点，这个交点可能正好是地雷或者是两个地雷的行列序号的组合。再做第三次询问，得到两个交点至少有一个是地雷。第四次询问即可排除。\n\n\n参考代码#\n\n","routePath":"/posts/algorithm/cfround931div2","lang":"","toc":[{"text":"题意","id":"题意","depth":2,"charIndex":20},{"text":"数据范围","id":"数据范围","depth":4,"charIndex":96},{"text":"思路","id":"思路","depth":2,"charIndex":161},{"text":"参考代码","id":"参考代码","depth":2,"charIndex":212},{"text":"题意","id":"题意-1","depth":2,"charIndex":252},{"text":"数据范围","id":"数据范围-1","depth":4,"charIndex":317},{"text":"思路","id":"思路-1","depth":2,"charIndex":355},{"text":"参考代码","id":"参考代码-1","depth":2,"charIndex":366},{"text":"题意","id":"题意-2","depth":2,"charIndex":393},{"text":"数据范围","id":"数据范围-2","depth":4,"charIndex":464},{"text":"思路","id":"思路-2","depth":2,"charIndex":528},{"text":"参考代码","id":"参考代码-2","depth":2,"charIndex":641}],"domain":"","frontmatter":{"title":"Codeforces Round 931(div2)","date":"2024-03-13T04:26:22.000Z","draft":false,"authors":[],"description":"","tags":["算法","CF"],"categories":["在学算法的日子里"],"series":["题解记录"],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"","featuredImagePreview":"","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":13,"title":"Codeforces Round 932(div2)","content":"A-Entertainment in MAC#\n\n\n题意#\n\n可以对一个字符串进行两种操作：\n\n 1. 将字符串反转\n 2. 将该字符串反转后接在原串的后面。\n\n可以进行任意次上述操作，获得字典序最小的字符串。\n\n数据范围#\n\n$t(1≤t≤500)$\n\n$n(2≤n≤10^9)$\n\n$s(1\\le |s|\\le 100)$\n\n\n思路#\n\n对比反转前后的字符串字典序大小，再决定是操作1还是操作2\n\n\n参考代码#\n\n\n\n\nB-Informatics in MAC#\n\n\n题意#\n\n$MEX$：不属于该数组的最小非负整数。\n\n对一个数组分成$k$个子段，要求每段的$MEX$都等于相同的数。\n\n找到这样的子段分法，或者报告不存在合法的分法。\n\n数据范围#\n\n$t(1≤t≤10^4)$\n\n$n(2≤n≤10^5)$\n\n$a_i(0\\le a_i\\lt n)$\n\n\n思路#\n\n假设$MEX=2$，则分成$k$段的方式为前$k-1$段只要都出现过$0,1$就进行分段，最后一段保证含$0,1$和达到第$n$个数。\n\n确定$MEX$：遍历数组$a$，找到最小的没有出现过的数（该数不大于$n$），该数即为$MEX$。\n\n\n参考代码#\n\n\n\n\nD-Exam in MAC#\n\n\n题意#\n\n有一个集合$s$。\n\n找到满足$0\\le x\\le y\\le c$且$x+y$和$y-x$均不包含在集合$s$中的整数对$(x,y)$的个数。\n\n数据范围#\n\n$t(1≤t≤2\\times 10^4)$\n\n$n(1≤n≤3\\times 10^5)$\n\n$c(1\\le c\\le 10^9)$\n\n\n思路#\n\n容斥。\n\n合格的整数对=满足$x+y\\in s$+满足$y-x\\in s$-既满足$x+y\\in s$又满足$y-x\\in s$。\n\n\n参考代码#\n\n","routePath":"/posts/algorithm/cfround932div2","lang":"","toc":[{"text":"题意","id":"题意","depth":2,"charIndex":25},{"text":"数据范围","id":"数据范围","depth":4,"charIndex":106},{"text":"思路","id":"思路","depth":2,"charIndex":165},{"text":"参考代码","id":"参考代码","depth":2,"charIndex":201},{"text":"题意","id":"题意-1","depth":2,"charIndex":235},{"text":"数据范围","id":"数据范围-1","depth":4,"charIndex":321},{"text":"思路","id":"思路-1","depth":2,"charIndex":381},{"text":"参考代码","id":"参考代码-1","depth":2,"charIndex":507},{"text":"题意","id":"题意-2","depth":2,"charIndex":534},{"text":"数据范围","id":"数据范围-2","depth":4,"charIndex":612},{"text":"思路","id":"思路-2","depth":2,"charIndex":687},{"text":"参考代码","id":"参考代码-2","depth":2,"charIndex":760}],"domain":"","frontmatter":{"title":"Codeforces Round 932(div2)","date":"2024-03-13T04:26:06.000Z","draft":false,"authors":[],"description":"","tags":["算法","CF"],"categories":["在学算法的日子里"],"series":["题解记录"],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"","featuredImagePreview":"","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":14,"title":"Codeforces Round 933(div3)","content":"A-Rudolf and the Ticket#\n\n\n题意#\n\n左边口袋有一些面值为$b_1,b_2,b_3,...,b_n$的硬币，右边有一些面值为$c_1,c_2,c_3,...,c_m$的硬币，问有多少个$(f,s)$\n可以使得$b_f+c_s\\le k$成立\n\n数据范围#\n\n$t(1≤t≤100)$\n\n$n,m(1≤n,m≤100)$\n\n$k(1\\le k\\le 2000)$\n\n$b_i,c_i(1\\le b_i,c_i\\le 1000)$\n\n\n思路#\n\n双层循环遍历\n\n\n参考代码#\n\n\n\n\nB-Rudolf and 121#\n\n\n题意#\n\n可以对一个数组执行如下操作：\n\n选中一个索引$i(2\\le i\\le n-1)$：\n\n * $a_{i-1}=a_{i-1}-1$\n * $a_i=a_i-2$\n * $a_{i+1}=a_{i+1}-1$\n\n询问是否可以通过这个运算使得所有元素变为0\n\n数据范围#\n\n$t(1≤t≤10^4)$\n\n$n(3≤n≤2\\times 10^5)$\n\n$a_i(0\\leq a_i\\le 10^9)$\n\n\n思路#\n\n从左向右遍历，若有大于0的数则对其进行置零，且更新其后一位和两位的数值，直到出现负数或无法执行为止。检查操作后的$a$数组是否符合要求\n\n\n参考代码#\n\n\n\n\nC-Rudolf and the Ugly String#\n\n\n题意#\n\n对字符串$s$，询问至少需要多少次删除字符的操作可以使得字符串中没有子段$map$和$pie$。\n\n数据范围#\n\n$t(1≤t≤10^4)$\n\n$n(1≤n≤10^6)$\n\n\n思路#\n\n先查询子段$mapie$的数量，并删去字符$p$，再对剩下的字符串中存在的$map$和$pie$进行计数。\n\n\n参考代码#\n\n\n\n\nD-Rudolf and the Ball Game#\n\n\n题意#\n\n扔球游戏，$n$个人围成一圈，每次球可以选择顺时针或逆时针传球$r_i(1\\le r_i \\le\nn-1)$个单位，已知起始球的位置和每次传递的距离，以及部分时刻传球的方向。询问最后球到了谁的手上。\n\n数据范围#\n\n$t(1≤t≤10^4)$\n\n$n,m(1≤n≤1000,1\\le m\\le 1000)$\n\n$x(1\\le x\\le n)$\n\n$r_i(1\\le r_i\\le n-1)$\n\n\n思路#\n\n按题意模拟即可，每次记录球的所有可能位置，并更新。\n\n\n参考代码#\n\n\n\n\nE-Rudolf and k Bridges#\n\n\n题意#\n\n需要在一条河上建桥，每个位置建立桥墩的花费是$a_{i,j}+1$，$a_{i+j}$是到水面的深度。桥要求宽为$k$，任意两个桥墩的距离不能超过$d$，桥的首\n尾都需要有支架。\n\n数据范围#\n\n$t(1≤t≤1000)$\n\n$n,k(1≤k\\le n≤100)$\n\n$m(3\\le m\\le 2\\times 10^5)$\n\n\n思路#\n\n对每一行进行DP，可以获得每一行建桥的最小花费。再对其求前缀和，找到总花费最小的连续$k$段。\n\n进行DP状态转移时，需要优先选中距离不大于$d$的桥墩点中，花费最小的桥墩。\n\n\n参考代码#\n\n","routePath":"/posts/algorithm/cfround933div3","lang":"","toc":[{"text":"题意","id":"题意","depth":2,"charIndex":26},{"text":"数据范围","id":"数据范围","depth":4,"charIndex":134},{"text":"思路","id":"思路","depth":2,"charIndex":228},{"text":"参考代码","id":"参考代码","depth":2,"charIndex":242},{"text":"题意","id":"题意-1","depth":2,"charIndex":272},{"text":"数据范围","id":"数据范围-1","depth":4,"charIndex":405},{"text":"思路","id":"思路-1","depth":2,"charIndex":477},{"text":"参考代码","id":"参考代码-1","depth":2,"charIndex":552},{"text":"题意","id":"题意-2","depth":2,"charIndex":594},{"text":"数据范围","id":"数据范围-2","depth":4,"charIndex":649},{"text":"思路","id":"思路-2","depth":2,"charIndex":687},{"text":"参考代码","id":"参考代码-2","depth":2,"charIndex":748},{"text":"题意","id":"题意-3","depth":2,"charIndex":788},{"text":"数据范围","id":"数据范围-3","depth":4,"charIndex":894},{"text":"思路","id":"思路-3","depth":2,"charIndex":991},{"text":"参考代码","id":"参考代码-3","depth":2,"charIndex":1024},{"text":"题意","id":"题意-4","depth":2,"charIndex":1060},{"text":"数据范围","id":"数据范围-4","depth":4,"charIndex":1156},{"text":"思路","id":"思路-4","depth":2,"charIndex":1229},{"text":"参考代码","id":"参考代码-4","depth":2,"charIndex":1324}],"domain":"","frontmatter":{"title":"Codeforces Round 933(div3)","date":"2024-03-13T04:25:46.000Z","draft":false,"authors":[],"description":"","tags":["算法","CF"],"categories":["在学算法的日子里"],"series":["题解记录"],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"","featuredImagePreview":"","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":15,"title":"Codeforces Round 977 (Div. 2, based on COMPFEST 16 - Final Round)","content":"A. Meaning Mean#\n\n\n题意#\n\n可以选择 2 个不同的索引$i,j$，将数组中这两个索引对应的数删除，然后将$\\lfloor \\frac{a_i+a_j}{2}\n\\rfloor$添加到数组的最后。可知到最后只会剩下一个数，最大化最后剩余的这个数$x$，并输出。\n\n数据范围#\n\n * $2\\leq n \\leq 50$\n * $1\\leq a_i\\leq 10^9$\n\n\n思路#\n\n考虑三个数$a\\lt b\\lt c$时，按照各种顺序合并的情况下，$\\lfloor \\frac{\\lfloor \\frac{a+b}{2}\n\\rfloor+c}{2}\\rfloor$是最好的操作。\n\n\n参考代码#\n\n\n\n\nB. Maximize Mex#\n\n\n题意#\n\n对一个给定的数组$a$和给定的数$x$，可以进行如下操作：\n\n * 选择一个索引，$a_i:=a_i + x$。\n\n可以执行这个操作任意次，询问这个数组最大的$MEX$值是多少。\n\n数据范围#\n\n * $1\\leq t\\leq 5000$\n * $1\\leq n\\leq 2\\times 10^5$\n * $0\\leq x\\leq 10^9$\n\n\n思路#\n\n赛后再交发现 T 了...剪枝优化了一下。\n\n首先容易观察到，$a_i:=a_i + x$的操作不会改变$a_i$所属的模$x$的同余系，在把$a$按照模$x$的值进行分组之后，对每个组，check\n对应集合中是否能满足$[1, n-1]$的范围内的$a_i$都存在，遍历时，计数$a_i=k\\times x + (a_i \\mod\nx)$的$k$的数量，如果$k$从$0$到$\\lfloor \\frac{n-1}{x}\\rfloor + ((n-1) \\mod x >= a_i \\mod\nx)$每一位都满足$\\sum_0^{k_i} cnt[k_i] \\gt k_i$，则说明同余集合中到$ki\\times x+a_i\\mod\nx$的值都是可以满足的。\n\n最后检测一下$vis$数组，寻找$mex$。\n\n\n参考代码#\n\n\n\n\nC. Adjust The Presentation (Easy Version && Hard Version)#\n\n\n题意#\n\n$n$个人排成一队，依次播放$m$张幻灯片，当一个人播放过幻灯片之后，可以重新将他插入任意的位置，或者留在队首播放下一张幻灯片。每张幻灯片都有一个最佳播放者，如\n果所有的幻灯片都由其最佳播放者播放，则整个播放是完美的，输出YA，否则输出TIDAK。询问是否可以通过调整，使得所有的幻灯片都完美播放。\n\n同时支持$q$次修改幻灯片的最佳播放者，询问每次修改之后的播放效果，输出YA或TIDAK。\n\n数据范围#\n\n * $1 \\leq t\\leq 10^4$\n * $1\\leq n,m \\leq 2\\times 10^5$\n * $0\\leq q\\leq 2\\times 10^5$\n * $1\\leq a_i,b_i\\leq n$\n * $1\\leq s_i\\leq m,1\\leq t_i\\leq n$\n\n\n思路#\n\n幻灯片$i$是否能被最佳播放者播放，只需要保证其播放者$s_i$在播放$i$时或之前出现，也就是说，如果数组$b$中每个编号最先出现的次序排序后，若恰好是$a$\n的前缀，则是可以满足的。\n\n差分数组计数$a$数组中第$i$个数$a[i]$在$b$中最先出现次序排序后的次序是否大于等于前一个数，即是否上升。利用$set$更新$b$中每个编号最先出现的\n位置。\n\n每次$b_{s_i}:=t_i$操作后，更新检查编号$b[s_i]$前后编号的新次序是否合法（与$a$中$b[s_i]$的前一位置的编号的最早位置相比是否上升）\n，编号$t_i$前后是否合法，更新$diff$数组和$sum$值。\n\n\n\n\nD. Boss, Thirsty#\n\n\nE1. Digital Village (Easy Version) && (Hard Version)#\n\n\n题意#\n\n居民房屋构成一个无向图，包含$n$个点$m$条边，其中$p$户需要网络服务，可以在任意的房屋中安置交换机，房屋$s_i$与交换机所在房屋$s_j$之间的延迟是$\ns_i$到$s_j$的简单路径上最大的延迟。可以任意选择放置交换机的位置，询问在逐渐增加交换机的过程中，所有需要网络服务的居民的最小总延迟。\n\n数据范围#\n\n * $1\\leq t \\leq 2000$\n * $2\\leq n,\\leq 5000$\n * $n-1\\leq m \\leq 5000$\n * $1\\leq p \\leq n$\n * $1\\leq s\\leq n$\n * $1\\leq u_i\\lt w_i\\leq n;1\\leq w_i\\leq 10^9$\n\n\n思路#\n\n\n参考代码#","routePath":"/posts/algorithm/cfround977div2","lang":"","toc":[{"text":"题意","id":"题意","depth":2,"charIndex":18},{"text":"数据范围","id":"数据范围","depth":4,"charIndex":139},{"text":"思路","id":"思路","depth":2,"charIndex":193},{"text":"参考代码","id":"参考代码","depth":2,"charIndex":299},{"text":"题意","id":"题意-1","depth":2,"charIndex":328},{"text":"数据范围","id":"数据范围-1","depth":4,"charIndex":424},{"text":"思路","id":"思路-1","depth":2,"charIndex":507},{"text":"参考代码","id":"参考代码-1","depth":2,"charIndex":867},{"text":"题意","id":"题意-2","depth":2,"charIndex":938},{"text":"数据范围","id":"数据范围-2","depth":4,"charIndex":1141},{"text":"思路","id":"思路-2","depth":2,"charIndex":1298},{"text":"题意","id":"题意-3","depth":2,"charIndex":1679},{"text":"数据范围","id":"数据范围-3","depth":4,"charIndex":1837},{"text":"思路","id":"思路-3","depth":2,"charIndex":2003},{"text":"参考代码","id":"参考代码-2","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"title":"Codeforces Round 977 (Div. 2, based on COMPFEST 16 - Final Round)","subtitle":"","date":"2024-10-25T06:57:19.000Z","lastmod":"2024-10-25T06:57:19.000Z","draft":false,"authors":[],"description":"Codeforces Round 977 (Div. 2, based on COMPFEST 16 - Final Round)","tags":["算法","CF"],"categories":["在学算法的日子里"],"series":["题解记录"],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"https://img.dodolalorc.cn/i/2024/12/10/67580a1859420.jpeg","featuredImagePreview":"https://img.dodolalorc.cn/i/2024/12/10/67580a1859420.jpeg","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":16,"title":"Codeforces Round 980 (Div. 2)","content":"A. Profitable Interest Rate#\n\n\n题意#\n\n有两种储值方式——无利可图和盈利，“盈利”可以保证盈利，但是有最低储值要求，“无利可图”类型没有利息，但是可以让“盈利”的最低储值降低。在“无利可图”储值$x$\n元，可以让“盈利”的最低值要求降低$2\\times\nx$元，最低储值不能低于$0$元，两种储值均不能取出。现在Alice拥有$a$元，并想使存入“盈利”的金额越多越好，求Alice最多存入多少“盈利”类型的金额。\n\n数据范围#\n\n * $1\\leq t\\leq 10^4$\n * $1\\leq a,b\\leq 10^9$\n\n\n思路#\n\n假设存入$x$元在“无利可图”，则“盈利”的最低储值降为$b-2\\times\nx$，此时如果Alice的剩余金额$a-x$可以达到最低储值，则答案为$a-x$，否则为$0$，最小化$x$即可。\n\n\n参考代码#\n\n\n\n\nB. Buying Lemonade#\n\n\n题意#\n\n柠檬水售卖机有$n$个按钮，但是无法辨认每个按钮对应的槽位还剩多少柠檬水，购买者知道每个槽位最初的柠檬水数量，每按下一个按钮，如果该按钮对应的槽位还有柠檬水，则\n可以售出$1$瓶柠檬水，若槽位为空，则将没有任何东西掉出来。现在需要精确购买$k$瓶柠檬水，保证柠檬水售卖机里有足够的柠檬水，即$\\sum_{i=1}^{n}\na_i \\ge k$。求问最少的可以保证达成任务的点击次数。\n\n数据范围#\n\n * $1\\leq t\\leq 10^4$\n * $1\\leq n\\leq 2\\times 10^5$\n * $1\\leq k\\leq 10^9$\n * $1\\leq a_i\\leq 10^9$\n\n$n$之和不超过$2\\times 10^5$。\n\n\n思路#\n\n基本的贪心购买思路是一直按同一个按钮，直到该槽位为空，考虑到购买$k$瓶至少需要$k$次基本点击，我们需要最小化会浪费的点击次数，即点空槽位的次数。\n\n假设当前每个槽位都至少有$2$瓶柠檬水，我们想最小化点空的次数，最好先把每个按钮都点击$2$次，如果此时的总数足够$k$，我们就计数次数，否则去掉空槽位（通过\n1 次点击去除），我们要继续最小化。\n\n二分在每个按钮点击的次数，查询能买到的柠檬水总数，计数最少的次数，即第一个满足总数大于等于$k$的那个次数。\n\n\n参考代码#\n\n\n\n\nC. Concatenation of Arrays#\n\n\n题意#\n\n有$n$个二元组，将这些二元组重新排序后让序列的逆序数最小，输出排序后的结果。\n\n数据范围#\n\n * $1\\leq t\\leq 10^4$\n * $1\\leq n\\leq 10^5$\n * $1\\leq a_{i,j}\\leq 10^9$\n\n\n思路#\n\n排序，将二元组按照两数之和、第一位数、第二位数的优先级顺序从小到大排序。\n\n\n参考代码#\n\n\n\n\nD. Skipping#\n\n\n题意#\n\n问答系统，对第$i$个题，如果选择回答，可以获得$a_i$分数，接下来只能选择序号$j\\lt i$且没有操作过的问题。也可以选择跳过，接下来可以选择$j\\leq\nb_i$的未操作过的题目。从$1$号问题开始回答。\n\n\n思路#\n\n注意到，当跳到索引$i$时，所有$1\\leq k\\leq i$的没有回答过的题目，都可以通过依次回答。我们只需要贪心的选择前置和-到达某个位置的最小代价即可。\n\n考虑用一个全局$multiset$维护当前可以使用的代价，从$1$号问题开始，每个问题的$b_i$指向一个到$b_i+1$会“失效”的最小代价，每次移动时去除失\n效代价，并加入新的最小代价，维护最大得分即可。\n\n维护时可以注意到$b_i\\leq i$的跳题没有意义，不如直接向前答题，可以通过判断去除这种移动。\n\n\n参考代码#\n\n","routePath":"/posts/algorithm/cfround980div2","lang":"","toc":[{"text":"A. Profitable Interest Rate","id":"a-profitable-interest-rate","depth":2,"charIndex":-1},{"text":"题意","id":"题意","depth":3,"charIndex":30},{"text":"数据范围","id":"数据范围","depth":4,"charIndex":224},{"text":"思路","id":"思路","depth":3,"charIndex":279},{"text":"参考代码","id":"参考代码","depth":3,"charIndex":383},{"text":"B. Buying Lemonade","id":"b-buying-lemonade","depth":2,"charIndex":393},{"text":"题意","id":"题意-1","depth":3,"charIndex":415},{"text":"数据范围","id":"数据范围-1","depth":4,"charIndex":613},{"text":"思路","id":"思路-1","depth":3,"charIndex":745},{"text":"参考代码","id":"参考代码-1","depth":3,"charIndex":983},{"text":"C. Concatenation of Arrays","id":"c-concatenation-of-arrays","depth":2,"charIndex":993},{"text":"题意","id":"题意-2","depth":3,"charIndex":1023},{"text":"数据范围","id":"数据范围-2","depth":4,"charIndex":1069},{"text":"思路","id":"思路-2","depth":3,"charIndex":1150},{"text":"参考代码","id":"参考代码-2","depth":3,"charIndex":1194},{"text":"D. Skipping","id":"d-skipping","depth":2,"charIndex":1204},{"text":"题意","id":"题意-3","depth":3,"charIndex":1219},{"text":"思路","id":"思路-3","depth":3,"charIndex":1333},{"text":"参考代码","id":"参考代码-3","depth":3,"charIndex":1577}],"domain":"","frontmatter":{"title":"Codeforces Round 980 (Div. 2)","subtitle":"","date":"2024-11-26T06:28:27.000Z","lastmod":"2024-11-26T06:28:27.000Z","draft":false,"authors":null,"description":"","tags":["算法","CF"],"categories":["在学算法的日子里"],"series":["题解记录"],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"https://img.dodolalorc.cn/i/2024/12/10/67580e4ad64c9.png","featuredImagePreview":"https://img.dodolalorc.cn/i/2024/12/10/67580e4ad64c9.png","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":17,"title":"Codeforces Round 990 (Div. 2)","content":"A. Alyona and a Square Jigsaw Puzzle#\n\n\n题意#\n\nAlyona按照顺时针围绕第一个拼图放置拼图，Alyona每天会按顺序放置一定数量的拼图，如果一天结束时拼图的组装部分没有任何已开始但未完成的层，Alyona会\n感到开心。给出每天放置拼图的数量，询问Alyona感到快乐的天数。\n\n数据范围#\n\n * $1\\leq t\\leq 500$\n * $1\\leq n\\leq 100$\n * $1\\leq a_i\\leq 100,a_1=1$\n\n\n思路#\n\n检查每天完成添加拼图时的总拼图数是否恰好是一个奇数的平方数，若是则该天会感到快乐。\n\n\n代码#\n\n\n\n\nB. Replace Character#\n\n\n题意#\n\n在一个长度为$n$的字符串中，执行一次这样的操作：\n\n * 选择两个索引$i,j(1\\leq i,j\\leq n)$，可以选择$i = j$。\n * 进行赋值$s_i:=s_j$。\n\n要求输出在进行该操作之后，字典序最小的那个字符串。\n\n数据范围#\n\n * $1\\leq t\\leq 500$\n * $1\\leq n\\leq 10$\n\n\n思路#\n\n将其中一个数量最少的字母改成数量最多的字母，不过这个题数据范围很小，也可以直接暴力。\n\n\n代码#\n\n\n\n\nC. Swap Columns and Find a Path#\n\n\n题意#\n\n在一个$2\\times\nn$的矩阵中，从$(1,1)$走到$(2,n)$点，只能向右和向下走，每个位置上有一个$a_{i,j}$的分数，需要最大化路径上的总分。可以支持任意次这样的操作\n：\n\n * 选择两列$i,j$，将列$i$和列$j$进行交换，即$swap(a_{1,i},a_{1,j})$和$swap(a_{2,i},a_{2,j})$.\n\n请执行最大化路径上的数之和，并输出这个总和。\n\n数据范围#\n\n * $1\\leq t\\leq 5000$\n * $1\\leq n\\leq 5000$\n * $-10^5\\leq a_{i,j}\\leq 10^5$\n\n\n思路#\n\n观察可知，选择的路径长度固定是$n+1$，由于只能向右或者向下走，实际的路径的形状一定是在第一行取前一段，再再第二行取后一段，对每列进行排序后贪心的选择最大的一\n组合法的数即可。\n\n书写的时候判断转折的一列时，也可以反向先算出$2\\times\nn$个数的总和，再贪心的减掉$n-1$个较小的数，注意只有转折的地方一列的两个数都能取到，而其他位置的数只能取一个值。\n\n\n代码#\n\n\n\n\nD. Move Back at a Cost#\n\n\n题意#\n\n给出一个长度为$n$的数组$a$，可以执行如下操作：\n\n * 选择一个索引$i$，将$a_i+1$添加到数组的末尾，并删去$a_i$。\n\n可以执行这样的操作任意次，请输出字典序最小的操作之后的数组$a$。\n\n数据范围#\n\n * $1\\leq t\\leq 10^4$\n * $1\\leq n\\leq 10^5$\n * $1\\leq a_i\\leq 10^9$\n\n\n思路#\n\n尽量保留原数组中从小到达排列的数，将其中不符合单调性的点挪到数组的后面，不要让这些将挪到数组后面的数再次挪动。\n\n维护一个全局的multiset，记录所有需要挪动的数字，将这些数+1 后依次添加到原来数组生成的有序序列的后面。\n\n\n代码#\n\n","routePath":"/posts/algorithm/cfround990div2","lang":"","toc":[{"text":"A. Alyona and a Square Jigsaw Puzzle","id":"a-alyona-and-a-square-jigsaw-puzzle","depth":2,"charIndex":-1},{"text":"题意","id":"题意","depth":3,"charIndex":39},{"text":"数据范围","id":"数据范围","depth":4,"charIndex":160},{"text":"思路","id":"思路","depth":3,"charIndex":240},{"text":"代码","id":"代码","depth":3,"charIndex":289},{"text":"B. Replace Character","id":"b-replace-character","depth":2,"charIndex":297},{"text":"题意","id":"题意-1","depth":3,"charIndex":321},{"text":"数据范围","id":"数据范围-1","depth":4,"charIndex":445},{"text":"思路","id":"思路-1","depth":3,"charIndex":495},{"text":"代码","id":"代码-1","depth":3,"charIndex":545},{"text":"C. Swap Columns and Find a Path","id":"c-swap-columns-and-find-a-path","depth":2,"charIndex":553},{"text":"题意","id":"题意-2","depth":3,"charIndex":588},{"text":"数据范围","id":"数据范围-2","depth":4,"charIndex":792},{"text":"思路","id":"思路-2","depth":3,"charIndex":877},{"text":"代码","id":"代码-2","depth":3,"charIndex":1066},{"text":"D. Move Back at a Cost","id":"d-move-back-at-a-cost","depth":2,"charIndex":1074},{"text":"题意","id":"题意-3","depth":3,"charIndex":1100},{"text":"数据范围","id":"数据范围-3","depth":4,"charIndex":1209},{"text":"思路","id":"思路-3","depth":3,"charIndex":1286},{"text":"代码","id":"代码-3","depth":3,"charIndex":1407}],"domain":"","frontmatter":{"title":"Codeforces Round 990 (Div. 2)","subtitle":"","date":"2024-12-05T11:27:40.000Z","lastmod":"2024-12-05T11:27:40.000Z","draft":false,"authors":null,"description":null,"tags":["算法","CF"],"categories":["在学算法的日子里"],"series":["题解记录"],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"https://img.dodolalorc.cn/i/2024/12/10/67580e40e3ea7.png","featuredImagePreview":"https://img.dodolalorc.cn/i/2024/12/10/67580e40e3ea7.png","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":18,"title":"计算几何模板","content":"> 试着用计算机来解决几何问题吧(●'◡'●)\n\n\n前置知识#\n\n * 几何基础\n * 平面直角坐标系\n * 极坐标与极坐标系\n * 向量（向量积）\n\n\n二维计算几何基础#\n\n\n图形的表示#\n\n\n点与线的表示#\n\n例图：\n\n\n\n\n\n\n距离与旋转#\n\n例图：\n\n\n\n\n\n向量旋转解析#\n\n设$\\vec{a}=(x,y)$，倾角为$\\theta$，长度为$l=\\sqrt{x^2+y^2}$。则$x=l\\cos{\\theta},y=l\\sin{\\th\neta}$，顺时针旋转后得到$\\vec{b}=(l\\cos{\\theta+\\alpha},l\\sin{\\theta+\\alpha})$ 。\n\n三角恒等变化：\n\n$$ \\vec{b}=(\\cos{(\\theta+\\alpha)}l,\\sin{(\\theta+\\alpha)}l) $$\n\n$$\n=(l(\\cos{\\theta}\\cos{\\alpha-sin{\\theta}sin{\\alpha}}),l(\\sin{\\theta}\\cos{\\alpha}+\n\\sin{\\alpha}\\cos{\\theta})) $$\n\n$$ =(x \\cos{\\alpha-y \\sin{\\alpha},y \\cos{\\alpha}+x \\sin{\\alpha}}) $$\n\n\n点积与叉积#\n\n例图：\n\n\n\n\n\n * 点积：也叫数量积、内积。几何意义是一个向量在另一个向量上的投影再乘第二个向量的模长，是一个实数，有交换律。\n   * 若同向($\\theta = 0°$)，为模长之积。\n   * 若锐角($\\theta \\lt 90°$)，数量积为正\n   * 若直角($\\theta = 90°$)，数量积为 0\n   * 若钝角($\\theta \\gt 90°$)，数量积为负\n   * 若反向($\\theta = 180°$)，为模长之积的相反数\n * 叉积：也叫外积，几何意义是两向量围成的平面四边形的面积。是一个向量，其方向$\\vec{a}\\times\n   \\vec{b}$：用右手从$\\vec{a}$沿着不大于平角的方向向$\\vec{b}$ 旋转，拇指方向是外积的方向。没有交换律。\n   * 若平行，外积为$\\vec{0}$\n   * 共起点后，对于$\\vec{a}\\times\n     \\vec{b}$，若$\\vec{a}$在$\\vec{b}$的右侧，外积为正，否则外积为负（以纸面为参考，$\\vec{a}$往$\\vec{b}$是逆时针\n     为正，顺时针为负）\n\n由向量外积可以判断两向量的旋转关系、方便求出点到直线的距离。适用于凸包和旋转卡壳。\n\n观察两个式子：\n\n * 投影：$dot=|A||B|\\cosθ$\n\n * 面积：$det=|A||B|\\sinθ$\n\n可以发现点积与叉积的正负由角度决定，故根据点积和叉积的正负，可以判断向量夹角的象限。\n\n\n\n\n\n\n判等判交求交#\n\n\n浮点数等于零#\n\n注意浮点数的精度误差，一般用sgn()来实现相等判断\n\n\n\n\n点判等#\n\n也是一样要注意精度捏\n\n\n\n\n点在线段上#\n\n点在线段上有两个要求：\n\n * 点在直线上：叉积判断共线\n * 点在两端点上：点积判断方向\n\n\n\n\n\n * 叉乘为 0 则共线(0° 或 180°)\n\n注意：可能需要处理线段退化的情况：线段退化时直接调用会返回true。\n\n线段退化情况在调用之前自行判断。\n\n\n线段判交#\n\n线段有交的两种情况：\n\n * 一条线段的端点在另一条线段上。\n * 互相严格跨立。\n\n第一种使用point_on_segment()处理；\n\n第二种用叉积判断角度异号。\n\n\n\n\n\n几种测试情况思考：\n\n   \n   \n\n\n直线求交#\n\n求两条直线的交点\n\n直线和直线的位置关系有三种：\n\n 1. 平行\n 2. 有一个交点\n 3. 重合(共线)\n\n判断位置关系#\n\n思路：\n\n\n\n判断平行(包括重合)：叉积是否为 0\n\n\n\n判断共线：平行且交换端点后也平行\n\n\n\n两直线相交求交点#\n\n使用面积计算等高三角形底边的比例求交点。\n\n注意：这里使用了除法，除法会导致精度严重下降(通常 epsilon 就是为了克服除法的误差而引入的)\n\n\n\n这里$\\triangle ABC$与$\\triangle ABD$共底，面积之比（叉积之比）即为 CK 与 KD 的长度之比。则：\n\n对$K(k_x,k_y),C(c_x,c_y),D(d_x,d_y)$，有：\n\n$$ CK=\\frac{u}{u+v}CD $$\n\nso：K 是 CD 的一个定比分点。\n\n\n\n\n射线求交（留思考#\n\n两条射线之间的位置关系：\n\n 1. 平行（不重合）\n 2. 共线同向（部分重合或完全重合）\n 3. 共线反向且不重合\n 4. 共线反向且部分重合\n 5. 相交\n\n求交点#\n\n两条射线如果有相交交点的话（情况 5），这个交点一定是两条射线所在直线的交点，用前文的方法求即可。\n\n判断相交#\n\n对于射线来说，若有交点，则交点一定在两条射线所在直线上，射线可以看作其所在直线的一部分，那么只要判断这个交点是否同时在两条射线的延长线方向即可。\n\n\n距离#\n\n\n点到线段距离#\n\n点到线短距离有两种情况：\n\n 1. 垂线段长度\n 2. 到某个端点的距离\n\n * 注意线段退化问题\n\n\n\n\n凸包#\n\n能包含所有给定点的最小凸多边形的叫做凸包\n\n * 凸多边形：每个内角在$[0,\\pi)$内的简单多边形；如果允许非严格则是$[0,\\pi]$\n * 或者，点集所有可能的带权平均点集合为凸包。\n\n\n求凸包#\n\n有两种求法：Graham 算法和Andrew 算法，两种算法的时间复杂度都是$O(n\\log n)$。区别在于对点的排序方式不同。\n\n\nAndrew 算法#\n\n对点的排序方法：按照$x$为第一关键字，$y$为第二关键字，对点集进行排序，排序完成后，易知：第 1 个点和第 n 个点一定在凸包点集里。\n\n可以分别求出下凸壳和上凸壳，求上下两半时也不会互相影响。\n\n算法：用栈来维护在凸包上的点\n\n * 逆时针先求下凸壳：第 1 个点和第 2\n   个先入栈，当加入更多点时，设栈中的倒数第二个点为$A$，最后一个点为$B$，新加入的点为$C$，若$B$在$\\vec{AC}$的左边(或在线上)，则将$B\n   $弹出，令$C$入栈。\n * 接下来依然是逆时针求上凸壳，上述求下凸包时，最后入栈的点一定是$n$号点，在加入$n-1$\n   号点后，我们继续上一步的一模一样的操作：判断旧点和新向量的位置关系再做取舍。\n * 注意，求上凸壳的时候依然是遍历到 1 号点，此时会有首尾相同，点重复的问题。\n\n凸包的周长：($k$为凸包中点的个数)\n\n$$ C=\\sum_{i=0}^{i=k-1}dis(p_{i},p_{(i+1) \\mod{k}}) $$\n\n模版代码：\n\n\n\n\nGraham 算法#\n\n取左下角的点为基准，对其余点进行逆时针排序。\n\n * 由于其他点相对于基准点在$[0,\\pi )$的半平面内，因此可以直接使用叉积排序\n * 不要使用atan2：当值域很大时，精度难以区分相近的点\n * 注意处理极角序相同的点：按照到基准点的距离从小到大排序。\n\n用一根细线尝试绕过所有点。\n\n * 需要弹出不满足凸性的点\n * 使用单调栈实现\n\n\n\n\n两种算法相比#\n\nGraham 不够好：相对较慢，容易写错\n\n * 相对较慢：排序需要计算$O(n\\log n)$次叉积。\n * 任意写错：细节比较多，任意出现挂边界的情况。\n\nAndrew 算法扫描两遍计算出上下凸壳，通常在效率和实现上相比 Graham 有优势。\n\n凸包典题：\n\n[P2742 USACO5.1] 圈奶牛 Fencing the Cows /【模板】二维凸包 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n\n[P3829 SHOI2012] 信用卡凸包 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n\n\n三分#\n\n二分要求单调性，最基本的应用是求一个单调函数的零点。\n\n三分是二分的变种，它的基本用途是求单峰函数的极值点。\n\n三分的原理：以求极大值为例。每次对一个区间$[l,r]$求三等分点$lp$和$rp$：\n\n * 如果$f(lp)\\lt\n   f(rp)$，说明极大值一定在$[lp,r]$内取到，因为如果在$[0,lp]$内，那$rp$一定处于单调下降的区间内，它的函数值不可能大于$f(lp)$\n   ，于是我们令$l=lp$\n * 如果$f(lp)\\gt f(rp)$，同理，极大值一定在$[l,rp]$内取到，令$r=rp$\n\n这样进行下去，直到$fabs(l-r)\\lt eps$ 为止，如果是求极小值，只需要把处于判断处的大于小于互换。\n\n\n\n\n优化#\n\n按照上面的算法，每次减少三分之一的长度，但其实还可以通过在中点附近取点来优化，这样每次可以减少约二分之一的长度。\n\n\n\n\n题单部分#\n\n\n基础#\n\n * Problem - B. Balloon Darts\n\n * P1652 圆 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n\n * P1257 平面上的最接近点对 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n\n * P1142 轰炸 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n\n * P1355 神秘大三角 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn) // 这题莫名卡输入格式，坏！\n\n一些子问题 Q\n\n * 如何求一组点中用一条直线穿过的最多的点数？$O(n^3)$做法、$O(n^2logm)$做法\n\n\n难一些的#\n\n * Panda Preserve - Problem - QOJ.ac\n\n * Convex Hull Extension - Problem - QOJ.ac\n\n * Minimum Euclidean Distance - Problem - QOJ.ac\n\n\n模版代码#\n\n","routePath":"/posts/algorithm/geometry","lang":"","toc":[{"text":"图形的表示","id":"图形的表示","depth":2,"charIndex":88},{"text":"点与线的表示","id":"点与线的表示","depth":3,"charIndex":97},{"text":"距离与旋转","id":"距离与旋转","depth":3,"charIndex":116},{"text":"向量旋转解析","id":"向量旋转解析","depth":4,"charIndex":133},{"text":"点积与叉积","id":"点积与叉积","depth":3,"charIndex":552},{"text":"判等判交求交","id":"判等判交求交","depth":2,"charIndex":1210},{"text":"浮点数等于零","id":"浮点数等于零","depth":3,"charIndex":1220},{"text":"点判等","id":"点判等","depth":3,"charIndex":1260},{"text":"点在线段上","id":"点在线段上","depth":3,"charIndex":1281},{"text":"线段判交","id":"线段判交","depth":3,"charIndex":1420},{"text":"直线求交","id":"直线求交","depth":3,"charIndex":1538},{"text":"判断位置关系","id":"判断位置关系","depth":4,"charIndex":1600},{"text":"两直线相交求交点","id":"两直线相交求交点","depth":4,"charIndex":1658},{"text":"射线求交（留思考","id":"射线求交留思考","depth":3,"charIndex":1901},{"text":"求交点","id":"求交点","depth":4,"charIndex":1993},{"text":"判断相交","id":"判断相交","depth":4,"charIndex":2050},{"text":"距离","id":"距离","depth":2,"charIndex":2132},{"text":"点到线段距离","id":"点到线段距离","depth":3,"charIndex":2138},{"text":"求凸包","id":"求凸包","depth":2,"charIndex":2304},{"text":"Andrew 算法","id":"andrew-算法","depth":3,"charIndex":2378},{"text":"Graham 算法","id":"graham-算法","depth":3,"charIndex":2847},{"text":"两种算法相比","id":"两种算法相比","depth":3,"charIndex":3036},{"text":"优化","id":"优化","depth":2,"charIndex":3649},{"text":"基础","id":"基础","depth":3,"charIndex":3723},{"text":"难一些的","id":"难一些的","depth":3,"charIndex":4029}],"domain":"","frontmatter":{"title":"计算几何模板","date":"2024-03-09T13:54:39.000Z","lastmod":"2024-03-12T10:28:00.000Z","draft":true,"authors":[],"description":"","tags":["算法","计算几何","算法模板"],"categories":["在学算法的日子里"],"series":["算法模板笔记"],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"","featuredImagePreview":"","toc":{"enable":true},"math":{"enable":true},"lightgallery":true,"license":""},"version":""},{"id":19,"title":"图论基础||存储图||DFS、BFS(图论)","content":"1.1图的定义#\n\n上课讲过一大堆这里不再赘述，直接学习代码实现。\n\n\n1.2图的存储#\n\n例图展示：\n\n\n\n设n个点，m条边\n\n上图的数据（按照 起点-终点-权值）：\n\n\n\n邻接矩阵#\n\n * 遍历效率低、不能存重边、初始化效率低初始化O(n^2)时间，建图O(m)时间、空间开销大O(n^2)\n * 对于稀疏图来说大部分是INF，空间利用效率也不高\n\n前向星#\n\n前向星涉及排序，所以其时间复杂度和排序算法有关，一般情况下时间复杂度为O(mlog\nm)，空间上需要两个数组（记录边的边数组、记录各点在边数组中起始位置的head数组），空间复杂度为O(m+n)\n\n优点：在点特别多时可以存储重边\n\n缺点：不能直接判断任意两个点之间是否有边。排序和初始化数组费时间。\n\n需要的数据结构如下：\n\n\n\nNODE用来存储每条边的信息，边按照输入读取后再排序，排序之后使用head[maxn]来储存各个点的在edge[maxm]里的起始位置。\n\n排序方式：\n\n\n\n完整代码：\n\n\n\n邻接表#\n\n图的一种链式存储结构，把图G中所有邻接于v~i~的顶点链接成为一个v~i~的单链表。\n\n三种实现方法：\n\n1. 动态建表#\n\n动态建表的时间效率是O(m)，空间效率是O(m)，主要的时间损耗在于不断地申请新空间，且判断任意两个点之间是否有边相连的效率也低（需要搜索各个点的单链表）(感觉\n还好？)。\n\n数据结构：\n\n\n\n完整代码：\n\n\n\n注意到，无向图中各点的度正好是各点的单链表中链节的个数，也就是上述代码中ind最后的结果值，而之余有向图，ind就是对应顶点的出度。\n\n若要求得入度则必须遍历整个邻接表或者建立一个逆链接表（以v~i~边为终边的链接表）。\n\n注意：一个图 的邻接表不是唯一的，其具体的邻接次序与边的输入次序有关。\n\n2. vector模拟链表实现#\n\nvector模拟链表的实现方式与前一种区别不大（前插入和后插入的区别？反正基本没有质变）\n\n不过这种方式代码量少，不容易出错，也不用指针指来指去。也不需要我们来考虑内存的申请和释放。比较友好（qwq）\n\n需要数据结构：\n\n\n\n完整代码：\n\n\n\n3. ★★★静态建表（链式前向星）#\n\n邻接表的静态建表存储图的方式也称链式前向星，基于前向星，以提高构造效率为目的设计的存储方式，最终形成的数据是一个变形的邻接表。\n\n链式前向星采用数组模拟链表的方式实现邻接表的功能，使用很少的额外空间，是目前建图和遍历效率最高的存储方式。\n\n数据结构：\n\n\n\n数组模拟链表的主要方式是记录下一节点的位置在整个数组的位置坐标，并将这个标志坐标存在一个head数组中，遍历时根据输入的边的信息更新head对应的更新位置，并将\n原来的节点信息存在此时读入的边的next数据中。\n\n存值方式：\n\n\n\n完整代码：\n\n\n\n除了不能直接用起点终点确定是否有边外，链式前向星几乎是完美的。\n\n\n1.3图的遍历#\n\n从v~0~出发系统的访问图G中所有的顶点，每个顶点访问一次，称为图的遍历。\n\n深度优先遍历#\n\n从一个节点开始，按照连接，访问到最后一个没有被访问的顶点，然后再从顺序上没有被访问的分路继续访问到最深处，如此循环至全部被访问。\n\n深度优先样例代码：\n\n\n\n完整代码：\n\n\n\n注意：这里还是使用强推的链式前向星数据结构来储存图，因为边在读入的时候是前插入，所以后读入的边会先被遍历。\n\n广度优先遍历#\n\n广度优先就是先访问顶点v~0~的所有边的终点，然后再访问第一条边往下延续的未被访问的顶点（第一条边往下没有就第二条边...如此搜索）\n\n广度优先用到了队列来记录遍历某顶点广度时，遍历的这个终点的下一点(next)是否被遍历，如果未被遍历则标记入队，等待当前顶点按照广度优先被遍历完终点后从该队列中\n获得下一轮被遍历的点。\n\n广度优先样例代码：\n\n（啊啊啊突然发现拼错单词了，其实队列的单词是queue，不过在c++里引用了stl容器还用queue命名不太好吧(虽然没影响)...不管了！算了，还是改过来吧Q\nAQ）\n\n\n\n完整代码：\n\n\n\n * 深度优先和广度优先都是通过边来搜索检查邻边是否被遍历到，所以时间复杂度相同，不过访问序列不同。","routePath":"/posts/algorithm/graph_basic","lang":"","toc":[{"text":"1.1图的定义","id":"11图的定义","depth":3,"charIndex":-1},{"text":"1.2图的存储","id":"12图的存储","depth":3,"charIndex":35},{"text":"邻接矩阵","id":"邻接矩阵","depth":4,"charIndex":87},{"text":"前向星","id":"前向星","depth":4,"charIndex":177},{"text":"邻接表","id":"邻接表","depth":4,"charIndex":436},{"text":"1.3图的遍历","id":"13图的遍历","depth":3,"charIndex":1208},{"text":"深度优先遍历","id":"深度优先遍历","depth":4,"charIndex":1257},{"text":"广度优先遍历","id":"广度优先遍历","depth":4,"charIndex":1409}],"domain":"","frontmatter":{"title":"图论基础||存储图||DFS、BFS(图论)","date":"2024-01-06T06:15:17.000Z","draft":false,"tags":["图论","算法","算法模板"],"categories":["在学算法的日子里"],"series":["算法模板笔记"],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"","featuredImagePreview":"","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":20,"title":"2024杭电钉耙编程联赛Day1||补题","content":"1001-循环位移#\n\n$(709/3775)$\n\n\n题意#\n\n将字符串$S=S_0+S_1+S_2+...+S_{n-1}$循环位移$k$次后得到$S(k)=S_{k\\bmod n\n}+...+S_{n-1}+S+0+...+S_{(k-1)\\bmod n}$。\n\n定义$[A]={A(k),k\\in N}$。给出$T$组串$A,B$，询问$B$有多少个子串在$[A]$ 中。\n\n数据范围#\n\n * $|A|\\leq |B|$\n * $\\sum|B|\\leq 1048576$\n\n\n思路#\n\n思路1：字符串哈希#\n\n记字符串$A$的长度是$n$，将字符串$A$转变为首尾相连的样子（$A=A+A.substr(1,n-1)$），并计算其中每个长度为$n$的哈希值，用map存值\n，再对字符串$B$进行哈希，同样也对长度为$n$的子串计算哈希值，若有符合的则计数。\n\n\n代码#\n\n代码1：字符串哈希#\n\n\n\n\n1002-星星#\n\n$(991/1659)$\n\n\n题意#\n\n小$A$有$n$次获得星星的机会，第$i$次有如下5种选择：\n\n * 跳过\n * $a_i$的代价获得$1$颗星星\n * $b_i$的代价获得$2$颗星星\n * $c_i$的代价获得$3$颗星星\n * $d_i$的代价获得$4$颗星星\n\n请问若想恰好获得$k$颗星星，所需要的最小代价是多少。\n\n数据范围#\n\n * $1\\leq n\\leq 1000$\n * $0\\leq k\\leq n\\times 4$\n * $0\\lt a_i\\leq b_i\\leq c_i\\leq d_i\\leq 10^9$\n\n\n思路#\n\n基础的动态规划。记$dp[i]$表示获得$i$颗星星的最小代价。\n\n\n代码#\n\n\n\n\n1008-位运算#\n\n$(918/1427)$\n\n\n题意#\n\n有多少在范围$[0,2^k)$中的$a,b,c,d$构成的四元组$(a,b,c,d)$满足$a \\& b\\oplus c | d=n$。\n\n数据范围#\n\n * $1\\leq T\\leq 10$\n * $1\\leq k\\leq 15,0\\leq n\\lt 2^k$\n\n\n思路#\n\n记$x=a \\& b\\oplus c |\nd$，$x$的每一位只有1和0的可能，而每位上的数字只和$a,b,c,d$对应位是$1$或$0$有关，枚举四个数的$1/0$，统计$x$是$0$的组合和是$1$\n的组合的数量。再根据$n$的$k$位进行统计即可。\n\n\n代码#\n\n\n\n\n1012-并#\n\n$(241/1229)$\n\n\n题意#\n\n给出在二维平面上的$n$个矩形，随机选择$k$个不同的矩形$(k\\in [1,n])$，求这$k$个矩形所有覆盖部分的并集的面积的期望。\n\n数据范围#\n\n * $1\\leq n\\leq 2\\times 10^3$\n * $1\\leq x_{i,1}\\lt x_{i,2} \\leq 10^9$\n * $1\\leq y_{i,1}\\lt y_{i,2} \\leq 10^9$\n\n\n思路#\n\n将横纵坐标离散化之后可以将这$n$个矩形覆盖的部分分割成不重叠的若干个小矩形，每个小矩形设置权值，代表被原来的$n$个矩形覆盖的次数。设某个小矩形的覆盖次数是$\nm$，则在选择$k$个矩形时，这个小矩形的贡献是：$\\frac{\\binom{k}{n}-\\binom{k}{n-m}}{\\binom{k}{n}}$（全集-选\n除该矩形以外的部分），预处理离散后的矩形以及被覆盖$m$次的所有矩形的总面积，枚举计数即可。\n\n\n代码#\n\n","routePath":"/posts/algorithm/hdu24sd1","lang":"","toc":[{"text":"1001-循环位移","id":"1001-循环位移","depth":2,"charIndex":-1},{"text":"题意","id":"题意","depth":3,"charIndex":26},{"text":"数据范围","id":"数据范围","depth":4,"charIndex":190},{"text":"思路","id":"思路","depth":3,"charIndex":241},{"text":"思路1：字符串哈希","id":"思路1字符串哈希","depth":4,"charIndex":246},{"text":"代码","id":"代码","depth":3,"charIndex":384},{"text":"代码1：字符串哈希","id":"代码1字符串哈希","depth":4,"charIndex":389},{"text":"1002-星星","id":"1002-星星","depth":2,"charIndex":404},{"text":"题意","id":"题意-1","depth":3,"charIndex":429},{"text":"数据范围","id":"数据范围-1","depth":4,"charIndex":582},{"text":"思路","id":"思路-1","depth":3,"charIndex":687},{"text":"代码","id":"代码-1","depth":3,"charIndex":727},{"text":"1008-位运算","id":"1008-位运算","depth":2,"charIndex":735},{"text":"题意","id":"题意-2","depth":3,"charIndex":761},{"text":"数据范围","id":"数据范围-2","depth":4,"charIndex":836},{"text":"思路","id":"思路-2","depth":3,"charIndex":900},{"text":"代码","id":"代码-2","depth":3,"charIndex":1035},{"text":"1012-并","id":"1012-并","depth":2,"charIndex":1043},{"text":"题意","id":"题意-3","depth":3,"charIndex":1067},{"text":"数据范围","id":"数据范围-3","depth":4,"charIndex":1142},{"text":"思路","id":"思路-3","depth":3,"charIndex":1261},{"text":"代码","id":"代码-3","depth":3,"charIndex":1477}],"domain":"","frontmatter":{"title":"2024杭电钉耙编程联赛Day1||补题","subtitle":"","date":"2024-07-19T11:08:39.000Z","lastmod":"2024-07-19T11:08:39.000Z","draft":false,"authors":[],"description":"","tags":["算法","杭电","2024暑假集训"],"categories":["在学算法的日子里"],"series":["题解记录"],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"","featuredImagePreview":"","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":21,"title":"刷题记录||区间动态规划","content":"区间动态规划一般以区间作为动态规划的阶段。\n\n\n[P1880]石子合并#\n\n\n题目描述#\n\n在一个圆形操场的四周摆放 $N$ 堆石子，现要将石子有次序地合并成一堆，规定每次只能选相邻的 $2$\n堆合并成新的一堆，并将新的一堆的石子数，记为该次合并的得分。\n\n试设计出一个算法,计算出将 $N$ 堆石子合并成 $1$ 堆的最小得分和最大得分。\n\n输入格式\n\n数据的第 $1$ 行是正整数 $N$，表示有 $N$ 堆石子。\n\n第 $2$ 行有 $N$ 个整数，第 $i$ 个整数 $a_i$ 表示第 $i$ 堆石子的个数。\n\n输出格式\n\n输出共 $2$ 行，第 $1$ 行为最小得分，第 $2$ 行为最大得分。\n\n样例 #1\n\n样例输入 #1\n\n\n\n样例输出 #1\n\n\n\n提示\n\n$1\\leq N\\leq 100$，$0\\leq a_i\\leq 20$ 。\n\n\n思路#\n\n考虑状态转移：\n\n每次合并区间$[l,r]$时，可以由区间$[l,k]$和$[k+1,r]$的状态转移过来，记$f(i,j)$是合并区间$[i,j]$的最大得分，$sum(i,j\n)$是合并$[i,j]$的得分，则有： $$ f(i,j)=max(f(i,j),f(i,k)+f(k+1,j)+sum(i,j)) $$\n此题考虑到是环形数组，可以将数组复制一倍，枚举区间长度是$n$的最优值。\n\n\n代码#\n\n\n\n\n[P3146]248G#\n\n\n题面翻译#\n\n给定一个 $1\\ \\times n$ 的地图，在里面玩 $2048$，每次可以合并相邻两个（数值范围 $1\\sim\n40$），问序列中出现的最大数字的值最大是多少。注意合并后的数值并非加倍而是 $+1$，例如 $2$ 与 $2$ 合并后的数值为 $3$。\n\n\n题目描述#\n\nBessie likes downloading games to play on her cell phone, even though she\ndoesfind the small touch screen rather cumbersome to use with her large hooves.\n\nShe is particularly intrigued by the current game she is playing.The game starts\nwith a sequence of $N$ positive integers ($2 \\leq N\\leq 248$), each in the range\n$1 \\ldots 40$. In one move, Bessie cantake two adjacent numbers with equal\nvalues and replace them a singlenumber of value one greater (e.g., she might\nreplace two adjacent 7swith an 8). The goal is to maximize the value of the\nlargest numberpresent in the sequence at the end of the game. Please help\nBessiescore as highly as possible!\n\n输入格式\n\nThe first line of input contains $N$, and the next $N$ lines give the sequence\n\nof $N$ numbers at the start of the game.\n\n输出格式\n\nPlease output the largest integer Bessie can generate.\n\n样例 #1\n\n样例输入 #1\n\n\n\n样例输出 #1\n\n\n\n提示\n\nIn this example shown here, Bessie first merges the second and third 1s to\n\nobtain the sequence 1 2 2, and then she merges the 2s into a 3. Note that it is\n\nnot optimal to join the first two 1s.\n\n\n思路#\n\n区间dp，考虑转移： $$ f(i,j)=f(i,k)+1\\quad when:f(i,k)=f(k+1,j) $$\n同时要保证$f(i,k)$和$f(k+1,j)$在向$f(i,j)$转移之前，已经进行了\"合并\"。\n\n\n代码#\n\n\n\n\n[NOIP2006 提高组] 能量项链#\n\n\n题目描述#\n\n在 Mars 星球上，每个 Mars 人都随身佩带着一串能量项链。在项链上有 $N$\n颗能量珠。能量珠是一颗有头标记与尾标记的珠子，这些标记对应着某个正整数。并且，对于相邻的两颗珠子，前一颗珠子的尾标记一定等于后一颗珠子的头标记。因为只有这样，通\n过吸盘（吸盘是 Mars 人吸收能量的一种器官）的作用，这两颗珠子才能聚合成一颗珠子，同时释放出可以被吸盘吸收的能量。如果前一颗能量珠的头标记为\n$m$，尾标记为 $r$，后一颗能量珠的头标记为 $r$，尾标记为 $n$，则聚合后释放的能量为 $m \\times r \\times n$（Mars\n单位），新产生的珠子的头标记为 $m$，尾标记为 $n$。\n\n需要时，Mars\n人就用吸盘夹住相邻的两颗珠子，通过聚合得到能量，直到项链上只剩下一颗珠子为止。显然，不同的聚合顺序得到的总能量是不同的，请你设计一个聚合顺序，使一串项链释放出的\n总能量最大。\n\n例如：设 $N=4$，$4$ 颗珠子的头标记与尾标记依次为 $(2,3)(3,5)(5,10)(10,2)$。我们用记号 $\\oplus$\n表示两颗珠子的聚合操作，$(j \\oplus k)$ 表示第 $j,k$ 两颗珠子聚合后所释放的能量。则第 $4$，$1$ 两颗珠子聚合后释放的能量为：\n\n$(4 \\oplus 1)=10 \\times 2 \\times 3=60$。\n\n这一串项链可以得到最优值的一个聚合顺序所释放的总能量为：\n\n$(((4 \\oplus 1) \\oplus 2) \\oplus 3)=10 \\times 2 \\times 3+10 \\times 3 \\times 5+10\n\\times 5 \\times 10=710$。\n\n输入格式\n\n第一行是一个正整数 $N$（$4 \\le N \\le 100$），表示项链上珠子的个数。第二行是 $N$ 个用空格隔开的正整数，所有的数均不超过\n$1000$。第 $i$ 个数为第 $i$ 颗珠子的头标记（$1 \\le i \\le N$），当 $i\n\n至于珠子的顺序，你可以这样确定：将项链放到桌面上，不要出现交叉，随意指定第一颗珠子，然后按顺时针方向确定其他珠子的顺序。\n\n输出格式\n\n一个正整数 $E$（$E\\le 2.1 \\times 10^9$），为一个最优聚合顺序所释放的总能量。\n\n样例 #1\n\n样例输入 #1\n\n\n\n样例输出 #1\n\n\n\n提示\n\nNOIP 2006 提高组 第一题\n\n\n思路#\n\n将数组处理成环形数组，考虑转移： $$ f(i,j)=max(f(i,j),f(i,k)+f(k+1,j)+head[i]\\times\ntail[k]\\times tail[j]) $$ 枚举长度为$n$的区间，获得最大值。\n\n\n代码#\n\n\n\n\n[NOIP2007 提高组] 矩阵取数游戏#\n\n\n题目描述#\n\n帅帅经常跟同学玩一个矩阵取数游戏：对于一个给定的 $n \\times m$ 的矩阵，矩阵中的每个元素 $a_{i,j}$ 均为非负整数。游戏规则如下：\n\n 1. 每次取数时须从每行各取走一个元素，共 $n$ 个。经过 $m$ 次后取完矩阵内所有元素；\n 2. 每次取走的各个元素只能是该元素所在行的行首或行尾；\n 3. 每次取数都有一个得分值，为每行取数的得分之和，每行取数的得分 = 被取走的元素值 $\\times 2^i$，其中 $i$ 表示第 $i$ 次取数（从\n    $1$ 开始编号）；\n 4. 游戏结束总得分为 $m$ 次取数得分之和。\n\n帅帅想请你帮忙写一个程序，对于任意矩阵，可以求出取数后的最大得分。\n\n输入格式\n\n输入文件包括 $n+1$ 行：\n\n第一行为两个用空格隔开的整数 $n$ 和 $m$。\n\n第 $2\\sim n+1$ 行为 $n \\times m$ 矩阵，其中每行有 $m$ 个用单个空格隔开的非负整数。\n\n输出格式\n\n输出文件仅包含 $1$ 行，为一个整数，即输入矩阵取数后的最大得分。\n\n样例 #1\n\n样例输入 #1\n\n\n\n样例输出 #1\n\n\n\n提示\n\n【数据范围】\n\n对于 $60%$ 的数据，满足 $1\\le n,m\\le 30$，答案不超过 $10^{16}$。\n\n对于 $100%$ 的数据，满足 $1\\le n,m\\le 80$，$0\\le a_{i,j}\\le1000$。\n\n【题目来源】\n\nNOIP 2007 提高第三题。\n\n\n思路#\n\n设置$f(i,j)$表示取区间$[i,j]$获得的最大得分，根据题意可知，每行的最大值之间并不相关，可以分别计算每行取数得分的最大值再相加，注意此题涉及到高精度\n。\n\n考虑转移：\n\n$f(i,j)$可以由两种状态转移而来，一种是先取$a[i]$，再取$f(i+1,j)$，这时的得分是$f(i+1,j)\\times 2 +\na[i]\\times 2$；另一种是先取$a[j]$，再取$f(i,j-1)$，这时的得分是$f(i,j-1)\\times 2+a[j]\\times\n2$。两者取较大值即可。\n\n\n代码#\n\n\n\n\n[CQOI2007] 涂色#\n\n\n题目描述#\n\n假设你有一条长度为 $5$ 的木板，初始时没有涂过任何颜色。你希望把它的 $5$ 个单位长度分别涂上红、绿、蓝、绿、红色，用一个长度为 $5$\n的字符串表示这个目标：$\\texttt{RGBGR}$。\n\n每次你可以把一段连续的木板涂成一个给定的颜色，后涂的颜色覆盖先涂的颜色。例如第一次把木板涂成 $\\texttt{RRRRR}$，第二次涂成\n$\\texttt{RGGGR}$，第三次涂成 $\\texttt{RGBGR}$，达到目标。\n\n用尽量少的涂色次数达到目标。\n\n输入格式\n\n输入仅一行，包含一个长度为 $n$ 的字符串，即涂色目标。字符串中的每个字符都是一个大写字母，不同的字母代表不同颜色，相同的字母代表相同颜色。\n\n输出格式\n\n仅一行，包含一个数，即最少的涂色次数。\n\n样例 #1\n\n样例输入 #1\n\n\n\n样例输出 #1\n\n\n\n样例 #2\n\n样例输入 #2\n\n\n\n样例输出 #2\n\n\n\n提示\n\n$40%$ 的数据满足 $1\\le n\\le 10$。\n\n$100%$ 的数据满足 $1\\le n\\le 50$。\n\n\n思路#\n\n设$f(i,j)$表示完成区间$[i,j]$的最小涂色次数。取$i\\leq k\\lt\nj$则$f(i,j)$可以由$f(i,k)$和$f(k+1,j)$合并转移而来，转移时，若$s[k]=s[k+1]$，显然在区间$[i,k]$中涂位置$k$和涂\n位置$k+1$可以是同一步操作；若$s[i]=s[j]$，则涂位置$i$和$j$也可以是同一步操作，则转移方程如下： $$\nf(i,j)=f(i,k)+f(k+1,j)-(s[i]==s[j] \\or s[k]==s[k+1]) $$\n\n\n代码#\n\n\n\n\n[SCOI2003] 字符串折叠#\n\n\n题目描述#\n\n折叠的定义如下：\n\n 1. 一个字符串可以看成它自身的折叠。记作 S = S\n\n 2. X(S) 是 $X$ 个 S 连接在一起的串的折叠。记作 X(S) = SSSS…S。\n\n 3. 如果 A = A’, B = B’，则 AB = A’B’ 。例如：因为 3(A) = AAA, 2(B) = BB，所以 3(A)C2(B) =\n    AAACBB，而 2(3(A)C)2(B) = AAACAAACBB\n\n给一个字符串，求它的最短折叠。\n\n例如 AAAAAAAAAABABABCCD 的最短折叠为：9(A)3(AB)CCD。\n\n输入格式\n\n仅一行，即字符串 S，长度保证不超过 $100$。\n\n输出格式\n\n仅一行，即最短的折叠长度。\n\n样例 #1\n\n样例输入 #1\n\n\n\n样例输出 #1\n\n\n\n提示\n\n一个最短的折叠为：2(NEERC3(YES))\n\n\n思路#\n\n设$f(i,j)$是区间$[i,j]$折叠之后的最短长度，如果区间$[i,j]$可以被折叠，则状态转移： $$\nf(i,j)=max(f(i,j),f(i,k)+2+Len((j-i+1)/(k-i+1))) $$\n\n\n代码#\n\n","routePath":"/posts/algorithm/intervaldp","lang":"","toc":[{"text":"[P1880]石子合并","id":"p1880石子合并","depth":2,"charIndex":23},{"text":"题目描述","id":"题目描述","depth":3,"charIndex":38},{"text":"思路","id":"思路","depth":3,"charIndex":378},{"text":"代码","id":"代码","depth":3,"charIndex":582},{"text":"[P3146]248G","id":"p3146248g","depth":2,"charIndex":590},{"text":"题面翻译","id":"题面翻译","depth":3,"charIndex":605},{"text":"题目描述","id":"题目描述-1","depth":3,"charIndex":742},{"text":"思路","id":"思路-1","depth":3,"charIndex":1824},{"text":"代码","id":"代码-1","depth":3,"charIndex":1940},{"text":"[NOIP2006 提高组] 能量项链","id":"noip2006-提高组-能量项链","depth":2,"charIndex":1948},{"text":"题目描述","id":"题目描述-2","depth":3,"charIndex":1971},{"text":"思路","id":"思路-2","depth":3,"charIndex":3012},{"text":"代码","id":"代码-2","depth":3,"charIndex":3132},{"text":"[NOIP2007 提高组] 矩阵取数游戏","id":"noip2007-提高组-矩阵取数游戏","depth":2,"charIndex":3140},{"text":"题目描述","id":"题目描述-3","depth":3,"charIndex":3165},{"text":"思路","id":"思路-3","depth":3,"charIndex":3812},{"text":"代码","id":"代码-3","depth":3,"charIndex":4069},{"text":"[CQOI2007] 涂色","id":"cqoi2007-涂色","depth":2,"charIndex":4077},{"text":"题目描述","id":"题目描述-4","depth":3,"charIndex":4094},{"text":"思路","id":"思路-4","depth":3,"charIndex":4564},{"text":"代码","id":"代码-4","depth":3,"charIndex":4813},{"text":"[SCOI2003] 字符串折叠","id":"scoi2003-字符串折叠","depth":2,"charIndex":4821},{"text":"题目描述","id":"题目描述-5","depth":3,"charIndex":4841},{"text":"思路","id":"思路-5","depth":3,"charIndex":5229},{"text":"代码","id":"代码-5","depth":3,"charIndex":5344}],"domain":"","frontmatter":{"title":"刷题记录||区间动态规划","date":"2024-09-11T13:50:26.000Z","draft":false,"authors":[],"description":"","tags":["算法","DP"],"categories":["在学算法的日子里"],"series":["题解记录"],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"https://img.dodolalorc.cn/i/2024/12/10/67580ba9b1658.png","featuredImagePreview":"https://img.dodolalorc.cn/i/2024/12/10/67580ba9b1658.png","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":22,"title":"刷题记录||背包动态规划","content":"👾背包动态规划#\n\n背包动态规划是线性动态规划中特殊的一类，NOIP中考到的次数也不少。\n\n\n🍊[P1048]采药#\n\n\n> [NOIP2005 普及组] 采药\n> \n> \n> 题目描述\n> \n> 辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都\n> 是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药\n> 。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”\n> \n> 如果你是辰辰，你能完成这个任务吗？\n> \n> \n> 输入格式\n> \n> 第一行有 $2$ 个整数 $T$（$1 \\le T \\le 1000$）和 $M$（$1 \\le M \\le 100$），用一个空格隔开，$T$\n> 代表总共能够用来采药的时间，$M$ 代表山洞里的草药的数目。\n> \n> 接下来的 $M$ 行每行包括两个在 $1$ 到 $100$ 之间（包括 $1$ 和 $100$）的整数，分别表示采摘某株草药的时间和这株草药的价值。\n> \n> \n> 输出格式\n> \n> 输出在规定的时间内可以采到的草药的最大总价值。\n> \n> \n> 样例 #1\n> \n> \n> 样例输入 #1\n> \n> \n> \n> \n> 样例输出 #1\n> \n> \n> \n> \n> 提示\n> \n> 【数据范围】\n> \n>  * 对于 $30%$ 的数据，$M \\le 10$；\n>  * 对于全部的数据，$M \\le 100$。\n> \n> 【题目来源】\n> \n> NOIP 2005 普及组第三题\n\n🎈AC代码#\n\n\n\n\n🍊[P1060]开心的金明#\n\n\n> [NOIP2006 普及组] 开心的金明\n> \n> \n> 题目描述\n> \n> 金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间他自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说\n> 了算，只要不超过 $N$ 元钱就行”。今天一早金明就开始做预算，但是他想买的东西太多了，肯定会超过妈妈限定的 $N$\n> 元。于是，他把每件物品规定了一个重要度，分为 $5$ 等：用整数 $1-5$ 表示，第 $5$\n> 等最重要。他还从因特网上查到了每件物品的价格（都是整数元）。他希望在不超过 $N$ 元（可以等于 $N$\n> 元）的前提下，使每件物品的价格与重要度的乘积的总和最大。\n> \n> 设第$j$件物品的价格为 $v_j$，重要度为 $w_j$，共选中了 $k$ 件物品，编号依次为 $j_1,j_2,…,j_k$，则所求的总和为：\n> \n> $v_{j_1} \\times w_{j_1}+v_{j_2} \\times w_{j_2} …+v_{j_k} \\times w_{j_k}$。\n> \n> 请你帮助金明设计一个满足要求的购物单。\n> \n> \n> 输入格式\n> \n> 第一行，为 $2$ 个正整数，用一个空格隔开：$n,m$（$n<30000,m<25$）其中 $n$ 表示总钱数，$m$ 为希望购买物品的个数。\n> \n> 从第 $2$ 行到第 $m+1$ 行，第 $j$ 行给出了编号为 $j-1$ 的物品的基本数据，每行有 $2$ 个非负整数 $v,p$（其中 $v$\n> 表示该物品的价格 $(v \\le 10000)$，$p$ 表示该物品的重要度（$1\\le p\\le5$）。\n> \n> \n> 输出格式\n> \n> $1$ 个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值（$<100000000$）。\n> \n> \n> 样例 #1\n> \n> \n> 样例输入 #1\n> \n> \n> \n> \n> 样例输出 #1\n> \n> \n> \n> \n> 提示\n> \n> NOIP 2006 普及组 第二题\n\n\n🍊[P1855]榨取kkksc03#\n\n\n> 榨取kkksc03\n> \n> \n> 题目描述\n> \n> 洛谷 2 的团队功能是其他任何 OJ 和工具难以达到的。借助洛谷强大的服务器资源，任何学校都可以在洛谷上零成本的搭建 OJ 并高效率的完成训练计划。\n> \n> 为什么说是搭建 OJ 呢？为什么高效呢？\n> \n> \n> \n> 因为，你可以上传私有题目，团队外别人是无法看到的。我们还能帮你们评测！\n> \n> 你可以创建作业，给组员布置任务，查看组员的完成情况，还可以点评任意一份代码！\n> \n> 你可以创建比赛！既可以是 OI 赛制还可以是 ICPC 赛制！既可以是团队内部的私有比赛，也可以公开赛，甚至可以指定谁可以参加比赛。这样，搞“x\n> 校联赛”最合适不过了。洛谷凭借这个功能，希望能够提供公开及私有比赛的另外一个平台。\n> \n> \n> \n> 值得说明的是，本次比赛就是采用团队私有题目+邀请比赛的机制。\n> \n> 洛谷的运营组决定，如果一名 OIer 向他的教练推荐洛谷，并能够成功的使用（成功使用的定义是：该团队有 $20$ 个或以上的成员，上传 $10$\n> 道以上的私有题目，布置过一次作业并成功举办过一次公开比赛），那么他可以浪费掉 kkksc03 的一些时间的同时消耗掉 kkksc03\n> 的一些金钱以满足自己的一个愿望。\n> \n> kkksc03 的时间和金钱是有限的，所以他很难满足所有同学的愿望。所以他想知道在自己的能力范围内，最多可以完成多少同学的愿望？\n> \n> \n> 输入格式\n> \n> 第一行三个整数 $n,M,T$，表示一共有 $n$（$1 \\le n \\le 100$）个愿望， kkksc03 的手上还剩 $M$（$0 \\le M\n> \\le 200$）元，他的暑假有 $T$（$0 \\le T \\le 200$）分钟时间。\n> \n> 第 $2$~$n+1$ 行 $m_{i}$ , $t_{i}$ 表示第 $i$ 个愿望所需要的金钱和时间。\n> \n> \n> 输出格式\n> \n> 一行，一个数，表示 kkksc03 最多可以实现愿望的个数。\n> \n> \n> 样例 #1\n> \n> \n> 样例输入 #1\n> \n> \n> \n> \n> 样例输出 #1\n\n\n🍊[P5020]货币系统#\n\n\n> [NOIP2018 提高组] 货币系统\n> \n> \n> 题目背景\n> \n> NOIP2018 提高组 D1T2\n> \n> \n> 题目描述\n> \n> 在网友的国度中共有 $n$ 种不同面额的货币，第 $i$ 种货币的面额为 $a[i]$，你可以假设每一种货币都有无穷多张。为了方便，我们把货币种数为\n> $n$、面额数组为 $a[1..n]$ 的货币系统记作 $(n,a)$。\n> \n> 在一个完善的货币系统中，每一个非负整数的金额 $x$ 都应该可以被表示出，即对每一个非负整数 $x$，都存在 $n$ 个非负整数 $t[i]$ 满足\n> $a[i] \\times t[i]$ 的和为 $x$。然而， 在网友的国度中，货币系统可能是不完善的，即可能存在金额 $x$\n> 不能被该货币系统表示出。例如在货币系统 $n=3$, $a=[2,5,9]$ 中，金额 $1,3$ 就无法被表示出来。\n> \n> 两个货币系统 $(n,a)$ 和 $(m,b)$ 是等价的，当且仅当对于任意非负整数 $x$，它要么均可以被两个货币系统表出，要么不能被其中任何一个表出。\n> \n> 现在网友们打算简化一下货币系统。他们希望找到一个货币系统 $(m,b)$，满足 $(m,b)$ 与原来的货币系统 $(n,a)$ 等价，且 $m$\n> 尽可能的小。他们希望你来协助完成这个艰巨的任务：找到最小的 $m$。\n> \n> \n> 输入格式\n> \n> 输入文件的第一行包含一个整数 $T$，表示数据的组数。\n> \n> 接下来按照如下格式分别给出 $T$ 组数据。 每组数据的第一行包含一个正整数 $n$。接下来一行包含 $n$ 个由空格隔开的正整数 $a[i]$。\n> \n> \n> 输出格式\n> \n> 输出文件共有 $T$ 行，对于每组数据，输出一行一个正整数，表示所有与 $(n,a)$ 等价的货币系统 $(m,b)$ 中，最小的 $m$。\n> \n> \n> 样例 #1\n> \n> \n> 样例输入 #1\n> \n> \n> \n> \n> 样例输出 #1\n> \n> \n> \n> \n> 提示\n> \n> 在第一组数据中，货币系统 $(2, [3,10])$ 和给出的货币系统 $(n, a)$ 等价，并可以验证不存在 $m < 2$\n> 的等价的货币系统，因此答案为 $2$。 在第二组数据中，可以验证不存在 $m < n$ 的等价的货币系统，因此答案为 $5$。\n> \n> 【数据范围与约定】\n> \n> \n> \n> 对于 $100%$ 的数据，满足 $1 ≤ T ≤ 20, n,a[i] ≥ 1$。\n\n\n🍊[P1757]通天之分组背包#\n\n\n> 通天之分组背包\n> \n> \n> 题目背景\n> \n> 直达通天路·小 A 历险记第二篇\n> \n> \n> 题目描述\n> \n> 自 $01$ 背包问世之后，小 A 对此深感兴趣。一天，小 A 去远游，却发现他的背包不同于 $01$ 背包，他的物品大致可分为 $k$\n> 组，每组中的物品相互冲突，现在，他想知道最大的利用价值是多少。\n> \n> \n> 输入格式\n> \n> 两个数 $m,n$，表示一共有 $n$ 件物品，总重量为 $m$。\n> \n> 接下来 $n$ 行，每行 $3$ 个数 $a_i,b_i,c_i$，表示物品的重量，利用价值，所属组数。\n> \n> \n> 输出格式\n> \n> 一个数，最大的利用价值。\n> \n> \n> 样例 #1\n> \n> \n> 样例输入 #1\n> \n> \n> \n> \n> 样例输出 #1\n> \n> \n> \n> \n> 提示\n> \n> $1 \\leq m, n \\leq 1000$，$1\\leq k\\leq 100$，$a_i, b_i, c_i$ 在 int 范围内。\n\n\n🍊[P1064]金明的预算方案#\n\n\n> [NOIP2006 提高组] 金明的预算方案\n> \n> \n> 题目描述\n> \n> 金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你\n> 说了算，只要不超过 $n$\n> 元钱就行”。今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：\n> \n> 主件    附件\n> 电脑    打印机，扫描仪\n> 书柜    图书\n> 书桌    台灯，文具\n> 工作椅   无\n> \n> 如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有 $0$ 个、$1$ 个或 $2$\n> 个附件。每个附件对应一个主件，附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的 $n$ 元。于是，他把每件物品规定了一个重要度，分为\n> $5$ 等：用整数 $1 \\sim 5$ 表示，第 $5$ 等最重要。他还从因特网上查到了每件物品的价格（都是 $10$ 元的整数倍）。他希望在不超过\n> $n$ 元的前提下，使每件物品的价格与重要度的乘积的总和最大。\n> \n> 设第 $j$ 件物品的价格为 $v_j$，重要度为$w_j$，共选中了 $k$ 件物品，编号依次为 $j_1,j_2,\\dots,j_k$，则所求的总和为：\n> \n> $v_{j_1} \\times w_{j_1}+v_{j_2} \\times w_{j_2}+ \\dots +v_{j_k} \\times\n> w_{j_k}$。\n> \n> 请你帮助金明设计一个满足要求的购物单。\n> \n> \n> 输入格式\n> \n> 第一行有两个整数，分别表示总钱数 $n$ 和希望购买的物品个数 $m$。\n> \n> 第 $2$ 到第 $(m + 1)$ 行，每行三个整数，第 $(i + 1)$ 行的整数 $v_i$，$p_i$，$q_i$ 分别表示第 $i$\n> 件物品的价格、重要度以及它对应的的主件。如果 $q_i=0$，表示该物品本身是主件。\n> \n> \n> 输出格式\n> \n> 输出一行一个整数表示答案。\n> \n> \n> 样例 #1\n> \n> \n> 样例输入 #1\n> \n> \n> \n> \n> 样例输出 #1\n> \n> \n> \n> \n> 提示\n> \n> 数据规模与约定\n> \n> 对于全部的测试点，保证 $1 \\leq n \\leq 3.2 \\times 10^4$，$1 \\leq m \\leq 60$，$0 \\leq v_i\n> \\leq 10^4$，$1 \\leq p_i \\leq 5$，$0 \\leq q_i \\leq m$，答案不超过 $2 \\times 10^5$。\n\n\n🍊[P2946]Cow Frisbee Team#\n\n\n> [USACO09MAR] Cow Frisbee Team S\n> \n> \n> 题目描述\n> \n> 老唐最近迷上了飞盘，约翰想和他一起玩，于是打算从他家的 $N$ 头奶牛中选出一支队伍。\n> \n> 每只奶牛的能力为整数，第 $i$ 头奶牛的能力为$R_i$ 。飞盘队的队员数量不能少于 $1$、大于$N$。一支队伍的总能力就是所有队员能力的总和。\n> \n> 约翰比较迷信，他的幸运数字是 $F$ ，所以他要求队伍的总能力必须是 $F$ 的倍数。请帮他\n> \n> 算一下，符合这个要求的队伍组合有多少？由于这个数字很大，只要输出答案对 $10^8$ 取模的值。\n> \n> \n> 输入格式\n> \n> 第一行：两个用空格分开的整数：$N$ 和 $F$。\n> \n> 第二行到 $N+1$ 行：第 $i+1$ 行有一个整数$R_i$ ，表示第 $i$ 头奶牛的能力。\n> \n> \n> 输出格式\n> \n> 第一行：单个整数，表示方案数对 $10^8$ 取模的值。\n> \n> \n> 样例 #1\n> \n> \n> 样例输入 #1\n> \n> \n> \n> \n> 样例输出 #1\n> \n> \n> \n> \n> 提示\n> \n> 数据范围与约定\n> \n>  * 对于 $100%$ 的数据，$1 \\le N \\le 2000$，$1 \\le F \\le 1000$ ，$1 \\le R_i \\le 10^5$ 。\n\n\n🍊[P1156]垃圾陷阱#\n\n\n> 垃圾陷阱\n> \n> \n> 题目描述\n> \n> 卡门――农夫约翰极其珍视的一条 Holsteins 奶牛――已经落了到 “垃圾井” 中。“垃圾井” 是农夫们扔垃圾的地方，它的深度为 $D$（$2 \\le\n> D \\le 100$）英尺。\n> \n> 卡门想把垃圾堆起来，等到堆得与井同样高时，她就能逃出井外了。另外，卡门可以通过吃一些垃圾来维持自己的生命。\n> \n> 每个垃圾都可以用来吃或堆放，并且堆放垃圾不用花费卡门的时间。\n> \n> 假设卡门预先知道了每个垃圾扔下的时间 $t$（$1 \\le t \\le 1000$），以及每个垃圾堆放的高度 $h$（$1 \\le h \\le\n> 25$）和吃进该垃圾能维持生命的时间 $f$（$1 \\le f \\le 30$），要求出卡门最早能逃出井外的时间，假设卡门当前体内有足够持续 $10$\n> 小时的能量，如果卡门 $10$ 小时内（不含 $10$ 小时，维持生命的时间同）没有进食，卡门就将饿死。\n> \n> \n> 输入格式\n> \n> 第一行为两个整数，$D$ 和 $G$（$1 \\le G \\le 100$），$G$ 为被投入井的垃圾的数量。\n> \n> 第二到第 $G+1$ 行每行包括三个整数：$T$（$1 \\le T \\le 1000$），表示垃圾被投进井中的时间；$F$（$1 \\le F \\le\n> 30$），表示该垃圾能维持卡门生命的时间；和 $H$（$1 \\le H \\le 25$），该垃圾能垫高的高度。\n> \n> \n> 输出格式\n> \n> 如果卡门可以爬出陷阱，输出一个整数，表示最早什么时候可以爬出；否则输出卡门最长可以存活多长时间。\n> \n> \n> 样例 #1\n> \n> \n> 样例输入 #1\n> \n> \n> \n> \n> 样例输出 #1\n> \n> \n> \n> \n> 提示\n> \n> 【样例说明】\n> \n> 卡门堆放她收到的第一个垃圾：$\\mathrm{height}=9$；\n> \n> 卡门吃掉她收到的第 $2$ 个垃圾，使她的生命从 $10$ 小时延伸到 $13$ 小时；\n> \n> 卡门堆放第 $3$ 个垃圾，$\\mathrm{height}=19$；\n> \n> 卡门堆放第 $4$ 个垃圾，$\\mathrm{height}=20$。\n\n\n🍊[P5322]排兵布阵#\n\n\n> [BJOI2019] 排兵布阵\n> \n> \n> 题目描述\n> \n> 小 C 正在玩一款排兵布阵的游戏。在游戏中有 $n$ 座城堡，每局对战由两名玩家来争夺这些城堡。每名玩家有 $m$ 名士兵，可以向第 $i$ 座城堡派遣\n> $a_i$ 名士兵去争夺这个城堡，使得总士兵数不超过 $m$。\n> \n> 如果一名玩家向第 $i$ 座城堡派遣的士兵数严格大于对手派遣士兵数的两倍，那么这名玩家就占领了这座城堡，获得 $i$ 分。\n> \n> 现在小 C 即将和其他 $s$ 名玩家两两对战，这 $s$ 场对决的派遣士兵方案必须相同。小 C 通过某些途径得知了其他 $s$\n> 名玩家即将使用的策略，他想知道他应该使用什么策略来最大化自己的总分。\n> \n> 由于答案可能不唯一，你只需要输出小 C 总分的最大值。\n> \n> \n> 输入格式\n> \n> 输入第一行包含三个正整数 $s,n,m$，分别表示除了小 C 以外的玩家人数、城堡数和每名玩家拥有的士兵数。\n> \n> 接下来 $s$ 行，每行 $n$ 个非负整数，表示一名玩家的策略，其中第 $i$ 个数 $a_i$ 表示这名玩家向第 $i$ 座城堡派遣的士兵数。\n> \n> \n> 输出格式\n> \n> 输出一行一个非负整数，表示小 C 获得的最大得分。\n> \n> \n> 样例 #1\n> \n> \n> 样例输入 #1\n> \n> \n> \n> \n> 样例输出 #1\n> \n> \n> \n> \n> 样例 #2\n> \n> \n> 样例输入 #2\n> \n> \n> \n> \n> 样例输出 #2\n> \n> \n> \n> \n> 提示\n> \n> 样例1解释：\n> \n> 小 C 的最佳策略为向第 $1$ 座城堡和第 $2$ 座城堡各派遣 $5$ 名士兵。\n> \n> 样例2解释：\n> \n> 小 C 的最佳策略之一为向第 $1$ 座城堡派遣 $2$ 名士兵，向第 $2$ 座城堡派遣 $5$ 名士兵，向第 $3$ 座城堡派遣 $1$ 名士兵。\n> \n> 数据范围：\n> \n> 对于 $10%$ 的数据： $s=1,n \\le 3,m \\le 10$\n> \n> 对于 $20%$ 的数据： $s=1,n \\le 10,m \\le 100$\n> \n> 对于 $40%$ 的数据： $n\\le 10,m\\le 100$\n> \n> 对于另外 $20%$ 的数据： $s=1$\n> \n> 对于 $100%$ 的数据：\n> \n> $1\\le s \\le 100$\n> \n> $1\\le n \\le 100$\n> \n> $1\\le m \\le 20000$\n> \n> 对于每名玩家 $a_i \\ge 0$，$\\sum\\limits_{i=1}^n a_i \\le m$\n\n\n🍊[P5289]皮配#\n\n\n> [十二省联考 2019] 皮配\n> \n> \n> 题目背景\n> \n> 一年一度的综艺节目《中国好码农》又开始了。本季度，好码农由 Yazid、Zayid、小 R、大 R\n> 四位梦想导师坐镇，他们都将组建自己的梦想战队，并率领队员向梦想发起冲击。\n> \n> 四位导师的派系不尽相同，节目组为了营造看点，又将导师分成了不同的阵营，与此同时对不同阵营、不同派系都作出了战队总人数限制：\n> \n>  * 四位导师分成两个阵营：\n>    * Yazid、小 R 两位导师组成蓝阵营，他们两位的战队人数总和不得超过 $C_0$。\n>    * Zayid、大 R 两位导师组成红阵营，他们两位的战队人数总和不得超过 $C_1$。\n>  * 四位导师分成两个派系：\n>    * Yazid、Zayid 两位导师属于鸭派系，他们两位的战队人数总和不得超过 $D_0$。\n>    * 小 R、大 R 两位导师属于 R 派系，他们两位的战队人数总和不得超过 $D_1$。\n> \n> \n> 题目描述\n> \n> 本季好码农邀请到了全国各路学生精英参赛。他们来自全国 $c$ 个城市的 $n$ 所不同学校（城市的编号从 $1$ 至 $c$，学校的编号从 $1$ 至\n> $n$）。其中，第 $i$ 所学校所属的城市编号为 $b_i$，且共有 $s_i$ 名选手参赛。\n> \n> 在【题目背景】中提到的各总人数限制之外，本季度《中国好码农》的导师选择阶 段有额外规则如下：\n> \n>  * 来自同城市的所有选手必须加入相同的阵营。\n>  * 来自同学校的所有选手必须选择相同的导师。\n> \n> 对于导师，大部分学校的学生对导师没有偏好。但是有 $k$\n> 所学校，其中每所学校的学生有且仅有一位他们不喜欢的导师。同一所学校的学生不喜欢的导师相同，他们不会加入他们不喜欢的导师的战队。\n> \n> 面对琳琅满目的规则和选手的偏好，作为好码农忠实观众的你想计算出，在所有选 手都进行了战队选择后，战队组成共有多少种可能的局面？\n> \n>  * 两种战队组成的局面被认为是不同的，当且仅当在存在一所学校，使得在这两种 局面中这所学校的选手加入了不同导师的战队。\n>  * 由于答案可能很大，你只需输出可能局面数对 $998244353$ 取模的结果即可。\n> \n> \n> 输入格式\n> \n> 单个测试点中包含多组数据，输入的第一行包含一个非负整数 $T$ 表示数据组数。接下来依次描述每组数据，对于每组数据：\n> \n>  * 第 $1$ 行 $2$ 个正整数 $n$, $c$，分别表示学校数目、城市数目。\n>  * 第 $2$ 行 $4$ 个正整数 $C_0$, $C_1$, $D_0$, $D_1$，分别表示题目中所描述的四个限制。\n>  * 接下来 $n$ 行每行 $2$ 个正整数：\n>    * 这部分中第 $i$ 行的两个数依次为 $b_i$, $s_i$，分别表示第 $i$ 所学校的所属城市以及选手数目。\n>    * 保证 $b_i \\leqslant c$，$s_i \\leqslant\\min\\left{M, 10\\right}$。其中 $M = \\max\n>      \\left{C_0, C_1, D_0, D_1\\right}$。\n>  * 接下来 $1$ 行一个非负整数 $k$，表示选手有偏好的学校数目。\n>  * 接下来 $k$ 行，每行 $2$ 个整数 $i$, $p$，描述编号为 $i$ 的学校选手有偏好：\n>    * 其中，$p$ 为一个 $0$ 至 $3$ 之间的整数，描述该校选手不喜欢的导师：$0$ 代表 Yazid，$1$ 代表小 R，$2$ 代表\n>      Zayid，$3$ 代表大 R。\n>    * 保证 $1 \\leqslant i \\leqslant n$，且各行的 $i$ 互不相同。\n> \n> 对于输入的每一行，如果其包含多个数，则用单个空格将它们隔开。\n> \n> \n> 输出格式\n> \n> 依次输出每组数据的答案，对于每组数据：\n> \n>  * 一行一个整数，表示可能局面数对 $998244353$ 取模的结果。\n> \n> \n> 样例 #1\n> \n> \n> 样例输入 #1\n> \n> \n> \n> \n> 样例输出 #1\n> \n> \n> \n> \n> 提示\n> \n> \n> 样例 1 解释\n> \n> 对于第 $1$ 组数据：\n> \n>  * 唯一的城市 $1$ 包含共 $3$ 名选手，但红阵营的总人数限制为 $2$，无法容纳这些选手，因此他们被迫只能选择蓝阵营。\n>  * 在此基础上，由于 $1$ 号学校的选手不喜欢 Yazid 老师，因此他们就必须加入 R 派系的小 R 老师麾下。\n>  * 由于 R 派系总人数限制为 $2$，因此小 R 老师战队无法容纳 $2$ 号学校的选手，所以他们只能被迫加入Yazid 老师战队。\n>  * 综上所述，可能的局面仅有这一种。\n> \n> 对于第 $2$ 组数据：\n> \n>  * 一个显然的事实是，$1$ 号城市的所有选手都无法加入蓝阵营，这是因为 $1$ 号城市的选手总人数超过了蓝阵营的总人数限制，因此他们被迫全部加入红阵营。\n>  * 对于 $2$ 号城市选手加入蓝阵营的情况，稍加计算可得出共有 $15$ 种可能的局面。\n>  * 对于 $2$ 号城市选手加入红阵营的情况，稍加计算可得出共有 $7$ 种可能的局面。\n>  * 综上所述，可能的局面数为 $15 + 7 = 22$ 种。\n> \n> \n> 数据规模与约定\n> \n> \n> \n> 其中，$M = \\max\\left{C_0, C_1, D_0, D_1\\right}$。\n> \n> 对于所有测试点，保证 $T \\leqslant5$。\n> \n> 对于所有测试点中的每一组数据， 保证 $c \\leqslant n \\leqslant 1000$，$k \\leqslant 30$，$M\n> \\leqslant 2500$，$1 \\leqslant s_i \\leqslant \\min\\left{M, 10\\right}$。\n> \n> 另外，请你注意，数据并不保证所有的 $c$ 个城市都有参赛学校。\n> \n> \n> 提示\n> \n> 另外还有两组附加样例文件，请在附件中下载。\n> \n> 十二省联考命题组温馨提醒您：\n> \n> 数据千万条，清空第一条。\n> \n> 多测不清空，爆零两行泪。","routePath":"/posts/algorithm/knapsackdp","lang":"","toc":[{"text":"👾背包动态规划","id":"背包动态规划","depth":2,"charIndex":-1},{"text":"🍊[P1048]采药","id":"p1048采药","depth":3,"charIndex":47},{"text":"🎈AC代码","id":"ac代码","depth":4,"charIndex":739},{"text":"🍊[P1060]开心的金明","id":"p1060开心的金明","depth":3,"charIndex":751},{"text":"🍊[P1855]榨取kkksc03","id":"p1855榨取kkksc03","depth":3,"charIndex":1659},{"text":"🍊[P5020]货币系统","id":"p5020货币系统","depth":3,"charIndex":2606},{"text":"🍊[P1757]通天之分组背包","id":"p1757通天之分组背包","depth":3,"charIndex":3709},{"text":"🍊[P1064]金明的预算方案","id":"p1064金明的预算方案","depth":3,"charIndex":4181},{"text":"🍊[P2946]Cow Frisbee Team","id":"p2946cow-frisbee-team","depth":3,"charIndex":5366},{"text":"🍊[P1156]垃圾陷阱","id":"p1156垃圾陷阱","depth":3,"charIndex":5991},{"text":"🍊[P5322]排兵布阵","id":"p5322排兵布阵","depth":3,"charIndex":6966},{"text":"🍊[P5289]皮配","id":"p5289皮配","depth":3,"charIndex":8121}],"domain":"","frontmatter":{"title":"刷题记录||背包动态规划","date":"2024-03-09T13:49:34.000Z","draft":true,"authors":[],"description":"","tags":["算法","DP"],"categories":["在学算法的日子里"],"series":["题解记录"],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"","featuredImagePreview":"","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":23,"title":"LeetCode Hot 100记录（19/100）","content":"哈希(3/3)#\n\n\n1. 两数之和#\n\n\n题意#\n\n给定一个整数数组  nums  和一个整数目标值  target，请你在该数组中找出  和为目标值 target  的那  两个  整数，并返回它们的数组下标。\n\n你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。\n\n你可以按任意顺序返回答案。\n\n\n代码#\n\n\n\n\n49. 字母异位词分组#\n\n\n题意#\n\n给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。\n\n字母异位词 是由重新排列源单词的所有字母得到的一个新单词。\n\n\n代码#\n\n\n\n\n128. 最长连续序列#\n\n\n题意#\n\n给定一个未排序的整数数组  nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。\n\n请你设计并实现时间复杂度为  O(n)  的算法解决此问题。\n\n\n代码#\n\n\n\n\n双指针(4/4)#\n\n\n283. 移动零#\n\n\n题意#\n\n给定一个数组  nums，编写一个函数将所有  0  移动到数组的末尾，同时保持非零元素的相对顺序。\n\n请注意 ，必须在不复制数组的情况下原地对数组进行操作。\n\n\n代码#\n\n\n\n\n11. 盛最多水的容器#\n\n\n题意#\n\n给定一个长度为  n  的整数数组  height 。有  n  条垂线，第  i  条线的两个端点是  (i, 0)  和  (i, height[i]) 。\n\n找出其中的两条线，使得它们与  x  轴共同构成的容器可以容纳最多的水。\n\n返回容器可以储存的最大水量。\n\n说明： 你不能倾斜容器。\n\n\n代码#\n\n\n\n\n15. 三数之和#\n\n\n题意#\n\n给你一个整数数组  nums ，判断是否存在三元组  [nums[i], nums[j], nums[k]]  满足  i != j、i != k  且  j\n!= k ，同时还满足  nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为  0  且不重复的三元组。\n\n注意： 答案中不可以包含重复的三元组。\n\n\n代码#\n\n\n\n\n42. 接雨水#\n\n\n题意#\n\n给定  n  个非负整数表示每个宽度为  1  的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。\n\n\n代码#\n\n\n\n\n滑动窗口(2/2)#\n\n\n3. 无重复字符的最长子串#\n\n\n题意#\n\n给定一个字符串  s ，请你找出其中不含有重复字符的  最长子串  的长度。\n\n\n代码#\n\n\n\n\n438. 找到字符串中所有字母异位词#\n\n\n题意#\n\n给定两个字符串  s  和  p，找到  s  中所有  p  的  异位词  的子串，返回这些子串的起始索引。不考虑答案输出的顺序。\n\n\n代码#\n\n\n\n\n子串(3/3)#\n\n\n560. 和为 K 的子数组#\n\n\n题意#\n\n给你一个整数数组  nums  和一个整数  k ，请你统计并返回  该数组中和为  k  的子数组的个数 。\n\n子数组是数组中元素的连续非空序列。\n\n\n代码#\n\n\n\n\n239. 滑动窗口最大值#\n\n\n题意#\n\n给你一个整数数组  nums，有一个大小为  k  的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的  k \n个数字。滑动窗口每次只向右移动一位。\n\n返回  滑动窗口中的最大值 。\n\n\n代码#\n\n\n\n\n76. 最小覆盖子串#\n\n\n题意#\n\n给你一个字符串  s 、一个字符串  t 。返回  s  中涵盖  t  所有字符的最小子串。如果  s  中不存在涵盖  t  所有字符的子串，则返回空字符串\n \"\" 。\n\n\n代码#\n\n\n\n\n普通数组(5/5)#\n\n\n53. 最大子数组和#\n\n\n题意#\n\n给你一个整数数组  nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n\n子数组是数组中的一个连续部分。\n\n\n代码#\n\n\n\n\n56. 合并区间#\n\n\n题意#\n\n以数组  intervals  表示若干个区间的集合，其中单个区间为  intervals[i] = [starti,\nendi] 。请你合并所有重叠的区间，并返回  一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。\n\n\n代码#\n\n\n\n\n57. 轮转数组#\n\n\n题意#\n\n给定一个整数数组  nums，将数组中的元素向右轮转  k  个位置，其中  k  是非负数。\n\n\n代码#\n\n\n\n\n58. 除自身以外数组的乘积#\n\n\n题意#\n\n给你一个整数数组  nums，返回 数组  answer ，其中  answer[i]  等于  nums  中除  nums[i]  之外其余各元素的乘积\n 。\n\n题目数据  保证  数组  nums之中任意元素的全部前缀元素和后缀的乘积都在   32 位  整数范围内。\n\n请  不要使用除法， 且在  O(n)  时间复杂度内完成此题。\n\n\n代码#\n\n\n\n\n59. 缺失的第一个正数#\n\n\n题意#\n\n给你一个未排序的整数数组  nums ，请你找出其中没有出现的最小的正整数。\n\n请你实现时间复杂度为  O(n)  并且只使用常数级别额外空间的解决方案。\n\n\n代码#\n\n\n\n\n矩阵(2/4)#\n\n\n73. 矩阵置零#\n\n\n题意#\n\n给定一个  $m \\times n$  的矩阵，如果一个元素为  0 ，则将其所在行和列的所有元素都设为  0 。请使用  原地  算法。\n\n\n代码#\n\n\n\n\n54. 螺旋矩阵#\n\n\n题意#\n\n给你一个  m  行  n  列的矩阵  matrix ，请按照  顺时针螺旋顺序 ，返回矩阵中的所有元素。\n\n\n代码#\n\n\n\n\n48. 旋转图像#\n\n\n题意#\n\n给定一个  $n\\times n$ 的二维矩阵  matrix  表示一个图像。请你将图像顺时针旋转 90 度。\n\n你必须在  原地  旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要  使用另一个矩阵来旋转图像。\n\n\n240. 搜索二维矩阵 II#","routePath":"/posts/algorithm/lchot100","lang":"","toc":[{"text":"1. 两数之和","id":"1-两数之和","depth":2,"charIndex":10},{"text":"题意","id":"题意","depth":3,"charIndex":21},{"text":"代码","id":"代码","depth":3,"charIndex":159},{"text":"49. 字母异位词分组","id":"49-字母异位词分组","depth":2,"charIndex":167},{"text":"题意","id":"题意-1","depth":3,"charIndex":182},{"text":"代码","id":"代码-1","depth":3,"charIndex":261},{"text":"128. 最长连续序列","id":"128-最长连续序列","depth":2,"charIndex":269},{"text":"题意","id":"题意-2","depth":3,"charIndex":284},{"text":"代码","id":"代码-2","depth":3,"charIndex":375},{"text":"283. 移动零","id":"283-移动零","depth":2,"charIndex":395},{"text":"题意","id":"题意-3","depth":3,"charIndex":407},{"text":"代码","id":"代码-3","depth":3,"charIndex":494},{"text":"11. 盛最多水的容器","id":"11-盛最多水的容器","depth":2,"charIndex":502},{"text":"题意","id":"题意-4","depth":3,"charIndex":517},{"text":"代码","id":"代码-4","depth":3,"charIndex":673},{"text":"15. 三数之和","id":"15-三数之和","depth":2,"charIndex":681},{"text":"题意","id":"题意-5","depth":3,"charIndex":693},{"text":"代码","id":"代码-5","depth":3,"charIndex":871},{"text":"42. 接雨水","id":"42-接雨水","depth":2,"charIndex":879},{"text":"题意","id":"题意-6","depth":3,"charIndex":890},{"text":"代码","id":"代码-6","depth":3,"charIndex":951},{"text":"3. 无重复字符的最长子串","id":"3-无重复字符的最长子串","depth":2,"charIndex":972},{"text":"题意","id":"题意-7","depth":3,"charIndex":989},{"text":"代码","id":"代码-7","depth":3,"charIndex":1035},{"text":"438. 找到字符串中所有字母异位词","id":"438-找到字符串中所有字母异位词","depth":2,"charIndex":1043},{"text":"题意","id":"题意-8","depth":3,"charIndex":1065},{"text":"代码","id":"代码-8","depth":3,"charIndex":1140},{"text":"560. 和为 K 的子数组","id":"560-和为-k-的子数组","depth":2,"charIndex":1159},{"text":"题意","id":"题意-9","depth":3,"charIndex":1177},{"text":"代码","id":"代码-9","depth":3,"charIndex":1259},{"text":"239. 滑动窗口最大值","id":"239-滑动窗口最大值","depth":2,"charIndex":1267},{"text":"题意","id":"题意-10","depth":3,"charIndex":1283},{"text":"代码","id":"代码-10","depth":3,"charIndex":1392},{"text":"76. 最小覆盖子串","id":"76-最小覆盖子串","depth":2,"charIndex":1400},{"text":"题意","id":"题意-11","depth":3,"charIndex":1414},{"text":"代码","id":"代码-11","depth":3,"charIndex":1508},{"text":"53. 最大子数组和","id":"53-最大子数组和","depth":2,"charIndex":1529},{"text":"题意","id":"题意-12","depth":3,"charIndex":1543},{"text":"代码","id":"代码-12","depth":3,"charIndex":1622},{"text":"56. 合并区间","id":"56-合并区间","depth":2,"charIndex":1630},{"text":"题意","id":"题意-13","depth":3,"charIndex":1642},{"text":"代码","id":"代码-13","depth":3,"charIndex":1763},{"text":"57. 轮转数组","id":"57-轮转数组","depth":2,"charIndex":1771},{"text":"题意","id":"题意-14","depth":3,"charIndex":1783},{"text":"代码","id":"代码-14","depth":3,"charIndex":1838},{"text":"58. 除自身以外数组的乘积","id":"58-除自身以外数组的乘积","depth":2,"charIndex":1846},{"text":"题意","id":"题意-15","depth":3,"charIndex":1864},{"text":"代码","id":"代码-15","depth":3,"charIndex":2043},{"text":"59. 缺失的第一个正数","id":"59-缺失的第一个正数","depth":2,"charIndex":2051},{"text":"题意","id":"题意-16","depth":3,"charIndex":2067},{"text":"代码","id":"代码-16","depth":3,"charIndex":2152},{"text":"73. 矩阵置零","id":"73-矩阵置零","depth":2,"charIndex":2171},{"text":"题意","id":"题意-17","depth":3,"charIndex":2183},{"text":"代码","id":"代码-17","depth":3,"charIndex":2260},{"text":"54. 螺旋矩阵","id":"54-螺旋矩阵","depth":2,"charIndex":2268},{"text":"题意","id":"题意-18","depth":3,"charIndex":2280},{"text":"代码","id":"代码-18","depth":3,"charIndex":2342},{"text":"48. 旋转图像","id":"48-旋转图像","depth":2,"charIndex":2350},{"text":"题意","id":"题意-19","depth":3,"charIndex":2362},{"text":"240. 搜索二维矩阵 II","id":"240-搜索二维矩阵-ii","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"title":"LeetCode Hot 100记录（19/100）","subtitle":"","date":"2025-03-13T06:13:22.000Z","lastmod":"2025-03-13T06:13:22.000Z","draft":false,"authors":null,"description":null,"tags":["算法","LeetCode"],"categories":["在学算法的日子里"],"series":["题解记录"],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"https://img.dodolalorc.cn/i/2025/03/03/67c55994b7733.jpg","featuredImagePreview":"https://img.dodolalorc.cn/i/2025/03/03/67c55994b7733.jpg","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":24,"title":"刷题记录||线性动态规划","content":"线性动态规划#\n\n线性动态规划，即具有线性阶段划分的动态规划。\n\n\n[P1216]数字三角形#\n\n\n题目描述#\n\n观察下面的数字金字塔。\n\n写一个程序来查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到左下方的点也可以到达右下方的点。\n\n\n\n在上面的样例中，从 $7 \\to 3 \\to 8 \\to 7 \\to 5$ 的路径产生了最大权值。\n\n输入格式\n\n第一个行一个正整数 $r$ ,表示行的数目。\n\n后面每行为这个数字金字塔特定行包含的整数。\n\n输出格式\n\n单独的一行,包含那个可能得到的最大的和。\n\n样例 #1\n\n样例输入 #1\n\n\n\n样例输出 #1\n\n\n\n提示\n\n【数据范围】\n\n对于 $100%$ 的数据，$1\\le r \\le 1000$，所有输入在 $[0,100]$ 范围内。\n\n题目翻译来自NOCOW。\n\nUSACO Training Section 1.5\n\nIOI1994 Day1T1\n\n\n参考代码#\n\n\n\n\n[P1020]导弹拦截#\n\n\n题目描述#\n\n某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高\n度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。\n\n输入导弹依次飞来的高度，计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。\n\n输入格式\n\n一行，若干个整数，中间由空格隔开。\n\n输出格式\n\n两行，每行一个整数，第一个数字表示这套系统最多能拦截多少导弹，第二个数字表示如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。\n\n样例 #1\n\n样例输入 #1\n\n\n\n样例输出 #1\n\n\n\n提示\n\n对于前 $50%$ 数据（NOIP 原题数据），满足导弹的个数不超过 $10^4$ 个。该部分数据总分共 $100$ 分。可使用$\\mathcal\nO(n^2)$ 做法通过。\n\n对于后 $50%$ 的数据，满足导弹的个数不超过 $10^5$ 个。该部分数据总分也为 $100$ 分。请使用 $\\mathcal O(n\\log n)$\n做法通过。\n\n对于全部数据，满足导弹的高度为正整数，且不超过 $5\\times 10^4$。\n\n此外本题开启 spj，每点两问，按问给分。\n\n--------------------------------------------------------------------------------\n\n$\\text{upd 2022.8.24}$：新增加一组 Hack 数据。\n\n\n参考代码#\n\n\n\n\n[P1091]合唱队形#\n\n\n题目描述#\n\n$n$ 位同学站成一排，音乐老师要请其中的 $n-k$ 位同学出列，使得剩下的 $k$ 位同学排成合唱队形。\n\n合唱队形是指这样的一种队形：设 $k$ 位同学从左到右依次编号为 $1,2,$ … $,k$，他们的身高分别为 $t_1,t_2,$ …\n$,t_k$，则他们的身高满足 $t_1< \\cdots t_{i+1}>$ … $>t_k(1\\le i\\le k)$。\n\n你的任务是，已知所有 $n$ 位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。\n\n输入格式\n\n共二行。\n\n第一行是一个整数 $n$（$2\\le n\\le100$），表示同学的总数。\n\n第二行有 $n$ 个整数，用空格分隔，第 $i$ 个整数 $t_i$（$130\\le t_i\\le230$）是第 $i$ 位同学的身高（厘米）。\n\n输出格式\n\n一个整数，最少需要几位同学出列。\n\n样例 #1\n\n样例输入 #1\n\n\n\n样例输出 #1\n\n\n\n提示\n\n对于 $50%$ 的数据，保证有 $n \\le 20$。\n\n对于全部的数据，保证有 $n \\le 100$。\n\n\n参考代码#\n\n\n\n\n[P1095]守望者的逃离#\n\n题目背景\n\n恶魔猎手尤迪安野心勃勃，他背叛了暗夜精灵，率领深藏在海底的娜迦族企图叛变。\n\n\n题目描述#\n\n守望者在与尤迪安的交锋中遭遇了围杀，被困在一个荒芜的大岛上。\n\n为了杀死守望者，尤迪安开始对这个荒岛施咒，这座岛很快就会沉下去。到那时，岛上的所有人都会遇难。\n\n守望者的跑步速度为 $17m/s$，以这样的速度是无法逃离荒岛的。庆幸的是守望者拥有闪烁法术，可在 $1s$ 内移动\n$60m$，不过每次使用闪烁法术都会消耗魔法值 $10$ 点。守望者的魔法值恢复的速度为 $4$ 点每秒，只有处在原地休息状态时才能恢复。\n\n现在已知守望者的魔法初值 $M$，他所在的初始位置与岛的出口之间的距离 $S$，岛沉没的时间\n$T$。你的任务是写一个程序帮助守望者计算如何在最短的时间内逃离荒岛，若不能逃出，则输出守望者在剩下的时间内能走的最远距离。\n\n注意：守望者跑步、闪烁或休息活动均以秒为单位，且每次活动的持续时间为整数秒。距离的单位为米。\n\n输入格式\n\n输入数据共一行三个非负整数，分别表示 $M$，$S$，$T$。\n\n输出格式\n\n输出数据共两行。\n\n第一行一个字符串 $\\texttt{Yes}$ 或 $\\texttt{No}$，即守望者是否能逃离荒岛。\n\n第二行包含一个整数。第一行为 $\\texttt{Yes}$ 时表示守望者逃离荒岛的最短时间；第一行为 $\\texttt{No}$ 时表示守望者能走的最远距离。\n\n样例 #1\n\n样例输入 #1\n\n\n\n样例输出 #1\n\n\n\n样例 #2\n\n样例输入 #2\n\n\n\n样例输出 #2\n\n\n\n提示\n\n对于 $30%$ 的数据，$1 \\le T \\le 10$，$ 1 \\le S \\le 100$；\n\n对于 $50%$ 的数据，$1 \\le T \\le 10^3$，$ 1 \\le S \\le 10^4$；\n\n对于 $100%$ 的数据，$1 \\le T \\le 3\\times 10^5$，$0 \\le M \\le 10^3$，$ 1 \\le S \\le 10^8$。\n\n\n参考代码#\n\n\n\n\n[P1541]乌龟棋#\n\n题目背景\n\n小明过生日的时候，爸爸送给他一副乌龟棋当作礼物。\n\n\n题目描述#\n\n乌龟棋的棋盘是一行 $N$ 个格子，每个格子上一个分数（非负整数）。棋盘第 $1$ 格是唯一的起点，第 $N$\n格是终点，游戏要求玩家控制一个乌龟棋子从起点出发走到终点。\n\n乌龟棋中 $M$ 张爬行卡片，分成 $4$ 种不同的类型（$M$ 张卡片中不一定包含所有 $4$ 种类型的卡片，见样例），每种类型的卡片上分别标有\n$1,2,3,4$\n四个数字之一，表示使用这种卡片后，乌龟棋子将向前爬行相应的格子数。游戏中，玩家每次需要从所有的爬行卡片中选择一张之前没有使用过的爬行卡片，控制乌龟棋子前进相应的\n格子数，每张卡片只能使用一次。\n\n游戏中，乌龟棋子自动获得起点格子的分数，并且在后续的爬行中每到达一个格子，就得到该格子相应的分数。玩家最终游戏得分就是乌龟棋子从起点到终点过程中到过的所有格子的\n分数总和。\n\n很明显，用不同的爬行卡片使用顺序会使得最终游戏的得分不同，小明想要找到一种卡片使用顺序使得最终游戏得分最多。\n\n现在，告诉你棋盘上每个格子的分数和所有的爬行卡片，你能告诉小明，他最多能得到多少分吗？\n\n输入格式\n\n每行中两个数之间用一个空格隔开。\n\n第 $1$ 行 $2$ 个正整数 $N,M$，分别表示棋盘格子数和爬行卡片数。\n\n第 $2$ 行 $N$ 个非负整数，$a_1,a_2,…,a_N$，其中 $a_i$ 表示棋盘第 $i$ 个格子上的分数。\n\n第 $3$ 行 $M$ 个整数，$b_1,b_2,…,b_M$，表示 $M$ 张爬行卡片上的数字。\n\n输入数据保证到达终点时刚好用光$M$张爬行卡片。\n\n输出格式\n\n$1$ 个整数，表示小明最多能得到的分数。\n\n样例 #1\n\n样例输入 #1\n\n\n\n样例输出 #1\n\n\n\n提示\n\n每个测试点 1s。\n\n小明使用爬行卡片顺序为 $1,1,3,1,2$，得到的分数为 $6+10+14+8+18+17=73$。注意，由于起点是 $1$，所以自动获得第 $1$\n格的分数 $6$。\n\n对于 $30%$ 的数据有 $1≤N≤30,1≤M≤12$。\n\n对于 $50%$ 的数据有 $1≤N≤120,1≤M≤50$，且 $4$ 种爬行卡片，每种卡片的张数不会超过 $20$。\n\n对于 $100%$ 的数据有 $1≤N≤350,1≤M≤120$，且 $4$ 种爬行卡片，每种卡片的张数不会超过\n$40$；$0≤a_i≤100,1≤i≤N,1≤b_i≤4,1≤i≤M$。\n\n\n参考代码#\n\n\n\n\n[P1868]饥饿的奶牛#\n\n\n题目描述#\n\n有一条奶牛冲出了围栏，来到了一处圣地（对于奶牛来说），上面用牛语写着一段文字。\n\n现用汉语翻译为：\n\n有 $N$ 个区间，每个区间 $x,y$ 表示提供的 $x\\sim y$ 共 $y-x+1$ 堆优质牧草。你可以选择任意区间但不能有重复的部分。\n\n对于奶牛来说，自然是吃的越多越好，然而奶牛智商有限，现在请你帮助他。\n\n输入格式\n\n第一行一个整数 $N$。\n\n接下来 $N$ 行，每行两个数 $x,y$，描述一个区间。\n\n输出格式\n\n输出最多能吃到的牧草堆数。\n\n样例 #1\n\n样例输入 #1\n\n\n\n样例输出 #1\n\n\n\n提示\n\n$1 \\leq n \\leq 1.5 \\times 10^5$，$0 \\leq x \\leq y \\leq 3 \\times 10^6$。\n\n\n参考代码#\n\n","routePath":"/posts/algorithm/lineardp","lang":"","toc":[{"text":"线性动态规划","id":"线性动态规划","depth":2,"charIndex":-1},{"text":"[P1216]数字三角形","id":"p1216数字三角形","depth":2,"charIndex":33},{"text":"题目描述","id":"题目描述","depth":3,"charIndex":49},{"text":"参考代码","id":"参考代码","depth":3,"charIndex":418},{"text":"[P1020]导弹拦截","id":"p1020导弹拦截","depth":2,"charIndex":428},{"text":"题目描述","id":"题目描述-1","depth":3,"charIndex":443},{"text":"参考代码","id":"参考代码-1","depth":3,"charIndex":1133},{"text":"[P1091]合唱队形","id":"p1091合唱队形","depth":2,"charIndex":1143},{"text":"题目描述","id":"题目描述-2","depth":3,"charIndex":1158},{"text":"参考代码","id":"参考代码-2","depth":3,"charIndex":1645},{"text":"[P1095]守望者的逃离","id":"p1095守望者的逃离","depth":2,"charIndex":1655},{"text":"题目描述","id":"题目描述-3","depth":3,"charIndex":1717},{"text":"参考代码","id":"参考代码-3","depth":3,"charIndex":2534},{"text":"[P1541]乌龟棋","id":"p1541乌龟棋","depth":2,"charIndex":2544},{"text":"题目描述","id":"题目描述-4","depth":3,"charIndex":2590},{"text":"参考代码","id":"参考代码-4","depth":3,"charIndex":3612},{"text":"[P1868]饥饿的奶牛","id":"p1868饥饿的奶牛","depth":2,"charIndex":3622},{"text":"题目描述","id":"题目描述-5","depth":3,"charIndex":3638},{"text":"参考代码","id":"参考代码-5","depth":3,"charIndex":3983}],"domain":"","frontmatter":{"title":"刷题记录||线性动态规划","date":"2024-03-09T13:47:13.000Z","draft":false,"authors":[],"description":"","tags":["算法","DP"],"categories":["在学算法的日子里"],"series":["题解记录"],"hiddenFromHomePage":true,"hiddenFromSearch":false,"featuredImage":"","featuredImagePreview":"","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":25,"title":"","content":"","routePath":"/posts/algorithm/mst","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":26,"title":"2024牛客暑假多校训练营Day1||补题","content":"A-Bit Common#\n\n\n题意#\n\n计算满足长度为$n$，每个元素小于$2^m$，且存在至少一个子序列满足按位$AND$后是$1$的序列的数量。\n\n答案对正整数$q$取模。\n\n数据范围#\n\n * $1\\leq n,m\\leq 5000$\n * $1\\leq q\\leq 10^9$\n\n\n思路#\n\n按位分析，对于一个长度为$n$的序列，序列中的数分为$k$个末尾是$1$的数和$n-k$个末尾是$0$的数。\n\n * 末尾为$1$的数中，除末位以外的数位（$m-1$位），每一位的组合是$2^k-1$种（要除去全为1的情况）。\n * 末尾为$0$的数中，除末位以外数位上的取值是任意的。\n * 选择哪些数是末尾$1$需要考虑组合数。\n\n所以，总方案数是： $$ \\binom{n}{k}\\times (2^k-1)^{m-1}\\times (2^{n-k})^{(m-1)} =\n\\binom{n}{k}\\times (2^n-2^{n-k})^{m-1} $$ 最后对$q$取模即可。\n\n\n代码#\n\n\n\n\nB-A Bit More Common#\n\n\n题意#\n\n在A题的条件下，增加要求满足存在两个不同的非空子序列$AND$和是$1$。\n\n数据范围#\n\n * $1\\leq n,m\\leq 5000$\n * $1\\leq q \\leq 10^9$\n\n\n思路#\n\n有A题的基础，我们已知至少有$1$个子序列的组合数，接下来我们计算只有$1$个子序列的组合数。两者相减即可求出答案。\n\n满足只有1个子序列的组合数所代表的情况是这样的： $$ let:k=3\\ 101111\\ 010101\\ 111011 $$\n需要满足每一个竖列至少有一个特殊的$0$（这个0同时是该数位上唯一的0），且这k个数每个数至少有1个$0$ （条件2）。\n\n对于偶数的组合种数还是不变的，为$\\binom{n}{k}\\times 2^{(n-k)(m-1)}$。\n\n * 当$k=1$时，子序列是$\\{0b00000001\\}$，只有一个数，剩余的$n-k$个数都是偶数。\n\n * 当$k\\neq\n   1$时，考虑：一共有$m-1$个特殊$0$，每个$0$有对应的数位，要将这$m-1$个$0$分配到$k$个位置（位置并不互相区分），每个位置至少有$1$个\n   ，也就是第二类斯特林数。\n\n考虑状态转移：\n\n现在有$i$个数，要从$j-1$个特殊位的基础上再增加一个特殊0，这个特殊位要么增加到第$i$个数（第$i$个数已经有至少$1$个特殊$0$）上，要么增加到前$\ni-1$个（已经至少包含一个特殊$0$的）数上，这两种增加方法都有$i$种不同的方案。\n\n这$i$个数中要包含$j$个特殊$0$的方案数记为$f[i][j]$，则存在递推式： $$ f[i][j]= i\\times (f[i-1][j-1] +\nf[i][j-1]) $$\n考虑到只有$k$个数中特殊$0$的个数大于等于k时的方案数才是有效的，同时，每个有效方案中，每一列除了作为特殊$0$的位置以外的位置都可以任意填（只要不是全1或\n者只有1个特殊$0$的情况），故这$k$个奇数的方案总数是$\\sum_{t=k}^{m-1} f[k][t]\\times\n(2^k-1-k)^{m-1-t}$，再乘此时的偶数方案数，即为$k$时的总数。\n\n\n代码#\n\n\n\n\nC-Sum of Suffix Sums#\n\n\n题意#\n\n维护一个初始为空的非负整数序列，支持$q$次如下操作：\n\n每次移除末尾的$t$个整数，然后在末尾假如一个整数$v$，操作后输出当前序列所有后缀和的总和，答案对$10^9+7$取模。\n\n数据范围#\n\n * $1\\leq q\\leq 5\\times 10^5$\n * $0\\leq v\\leq 10^9$\n\n\n思路#\n\n每个数对后缀和总和的贡献是它当前位置的序号乘以它本身的值，也就是$a_i$的贡献是$a_i\\times i$ 。根据这个特点和数据范围，我们可以维护后缀和总和。\n\n\n代码#\n\n\n\n\nH-World Finals#\n\n签到题。\n\n\n题意#\n\nlzr010506队伍可以参加46th的WF和47th的WF，这两个WF将同时举行，所以lzr010506必须选择其中一个参加。lzr010506可以预知每个队\n伍的在比赛中的成绩（过题数和罚时），排名规则为过题数多优先，过题数相同则罚时少优先。\n\n除了lzr010506队伍，还有其他有资格参加两场比赛的队伍。提问，在给出所有队伍的预测成绩之后，lzr010506队伍能够获得的最好成绩排名是多少。\n\n数据范围#\n\n * $1 \\leq number of teams \\leq 105$\n\n\n思路#\n\n最优情况是，除了lzr010506队伍，同时可以参加两场比赛的队伍都参加lzr010506队伍没有参加那一场，然后计算最佳排名即可。\n\n\n代码#\n\n\n\n\nI-Mirror Maze#\n\n补出这题ddl也是死而无憾了。\n\n\n题意#\n\n在$n\\times m$ 的矩阵镜子迷宫里，给出一个点光源，光的传播与镜子的类型\\、|、-、/有关（详情戳这）。\n\n提问经过足够长的时间后，这束光被多少个不同的镜子反射过。\n\n数据范围#\n\n * $1\\leq n,m \\leq 1000$\n * $1\\leq q\\leq 10^5$\n\n\n思路#\n\n考虑到光路可逆，在迷宫中的所有可能存在的光路必然是链或者环，不会出现分叉或者是汇集。考虑数据范围$1\\leq n,m\\leq\n1000$和光的方向有上下左右4个，可以通过记忆化搜索来记录已经搜索过的状态，保证每次搜索的复杂度在$n\\times m$以内，总复杂度不超过$4\\times\nn\\times m$。\n\n具体搜索方法见代码。\n\n\n代码#\n\n","routePath":"/posts/algorithm/nc24sd1","lang":"","toc":[{"text":"A-Bit Common","id":"a-bit-common","depth":2,"charIndex":-1},{"text":"题意","id":"题意","depth":3,"charIndex":15},{"text":"数据范围","id":"数据范围","depth":4,"charIndex":90},{"text":"思路","id":"思路","depth":3,"charIndex":145},{"text":"代码","id":"代码","depth":3,"charIndex":446},{"text":"B-A Bit More Common","id":"b-a-bit-more-common","depth":2,"charIndex":454},{"text":"题意","id":"题意-1","depth":3,"charIndex":477},{"text":"数据范围","id":"数据范围-1","depth":4,"charIndex":521},{"text":"思路","id":"思路-1","depth":3,"charIndex":577},{"text":"代码","id":"代码-1","depth":3,"charIndex":1397},{"text":"C-Sum of Suffix Sums","id":"c-sum-of-suffix-sums","depth":2,"charIndex":1405},{"text":"题意","id":"题意-2","depth":3,"charIndex":1429},{"text":"数据范围","id":"数据范围-2","depth":4,"charIndex":1526},{"text":"思路","id":"思路-2","depth":3,"charIndex":1587},{"text":"代码","id":"代码-2","depth":3,"charIndex":1675},{"text":"H-World Finals","id":"h-world-finals","depth":2,"charIndex":1683},{"text":"题意","id":"题意-3","depth":3,"charIndex":1707},{"text":"数据范围","id":"数据范围-3","depth":4,"charIndex":1914},{"text":"思路","id":"思路-3","depth":3,"charIndex":1960},{"text":"代码","id":"代码-3","depth":3,"charIndex":2034},{"text":"I-Mirror Maze","id":"i-mirror-maze","depth":2,"charIndex":2042},{"text":"题意","id":"题意-4","depth":3,"charIndex":2076},{"text":"数据范围","id":"数据范围-4","depth":4,"charIndex":2169},{"text":"思路","id":"思路-4","depth":3,"charIndex":2225},{"text":"代码","id":"代码-4","depth":3,"charIndex":2399}],"domain":"","frontmatter":{"title":"2024牛客暑假多校训练营Day1||补题","subtitle":"","date":"2024-07-16T11:36:00.000Z","lastmod":"2024-07-16T11:36:00.000Z","draft":false,"authors":[],"description":"","tags":["2024暑假集训","算法","牛客"],"categories":["在学算法的日子里"],"series":["题解记录"],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"","featuredImagePreview":"","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":27,"title":"2024牛客暑假多校训练营Day10||补题","content":"A-Surrender to My Will#\n\n\n题意#\n\n根据上票状态判断是否投降。4票及以上赞同投降则投降成功。\n\n数据范围#\n\n * $1\\leq i \\leq 5$\n * $1\\leq j\\leq i,S[j]\\in\\{Y,N\\}$\n\n\n思路#\n\n计数模拟即可。\n\n\n代码#\n\n\n\n\nB-std::pair#\n\n\n题意#\n\n使用std::pair声明$n$个变量，进行对于这些变量的$q$个询问，回答其数据类型。\n\n数据范围#\n\n * $1\\leq n,q\\leq 1000$\n\n每行输入不超过5000字符\n\n\n思路#\n\n按.分割询问的变量，逐层确定当前的数据类型。\n\n\n代码#\n\n\n\n\nF-Collinear Exception#\n\n\n题意#\n\n在$\\{1,...,n\\}\\times \\{1,...,n\\}$的坐标逐渐加入$n\\times\nn$个数，如果即将加入的这个数与已有的形成了三点共线，则该数不能被成功加入，输出一个长度为$n\\times n$的01串，表示第$i$个点能否成功加入。\n\n数据结构#\n\n * $1\\leq n\\leq 1000$\n * $1\\leq x_i,y_i\\leq n$\n\n\n思路#\n\n每行每列都不能拥有超过$2$个点，若某行或某列已经超过2个点则直接判不能加入，用一个$vis$数组记录某点是否能被成功加入，加入新点时，遍历图中已有的点，枚举与\n图中已有点形成的直线的斜率$(dx,dy)$，$dx$、$dy$互质，从当前点$(x,y)$向两边转移到$(x\\pm dx,y\\pm\ndy)$，并标记该处不能被访问。\n\n\n代码#\n\n\n\n\nH-All-in at the Pre-flop#\n\n\n题意#\n\n两个玩家拥有$a$和$b$的筹码，在一场公平游戏中全押，等概率成为输家或赢家，若赢家的筹码不少于输家，游戏结束，该局赢家为最终胜利者。否则输家向赢家支付等同于赢\n家筹码的筹码。问游戏结束时两个玩家分别的胜率是多少（模$998244353$）。\n\n数据范围#\n\n * $1\\leq a,b\\leq 998244353$\n\n\n思路#\n\n游戏结束时要求赢家筹码不少于输家，另$f(x)$为玩家筹码量为$x$时的胜率，$n$为总筹码数，也就是$a+b$，则有： $$ f(0)=0,f(n)=1\\\n\\begin{cases} f(x)=\\frac{1}{2}\\times f(0)+\\frac{1}{2}\\times f(2 x)\\quad x\\lt\nn/2\\ f(x)=\\frac{1}{2}\\times f(n)+\\frac{1}{2}\\times f(2 x-n)\\quad x\\geq n/2\n\\end{cases} $$ 玩家押上$x$筹码后，对方押上$n-x$筹码，若$x\\geq\nn-x$则玩家为赢家时直接胜利，为输家时向对方交付$n-x$筹码，自己留下$x-(n-x)=2\\times\nx-n$筹码，这时候的胜率变为$f(2x-n)$，发生这两种情况的概率都是$0.5$。打表后发现$f(x)=\\frac{x}{n}$是线性方程的解。\n\n输出$\\frac{a}{a+b}$和$\\frac{a}{a+b}$。\n\n\n代码#\n\n","routePath":"/posts/algorithm/nc24sd10","lang":"","toc":[{"text":"A-Surrender to My Will","id":"a-surrender-to-my-will","depth":2,"charIndex":-1},{"text":"题意","id":"题意","depth":3,"charIndex":25},{"text":"数据范围","id":"数据范围","depth":4,"charIndex":60},{"text":"思路","id":"思路","depth":3,"charIndex":123},{"text":"代码","id":"代码","depth":3,"charIndex":138},{"text":"B-std::pair","id":"b-stdpair","depth":2,"charIndex":146},{"text":"题意","id":"题意-1","depth":3,"charIndex":161},{"text":"数据范围","id":"数据范围-1","depth":4,"charIndex":212},{"text":"思路","id":"思路-1","depth":3,"charIndex":260},{"text":"代码","id":"代码-1","depth":3,"charIndex":290},{"text":"F-Collinear Exception","id":"f-collinear-exception","depth":2,"charIndex":298},{"text":"题意","id":"题意-2","depth":3,"charIndex":323},{"text":"数据结构","id":"数据结构","depth":4,"charIndex":454},{"text":"思路","id":"思路-2","depth":3,"charIndex":510},{"text":"代码","id":"代码-2","depth":3,"charIndex":682},{"text":"H-All-in at the Pre-flop","id":"h-all-in-at-the-pre-flop","depth":2,"charIndex":690},{"text":"题意","id":"题意-3","depth":3,"charIndex":718},{"text":"数据范围","id":"数据范围-2","depth":4,"charIndex":846},{"text":"思路","id":"思路-3","depth":3,"charIndex":884},{"text":"代码","id":"代码-3","depth":3,"charIndex":1333}],"domain":"","frontmatter":{"title":"2024牛客暑假多校训练营Day10||补题","subtitle":"","date":"2024-08-15T10:45:46.000Z","lastmod":"2024-08-15T10:45:46.000Z","draft":false,"authors":[],"description":"","tags":["2024暑假集训","算法","牛客"],"categories":["在学算法的日子里"],"series":["题解记录"],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"https://img.dodolalorc.cn/i/2024/12/10/67580e5224009.png","featuredImagePreview":"https://img.dodolalorc.cn/i/2024/12/10/67580e5224009.png","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":28,"title":"2024牛客暑假多校训练营Day2||补题","content":"A-Floor Tiles#\n\n\n题意#\n\n存在A型、B型两种砖：\n\n\n\n现用这两种砖拼成$N\\times M$的矩形，提问是否有恰好存在$K$条曲线的平铺方式，曲线如下：\n\n\n\n数据范围#\n\n * $1\\leq T\\leq 10^5$\n * $1\\leq N,M\\leq 800$\n * $1\\leq K \\leq 2\\times N\\times M$\n\n\n思路#\n\n边缘一圈的点所在的线一定不是一个环，所以最少的线数相当于都是A型或B型时的线数，也就是$N\\times M$个，若要比$N\\times\nM$个多，则多的部分只能是图形中环的数目，贪心的让所有的环最小，则能构造出最多的环，最小的环如例图中一样，当平铺的方式是 $$ AB\\ BA $$\n时，形成的环是最小的。\n\n同时注意到，成环的四块砖块是可以共用的，也就是说在： $$ ABAB\\ BABA\\ ABAB $$ 中有3个环。\n\n首先构造成环数量最多的$N\\times M$，在输出时记录当前已经拥有多少个环，若超过所需的数量则不再输出可以成环的砖块类型。\n\n\n代码#\n\n\n\n\nB-MST#\n\n\n题意#\n\n给定一个$n$顶点的带权无向图$G$。\n\n每次询问一个点集$S$，求$S$关于$G$的导出子图的最小生成树的质量，若无则输出-1。\n\n数据范围#\n\n * $2\\leq n\\leq 10^5$\n * $1\\leq m,q\\leq 10^5$\n * $1\\leq w_i \\leq 10^9$\n * $\\sum k_i\\leq 10^5$\n\n\n思路#\n\n注意点数$n$和边数$m$的范围都不超过$10^5$，若通过枚举两个点来确定符合条件的边，则复杂度是$O(n^2)$，而如果按照枚举边来确定符合条件的边，复杂度\n是$O(m)$，于是优化的思路是根据每次$k$和$\\sqrt {maxn}$的大小关系来选择加入边的方式。\n\n代码\n\n\n\n\nC-Red Walking on Grid#\n\n\n题意#\n\n在一个$2\\times n$\n的网格中，每个格子要么是红色（R），要么是白色（W）。每次只能踩在当前格子的上下左右相邻的红色格子上，并且在离开当前的格子之后，当前格子将从红色变为白色，提问最\n长。\n\n数据范围#\n\n * $1\\leq n\\leq 10^6$\n\n\n思路#\n\n直接从左往右搜索即可，若当前列有红色格子，则它可以由前一列相邻格子的步数+1转移过来，或者是从下方或上方的红色格子转移过来，两者选更优的解作为答案即可。\n\n\n代码#\n\n\n\n\nE-GCD VS XOR#\n\n有人卡签到。。。TAT\n\n\n题意#\n\n给定正整数$x$，求满足$gcd(x,y)=x\\oplus y$的小于$x$的正整数$y$。若无则打印-1\n\n数据范围#\n\n * $1\\leq t\\leq 10^4$\n * $1\\leq x\\leq 10^{18}$\n\n\n思路#\n\n距离考虑，对于数$x=0b10011010$，考虑异或的性质$A\\oplus 0=A,A\\oplus A=0$，设$x\\oplus y=k$，$y\\lt\nx$，我们直接构造$k$为$x$最右侧的$1$开始的数，这样的$k$可以满足必然为$x$的倍数，同时，若要满足$gcd(x,y)=k$，构造$y$的时候要满足除\n了$lowbit(x)$以外的数位都与$x$相同。\n\n\n代码#\n\n\n\n\nH-Instructions Substring#\n\n\n题意#\n\n有一个操作字符串，由W，S，A，D组成，对应上下左右位移一位，从原点$(0,0)$开始，将操作字符串的一个非空连续子段作为选择的操作，问有多少操作可以经过目标点\n$(x,y)$。\n\n数据范围#\n\n * $1\\leq n\\leq 2\\times 10^5$\n * $-10^5\\leq x,y\\leq 10^5$\n\n\n思路#\n\n考虑记录每次操作后的坐标$(u,v)$，对该偏移坐标$(\\Delta x,\\Delta\ny)$计数，并逐步计算到达目标$(x,y)$需要去除的偏移坐标量$(u-\\Delta x,v - \\Delta\ny)$，这个需要去掉的操作数乘以当前的步数坐标（去掉$(u-\\Delta x,v-\\Delta\ny)$之后，从当前步开始，之后不管在哪停下，都是有效的路径数目），之后对该偏移坐标数清零，避免重复计数（之后新出现的只在之后的操作中被计数）。\n\n\n代码#\n\n\n\n\nI-Red Playing Cards#\n\n\n题意#\n\n对于一个长度为$2\\times\nn$的一维数组，$1$到$n$每个元素恰好出现两次。每次操作可以删掉一个长度不小于$2$的首尾相同的连续子数组，获得该连续子数组的首尾元素值乘以元素数量的分数。\n为最终可以得到多少分。\n\n数据范围#\n\n * $1\\leq a_i\\leq n\\leq 3000$\n\n\n思路#\n\n每个数有两个坐标，假设数$i$的坐标为$l_i$和$r_i$，预处理出以数$i$为一个操作时的分数$f(i)$，那么对于区间$[l_i,r_i]$，可以计算其中\n每个数的贡献（即$i$），若出现满足$l_i\\lt l_j \\lt r_j\\lt r_i $，则用$max(i,j)$代替区间$[l_j,r_j]$的贡献。\n\n计算区间$[l_i,k]$的最大分数$g(k)$，$g(k)$符合： $$ g(k)= \\begin{cases} max(g(k-1) +\ni,g(l_j-1)+f(j)),& (k=r_j \\quad and \\quad l_i \\lt l_j)\\ g(k-1) + i & \\end{cases}\n$$ 直到$k=r_i$，得到$f(i)=g(r_i)$。\n\n\n代码#\n\n","routePath":"/posts/algorithm/nc24sd2","lang":"","toc":[{"text":"A-Floor Tiles","id":"a-floor-tiles","depth":2,"charIndex":-1},{"text":"题意","id":"题意","depth":3,"charIndex":16},{"text":"数据范围","id":"数据范围","depth":4,"charIndex":89},{"text":"思路","id":"思路","depth":3,"charIndex":179},{"text":"代码","id":"代码","depth":3,"charIndex":463},{"text":"B-MST","id":"b-mst","depth":2,"charIndex":471},{"text":"题意","id":"题意-1","depth":3,"charIndex":480},{"text":"数据范围","id":"数据范围-1","depth":4,"charIndex":552},{"text":"思路","id":"思路-1","depth":3,"charIndex":655},{"text":"C-Red Walking on Grid","id":"c-red-walking-on-grid","depth":2,"charIndex":803},{"text":"题意","id":"题意-2","depth":3,"charIndex":828},{"text":"数据范围","id":"数据范围-2","depth":4,"charIndex":933},{"text":"思路","id":"思路-2","depth":3,"charIndex":964},{"text":"代码","id":"代码-1","depth":3,"charIndex":1048},{"text":"E-GCD VS XOR","id":"e-gcd-vs-xor","depth":2,"charIndex":1056},{"text":"题意","id":"题意-3","depth":3,"charIndex":1085},{"text":"数据范围","id":"数据范围-3","depth":4,"charIndex":1145},{"text":"思路","id":"思路-3","depth":3,"charIndex":1201},{"text":"代码","id":"代码-2","depth":3,"charIndex":1392},{"text":"H-Instructions Substring","id":"h-instructions-substring","depth":2,"charIndex":1400},{"text":"题意","id":"题意-4","depth":3,"charIndex":1428},{"text":"数据范围","id":"数据范围-4","depth":4,"charIndex":1524},{"text":"思路","id":"思路-4","depth":3,"charIndex":1591},{"text":"代码","id":"代码-3","depth":3,"charIndex":1818},{"text":"I-Red Playing Cards","id":"i-red-playing-cards","depth":2,"charIndex":1826},{"text":"题意","id":"题意-5","depth":3,"charIndex":1849},{"text":"数据范围","id":"数据范围-5","depth":4,"charIndex":1964},{"text":"思路","id":"思路-5","depth":3,"charIndex":2003},{"text":"代码","id":"代码-4","depth":3,"charIndex":2353}],"domain":"","frontmatter":{"title":"2024牛客暑假多校训练营Day2||补题","subtitle":"","date":"2024-07-19T11:06:03.000Z","lastmod":"2024-07-19T11:06:03.000Z","draft":false,"authors":[],"description":"","tags":["2024暑假集训","算法","牛客"],"categories":["在学算法的日子里"],"series":["题解记录"],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"","featuredImagePreview":"","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":29,"title":"2024牛客暑假多校训练营Day3||补题","content":"A-Bridging the Gap 2#\n\n\n题意#\n\n在河岸的一侧有$n$个人，每个人有一个体力值$h_i$，有一艘船可以将人从一侧载到另一侧，每次航行需要至少$L$个人掌舵，每次掌舵会花费每个掌舵人的一点体力，当\n体力不足一点时，这个人不能再掌舵，船的容量最大是$R$，提问是否能够将这些人都运送到对岸。\n\n数据范围#\n\n * $1\\leq L\\lt R\\leq n\\leq 5\\times 10^5$\n * $1\\leq h_i\\leq 5\\times 10^5$\n\n\n思路#\n\n贪心的运输，从左岸运输的最小次数是$k=\\lceil \\frac{n-R}{R-L}\n\\rceil$，计算每个人最多的来回次数$a_i$，假如满足$\\sum_{i-1}^{n} min(k,a_i)\\geq k\\times\nL$，则可以将所有人都运输到对岸。\n\n\n代码#\n\n\n\n\nB-Crash Test#\n\n\n题意#\n\n小车有$n$个引擎，第$i$个引擎可以让车前进$h[i]$米。在小车起点正前方距离为$D$处有一反弹墙面，小车如果撞在墙上将会被回弹与当前剩余的前进米数相同的距\n离，并保持车头朝向墙面。小车可以使用任意引擎任意次，询问距离墙面最近的距离是多少。\n\n数据范围#\n\n * $1\\leq n\\leq 100$\n * $1\\leq D \\leq 10^{18}$\n * $1\\leq h[i]\\leq 10^{18}$\n\n\n思路#\n\n假设当前选择了某个引擎，并只使用这个引擎，易知，我们可以将距离$d$减小到$\\min(d\\bmod h[i],h[i]-d\\bmod h[i])$。\n\n接下来选择另一种引擎，在刚才的基础上，我们可以将距离减小到$\\min(d\\bmod h[i+1],h[i+1]-d\\bmod h[i+1])$。\n\n设$gcd(h[i],h[i+1])=k$，$h[i]=ak,h[i+1]=bk$，则$d$的变化其实是这样的：\n\n$$ \\begin{align*} d_1=&\\min(d_0\\bmod ak,d_0-d_0\\bmod ak)\\ =&\\min(d_0\\bmod\nk,d_0-d_0\\bmod k)\\ d_2=&\\min(d_1\\bmod bk,d_1-d_1\\bmod bk)\\ =&\\min(d_1\\bmod\nk,d_1-d_1\\bmod k)\\ =&d_1\\ =&\\min(d_0\\bmod k,d_0-d_0\\bmod k)\\ &.......\n\\end{align*} $$\n\n观察结果，可以发现最小的$|dis-d|$之和所有引擎的$gcd$有关，计算$h[]$数组的$gcd$即可。\n\n\n代码#\n\n\n\n\nD-Dominoes!#\n\n\n题意#\n\n一张多米诺骨牌的左右两端各有一个数字，给出$n$张这样的多米诺骨牌，是否存在一个可以另所有相邻且不在同一张牌上的两个数字不一样的序列。\n\n数据范围#\n\n * $1\\leq n\\leq 2\\times 10^5$\n * $1\\leq x_i,y_i\\leq 10^9$\n\n\n思路#\n\n首先注意到当 某个数字的数量大于等于$n+2$时，一定没有合法的排列。\n\n而如果符合$\\lt n+2$，一定有合法序列。\n\n如果所有骨牌都满足$x_i\\neq y_i$，则只要满足每次从两侧加入的牌相邻没有相同数字即可，一定有合法序列。\n\n优先考虑排列$x_i=y_i$的骨牌。将$x_i =\ny_i$的骨牌按照数量从大到小排序，每次选择一张牌，假设这张牌的数字是$p$，之后选择现存数量最多的且符合$x_j = y_j\\neq\np$的一张牌，放在右侧，接下来继续取两侧相同骨牌中数目最多的，若两侧相同骨牌数目不足$2$种，则加入任意两侧不同的牌，注意接触端的条件\n\n\n代码#\n\n\n\n\nE-Malfunctioning Typewriter#\n\n\n题意#\n\n有一台打字机，对于每次键入的字符（只有0或1），每次有p的概率正确键入，有$n$句长度为$m$的不会重复的诗句，这些诗句可以以任意顺序组合成一首长度为$n$的诗\n。询问在打字这首诗的时候，有多大的概率成果打出。\n\n数据范围#\n\n * $1\\leq n,m\\leq 1000$\n * $0.5\\leq q\\leq 1$\n\n\n思路#\n\n将$n$句诗建立字典树，对每个节点统计以该结点为前缀的字符串数目。\n\n考虑到只有01，每个节点下最多只有0或1的子节点。记某个节点为$u$，将节点$u$前缀打对的概率可以预处理（$f(x,y)$表示打对$x$个$1$，$y$个$0\n$的概率），打对一整首诗歌是遍历完字典树上的每个字符串$1$次，对于字典树上的某个非叶子节点，在遍历时，经过该结点的数目是它的子树中有多少个叶子结点决定的，假设\n有$x$是从该节点（表示一个前缀）往后以1为根节点的子树中的叶子结点数目，$y$是以0为根节点的子树中叶子结点的数目，那么在决策当前是否正确输出了0/1的概率是\n$f(x,y)$（相当于在当前节点输出正确的$x$个1和$y$个0的概率代表这一步打字输出了$x+y$个合法下行子串的概率），故总概率是$\\prod_u\nf(sz(lp),sz(rp))$。\n\n对$f(x,y)$的预处理：\n\n$$ f(x,y)=\\max(p\\times f(x-1,y)+(1-p)\\times f(x,y),p\\times f(x,y-1)+(1-p)\\times\nf(x-1,y)) $$\n\n\n代码#\n\n\n\n\nJ-Rigged Games#\n\n\n题意#\n\n比赛由大分比和小分比一同决定最终的胜负，小分比Bo2a-1：先胜出a场为胜。大分比Bo2b-1：先胜出b场为胜。记1次小分比胜负为大分比的一场。\n\n现在有一个长度为$n$的01字符串，字符串是无限循环重复的，用于记录每一次比赛的胜负，从01字符串的每个位置开始比赛，询问谁会赢得整个比赛。\n\n数据范围#\n\n * $1\\leq n,a,b\\leq 10^5$\n\n\n思路#\n\n倍增思想，在01循环串中，记录每个位置开始后进行Bo2a-1小局的胜负，以及下一步从哪个位置开始。数组f[i][j]表示从$i$开始进行$2^j$轮后到达的位置\n、对应的$0$、$1$ 的胜利次数。\n\n在统计Bo2b-1时，我们要找到第一次0或1胜利b次以上的位置，将j倒序处理，$2b-1$是最多获得终局的次数，$b$是最少获得终局的次数。假设$b=5$，需要\n至少$5$局，至多$9$局定胜负，注意到$9=2^3+2^0$，在计数恰好$9$局时，应当只统计先$2^3=8$局，然后往后再统计$2^0=1$局（这里先1后8\n也不会影响结果，只要保证不超过9局即可）。在计算Bo2b-1的结果时，每次统计恰好$2b-1$。\n\n\n代码#\n\n\n\n\nL-Sudoku and Minesweeper#\n\n\n题意#\n\n给出一个$9\\times 9$的数独，在这个数独的基础上构造一个扫雷地图，将数独上的一些数字替换为*，但是不能将所有数字都替换为*，使得整个扫雷地图合法。\n\n\n思路#\n\n在铺满地雷的地图上保留一些数字，数字8表明该格周围都是*，所以选择保留所有的8，并再次遍历一遍所有的地图（注意边界），删掉不符合要求的8。\n\n或者另一个想法：中间$3\\times 3$的格子中中一定有一个数字8，在去掉除了这个8以外的所有数字之后，这个8一定是符合要求的。\n\n\n代码#\n\n","routePath":"/posts/algorithm/nc24sd3","lang":"","toc":[{"text":"A-Bridging the Gap 2","id":"a-bridging-the-gap-2","depth":2,"charIndex":-1},{"text":"题意","id":"题意","depth":3,"charIndex":23},{"text":"数据范围","id":"数据范围","depth":4,"charIndex":156},{"text":"思路","id":"思路","depth":3,"charIndex":238},{"text":"代码","id":"代码","depth":3,"charIndex":375},{"text":"B-Crash Test","id":"b-crash-test","depth":2,"charIndex":383},{"text":"题意","id":"题意-1","depth":3,"charIndex":399},{"text":"数据范围","id":"数据范围-1","depth":4,"charIndex":528},{"text":"思路","id":"思路-1","depth":3,"charIndex":612},{"text":"代码","id":"代码-1","depth":3,"charIndex":1118},{"text":"D-Dominoes!","id":"d-dominoes","depth":2,"charIndex":1126},{"text":"题意","id":"题意-2","depth":3,"charIndex":1141},{"text":"数据范围","id":"数据范围-2","depth":4,"charIndex":1215},{"text":"思路","id":"思路-2","depth":3,"charIndex":1282},{"text":"代码","id":"代码-2","depth":3,"charIndex":1572},{"text":"E-Malfunctioning Typewriter","id":"e-malfunctioning-typewriter","depth":2,"charIndex":1580},{"text":"题意","id":"题意-3","depth":3,"charIndex":1611},{"text":"数据范围","id":"数据范围-3","depth":4,"charIndex":1723},{"text":"思路","id":"思路-3","depth":3,"charIndex":1777},{"text":"代码","id":"代码-3","depth":3,"charIndex":2268},{"text":"J-Rigged Games","id":"j-rigged-games","depth":2,"charIndex":2276},{"text":"题意","id":"题意-4","depth":3,"charIndex":2294},{"text":"数据范围","id":"数据范围-4","depth":4,"charIndex":2445},{"text":"思路","id":"思路-4","depth":3,"charIndex":2480},{"text":"代码","id":"代码-4","depth":3,"charIndex":2799},{"text":"L-Sudoku and Minesweeper","id":"l-sudoku-and-minesweeper","depth":2,"charIndex":2807},{"text":"题意","id":"题意-5","depth":3,"charIndex":2835},{"text":"思路","id":"思路-5","depth":3,"charIndex":2920},{"text":"代码","id":"代码-5","depth":3,"charIndex":3064}],"domain":"","frontmatter":{"title":"2024牛客暑假多校训练营Day3||补题","subtitle":"","date":"2024-07-23T10:37:58.000Z","lastmod":"2024-07-23T10:37:58.000Z","draft":false,"authors":[],"description":"","tags":["2024暑假集训","算法","牛客"],"categories":["在学算法的日子里"],"series":["题解记录"],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"","featuredImagePreview":"","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":30,"title":"2024牛客暑假多校训练营Day4||补题","content":"A-LCT#\n\n\n题意#\n\n给定一棵有根树，每次询问前$i$条边组成的森林中，第$c_i$个点为根的树的深度。\n\n数据范围#\n\n * $2\\leq n\\leq 10^6$\n * $1\\leq a_i,b_i,c_i\\leq n,a_i\\neq b_i$\n\n\n思路#\n\n带权并查集，维护每个节点在当前所属树的层数，维护所有以该节点为根节点的树的深度。\n\n\n代码#\n\n\n\n\nC-Sort4#\n\n\n题意#\n\n给出一个排列，每次选择四个位置交换其中的元素，求将该排列排序成上升序列的最小操作次数。\n\n数据范围#\n\n * $1\\leq t\\leq 10^5$\n * $1\\leq n\\leq 10^6$\n\n\n思路#\n\n令$p_i$是排序之后数$a_i$的位置，每个$(p_i,a_i)$对应了一个关系。易知这样的关系会形成若干个环，如果环的长度是$3$或$4$，则一次交换可以让\n这个环上的数字都归位，如果是大于$4$的环，每次在这个环上进行一次操作可以让环的长度减少$3$，如果是两个长度为$2$的环，则一次操作可以让两个长度为$2$的环\n归位。\n\n\n代码#\n\n\n\n\nF-Good Tree#\n\n\n题意#\n\n一棵树，树上的边权都是$1$，定义$f(u)=\\sum_v\ndis(u,v)$，给出一个$x$，寻找一个满足存在两个点$u,v$使得$f(u)-f(v)=x$成立的最少节点子树，输出节点数。\n\n数据范围#\n\n * $1\\leq t\\leq 10^5$\n * $1\\leq x \\leq 10^{18}$\n\n\n思路#\n\n$f(u)$为点$u$到各个其他节点的距离之和，只有$u\\rightarrow\nv$一条路径的时候，$f(u)=f(v)=dia(u,v)$，若要增加$f(u)$和$f(v)$之间的差值，每在$v$上增加一个在$v$的子树中的节点，$f(u\n)-f(v)$的值就会增加一倍$dis(u,v)$。\n\n当有奇数个点，$2\\times k +1$个点，另$dis(u,v)=k$，剩余$k$个点都是$v$的子树中的节点，$f(u)-f(v)$最大是$k^2$。\n\n当有偶数个点，$2\\times k+2$，同理，$f(u)-f(v)$的最大值是$k(k+1)$。\n\n下一个奇数是$(k+1)^2$，再下一个偶数的是$(k+1)(k+2)$...\n\n故对于一个确定的$x$，我们需要确定落在哪个$(k^2,(k+1)^2]$区间，然后再确定是在区间$(k^2,k(k+1)]$还是$(k(k+1),(k+1)^\n2]$，也就是点数应该至少是大于$2\\times k+1$还是$2\\times k+2$。\n\n在区间$(k(k+1),(k+1)^2)$中，一定可以构造出$2\\times k+3$的方法；\n\n在区间$(k^2,k(k+1)]$中，如果$k$为奇数，可以构造出$2\\times k+3$，如果$k$为偶数，可以构造出$2\\times k+2$。\n\n\n代码#\n\n\n\n\nG-Horse Drinks Water#\n\n\n题意#\n\n将军饮马问题。在平面坐标轴中，只有$x、y$轴的飞负半轴是水源，给出马儿的坐标和营地的坐标，求最短距离。\n\n数据范围#\n\n * $1\\leq t\\leq 10^5$\n * $0\\leq x_G,y_G,x_T,u_T\\leq 10^9$\n\n\n思路#\n\n将坐标按坐标轴对称，求距离。\n\n\n代码#\n\n\n\n\nH-Yet Another Origami Problem#\n\n\n题意#\n\n可以选择任意坐标$p$，进行如下二选一操作：\n\n 1. 若符合$a_i\\leq a_p$，可以重新赋值$a_i\\leftarrow a_i + 2(a_p-a_i)$。\n 2. 若符合$a_i\\geq a_p$，可以重新赋值$a_i \\leftarrow a_i-a(a_i-a_p)$\n\n可以进行上述操作若干次，求问可以将$a$数组的范围收敛到多小。\n\n数据范围#\n\n * $1\\leq t\\leq 5\\times 10^5$\n * $1\\leq n\\leq 10^5$\n * $0\\leq a_i\\leq 10^{16}$\n\n\n思路#\n\n上面的操作可以进行无数次，通过模拟可以意识到，这是一个类似折纸的操作，是将某个数沿着某条线折叠到另一边的操作。注意到每次操作不是必须要对每个$a_i$进行这样的\n翻折的，例如当$a_i\\lt a_p$时选择操作2，可以避免$a_i$的翻折。\n\n通过翻折让数组的范围收束到最小。假设当前只有3个各不相同的数，这三个数从小到大排列之后是${a,b,c}$，那么在数轴上形成了距离$x=b-a$和$y=c-b$\n，对于这三个数来说，通过折叠，假设是$a$沿着$b$向$c$折叠，将$x$变为$x\\bmod\ny$（不断沿着$y$的两边折叠，直到落在$b、c$之间），若此时$x\\neq\n0$，则$y$也可以通过一样的方法收束到小于$x$的某个长度。故获得的最小的范围应该是$x、y$的$gcd$。\n\n同样的思想可以拓展到多个数的时候。\n\n\n代码#\n\n\n\n\nI-Friends#\n\n\n题意#\n\n$n$个人从左到右排成一排，编号从$1$到$n-1$，这$n$个人之间有$m$对好朋友，求有多少个区间$[l,r]$中每两对都是好朋友。\n\n数据范围#\n\n * $1\\leq n,m \\leq 10^6$\n\n\n思路#\n\n假设已有一个区间$[l,r]$符合要求，且$r$是以$l$为左端点的时候最远的符合要求的右端点。那么显然有：\n\n当加入$r+1$时，$r+1$号与$[l,r]$中的至少一个人不是好友关系。同时，区间$[l+1,r]$是一个友好区间，于是在移动左端点时，右端点只需要从上一个\n左端点的最远右端点开始检查即可。\n\n\n代码#\n\n","routePath":"/posts/algorithm/nc24sd4","lang":"","toc":[{"text":"A-LCT","id":"a-lct","depth":2,"charIndex":-1},{"text":"题意","id":"题意","depth":3,"charIndex":8},{"text":"数据范围","id":"数据范围","depth":4,"charIndex":56},{"text":"思路","id":"思路","depth":3,"charIndex":128},{"text":"代码","id":"代码","depth":3,"charIndex":176},{"text":"C-Sort4","id":"c-sort4","depth":2,"charIndex":184},{"text":"题意","id":"题意-1","depth":3,"charIndex":195},{"text":"数据范围","id":"数据范围-1","depth":4,"charIndex":245},{"text":"思路","id":"思路-1","depth":3,"charIndex":298},{"text":"代码","id":"代码-1","depth":3,"charIndex":471},{"text":"F-Good Tree","id":"f-good-tree","depth":2,"charIndex":479},{"text":"题意","id":"题意-2","depth":3,"charIndex":494},{"text":"数据范围","id":"数据范围-2","depth":4,"charIndex":596},{"text":"思路","id":"思路-2","depth":3,"charIndex":653},{"text":"代码","id":"代码-2","depth":3,"charIndex":1234},{"text":"G-Horse Drinks Water","id":"g-horse-drinks-water","depth":2,"charIndex":1242},{"text":"题意","id":"题意-3","depth":3,"charIndex":1266},{"text":"数据范围","id":"数据范围-3","depth":4,"charIndex":1325},{"text":"思路","id":"思路-3","depth":3,"charIndex":1392},{"text":"代码","id":"代码-3","depth":3,"charIndex":1414},{"text":"H-Yet Another Origami Problem","id":"h-yet-another-origami-problem","depth":2,"charIndex":1422},{"text":"题意","id":"题意-4","depth":3,"charIndex":1455},{"text":"数据范围","id":"数据范围-4","depth":4,"charIndex":1638},{"text":"思路","id":"思路-4","depth":3,"charIndex":1726},{"text":"代码","id":"代码-4","depth":3,"charIndex":2097},{"text":"I-Friends","id":"i-friends","depth":2,"charIndex":2105},{"text":"题意","id":"题意-5","depth":3,"charIndex":2118},{"text":"数据范围","id":"数据范围-5","depth":4,"charIndex":2193},{"text":"思路","id":"思路-5","depth":3,"charIndex":2227},{"text":"代码","id":"代码-5","depth":3,"charIndex":2388}],"domain":"","frontmatter":{"title":"2024牛客暑假多校训练营Day4||补题","subtitle":"","date":"2024-07-31T07:55:48.000Z","lastmod":"2024-07-31T07:55:48.000Z","draft":false,"authors":[],"description":"","tags":["2024暑假集训","算法","牛客"],"categories":["在学算法的日子里"],"series":["题解记录"],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"","featuredImagePreview":"","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":31,"title":"2024牛客暑假多校训练营Day5||补题","content":"TODO","routePath":"/posts/algorithm/nc24sd5","lang":"","toc":[],"domain":"","frontmatter":{"title":"2024牛客暑假多校训练营Day5||补题","subtitle":"","date":"2024-07-31T07:55:57.000Z","lastmod":"2024-07-31T07:55:57.000Z","draft":false,"authors":[],"description":"","tags":["2024暑假集训","算法","牛客"],"categories":["在学算法的日子里"],"series":["题解记录"],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"https://img.dodolalorc.cn/i/2024/12/10/67580c6f05b30.png","featuredImagePreview":"https://img.dodolalorc.cn/i/2024/12/10/67580c6f05b30.png","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":32,"title":"2024牛客暑假多校训练营Day6||补题","content":"A-Cake#\n\n\n题意#\n\nOscar和Grammy玩游戏，第一阶段两人轮流在有根树上走，走到叶子停止，经过的边有两种，标0边或者标1边，记录走下的01串。设01串的长度是$m$，第二阶段\nOscar将蛋糕切成$m$份，有些蛋糕可以是空的，按照第一阶段的01串顺序依次拿蛋糕（1代表Grammy拿，0代表Oscar拿），两人都想获得最多的蛋糕，求最后\nGrammy获得的蛋糕比例。\n\n数据范围#\n\n * $1\\leq n\\leq 2\\times 10^5$\n\n\n思路#\n\n在第二阶段，Oscar分蛋糕的时候，是对当前串寻找一个0占比最大的前缀，然后拿走占比一致的蛋糕。\n\n于是，在第一阶段时，首先树上每个节点即代表一个前缀，预处理出每个节点为前缀时0的占比，在之后两人轮流取数时，Oscar会取选择下一个节点轮流选择后0占比最大的节\n点，Grammy会选择0占比最小的节点。\n\n\n代码#\n\n\n\n\nB-Cake 2#\n\n\n题意#\n\n对一个正$n$边形，顶点按顺时针标为$0\\sim n-1$，在每一个$i$和$(i+k)\\bmod n$的顶点之间切一刀，问最终能切出多少块蛋糕。\n\n数据范围#\n\n * $1\\leq n\\leq 10^6$\n * $2\\leq k\\leq n-2$\n\n\n思路#\n\n找规律可以发现除了$2\\times k=n$时答案为$n$，其他情况都符合$n\\times \\min(n-k,k) +1$。\n\n\n代码#\n\n\n\n\nD-Puzzle: Wagiri#\n\n\n题意#\n\n无向图中有两种边，对原图进行删边，要求删完边之后图仍是联通的，且所有的轮边只在环中出现，所有的切边都不在环，判断是否存在合适的删边操作，若有再输出结果的连接情况\n。\n\n数据范围#\n\n * $1\\leq n\\leq 10^5$\n * $n-1\\leq m\\leq 2\\times 10^5$\n * $1\\leq u_i,v_i\\leq n$\n * $t_i\\in \\{\"Lun\",\"Qie\"\\}$\n\n\n思路#\n\n将所有的$Lun$边中成环的部分进行缩点，再根据$Qie$边对这些点生成一棵树。\n\n\n代码#\n\n\n\n\nH-Genshin Impact's Fault#\n\n\n题意#\n\n每次抽卡的结果是3星、4星、5星非Up、5星Up四种结果中的一种。同时也符合如下的要求：\n\n * 连续10抽中不会全是3星。\n * 连续90抽中至少有一个是5星非Up或5星Up\n * 每两个连续的5星中至少有一个是5星非Up\n\n给出一个抽卡结果序列，判断该抽卡结果是否符合上述规则。\n\n数据范围#\n\n * $1\\leq T\\leq 10^5$\n * $1\\leq |S|\\leq 10^6$\n\n\n思路#\n\n模拟。\n\n\n代码#\n\n\n\n\nF-Challenge NPC 2#\n\n\n题意#\n\n在一个森林的补图中寻找哈密顿路径。\n\n注：哈密顿路径指经过图中所有顶点一次且仅经过一次。\n\n数据范围#\n\n * $n\\leq 5\\times 10^5$\n\n\n思路#\n\n森林中有且只有一棵菊花是无解的。剩余情况中，假如树是一棵菊花，则将其分为花瓣和花心两部分，花瓣可以连成一条路径，花心单独成为一条路径，假如不是一棵菊花，则寻找树\n的一个叶子结点，再从叶子结点进行BFS，按照246...135...的顺序将点穿起来，加入答案。\n\n最后将不能相连的一组花瓣花心分别接在答案的两边，输出答案即可。\n\n\n代码#\n\n","routePath":"/posts/algorithm/nc24sd6","lang":"","toc":[{"text":"A-Cake","id":"a-cake","depth":2,"charIndex":-1},{"text":"题意","id":"题意","depth":3,"charIndex":9},{"text":"数据范围","id":"数据范围","depth":4,"charIndex":192},{"text":"思路","id":"思路","depth":3,"charIndex":231},{"text":"代码","id":"代码","depth":3,"charIndex":390},{"text":"B-Cake 2","id":"b-cake-2","depth":2,"charIndex":398},{"text":"题意","id":"题意-1","depth":3,"charIndex":410},{"text":"数据范围","id":"数据范围-1","depth":4,"charIndex":490},{"text":"思路","id":"思路-1","depth":3,"charIndex":542},{"text":"代码","id":"代码-1","depth":3,"charIndex":612},{"text":"D-Puzzle: Wagiri","id":"d-puzzle-wagiri","depth":2,"charIndex":620},{"text":"题意","id":"题意-2","depth":3,"charIndex":640},{"text":"数据范围","id":"数据范围-2","depth":4,"charIndex":729},{"text":"思路","id":"思路-2","depth":3,"charIndex":845},{"text":"代码","id":"代码-2","depth":3,"charIndex":893},{"text":"H-Genshin Impact's Fault","id":"h-genshin-impacts-fault","depth":2,"charIndex":901},{"text":"题意","id":"题意-3","depth":3,"charIndex":929},{"text":"数据范围","id":"数据范围-3","depth":4,"charIndex":1077},{"text":"思路","id":"思路-3","depth":3,"charIndex":1132},{"text":"代码","id":"代码-3","depth":3,"charIndex":1143},{"text":"F-Challenge NPC 2","id":"f-challenge-npc-2","depth":2,"charIndex":1151},{"text":"题意","id":"题意-4","depth":3,"charIndex":1172},{"text":"数据范围","id":"数据范围-4","depth":4,"charIndex":1223},{"text":"思路","id":"思路-4","depth":3,"charIndex":1256},{"text":"代码","id":"代码-4","depth":3,"charIndex":1426}],"domain":"","frontmatter":{"title":"2024牛客暑假多校训练营Day6||补题","subtitle":"","date":"2024-08-05T02:15:52.000Z","lastmod":"2024-08-05T02:15:52.000Z","draft":false,"authors":[],"description":"","tags":["2024暑假集训","算法","牛客"],"categories":["在学算法的日子里"],"series":["题解记录"],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"https://img.dodolalorc.cn/i/2024/12/10/67580cc38a90f.png","featuredImagePreview":"https://img.dodolalorc.cn/i/2024/12/10/67580cc38a90f.png","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":33,"title":"2024牛客暑假多校训练营Day7||补题","content":"I-Fight Against the Monster#\n\n\n题意#\n\n使用机器对抗怪兽，一台机器有以下两种功能：\n\n * 战斗：使怪兽血量减少1点，后技巧丧失所有功能\n * 创造：需要$m$台机器同时使用，创造出$k$台新机器，每台机器仅能使用一次创造功能。\n\n怪兽初始血量是$h$，血量下降至$0$ 时死亡，请计算初始最少需要多少机器才能打败怪兽。\n\n数据范围#\n\n * $1\\leq t\\leq 2\\times 10^5$\n * $1\\leq k\\leq m \\leq 10^6$\n * $0\\leq h\\leq 10^9$\n\n\n思路#\n\n根据机器的功能特点，我们尽可能让每台机器进行创造。若最初有$x$台机器，则进行一次创造之后拥有$x+k(x\\ge\nm)$台机器，其中有$k+x-m$台机器拥有创造能力，最多拥有的机器数目是直到拥有创造能力的机器数目低于$m$时拥有的机器数目。可以发现除了第一次使用$m$台机\n器进行创造，之后使用$m$台机器进行创造时，可以使用$k$台新制造的机器加上$m-k$台最初拥有的机器进行创造，那么最多拥有的机器数目是： $$ f(x)=\n\\begin{cases} x\\quad x\\lt m\\ x+k\\times (\\lfloor (x-m)/(m-k)\\rfloor+1)\n\\end{cases} $$ 二分寻找符合条件的最少的最初机器数即可。\n\n不过队友在赛时提供了一种更加直观不必二分求解的方法：\n\n怪兽每受到$m$点攻击时，可以将这$m$点攻击看成是花费$m-k$台机器，在保证至少能发出一次$m$点攻击时，最初的机器数目要有$m$个，同时，怪物剩余不足$m\n$点血量时，只能再用额外的机器进行攻击。相关代码也贴在下面了。\n\n\n代码#\n\n\n\n\nJ-Ball#\n\n\n题意#\n\n坐标轴上有一根木棒，左端点在原点$(0,0)$处，垂直$y$轴放置，右端点在$(l,0)$处，在坐标轴上有一个点$P(x,y)$，询问在木棒上是否有一个点，满足\n当木棒绕着该点旋转时可以击中点$P$，如有则输出该点坐标，若无输出$-1$。\n\n数据范围#\n\n * $1\\leq T\\leq 10^4$\n * $1\\leq l\\leq 10^5$\n * $-10^5\\leq x,y \\leq 10^5$\n\n\n思路#\n\n木棒可以到达的最大范围是以$(0,0)$为旋转中心和以$(l,0)$为旋转中心的旋转范围的并集。\n\n\n代码#\n\n\n\n\nK-Strings, Subsequences, Reversed Subsequences, Prefixes#\n\n\n题意#\n\n给出一个字符串$s$和一个字符串$t$，要求在$s$中寻找以$t$为前缀，以$t$的翻转串为后缀的$s$的子串，求这样的本质不同的子串数目。\n\n数据范围#\n\n * $1\\leq n,m \\leq 10^6$\n * $s_i,t_i\\in [a,z]$\n\n\n思路#\n\n前缀和后缀可以直接暴力从$s$最左侧和最右侧枚举，前后缀还要加上有公共重叠部分的数目，之后的问题就是如何计算中间部分的本质不同的子串了。\n\n另中间部分的字符串为$s'$，在$s'$上，设$f[i]$表示到第$i$位时拥有多少个本质不同的子串，将$a[i]$加入时，$a[i]$可以加入在$f[i-1]\n$时的所有本质不同的子串的后面，这样形成的字符串中，与原来答案重复的是上一个字符$a[i]$加入时拥有的本质不同的字符串数目，所以转移方程是这样： $$\nf[i]=2\\times f[i-1]-f[last[a[i]]-1] $$\n\n在处理前后缀的时候，当前后缀所处的最小区域有相交时，枚举允许重叠的长度时要至少从重叠部分的长度开始进行枚举。\n\n\n代码#\n\n","routePath":"/posts/algorithm/nc24sd7","lang":"","toc":[{"text":"I-Fight Against the Monster","id":"i-fight-against-the-monster","depth":2,"charIndex":-1},{"text":"题意","id":"题意","depth":3,"charIndex":30},{"text":"数据范围","id":"数据范围","depth":4,"charIndex":177},{"text":"思路","id":"思路","depth":3,"charIndex":267},{"text":"代码","id":"代码","depth":3,"charIndex":739},{"text":"J-Ball","id":"j-ball","depth":2,"charIndex":747},{"text":"题意","id":"题意-1","depth":3,"charIndex":757},{"text":"数据范围","id":"数据范围-1","depth":4,"charIndex":883},{"text":"思路","id":"思路-1","depth":3,"charIndex":965},{"text":"代码","id":"代码-1","depth":3,"charIndex":1021},{"text":"K-Strings, Subsequences, Reversed Subsequences, Prefixes","id":"k-strings-subsequences-reversed-subsequences-prefixes","depth":2,"charIndex":1029},{"text":"题意","id":"题意-2","depth":3,"charIndex":1089},{"text":"数据范围","id":"数据范围-2","depth":4,"charIndex":1166},{"text":"思路","id":"思路-2","depth":3,"charIndex":1222},{"text":"代码","id":"代码-2","depth":3,"charIndex":1552}],"domain":"","frontmatter":{"title":"2024牛客暑假多校训练营Day7||补题","subtitle":"","date":"2024-08-08T16:26:24.000Z","lastmod":"2024-08-08T16:26:24.000Z","draft":false,"authors":[],"description":"","tags":["2024暑假集训","算法","牛客"],"categories":["在学算法的日子里"],"series":["题解记录"],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"https://img.dodolalorc.cn/i/2024/12/10/67580d0599587.png","featuredImagePreview":"https://img.dodolalorc.cn/i/2024/12/10/67580d0599587.png","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":34,"title":"2024牛客暑假多校训练营Day8||补题","content":"A-Haitang and Game#\n\n\n题意#\n\n给出一个数组，两人轮流，每次选择数组中的两个数，若这两个数的$gcd$不在当前的数组里，就将这两个数的$gcd$加入到数组中，不能再加数的一方输。\n\n数据范围#\n\n * $1\\leq t\\leq 100$\n * $1\\leq n\\leq 10^5$\n * $1\\leq a_i\\leq 10^5$\n\n\n思路#\n\n整个数组的最终含有哪些数是确定的，枚举$1\\sim\na_{max}$的每个数，记为$x$，查看数组中大于$x$的整数倍的数，若这些倍数的$gcd$恰好等于$x$，则$x$会出现在最终的数组中。\n\n\n代码#\n\n\n\n\nK-Haitang and Ava#\n\n\n题意#\n\n符合以下条件的字符串的合法的：\n\n * 空串是合法的。\n * 在合法串$S$的前面或后面加$ava$ 形成的字符串是合法的。\n * 在合法串$S$的前面或后面加$avava$ 形成的字符串是合法的。\n\n给你一个字符串，判断它是否合法。\n\n数据范围#\n\n * $1\\leq T\\leq 1.7\\times 10^5$\n * $3\\leq |S| \\leq 5\\times 10^5$\n\n\n思路#\n\n逐步删去前缀或后缀，若最后能删成空串，则为合法串。\n\n\n代码#\n\n","routePath":"/posts/algorithm/nc24sd8","lang":"","toc":[{"text":"A-Haitang and Game","id":"a-haitang-and-game","depth":2,"charIndex":-1},{"text":"题意","id":"题意","depth":3,"charIndex":21},{"text":"数据范围","id":"数据范围","depth":4,"charIndex":101},{"text":"思路","id":"思路","depth":3,"charIndex":177},{"text":"代码","id":"代码","depth":3,"charIndex":281},{"text":"K-Haitang and Ava","id":"k-haitang-and-ava","depth":2,"charIndex":289},{"text":"题意","id":"题意-1","depth":3,"charIndex":310},{"text":"数据范围","id":"数据范围-1","depth":4,"charIndex":434},{"text":"思路","id":"思路-1","depth":3,"charIndex":508},{"text":"代码","id":"代码-1","depth":3,"charIndex":541}],"domain":"","frontmatter":{"title":"2024牛客暑假多校训练营Day8||补题","subtitle":"","date":"2024-08-08T16:26:32.000Z","lastmod":"2024-08-08T16:26:32.000Z","draft":false,"authors":[],"description":"","tags":["2024暑假集训","算法","牛客"],"categories":["在学算法的日子里"],"series":["题解记录"],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"https://img.dodolalorc.cn/i/2024/12/10/67580d3f3b117.png","featuredImagePreview":"https://img.dodolalorc.cn/i/2024/12/10/67580d3f3b117.png","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":35,"title":"2024牛客寒假营1||补题","content":"A-DFS搜索#\n\n\n题意#\n\n给一个字符串，判断其中是否包含dfs子序列和DFS子序列。\n\n数据范围#\n\n$T(1≤T≤100)$\n\n$n(1≤n≤50)$\n\n\n思路#\n\n直接搜。\n\n\n参考代码#\n\n\n\n\nB-关鸡#\n\n\n题意#\n\n\n\n从点(1, 0)出发，在宽为22、长为2×10^9^+12×10^9^+1的管道中有一些不可跨越的坐标点，判断最少添加几个着火点，使得无法走到左右端点。\n\n数据范围#\n\n$T(1≤T≤1e4)$\n\n$0≤n≤1e5$\n\n$r,c(1≤r≤2,−1e9≤c≤1e9)$\n\n\n思路#\n\n分别堵住两端的管道即可，堵住有三种情况：\n\n\n\n\n参考代码#\n\n\n\n\nC-按闹分配#\n\n\n题意#\n\n有n个人要排队办理业务，每个人的不满意度Di按照办完本人业务后的那一刻一共花费了多少时间来算，办事人员合理安排排队顺序，使得总不满意度$S_{min}=\\sum\n_{i=1}^{n}D_i$最小，记为$S_{min}$。\n\n然后急急鸡带着需要花费tc时间的业务想插队，办事人员对其的容忍度M如果不小于急急鸡插队后的不满意度$S_{c}$与$S_{min}$的差值，则会允许急急鸡插队。\n\n有q组询问，每组询问给出容忍度M，求出在该容忍度下急急鸡最快能办完业务的时间。\n\n数据范围#\n\n$n,Q,t_c(1≤n,Q≤105,1≤t_c≤1e9)$\n\n$t_i(1≤t_i≤1e6)$\n\n$M(0≤M≤1e18)$\n\n\n思路#\n\n初始从小到大排，求每个客户的不满意度Di（做前缀和）\n\n\n参考代码#\n\n\n\n\nD-本题又主要考察了贪心#\n\n\n题意#\n\n大骗子！\n\nn个人的比赛，还剩m局，每局的结果有：\n\n 1. 胜方加3分，败方不得分\n 2. 平局各加一分\n\n求一号选手最好的名次（并列的取并列的排名）\n\n数据范围#\n\n$T(1≤T≤100)$\n\n$n,m(2≤n≤10,1\\leq m\\leq 10)$\n\n$0\\leq a_i\\leq 100$\n\n$u_i,v_i,1\\leq u_i,v_i\\leq n,u_i≠v_i$\n\n\n思路#\n\n不会贪，数据范围小可以直接dfs暴力每种情况取最优，$O(3^m)$\n\n\n参考代码#\n\n\n\n\nF-鸡数题#\n\n\n题意#\n\n求有多少个长为m的数组a同时满足以下条件：\n\n 1. 对任意i，都有$a_i>0$\n 2. 数组a严格递增\n 3. $a_1|a_2|...|a_{m-1}|a_m=2^n-1$（其中|为按位或操作）\n 4. 对任意$i≠j$有$a_i&a_j=0$（其中&为按位与操作）\n\n答案要对$10^9+7$取模\n\n数据范围#\n\n$1\\leq n,m\\leq 10^5$\n\n\n思路#\n\n条件3说明，在2进制下的$2^n-1$（也就是数$(\\overbrace{11\\dots111}^n)_2$）每一位1都至少在$a_1~a_m$中出现一次，数组\na的大小为m，联合条件4说明每个数位上的1最多只能出现1次，所以问题转化为，将n个不同位置上1分配给m个数，且每个数至少有1个1。可知$n\\geq m$。\n\n也就是一个第二类斯特林数$n\\brace m$。\n\n递推式： $$ {n\\brace k}={n-1\\brace k-1}+k{n-1\\brace k} $$ 边界是：${n\\brace m}=[n=0]$。\n\n通项： $$ {n\\brace m}=\\sum_{i=0}^m \\frac{(-1)^{m-i}\\times i^n}{i!\\times (m-i)!} $$\n\n\n参考代码#\n\n\n\n\nG-why买外卖#\n\n\n题意#\n\n一些可以叠加的满ai减bi的券，现在有m元，提问可以买到食物的原价最大值是多少。\n\n数据范围#\n\n$T(1≤T≤1e4)$\n\n$n,m(1≤n≤1e5,1≤m≤1e9)$\n\n$a_i,b_i(1≤a_i,b_i≤1e9)$\n\n\n思路#\n\n前缀和，按照ai升序排列，能用ai的券的食物一定也能使用原价小于等于ai的所有的券，最后枚举原价即可。\n\n\n参考代码#\n\n\n\n\nI-It's bertrand paradox. Again!#\n\n\n题意#\n\n有两种生成平面上的圆的方式，给已生成的数据判断是哪种方式生成的。\n\nbit-noob的方法：\n\n 1. 随机等概率地从开区间$(−100,100)$生成两个整数$x,y$。\n 2. 随机等概率地从闭区间$[1,100]$中生成一个$r$。\n 3. 判断$(x,y)$为圆心、$r$为半径的圆是否满足要求，若不满足，返回步骤2重新生成$r$，若满足，则将该圆加入到结果中。\n\nbuaa-noob的方法：\n\n 1. 随机等概率地从开区间$(−100,100)$生成两个整数$x,y$，随机等概率地从闭区间$[1,100]$中生成一个$r$。\n 2. 判断$(x,y)$为圆心、$r$为半径的圆是否满足要求，若不满足，返回步骤1重新生成$x,y,r$，若满足，则将该圆加入到结果中。\n\n数据范围#\n\n$n=10^5$\n\n$0< x_i,y_i< 100,0< r_i\\leq100$\n\n\n思路#\n\n两种方法中，第一种的x和y的取值更容易受到r的限制，在r均匀分布在$[1,100]$的情况下，bit-noob的方法相对于buaa-noob的方法，x,y会更偏\n向集中在原点附近。\n\n\n参考代码#\n\n\n\n\nH-01背包，但是bit#\n\n\n题意#\n\n$n$个物品，每个物品有价值$v_i$和重量$w_i$，所选物品的总重量是所选物品重量的按位或运算的结果，求总重量不超过$m$的最大价值和\n\n数据范围#\n\n$T(1≤T≤10^4)$\n\n$n,m(1≤n≤10^5,0\\leq m\\leq 10^8)$\n\n$v_i,w_i(0\\leq v_i,w_i\\leq 10^8)$\n\n\n思路#\n\n枚举m右移位后的数字，能被这个位数低于m、数位上全是1的新m覆盖的都能拿\n\n状态转换：拿新筛出来的可选与原来的比较，取价值较大的那个\n\n\n参考代码#\n\n\n\n\nL-要有光#\n\n\n题意#\n\n\n\n如图，有一点光源在轨迹L($x=c,y=0,0\\leq z\\leq\nd$)上移动，存在一宽为$2w$，高为$h$的绿墙W，和一无限大的白墙S，求投影在地面上的阴影的面积。\n\n数据范围#\n\n$1\\leq T\\leq 10^4$\n\n$1\\leq c,d,h,w\\leq 10^4$\n\n输出浮点数误差小于$10^{-4}$\n\n\n思路#\n\n当点光源放在地面上时投影最大(z=0时)，这个投影是一个等腰梯形（大三角形截去一个小三角形）。\n\n\n参考代码#\n\n\n\n\nM-牛客老粉才知道的秘密#\n\n\n题意#\n\n\n\n就像上图一样，当可见范围移动时固定位移为6格，当移动碰到末端时会以末端为最远到达处。给出比赛总题数，判断像这样移动可能的位置数目。\n\n数据范围#\n\n$1\\leq T\\leq 10^5$\n\n$6\\leq n\\leq 10^9$\n\n\n思路#\n\n判断n是否是6的倍数即可，如果正好是6的倍数，那么返回时并不产生新的位置。\n\n\n参考代码#\n\n","routePath":"/posts/algorithm/nc24wd1","lang":"","toc":[{"text":"A-DFS搜索","id":"a-dfs搜索","depth":2,"charIndex":-1},{"text":"题意","id":"题意","depth":3,"charIndex":10},{"text":"数据范围","id":"数据范围","depth":4,"charIndex":46},{"text":"思路","id":"思路","depth":3,"charIndex":81},{"text":"参考代码","id":"参考代码","depth":3,"charIndex":93},{"text":"B-关鸡","id":"b-关鸡","depth":2,"charIndex":103},{"text":"题意","id":"题意-1","depth":3,"charIndex":111},{"text":"数据范围","id":"数据范围-1","depth":4,"charIndex":196},{"text":"思路","id":"思路-1","depth":3,"charIndex":254},{"text":"参考代码","id":"参考代码-1","depth":3,"charIndex":284},{"text":"C-按闹分配","id":"c-按闹分配","depth":2,"charIndex":294},{"text":"题意","id":"题意-2","depth":3,"charIndex":304},{"text":"数据范围","id":"数据范围-2","depth":4,"charIndex":544},{"text":"思路","id":"思路-2","depth":3,"charIndex":617},{"text":"参考代码","id":"参考代码-2","depth":3,"charIndex":651},{"text":"D-本题又主要考察了贪心","id":"d-本题又主要考察了贪心","depth":2,"charIndex":661},{"text":"题意","id":"题意-3","depth":3,"charIndex":677},{"text":"数据范围","id":"数据范围-3","depth":4,"charIndex":760},{"text":"思路","id":"思路-3","depth":3,"charIndex":872},{"text":"参考代码","id":"参考代码-3","depth":3,"charIndex":914},{"text":"F-鸡数题","id":"f-鸡数题","depth":2,"charIndex":924},{"text":"题意","id":"题意-4","depth":3,"charIndex":933},{"text":"数据范围","id":"数据范围-4","depth":4,"charIndex":1092},{"text":"思路","id":"思路-4","depth":3,"charIndex":1122},{"text":"参考代码","id":"参考代码-4","depth":3,"charIndex":1475},{"text":"G-why买外卖","id":"g-why买外卖","depth":2,"charIndex":1485},{"text":"题意","id":"题意-5","depth":3,"charIndex":1497},{"text":"数据范围","id":"数据范围-5","depth":4,"charIndex":1544},{"text":"思路","id":"思路-5","depth":3,"charIndex":1616},{"text":"参考代码","id":"参考代码-5","depth":3,"charIndex":1675},{"text":"I-It's bertrand paradox. Again!","id":"i-its-bertrand-paradox-again","depth":2,"charIndex":1685},{"text":"题意","id":"题意-6","depth":3,"charIndex":1720},{"text":"数据范围","id":"数据范围-6","depth":4,"charIndex":2065},{"text":"思路","id":"思路-6","depth":3,"charIndex":2116},{"text":"参考代码","id":"参考代码-6","depth":3,"charIndex":2214},{"text":"H-01背包，但是bit","id":"h-01背包但是bit","depth":2,"charIndex":2224},{"text":"题意","id":"题意-7","depth":3,"charIndex":2240},{"text":"数据范围","id":"数据范围-7","depth":4,"charIndex":2316},{"text":"思路","id":"思路-7","depth":3,"charIndex":2408},{"text":"参考代码","id":"参考代码-7","depth":3,"charIndex":2482},{"text":"L-要有光","id":"l-要有光","depth":2,"charIndex":2492},{"text":"题意","id":"题意-8","depth":3,"charIndex":2501},{"text":"数据范围","id":"数据范围-8","depth":4,"charIndex":2595},{"text":"思路","id":"思路-8","depth":3,"charIndex":2669},{"text":"参考代码","id":"参考代码-8","depth":3,"charIndex":2724},{"text":"M-牛客老粉才知道的秘密","id":"m-牛客老粉才知道的秘密","depth":2,"charIndex":2734},{"text":"题意","id":"题意-9","depth":3,"charIndex":2750},{"text":"数据范围","id":"数据范围-9","depth":4,"charIndex":2824},{"text":"思路","id":"思路-9","depth":3,"charIndex":2872},{"text":"参考代码","id":"参考代码-9","depth":3,"charIndex":2917}],"domain":"","frontmatter":{"title":"2024牛客寒假营1||补题","date":"2024-02-02T12:30:40.000Z","lastmod":"2024-02-09T21:21:23.000Z","draft":false,"authors":[],"description":"","tags":["2024寒假训练","算法","牛客"],"categories":["在学算法的日子里"],"series":["题解记录"],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"","featuredImagePreview":"","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":36,"title":"2024牛客寒假营2||补题","content":"A-Tokitsukaze and Bracelet#\n\n\n题意#\n\n根据手环的三个属性值判断手环的等级。\n\n 1. 对攻击百分比来说，+0为100%，+1为150%，+2为200%\n 2. 对体力和精神来说，+0在${29,30,31,32}$里选择，+1在${34,36,38,40}$里选择，+2固定为45\n\n数据范围#\n\n$n(1≤n≤100)$\n\n$a_i,b_i,c_i(a_i∈{100,150,200};b_i,ci∈{29,30,31,32,34,36,38,40,45})$\n\n\n思路#\n\n模拟即可\n\n\n参考代码#\n\n\n\n\nB-Tokitsukaze and Cats#\n\n\n题意#\n\n关猫，每个猫被限制在一个单元格内就算被关住了，如图：\n\n\n\n给猫的坐标，询问至少需要多少片防猫网能把他们全都关住。\n\n数据范围#\n\n$n, m, k (1≤n,m≤300;1≤k≤n⋅m)$\n\n$x_i, y_i (1≤xi≤n; 1≤yi≤m)$\n\n\n思路#\n\n遍历坐标点判断它上下左右是否有隔板，如果没有则补充。\n\n\n参考代码#\n\n\n\n\nE&F-Tokitsukaze and Eliminate#\n\n\n题意#\n\n有一排n个宝石，第i个的颜色是$col_i$，可以进行如下的操作：\n\n选一种颜色x，将颜色为x的最右边的那颗宝石及其右边的所有宝石全部消除。\n\n数据范围#\n\n$T(1\\leq T\\leq 2 * 10^5)$\n\n$n(1\\leq n\\leq 2 * 10^5)$\n\neasy：$1\\leq col_i\\leq min(n,2)$\n\nhard：$1\\leq col_i\\leq n$\n\n\n思路#\n\n贪心，从右边枚举，当找到最后一种达到两次出现的颜色后，进行一次对该颜色的操作，直到所有宝石都被消除。\n\n\n参考代码#\n\n\n\n\nI-Tokitsukaze and Short Path (plus)#\n\n\n题意#\n\n有一个$n$个顶点的完全图$G$，顶点编号是$1$到$n$，编号为$i$的顶点值是$a_i$，边权的计算方式如下： $$ w_{u,v}=\n\\begin{cases} 0& \\text{u=v}\\ |a_u+a_v|+|a_u-a_v|& \\text{u ≠ v} \\end{cases} $$\n$dist(i,j)$定义为以$i$为起点到$j$的最短路。\n\n求： $$ \\sum_{i=1}^{n}\\sum_{j=1}^{n}dist(i,j) $$\n\n数据范围#\n\n$T(1\\leq T\\leq 2\\times 10^5)$\n\n$n(1\\leq n\\leq 2\\times 10^5)$\n\n$a_i(1\\leq a_i\\leq 2\\times 10^5)$\n\n\n思路#\n\n$$ |a_i+a_j|+|a_i-a_j|= \\begin{cases} &a_i+a_j+a_i-a_j&=2\\times a_i&\\quad a_i\\ge\na_j \\ &a_i+a_j+a_j-a_i&=2\\times a_j&\\quad a_i\\lt a_j \\end{cases} $$\n\n对$a$进行排序，计算每个数对总和的贡献，也就是比某数小的数的个数。\n\n\n参考代码#\n\n\n\n\nJ-Tokitsukaze and Short Path (minus)#\n\n\n题意#\n\n有一个$n$个顶点的完全图$G$，顶点编号是$1$到$n$，编号为$i$的顶点值是$a_i$，边权的计算方式如下： $$ w_{u,v}=\n\\begin{cases} 0& \\text{u=v}\\ |a_u+a_v|-|a_u-a_v|& \\text{u ≠ v} \\end{cases} $$\n$dist(i,j)$定义为以$i$为起点到$j$的最短路。\n\n求： $$ \\sum_{i=1}^{n}\\sum_{j=1}^{n}dist(i,j) $$\n\n数据范围#\n\n$T(1\\leq T\\leq 2\\times 10^5)$\n\n$n(1\\leq n\\leq 2\\times 10^5)$\n\n$a_i(1\\leq a_i\\leq 2\\times 10^5)$\n\n\n思路#\n\n$$ |a_i+a_j|-|a_i-a_j|= \\begin{cases} &a_i+a_j-a_i+a_j&=2\\times a_j&\\quad a_i\\ge\na_j \\ &a_i+a_j-a_j+a_i&=2\\times a_i&\\quad a_i\\lt a_j \\end{cases} $$\n\n如果$u$到$v$的直接路径的长度大于$dist(u,w)+dist(v,w)$，则取后者，假设$dist(u,v)=2\\times\na_v$，则有$dist(u,w)+dist(v,w)=2\\times a_v+2\\times a_v=4\\times a_v$，则只有当$2\\times\na_w$的值小于$a_v$时取后者找到数组中的最小值。\n\n对$a$ 进行排序，计算每个数对总和的贡献次数，也就是比某数或2×最小$a_i$大的数的个数。\n\n\n参考代码#\n\n","routePath":"/posts/algorithm/nc24wd2","lang":"","toc":[{"text":"A-Tokitsukaze and Bracelet","id":"a-tokitsukaze-and-bracelet","depth":2,"charIndex":-1},{"text":"题意","id":"题意","depth":3,"charIndex":29},{"text":"数据范围","id":"数据范围","depth":4,"charIndex":157},{"text":"思路","id":"思路","depth":3,"charIndex":249},{"text":"参考代码","id":"参考代码","depth":3,"charIndex":261},{"text":"B-Tokitsukaze and Cats","id":"b-tokitsukaze-and-cats","depth":2,"charIndex":271},{"text":"题意","id":"题意-1","depth":3,"charIndex":297},{"text":"数据范围","id":"数据范围-1","depth":4,"charIndex":361},{"text":"思路","id":"思路-1","depth":3,"charIndex":429},{"text":"参考代码","id":"参考代码-1","depth":3,"charIndex":463},{"text":"E&F-Tokitsukaze and Eliminate","id":"ef-tokitsukaze-and-eliminate","depth":2,"charIndex":473},{"text":"题意","id":"题意-2","depth":3,"charIndex":506},{"text":"数据范围","id":"数据范围-2","depth":4,"charIndex":583},{"text":"思路","id":"思路-2","depth":3,"charIndex":704},{"text":"参考代码","id":"参考代码-2","depth":3,"charIndex":762},{"text":"I-Tokitsukaze and Short Path (plus)","id":"i-tokitsukaze-and-short-path-plus","depth":2,"charIndex":772},{"text":"题意","id":"题意-3","depth":3,"charIndex":811},{"text":"数据范围","id":"数据范围-3","depth":4,"charIndex":1044},{"text":"思路","id":"思路-3","depth":3,"charIndex":1149},{"text":"参考代码","id":"参考代码-3","depth":3,"charIndex":1341},{"text":"J-Tokitsukaze and Short Path (minus)","id":"j-tokitsukaze-and-short-path-minus","depth":2,"charIndex":1351},{"text":"题意","id":"题意-4","depth":3,"charIndex":1391},{"text":"数据范围","id":"数据范围-4","depth":4,"charIndex":1624},{"text":"思路","id":"思路-4","depth":3,"charIndex":1729},{"text":"参考代码","id":"参考代码-4","depth":3,"charIndex":2108}],"domain":"","frontmatter":{"title":"2024牛客寒假营2||补题","date":"2024-02-09T06:46:52.000Z","lastmod":"2024-02-11T13:21:23.000Z","draft":false,"authors":[],"description":"","tags":["2024寒假训练","算法","牛客"],"categories":["在学算法的日子里"],"series":["题解记录"],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"","featuredImagePreview":"","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":37,"title":"2024牛客寒假营3||补题","content":"A-智乃与瞩目狸猫、幸运水母、月宫龙虾#\n\n\n题意#\n\n在不考虑单词词性的前提下，只要求两个单词的首字母忽略大小写相同时就认为它们可能是一组ubuntu代号，请你编写程序判断给定的两个单词是否可能是一个ubuntu代\n号。\n\n数据范围#\n\n$T(1\\leq T \\leq 10^5)$\n\n$S,T(1\\leq |S|,|T|\\leq 50)$\n\n\n思路#\n\n按题意判断即可\n\n\n参考代码#\n\n\n\n\nB-智乃的数字手串#\n\n\n题意#\n\n一个首尾相连的数组，若相邻的两个数之和为偶数选择拿走一个然后可以随意交换一对数，轮流操作，不能再操作的一方输。清楚姐姐先手。\n\n数据范围#\n\n$T(1\\leq T \\leq 10^4)$\n\n$N(1\\leq N\\leq 26)$\n\n$a_i(0\\leq a_i \\leq 10^9)$\n\n\n思路#\n\n只有1个数时直接取走，先手赢。\n\n2个数时：奇偶/奇奇/偶偶，都是后手赢。\n\n3个数时：奇偶奇/偶奇偶/奇奇奇/偶偶偶，都是先手赢。\n\n...\n\n结束时候的状态是奇偶奇偶...奇偶，如果数量是奇数个，一定存在奇奇/偶偶，操作后可能直接结束游戏或继续，如果数量是偶数个且可操作，则转移为奇数时的状态且此时下一\n位操作者一定可以再操作。双方的操作不会改变他面对该数字串时数字的个数的奇偶性。也就是说，只有一直面对奇数个数的一方才能赢。\n\n故判断原始长度，看先手是否在奇数位。\n\n\n参考代码#\n\n\n\n\nD-chino's bubble sort and maximum subarray sum(easy version)#\n\n\n题意#\n\n对一个数组内的元素进行恰好$K$次相邻元素交换后，求整个数组的最大子段和。\n\n数据范围#\n\n$N,K(2\\leq N\\leq 10^3,0\\leq K \\leq 1)$\n\n$a_i(-10^9\\leq a_i \\leq 10^9)$\n\n\n思路#\n\neasy版本的K只有两种取值（0和1），N的范围不大，分类处理，进行dp即可。\n\n\n参考代码#\n\n\n\n\nG-智乃的比较函数(easy version)#\n\n\n题意#\n\n给出一些cmp函数的规定，判断他们之间是否存在逻辑矛盾。\n\ncmp的排序规则是这样的：\n\n$cmp(x,y)=1$表示规定$x>y$，即$x$的顺序严格先于$y$\n\n数据范围#\n\n$T(1\\leq T\\leq 2\\times 10^4)$\n\n$N(1\\leq N\\leq 2)$\n\n$x,y,z(x,y\\in {1,2,3},z\\in{0,1})$，表示第$i$个约束关系为$cmp(a_x,a_y)=z$。\n\n\n思路#\n\n只有3个数、两个约束关系时，不能构成$a_xa_z$，只需判断最多存在2中约束关系时的逻辑是否合法。\n\n对于两个数$x$、$y$，不合法的约束关系只有：$cmp(x,y)=1$且$cmp(y,x)=1$\n\n\n参考代码#\n\n\n\n\nH-智乃的比较函数(normal version)#\n\n\n题意#\n\n同G\n\n数据范围#\n\n$T(1\\leq T\\leq 2\\times 10^4)$\n\n$N(1\\leq N\\leq 50)$\n\n$x,y,z(x,y\\in {1,2,3},z\\in{0,1})$，表示第$i$个约束关系为$cmp(a_x,a_y)=z$。\n\n\n思路#\n\n和G相比，N的范围大于2，不合法的情况增加了，但是依然只是3个数据之间判断合法性。\n\n新增的三个关系不合法的情况有：\n\n 1. $x $x\\leq y,y\\leq z,z\n\n分别特判即可。\n\n\n参考代码#\n\n\n\n\nL&M-智乃的36倍数(easy/hard version)#\n\n\n题意#\n\n定义一种运算$f$，可以将正整数按照字面值从左到右拼接，如：$f(123,569)=1234569$。\n\n一个正整数数组，其中有多少对有序对$i,j(i≠j)$满足$f(a_i,a_j)$是36的倍数。\n\n数据范围#\n\neasy:\n\n$N(1\\leq N\\leq 1000)$\n\n$a_i(1\\leq a_i \\leq 10)$\n\nhard：\n\n$N(1\\leq N\\leq 10^5)$\n\n$a_i(1\\leq a_i \\leq 10^{18})$\n\n\n思路#\n\neasy版本的数据较小，直接双层循环暴力即可。\n\nhard版本可以考虑同余，k是y的位数。 $$ f(x,y)=x\\times 10^{k}+y $$ $$ f(x,y)% 36=0 $$ $$\n(x\\times 10^{k}+y)%36=0 $$ $$ (x%36\\times 10^{k}%36+y%36)%36=0 $$\n对数组预处理后，枚举以$y$结尾。\n\n\n参考代码#\n\n","routePath":"/posts/algorithm/nc24wd3","lang":"","toc":[{"text":"A-智乃与瞩目狸猫、幸运水母、月宫龙虾","id":"a-智乃与瞩目狸猫幸运水母月宫龙虾","depth":2,"charIndex":-1},{"text":"题意","id":"题意","depth":3,"charIndex":22},{"text":"数据范围","id":"数据范围","depth":4,"charIndex":112},{"text":"思路","id":"思路","depth":3,"charIndex":173},{"text":"参考代码","id":"参考代码","depth":3,"charIndex":188},{"text":"B-智乃的数字手串","id":"b-智乃的数字手串","depth":2,"charIndex":198},{"text":"题意","id":"题意-1","depth":3,"charIndex":211},{"text":"数据范围","id":"数据范围-1","depth":4,"charIndex":280},{"text":"思路","id":"思路-1","depth":3,"charIndex":361},{"text":"参考代码","id":"参考代码-1","depth":3,"charIndex":604},{"text":"D-chino's bubble sort and maximum subarray sum(easy version)","id":"d-chinos-bubble-sort-and-maximum-subarray-sumeasy-version","depth":2,"charIndex":614},{"text":"题意","id":"题意-2","depth":3,"charIndex":678},{"text":"数据范围","id":"数据范围-2","depth":4,"charIndex":722},{"text":"思路","id":"思路-2","depth":3,"charIndex":802},{"text":"参考代码","id":"参考代码-2","depth":3,"charIndex":849},{"text":"G-智乃的比较函数(easy version)","id":"g-智乃的比较函数easy-version","depth":2,"charIndex":859},{"text":"题意","id":"题意-3","depth":3,"charIndex":886},{"text":"数据范围","id":"数据范围-3","depth":4,"charIndex":974},{"text":"思路","id":"思路-3","depth":3,"charIndex":1098},{"text":"参考代码","id":"参考代码-3","depth":3,"charIndex":1207},{"text":"H-智乃的比较函数(normal version)","id":"h-智乃的比较函数normal-version","depth":2,"charIndex":1217},{"text":"题意","id":"题意-4","depth":3,"charIndex":1246},{"text":"数据范围","id":"数据范围-4","depth":4,"charIndex":1255},{"text":"思路","id":"思路-4","depth":3,"charIndex":1380},{"text":"参考代码","id":"参考代码-4","depth":3,"charIndex":1482},{"text":"L&M-智乃的36倍数(easy/hard version)","id":"lm-智乃的36倍数easyhard-version","depth":2,"charIndex":1492},{"text":"题意","id":"题意-5","depth":3,"charIndex":1526},{"text":"数据范围","id":"数据范围-5","depth":4,"charIndex":1634},{"text":"思路","id":"思路-5","depth":3,"charIndex":1759},{"text":"参考代码","id":"参考代码-5","depth":3,"charIndex":1948}],"domain":"","frontmatter":{"title":"2024牛客寒假营3||补题","date":"2024-02-13T12:21:21.000Z","draft":false,"authors":[],"description":"","tags":["2024寒假训练","算法","牛客"],"categories":["在学算法的日子里"],"series":["题解记录"],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"","featuredImagePreview":"","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":38,"title":"2024牛客寒假营4||补题","content":"A-柠檬可乐#\n\n\n题意#\n\n输入$a,b,k$，判断$a\\ge k\\times b$是否成立\n\n数据范围#\n\n$a,b,k(1\\leq a,b,k\\leq 100)$\n\n\n思路#\n\n简单判断\n\n\n参考代码#\n\n\n\n\nB-左右互博#\n\n\n题意#\n\n有$n$堆石子，每次选择某堆石子，选一个整数$y(2\\leq y\\leq x)$，将石子分为$\\lfloor \\frac{x}{y}\n\\rfloor$和$x-\\lfloor \\frac{x}{y} \\rfloor$，直到某人不能操作时结束，不能操作者输。\n\n数据范围#\n\n$n,a_i(1\\leq n,a_i \\leq 2\\times 10^5)$\n\n\n思路#\n\n相当于每次至少分出1个石子出来，计算将所有石头分出1颗一份的操作数，判断拿到最后一颗石子的是谁即可。\n\n\n参考代码#\n\n\n\n\nC-冬眠#\n\n\n题意#\n\n给一个$n\\times m$的字符矩阵，每天有$q$次行循环移动或列循环移动，共执行$p$次，最后询问第$x$行$y$ 列是什么字符。\n\n$op=1$表示行循环移动\n\n$op=2$表示列循环移动\n\n数据范围#\n\n$1\\leq n,m,p,q\\leq 100$\n\n\n思路#\n\n记录循环移动顺序，然后将$(x,y)$的字符逆顺序模拟即可。\n\n\n参考代码#\n\n\n\n\nD-守恒#\n\n\n题意#\n\n有一个长度为$n$的数组，每次操作可以对数组$a$中的两个元素其中一个加1，另一个减1，要求每次操作后各元素任然是正整数，求操作结束后整个数组的最大公约数有多少\n种不同的值？\n\n数据范围#\n\n$1\\leq n,a_i\\leq 2\\times 10^5$\n\n\n思路#\n\n特判$n=1$的时候（答案为1）\n\n$n\\ge 2$时，枚举最大公约数，计数合适的数的数量即可。\n\n\n参考代码#\n\n","routePath":"/posts/algorithm/nc24wd4","lang":"","toc":[{"text":"A-柠檬可乐","id":"a-柠檬可乐","depth":2,"charIndex":-1},{"text":"题意","id":"题意","depth":3,"charIndex":9},{"text":"数据范围","id":"数据范围","depth":4,"charIndex":48},{"text":"思路","id":"思路","depth":3,"charIndex":86},{"text":"参考代码","id":"参考代码","depth":3,"charIndex":98},{"text":"B-左右互博","id":"b-左右互博","depth":2,"charIndex":108},{"text":"题意","id":"题意-1","depth":3,"charIndex":118},{"text":"数据范围","id":"数据范围-1","depth":4,"charIndex":252},{"text":"思路","id":"思路-1","depth":3,"charIndex":300},{"text":"参考代码","id":"参考代码-1","depth":3,"charIndex":358},{"text":"C-冬眠","id":"c-冬眠","depth":2,"charIndex":368},{"text":"题意","id":"题意-2","depth":3,"charIndex":376},{"text":"数据范围","id":"数据范围-2","depth":4,"charIndex":480},{"text":"思路","id":"思路-2","depth":3,"charIndex":513},{"text":"参考代码","id":"参考代码-2","depth":3,"charIndex":551},{"text":"D-守恒","id":"d-守恒","depth":2,"charIndex":561},{"text":"题意","id":"题意-3","depth":3,"charIndex":569},{"text":"数据范围","id":"数据范围-3","depth":4,"charIndex":663},{"text":"思路","id":"思路-3","depth":3,"charIndex":703},{"text":"参考代码","id":"参考代码-3","depth":3,"charIndex":759}],"domain":"","frontmatter":{"title":"2024牛客寒假营4||补题","date":"2024-02-26T11:54:28.000Z","draft":false,"authors":[],"description":"","tags":["2024寒假训练","算法","牛客"],"categories":["在学算法的日子里"],"series":["题解记录"],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"","featuredImagePreview":"","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":39,"title":"2024牛客寒假营5||补题","content":"A-mutsumi的质数合数#\n\n\n题意#\n\n一个由$n$个正整数组成的数组，求其中质数和合数共有几个。\n\n数据范围#\n\n$n(1\\leq n\\leq 100)$\n\n$a_i(1\\leq a_i\\leq 100)$\n\n\n思路#\n\n1不是质数也不是合数。\n\n\n参考代码#\n\n\n\n\nC-anon的私货#\n\n\n题意#\n\n给一个数组中一些位置插入$0$，要求插入后任意不是全$0$子段的平均值大于等于$1$，询问最多插入多少个$0$\n\n数据范围#\n\n$n(1\\leq n\\leq 10^5)$\n\n$a_i(1\\leq a_i\\leq 10^9)$\n\n\n思路#\n\n从第一位开始贪，统计在每一位前最多可以插入多少个0，考虑两数之间的0的数目不能大于这2位之间允许的最大值。\n\n\n参考代码#\n\n\n\n\nE-soyorin的数组操作（easy）#\n\n\n题意#\n\n有一个长为$n$的数组$a$\n\n操作：选择一个不超过$n$的偶数$k$，$a_i=a_i+i(1\\leq i\\leq k)$\n\n询问是否能在任意操作后使得数组非降序。\n\n数据范围#\n\n$T(1≤T≤10^6)$\n\n$n(1≤n≤10^5)$\n\n$a_i(1\\leq a_i\\leq 10^{12})$\n\n\n思路#\n\n操作的效果是使得$a_{i+1}-a{i}$的值增大1，从后往前遍历，将靠后的部分先操作为非降序（操作的效果会影响到前段）\n\n\n参考代码#\n\n\n\n\nG&H-sakiko的排列构造（easy/hard）#\n\n\n题意#\n\n构造一个长为$n$的排列，使得排列中每个$p_i+i(1\\leq i\\leq n)$都是质数。\n\n输出符合要求的排列，若无解输出-1。\n\n数据范围#\n\n$n(1\\leq n\\leq 10^6)$\n\n\n思路#\n\n排列是$1\\sim n$的，下标也是$1\\sim\nn$的，从$p_i=n$开始给寻找匹配的下标(在可选范围内从小到大)，也就是寻找使得$p_i+i$是质数的最小$i$，即比$p_i$大的最小质数。如果该符合要求\n的质数可以被找到就缩小范围，直到所有的数都可以被确定。(从ac结果看似乎并不存在无法被构造出的排列耶)\n\n\n参考代码#\n\n\n\n\nI-rikki的最短路#\n\n\n题意#\n\n给出一位轴上的3个坐标，$rikki$需要把$A$带到$T$的坐标，初始$rikki$在原点，且只知道$T$的坐标，到达$T$之后可以知道$A$的坐标。\n\n$rikki$有一个范围为$k$的视野，在$[u-k,u+k]$视野内的$A$可以被发现。\n\n数据范围#\n\n$t,a(-10^9\\leq t,a\\leq 10^9),k(1\\leq k\\leq 10^9)$\n\n\n思路#\n\n签到模拟(怎么会有人签到交7发才过啊(小声))\n\n视野只有在出发点的时候看A有用，其他情况按规则来qwq\n\n\n参考代码#\n\n\n\n\nJ-rikki的数组陡峭值#\n\n\n题意#\n\n数组的陡峭值：数组相邻元素之差的绝对值之和。\n\n给出数组$a$中每个元素$a_i$的范围$[l_i,r_i]$，求最小的陡峭值。\n\n数据范围#\n\n$n(1\\leq n\\leq 10^5)$\n\n$l_i,r_i(1\\leq l_i,r_i\\leq 10^9)$\n\n\n思路#\n\n贪心，从前往后遍历，如果$a_i$和$a_{i+1}$的范围有重合，则直接将$a_i$和$a_{i+1}$的值取成同一个数，陡峭值不增加，更新$a_{i+1}$\n的范围为两数重合的范围。如果范围不重合，两数分别取靠近的两个端点，并将$a_{i+1}$的范围缩成1个点。\n\n\n参考代码#\n\n\n\n\nK-soyorin的通知#\n\n\n题意#\n\n$soyorin$要把消息传递给$n$个人，每个知道消息的可以将消息传递给其他人。\n\n第$i$个人可以花费$a_i$将消息通知给最多$b_i$个人，前提是第$i$个人已知消息，消息源通知一个人花费为$p$。求最小花费。\n\n数据范围#\n\n$n(1\\leq n\\leq 1000)$\n\n$p(1\\leq p\\leq 10^6)$\n\n$a_i,b_i(1\\leq a_i,b_i\\leq 10^6)$\n\n\n思路#\n\ndp，更新通知$i$个人的最小花费。每当第$i$个人知道消息时更新使得$j$人知道消息的花费。\n\n\n参考代码#\n\n\n\n\nL-anon的星星#\n\n\n题意#\n\n赢一局可以收到1颗星星，输一局失去1颗星星，没有平局。\n\n已知一共玩了$n$局，共获得了$x$颗星星，求胜利了几局失败了几局。\n\n如果无法知道胜利的局数和失败的局数输出-1。\n\n数据范围#\n\n$n(1\\leq n\\leq 1000)$\n\n$x(-n\\leq x\\leq n)$\n\n\n思路#\n\n赢$k$局就是失败$n-k$局，星星数是$k-(n-k)$。如果$k$有合法值就是合法的。\n\n\n参考代码#\n\n\n\n\nM-mutsumi的排列连通#\n\n\n题意#\n\n有两个长度为$n$的排列上下组成$2\\times n$的矩形。\n\n有操作：选择数字$x$，将矩形中的$x$删去。\n\n询问至少多少次操作后，可以将矩形分成至少2个连通块（连通块不一定是矩形）。\n\n如果无法实现，输出-1。\n\n数据范围#\n\n$T(1\\leq T\\leq 10^5)$\n\n$n(1\\leq n\\leq 10^5)$\n\n排列$a(1\\leq a_i\\leq n)$\n\n排列$b(1\\leq b_i\\leq n)$\n\n$n$总和不超过$10_5$\n\n\n思路#\n\n特判$n=1,2$。\n\n$n\\ge 3$的最多删2个即可实现需求。\n\n遍历寻找是否存在$a_i=b_i$或者$a_i=b_{i+1}$或者$a_i=b_{i-1}$的情况，注意边界判断。\n\n\n参考代码#\n\n","routePath":"/posts/algorithm/nc24wd5","lang":"","toc":[{"text":"A-mutsumi的质数合数","id":"a-mutsumi的质数合数","depth":2,"charIndex":-1},{"text":"题意","id":"题意","depth":3,"charIndex":17},{"text":"数据范围","id":"数据范围","depth":4,"charIndex":53},{"text":"思路","id":"思路","depth":3,"charIndex":109},{"text":"参考代码","id":"参考代码","depth":3,"charIndex":128},{"text":"C-anon的私货","id":"c-anon的私货","depth":2,"charIndex":138},{"text":"题意","id":"题意-1","depth":3,"charIndex":151},{"text":"数据范围","id":"数据范围-1","depth":4,"charIndex":213},{"text":"思路","id":"思路-1","depth":3,"charIndex":271},{"text":"参考代码","id":"参考代码-1","depth":3,"charIndex":332},{"text":"E-soyorin的数组操作（easy）","id":"e-soyorin的数组操作easy","depth":2,"charIndex":342},{"text":"题意","id":"题意-2","depth":3,"charIndex":366},{"text":"数据范围","id":"数据范围-2","depth":4,"charIndex":456},{"text":"思路","id":"思路-2","depth":3,"charIndex":524},{"text":"参考代码","id":"参考代码-2","depth":3,"charIndex":593},{"text":"G&H-sakiko的排列构造（easy/hard）","id":"gh-sakiko的排列构造easyhard","depth":2,"charIndex":603},{"text":"题意","id":"题意-3","depth":3,"charIndex":633},{"text":"数据范围","id":"数据范围-3","depth":4,"charIndex":707},{"text":"思路","id":"思路-3","depth":3,"charIndex":738},{"text":"参考代码","id":"参考代码-3","depth":3,"charIndex":903},{"text":"I-rikki的最短路","id":"i-rikki的最短路","depth":2,"charIndex":913},{"text":"题意","id":"题意-4","depth":3,"charIndex":928},{"text":"数据范围","id":"数据范围-4","depth":4,"charIndex":1058},{"text":"思路","id":"思路-4","depth":3,"charIndex":1117},{"text":"参考代码","id":"参考代码-4","depth":3,"charIndex":1177},{"text":"J-rikki的数组陡峭值","id":"j-rikki的数组陡峭值","depth":2,"charIndex":1187},{"text":"题意","id":"题意-5","depth":3,"charIndex":1204},{"text":"数据范围","id":"数据范围-5","depth":4,"charIndex":1275},{"text":"思路","id":"思路-5","depth":3,"charIndex":1341},{"text":"参考代码","id":"参考代码-5","depth":3,"charIndex":1483},{"text":"K-soyorin的通知","id":"k-soyorin的通知","depth":2,"charIndex":1493},{"text":"题意","id":"题意-6","depth":3,"charIndex":1509},{"text":"数据范围","id":"数据范围-6","depth":4,"charIndex":1625},{"text":"思路","id":"思路-6","depth":3,"charIndex":1714},{"text":"参考代码","id":"参考代码-6","depth":3,"charIndex":1769},{"text":"L-anon的星星","id":"l-anon的星星","depth":2,"charIndex":1779},{"text":"题意","id":"题意-7","depth":3,"charIndex":1792},{"text":"数据范围","id":"数据范围-7","depth":4,"charIndex":1886},{"text":"思路","id":"思路-7","depth":3,"charIndex":1938},{"text":"参考代码","id":"参考代码-7","depth":3,"charIndex":1991},{"text":"M-mutsumi的排列连通","id":"m-mutsumi的排列连通","depth":2,"charIndex":2001},{"text":"题意","id":"题意-8","depth":3,"charIndex":2019},{"text":"数据范围","id":"数据范围-8","depth":4,"charIndex":2135},{"text":"思路","id":"思路-8","depth":3,"charIndex":2253},{"text":"参考代码","id":"参考代码-8","depth":3,"charIndex":2354}],"domain":"","frontmatter":{"title":"2024牛客寒假营5||补题","date":"2024-02-21T12:07:25.000Z","draft":false,"authors":[],"description":"","tags":["2024寒假训练","算法","牛客"],"categories":["在学算法的日子里"],"series":["题解记录"],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"","featuredImagePreview":"","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":40,"title":"2024牛客寒假营6||补题","content":"A-宇宙的终结#\n\n\n题意#\n\n在$[l,r]$中寻找某个恰好是三个不同素数的乘积的数，并输出任意一个合法答案即可。\n\n数据范围#\n\n$1\\leq l\\leq r \\leq 100$\n\n\n思路#\n\n数据小，模拟即可\n\n\n参考代码#\n\n\n\n\nB-爱恨的纠葛#\n\n\n题意#\n\n定义两个等长数组的亲密值：$|a_i-b_i|(1\\leq i\\leq\nn)$的最小值。给定2个数组，可以任意排列$a$数组的元素顺序，输出一个亲密度最小的方案（数组$a$的操作结果）。\n\n数据范围#\n\n$1\\leq n\\leq 10^5$\n\n$1\\leq a,b \\leq 10^9$\n\n\n思路#\n\n将$a,b$数组的数据放入\n一个数组中，进行排序，从第一位开始遍历，如果某两个相邻的数一个来自于$a$数组，一个来自于$b$数组，更新最小的差的绝对值，将$a$数组中的这两个相匹配的位置进\n行互换后输出$a$\n\n\n参考代码#\n\n\n\n\nC-心绪的解剖#\n\n\n题意#\n\n将$n$分解为三个斐波那契数列之和。\n\n数据范围#\n\n$1\\leq q \\leq 10^5$\n\n$1\\leq n\\leq 10^9$\n\n\n思路#\n\n斐波那契数列到$F_{45}$是大于$10^{10}$的，联系到斐波那契数列的单调性，每次二分出不大于$n$的一位$F_x$，再在$n$中减去这个$F_x$直到\n$n$为0，如果三次二分后无法使得$n=0$则无解。\n\n\n参考代码#\n\n\n\n\nD-友谊的套路#\n\n\n题意#\n\n一场$BO5$的游戏（五局三胜），已知某队伍获胜的概率是$p$，询问出现二追三的概率是多少？（二追三：先输两局，然后赢三局）\n\n数据范围#\n\n$0\\lt p\\lt 1$\n\n\n思路#\n\n赢赢输输输or输输赢赢赢\n\n\n参考代码#\n\n\n\n\nE-未来的预言#\n\n\n题意#\n\nBO机制：$BOx$代表$x$局先胜$x/2+1$次为赢，$x$为奇数。\n\n给出一个字符串，表示两队的获胜情况。R代表红队获胜，P代表紫队获胜。\n\n判断哪队获得了胜利，或是还没有决出结果，以及结束时的局数。\n\n数据范围#\n\n$1\\leq x\\leq 10^5$\n\n\n思路#\n\n遍历统计，先赢到$x/2$次的获胜。\n\n\n参考代码#\n\n\n\n\nI-时空的交织#\n\n\n题意#\n\n一个$n$行$m$列的矩阵，每个元素由$a$数组和$b$数组决定，第$i$行第$j$列的元素为$a_i\\times\nb_j$，选出一个子矩阵，使得子矩阵内的元素和尽可能大，输出该子矩阵的元素和。\n\n数据范围#\n\n$1\\leq n,m\\leq 10^5$\n\n$-10^4 \\leq a_i,b_i\\leq 10^4$\n\n\n思路#\n\n对$a、b$数组分别求最大子段和和最小子段和，最大子矩阵元素和是这四个数分别相乘的积中最大的一个。\n\n\n参考代码#\n\n","routePath":"/posts/algorithm/nc24wd6","lang":"","toc":[{"text":"A-宇宙的终结","id":"a-宇宙的终结","depth":2,"charIndex":-1},{"text":"题意","id":"题意","depth":3,"charIndex":10},{"text":"数据范围","id":"数据范围","depth":4,"charIndex":59},{"text":"思路","id":"思路","depth":3,"charIndex":93},{"text":"参考代码","id":"参考代码","depth":3,"charIndex":109},{"text":"B-爱恨的纠葛","id":"b-爱恨的纠葛","depth":2,"charIndex":119},{"text":"题意","id":"题意-1","depth":3,"charIndex":130},{"text":"数据范围","id":"数据范围-1","depth":4,"charIndex":230},{"text":"思路","id":"思路-1","depth":3,"charIndex":281},{"text":"参考代码","id":"参考代码-1","depth":3,"charIndex":393},{"text":"C-心绪的解剖","id":"c-心绪的解剖","depth":2,"charIndex":403},{"text":"题意","id":"题意-2","depth":3,"charIndex":414},{"text":"数据范围","id":"数据范围-2","depth":4,"charIndex":439},{"text":"思路","id":"思路-2","depth":3,"charIndex":488},{"text":"参考代码","id":"参考代码-2","depth":3,"charIndex":603},{"text":"D-友谊的套路","id":"d-友谊的套路","depth":2,"charIndex":613},{"text":"题意","id":"题意-3","depth":3,"charIndex":624},{"text":"数据范围","id":"数据范围-3","depth":4,"charIndex":693},{"text":"思路","id":"思路-3","depth":3,"charIndex":716},{"text":"参考代码","id":"参考代码-3","depth":3,"charIndex":736},{"text":"E-未来的预言","id":"e-未来的预言","depth":2,"charIndex":746},{"text":"题意","id":"题意-4","depth":3,"charIndex":757},{"text":"数据范围","id":"数据范围-4","depth":4,"charIndex":867},{"text":"思路","id":"思路-4","depth":3,"charIndex":895},{"text":"参考代码","id":"参考代码-4","depth":3,"charIndex":921},{"text":"I-时空的交织","id":"i-时空的交织","depth":2,"charIndex":931},{"text":"题意","id":"题意-5","depth":3,"charIndex":942},{"text":"数据范围","id":"数据范围-5","depth":4,"charIndex":1046},{"text":"思路","id":"思路-5","depth":2,"charIndex":1107},{"text":"参考代码","id":"参考代码-5","depth":3,"charIndex":1164}],"domain":"","frontmatter":{"title":"2024牛客寒假营6||补题","date":"2024-02-26T11:54:36.000Z","draft":false,"authors":[],"description":"","tags":["2024寒假训练","算法","牛客"],"categories":["在学算法的日子里"],"series":["题解记录"],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"","featuredImagePreview":"","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":41,"title":"2025牛客暑寒假多校训练营Day1（完結）","content":"A 茕茕孑立之影#\n\n\n题意#\n\n找一个不超过$1e18$的数$x$，使得$x$既不是任何$a_i$的倍数，也不是任何$a_i$的因数。若没有输出$-1$。\n\n数据范围#\n\n * $1\\leq n\\leq 1e5$\n * $1\\leq a_i\\leq 1e9$\n\n\n思路#\n\n观察到，如果数组中有$1$则不存在这样的数。\n\n$1\\leq a_i\\leq 1e9$，而$1\\leq x\\leq 1e18$，有解时任意数=输出一个大于$1e9$的质数即可。\n\n\n代码#\n\n\n\n\nB 一气贯通之刃#\n\n\n题意#\n\n给一棵树，寻找一条简单路径，使之遍历树上所有的顶点，输出起点和终点。如果没有这样的解则输出$-1$。\n\n简单路径是指这样一条路径，其经过的顶点和边互不相同。\n\n数据范围#\n\n * $2\\leq n\\leq 1e5$\n * $1\\leq u_i,v_i\\leq n,u_i\\neq v_i$\n\n\n思路#\n\n只有整个树是一条链时，从一个叶子节点到另一个叶子节点，才能有符合要求的简单路径。\n\n\n代码#\n\n\n\n\nC 兢兢业业之移#\n\n\n题意#\n\n有一个$n\\times n$的 01 矩阵，$n$是偶数，其中有刚好$\\frac{n^2}{4}$个1，请将这些 1 全部移动到矩阵左上角的位置，即$1\\leq\ni\\leq \\frac{n}{2},q\\leq j\\leq\n\\frac{n}{2}$的位置，规定移动只能与共边的方格交换，交换次数不超过$\\frac{n^3}{2}$。\n\n数据范围#\n\n * $2\\leq n\\leq 100$\n\n\n思路#\n\n考虑一条移动路径将 1 移动到左上角某个 0 的位置，如果这个路径上有其他的 1，显然移动路径中间的 1 到同样的目标 0 位置的次数是更小的。\n\n从左上角坐标点进行 bfs，最先碰到的 1 是最近的，还原 bfs 的路径。还原 bfs 的路径可以通过存储 bfs 时拓展的父节点来回溯获得。\n\n或者考虑寻找最短路时，路径只可能是直线或者直角线，假设路径需要“拐弯”才能到达某个 1，那这个“拐弯”的地方肯定是\n1。这样的路径的长度正好是曼哈顿距离，$n$比较小，可以遍历所有的 1 来选择举例要填的 0 最近的点。还原路径的时候按照先纵向再横向或者先横向再纵向都可以。\n\n\n代码 1：曼哈顿距离#\n\n\n\n\n代码 2：宽搜#\n\n\n\n\nD 双生双宿之决#\n\n\n题意#\n\n双生数组定义：数组大小为偶数，有且只有 2 种数，这两种数的数量相同。\n\n判断一个数组是不是双生数组。\n\n数据范围#\n\n * $1\\leq n\\leq 1e5$\n * $1\\leq a_i\\leq 1e9$\n\n\n思路#\n\n按性质判断即可。\n\n\n代码#\n\n\n\n\nE 双生双宿之错#\n\n\n题意#\n\n将一个数组变成双生数组，可以进行的操作是将某个数+1 或-1，求最小操作次数。\n\n数据范围#\n\n * $1\\leq n\\leq 1e5$\n * $1\\leq a_i\\leq 1e9$\n\n\n思路#\n\n首先想到，将数组分为小的一半和大的一半，这两半各找一个数作为双生数组中的标准数。\n\n这个数是中位数：\n\n考虑当前的中位数是$x$，代表有至少一半的数小于等于$x$，也有至少一半的数大于等于$x$，如果将$x$变成$x+1$，假设原来的花费是$y$，有$c$的数小于\n等于$x$。那么现在的花费是$y' = y+c-(n-c)$，由于$c\\ge n/2$，故$y'\\gt y$，$x-1$的情况也是同理。\n\n特别的，当两边的中位数是同一个数的时候，需要对某一边进行+1 或-1，取 min。\n\n\n代码#\n\n\n\n\nF 双生双宿之探#\n\n\n题意#\n\n计算一个数组中有多少连续子数组是双生数组。\n\n数据范围#\n\n * $1\\leq n\\leq 1e5$\n * $1\\leq a_i\\leq 1e9$\n\n\n思路#\n\n根据双生数组的特点，选出所有仅包含两种数的区间，在这个确定的最大的仅包含两种数的区间内计算区间中有多少个双生数组，由于仅包含两种数，可以将某种数记为\n1，另一种记为-1，计算该段区间的前缀和，前缀和相同的两个端点之间的区间是双生数组。\n\n\n代码#\n\n\n\n\nG 井然有序之衡#\n\n\n题意#\n\n将数组变成一个排列，可以进行的操作是将某个数+1，同时将另一个数-1，询问最小操作次数，若不能实现则输出-1。\n\n数据范围#\n\n * $1\\leq n\\leq 1e5$\n * $-1e9\\leq a_i\\leq 1e9$\n\n\n思路#\n\n排列中的数是 1~n，如果进行操作，一定是将大数减去的 1 加到小数上，让两个数都趋向要变成的数。从 n 开始枚举到\n1，如果当前的排列数$i$在数组中不存在，则选一个大于$i$的数，将它减去的数统计到答案中，过程中判断可行性。\n\n\n代码#\n\n\n\n\nH 井然有序之窗#\n\n\n题意#\n\n构造一个长度为 n 的排列，要求每个数$i$都符合在$[l_i,r_i]$范围内，如果不存在这样的排列，则输出-1，否则输出构造的排列。\n\n数据范围#\n\n * $1\\leq n\\leq 1e5$\n * $1\\leq l_i\\leq r_i\\leq n$\n\n\n思路#\n\n按照 1~n 的顺序构造排列，每次从可以使用的区间中取右端点最近的区间。\n\n\n代码#\n\n\n\n\nI 井然有序之桠#\n\n\n题意#\n\n给出排列$a$，构造另一个排列$b$，使得$\\sum_{i=1}^{n} gcd(a_i,b_i)=k$。\n\n数据范围#\n\n * $1\\leq n\\leq 1e5$\n * $1\\leq a_i\\leq n$\n\n\n思路#\n\n构造排列使$\\sum gcd(a_i,i)=k$，易知$k$的合法上界是$\\frac{(n+1)\\times\nn}{2}$，下届是$n$。从大到小遍历，找到某个端点，将数组分为$[1,r]$和$[r+1,n]$两组，右侧区间均取$a_i=i$，这个区间可以为空，找到最小\n的$r-1+r\\leq k'$成立的端点$r$，遍历的过程中$k$减去端点划过的值。\n\n分类讨论，记$x=k-(r-1)$。如果$x$为偶数，则取$a_x=x$，剩余的$1,...,x-1,x+1,...r$从大到小两两一组交换，实现除了$a_x=\nx$的其他小组都是 1。\n\n如果$x$为奇数，如果$r$为偶数，会出现$gcd(x-1,x+1)$，这个值是$2$，不符合要求，这时取$a_2=2$和$a_{x-1}=x-1$，可以实现与\n$a_x=x$一样的构造效果，注意判断$x=2$的情况。\n特殊的，当$x=3$时，可以构造$a_2=4$和$a_4=2$，这时$gcd(a_2,4)+gcd(a_4,2)=4=3+1$可行。\n\n\n代码#\n\n\n\n\nJ 硝基甲苯之袭#\n\n\n题意#\n\n在数组中选两个元素$a_i,a_j,(i\\neq j)$，求满足$a_i \\oplus a_j = gcd(a_i,a_j)$的$i,j$对数量。\n\n数据范围#\n\n * $1\\leq n\\leq 2e5$\n * $1\\leq a_i\\leq 2e5$\n\n\n思路#\n\n$x\\oplus y = g$，则有$y=x\\oplus g$，对每个$a_i$，枚举$g$，若有符合$g == gcd(x,x\\oplus\ng)$的则计入答案，答案要去掉一半重复计数的。\n\n\n代码#\n\n\n\n\nK 硝基甲苯之魇#\n\n\n题意#\n\n求一个数组中，有多少个区间$[l,r](l\\lt r)$满足区间内元素的最大公约数恰好等于它们的异或和。\n\n数据范围#\n\n * $1\\leq n\\leq 2e5$\n * $1\\leq a_i\\leq 1e9$\n\n\n思路#\n\n对于一个固定的区间$[l,r]$，其最大公约数可以用某种数据结构维护（线段树/ST 表/...），实现复杂度为$O(logn)$的查询。\n\n区间异或和可以利用前缀异或实现，根据异或的性质$A \\oplus 0 = A$、$A\\oplus\nA=0$，对于数组的前缀异或($pre[i]=pre[i-1]\\oplus a[i]$)，有$a_l\\oplus a_{l+1}\\oplus \\dots\n\\oplus a_r=pre[r]\\oplus pre[l-1]$，提供$O(1)$的查询。\n\n固定右端点$r$，当$l$逐渐减少，其区间$gcd$会逐渐变小，且变化的次数是 log\n级别的，通过在数据结构上二分，找出这些变化的端点，并统计在这个区间中异或和是对应的 gcd\n的数量的左端点，统计数量。这个异或的数量可以通过在求前缀异或数组时预处理获得，用 map\n存一下每个前缀异或值出现的位置数组，查询时，二分统计$[l_l,l_r]$中$xor$为$g\\oplus pre[r]$的数量。\n\n\n\n\n代码#\n\n\n\n\nL 一念神魔之耀#\n\n\n题意#\n\n有$l$盏灯，初始状态用一个字符串表示，0表示关闭，1表示开启，每一轮操作可以操作连续的$x$个或$y$个灯，将其状态反转，询问是否存在一种操作方式让所有的灯状\n态相同，如果没有输出-1。\n\n数据范围#\n\n * $1\\leq T\\leq 500$\n * $1\\le l\\leq 500$\n * $1\\leq x,y\\leq \\frac{l}{3}$\n * 操作轮数$n\\leq l^2$\n\n\n思路#\n\n假设$x=y$，将灯的状态调整成全 1，可以遍历每个 0，以这些 0 为左端点反转一个长度$x$，当某个 0 的右侧空间不足一个长度$x$时显然无解。\n\n$x\\neq y,x\\gt\ny$时，如果可以反转长度$x$，则在$x$上再反转一个$y$，可以得到仅反转$x-y$的效果，以此类推，直到最短的长度，这个过程也是辗转相除法的过程，最短的长度\n是$g=gcd(x,y)$。\n\n尝试按照长度$g$反转所有 0\n的位置，反转$s[i]='0',[i,i+x-1]$中的$g$长度的部分，则需要将剩余的$[i+g,i+x-1]$的部分恢复，不定方程$ax+bx=g$一定有解\n，当需要恢复的区间$[l,r]$长度大于等于$y$时进行一次长度为$y$的操作，如果不足$y$则考虑边界后哦向左或者向右拓展长度为$x$，并在接下来的操作中恢复\n。\n\n\n代码#\n\n\n\n\nM 数值膨胀之美#\n\n\n题意#\n\n定义一个数组的极差是数组的最大值和最小值的差，现在有一个数组，恰好进行一次下述操作：选择一个非空区间，将区间中的数都乘以 2。求这个数组最小的极差。\n\n数据范围#\n\n * $1\\leq n\\leq 1e5$\n * $1\\leq a_i\\leq 1e9$\n\n\n思路#\n\n极差是最大值减去最小值，将最大值翻倍肯定会增大极差，考虑将最小值乘 2\n才能得到更小的极差，依次枚举翻倍最小值、次小值，若当前的区间是连续的，与上一个合法区间取更小的极差，维护数组的极差。\n\n\n代码#\n\n","routePath":"/posts/algorithm/nc25wd1","lang":"","toc":[{"text":"A 茕茕孑立之影","id":"a-茕茕孑立之影","depth":2,"charIndex":-1},{"text":"题意","id":"题意","depth":3,"charIndex":11},{"text":"数据范围","id":"数据范围","depth":4,"charIndex":79},{"text":"思路","id":"思路","depth":3,"charIndex":132},{"text":"代码","id":"代码","depth":3,"charIndex":228},{"text":"B 一气贯通之刃","id":"b-一气贯通之刃","depth":2,"charIndex":236},{"text":"题意","id":"题意-1","depth":3,"charIndex":248},{"text":"数据范围","id":"数据范围-1","depth":4,"charIndex":333},{"text":"思路","id":"思路-1","depth":3,"charIndex":400},{"text":"代码","id":"代码-1","depth":3,"charIndex":448},{"text":"C 兢兢业业之移","id":"c-兢兢业业之移","depth":2,"charIndex":456},{"text":"题意","id":"题意-2","depth":3,"charIndex":468},{"text":"数据范围","id":"数据范围-2","depth":4,"charIndex":640},{"text":"思路","id":"思路-2","depth":3,"charIndex":670},{"text":"代码 1：曼哈顿距离","id":"代码-1曼哈顿距离","depth":3,"charIndex":963},{"text":"代码 2：宽搜","id":"代码-2宽搜","depth":3,"charIndex":979},{"text":"D 双生双宿之决","id":"d-双生双宿之决","depth":2,"charIndex":992},{"text":"题意","id":"题意-3","depth":3,"charIndex":1004},{"text":"数据范围","id":"数据范围-3","depth":4,"charIndex":1062},{"text":"思路","id":"思路-3","depth":3,"charIndex":1115},{"text":"代码","id":"代码-2","depth":3,"charIndex":1131},{"text":"E 双生双宿之错","id":"e-双生双宿之错","depth":2,"charIndex":1139},{"text":"题意","id":"题意-4","depth":3,"charIndex":1151},{"text":"数据范围","id":"数据范围-4","depth":4,"charIndex":1197},{"text":"思路","id":"思路-4","depth":3,"charIndex":1250},{"text":"代码","id":"代码-3","depth":3,"charIndex":1502},{"text":"F 双生双宿之探","id":"f-双生双宿之探","depth":2,"charIndex":1510},{"text":"题意","id":"题意-5","depth":3,"charIndex":1522},{"text":"数据范围","id":"数据范围-5","depth":4,"charIndex":1550},{"text":"思路","id":"思路-5","depth":3,"charIndex":1603},{"text":"代码","id":"代码-4","depth":3,"charIndex":1728},{"text":"G 井然有序之衡","id":"g-井然有序之衡","depth":2,"charIndex":1736},{"text":"题意","id":"题意-6","depth":3,"charIndex":1748},{"text":"数据范围","id":"数据范围-6","depth":4,"charIndex":1810},{"text":"思路","id":"思路-6","depth":3,"charIndex":1866},{"text":"代码","id":"代码-5","depth":3,"charIndex":1988},{"text":"H 井然有序之窗","id":"h-井然有序之窗","depth":2,"charIndex":1996},{"text":"题意","id":"题意-7","depth":3,"charIndex":2008},{"text":"数据范围","id":"数据范围-7","depth":4,"charIndex":2083},{"text":"思路","id":"思路-7","depth":3,"charIndex":2142},{"text":"代码","id":"代码-6","depth":3,"charIndex":2186},{"text":"I 井然有序之桠","id":"i-井然有序之桠","depth":2,"charIndex":2194},{"text":"题意","id":"题意-8","depth":3,"charIndex":2206},{"text":"数据范围","id":"数据范围-8","depth":4,"charIndex":2266},{"text":"思路","id":"思路-8","depth":3,"charIndex":2317},{"text":"代码","id":"代码-7","depth":3,"charIndex":2776},{"text":"J 硝基甲苯之袭","id":"j-硝基甲苯之袭","depth":2,"charIndex":2784},{"text":"题意","id":"题意-9","depth":3,"charIndex":2796},{"text":"数据范围","id":"数据范围-9","depth":4,"charIndex":2876},{"text":"思路","id":"思路-9","depth":3,"charIndex":2929},{"text":"代码","id":"代码-8","depth":3,"charIndex":3031},{"text":"K 硝基甲苯之魇","id":"k-硝基甲苯之魇","depth":2,"charIndex":3039},{"text":"题意","id":"题意-10","depth":3,"charIndex":3051},{"text":"数据范围","id":"数据范围-10","depth":4,"charIndex":3110},{"text":"思路","id":"思路-10","depth":3,"charIndex":3163},{"text":"代码","id":"代码-9","depth":3,"charIndex":3616},{"text":"L 一念神魔之耀","id":"l-一念神魔之耀","depth":2,"charIndex":3624},{"text":"题意","id":"题意-11","depth":3,"charIndex":3636},{"text":"数据范围","id":"数据范围-11","depth":4,"charIndex":3737},{"text":"思路","id":"思路-11","depth":3,"charIndex":3837},{"text":"代码","id":"代码-10","depth":3,"charIndex":4212},{"text":"M 数值膨胀之美","id":"m-数值膨胀之美","depth":2,"charIndex":4220},{"text":"题意","id":"题意-12","depth":3,"charIndex":4232},{"text":"数据范围","id":"数据范围-12","depth":4,"charIndex":4313},{"text":"思路","id":"思路-12","depth":3,"charIndex":4366},{"text":"代码","id":"代码-11","depth":3,"charIndex":4468}],"domain":"","frontmatter":{"title":"2025牛客暑寒假多校训练营Day1（完結）","subtitle":"","date":"2025-01-23T04:58:36.000Z","lastmod":"2025-01-23T04:58:36.000Z","draft":false,"authors":null,"description":"","tags":["2025寒假训练","算法","牛客"],"categories":["在学算法的日子里"],"series":["题解记录"],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"https://img.dodolalorc.cn/i/2025/02/05/67a26952e01a0.jpg","featuredImagePreview":"https://img.dodolalorc.cn/i/2025/02/05/67a26952e01a0.jpg","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":42,"title":"2025牛客暑寒假多校训练营Day2","content":"A 一起奏响历史之音！#\n\n\n题意#\n\n中国传统五声调中包含 1、2、3、5、6，判断一个乐谱是否仅由全部或部分五声调铺成。\n\n\n思路#\n\n按题意判断即可。\n\n\n代码#\n\n\n\n\nB 能去你家蹭口饭吃吗#\n\n\n题意#\n\n给出一个数组$a$，找到一个整数，要求整数尽可能大，但是至少要比数组中一半数量的数小。\n\n数据范围#\n\n * $1\\leq n\\leq 5e5$\n * $1\\leq a_i\\leq 1e6$\n\n\n思路#\n\n如果数组长度为奇数，则取中位数-1，即$a[n-n/2]-1$。\n\n如果数组长度为偶数，则取下标更大的中位数-1，即$a[n/2+1]-1$。\n\n\n代码#\n\n\n\n\nD 字符串里串#\n\n\n题意#\n\n定义字符串$s$的可爱度$k$：最大的满足存在长度为$k$的连续子串$a$和严格不连续子串$b$，使得$a=b$。\n\n给出字符串$s$，求其可爱度。\n\n数据范围#\n\n * $3\\leq m \\leq 2e5$\n\n\n思路#\n\n$b$是不连续子串，可以设计$a$和$b$仅最后一位或开头一位的在原串中的位置不同，那么只需要寻找符合条件的数量大于等于 2\n的字母，并比较分别去掉两端得到的最长的串的长度。\n\n\n代码#\n\n\n\n\nC 字符串外串#\n\n\n题意#\n\n定义字符串$s$的可爱度$k$：最大的满足存在长度为$k$的连续子串$a$和严格不连续子串$b$，使得$a=b$。构造长度为$n$的由小写字母组成的字符串，使其\n可爱度为$m$，或报告没有这样的合法字符串。\n\n数据范围#\n\n * $3\\leq m\\leq n\\leq n\\leq 2e5$\n\n\n思路#\n\n$a,b$两种字符串至少要有 1 位对应原串的位置不同，当$n=m$时显然无解。\n\n设字符串$t$是$a,b$左端对齐之后公共的部分，长度为$m-1$，小写字母只有 26 个，当$n-m\\gt\n26$时，不管怎么填后$n-m$的字母，都不可能与让所有在$i\\geq\nm$的范围内的字母只出现一次，出现多次则可爱度会增加。按照这样的思路构造前$m-1$长度的字符串，并保证在后一半的部分中字符$s[m-1]$出现且仅出现一次。\n\n\n代码#\n\n\n\n\nE 一起走很长的路！#\n\n\n题意#\n\n一列多米诺骨牌，质量是$a_i$，有$q$次询问，询问一个区间$[l,r]$，推倒第$l$位的多米诺骨牌，如果$\\sum_{i=l}^{i-1}\\geq\na_i$，则第$a_i$块可以顺利倒下，为了使第$r$块可以顺利倒下，可以进行一种操作：选择某个多米诺骨牌，将其质量+1\n或-1，对每个询问返回最少的可以推倒$r$的操作数。\n\n数据范围#\n\n * $1\\leq n,q\\leq 2e5$\n * $1\\leq a_i\\leq 1e9$\n * $1\\leq l\\leq r\\leq n$\n\n\n思路#\n\n对于一个区间，如果要进行操作时，肯定是将+1 加在第$l$位的牌上。\n\n当$l=1$时，容易直到，想要第$i$块牌倒下，需要$\\max(a_i-pre_{i-1},0)$的操作次数，$pre_i$是前$i$项的质量和，故在整个区间上\n，只需要取$\\max(a_i-pre_{i-1}),(l+1\\leq i\\leq r)$。\n\n在区间$[l,r]$中，如果要推倒第$i$块牌，则需要构造新的以$l$为左端点的$pre$，这个$pre$的值可以由$pre_i-pre_{l-1}$推倒，代入\n上式，则答案是$\\max(a_i-(pre_i-pre_{l-1}))$。用某种数据结构维护区间最大值。\n\n\n代码#\n\n\n\n\nF 一起找神秘的数！#\n\n\n题意#\n\n在区间$[l,r]$中找到两个数$x,y$，使之满足$x+y=(x\\ordinarycolon y)+(x \\land y)+(x \\oplus\ny)$，求这样的数对的数量。\n\n数据范围#\n\n * $1\\leq T \\leq 2e5$\n * $0\\leq l\\leq r\\leq 1e18$\n\n\n思路#\n\n打表猜结论，发现只有$x=y$时等式成立。\n\n\n代码#\n\n\n\n\nG 一起铸最好的剑！#\n\n\n题意#\n\n在$m$的幂次中找到最接近$n$的数。\n\n数据范围#\n\n * $1\\leq T \\leq 1e5$\n * $1\\leq n,m\\leq 1e9$\n\n\n思路#\n\n模拟。\n\n\n代码#\n\n\n\n\nH 一起画很大的圆！#\n\n\n题意#\n\n在矩形的边界上找三个不共线的点，使得过这三个点确定的圆的面积最大。\n\n数据范围#\n\n * $-1e6\\leq a,b,c,d\\leq 1e6$\n\n\n思路#\n\n合适的点的候选在矩形的四个直角附近一个单位长度的点中选，暴力枚举三个点，并判断取半径最大的圆。\n\n\n代码#\n\n\n\n\nI#\n\n\n题意#\n\n数据范围#\n\n\n思路#\n\n\n代码#\n\n\nJ 数据时间？#\n\n\n题意#\n\n有$n$个数据，每条数据由user_id、login_date、login_time组成，表示员工号，登录日期和登录时间。员工号是不超过$1e20$的整数，登录\n日期是一个YYYY-MM-DD模式的日期，登录时间是hh:mm:ss模式的时间。\n\n现在查询h年m月的员工在通勤时间（07:00:00-09:00:00和18:00:00-20:00:00）、午休时间（11:00:00-13:00:00）和临睡\n时间（22:00:00-01:00:00）的登录人次情况，同一个人在同一个时间段的多次登录算作一人次。时间段均包含边界。\n\n数据范围#\n\n * $1\\leq n\\leq 1e5$\n * $2000\\leq h\\leq 2030;1\\leq m\\leq 12$\n * $1\\leq user_{id}\\leq 10^{20}$\n * 日期和时间的格式如题意所述。\n\n\n思路#\n\n按题意模拟。\n\n\n代码#\n\n\n\n\nK 可以分开吗？#\n\n\n题意#\n\n有一块$n\\times m$的方块组成的矩阵，其中有一些蓝色方块，其余为灰色方块，定义两块方块的连通的：只有当两块方块在四连通方向有共边。\n\n当一个蓝色极大连通块可以脱离矩阵时，其任何蓝色方块不与任何灰色方块有共边。现在先在矩阵中通过移除灰色方块，取出一个蓝色极大连通块，求最少的操作次数。\n\n数据范围#\n\n * $1\\leq n,m\\leq 500$\n\n\n思路#\n\n并查集。\n\n遍历所有的蓝色方块，并查集维护每个蓝色方块寻找它属于的蓝色极大连通块，再通过遍历这些连通块的每个小方块的周围四格，统计需要敲掉的灰色方块的数量。\n\n\n代码#\n\n\n\n\nL#\n\n\n题意#\n\n数据范围#\n\n\n思路#\n\n\n代码#\n\n\nM 那是我们的影子#\n\n\n题意#\n\n在$3\\times n$的矩阵中，每个格子要么是$1\\sim 9$的数字，要么是?。求将所有的?填入$1\\sim 9$的数字，任意$3\\times\n3$的九宫格中的数字都不重复，求合法的填写方式的数量，答案对$1e9+7$取模。\n\n数据范围#\n\n * $3\\leq n\\leq 1e5$\n\n\n思路#\n\n易知，所有$i\\mod 3$相同的列的数字组成都是一样的。\n\n几种无合法解的情况：\n\n 1. 某一列有重复的数字\n 2. 某个$i\\mod 3$的组中数字的种数多于 3 种\n\n排除不合法的情况后，进行排列组合，将所有九宫格的数字位置情况汇总成一个标准九宫格后，里面有一些位置依然是?，数字不确定，这些不确定的$k$个位置对应$k$个没有\n出现过的数字，将其分成$3$组，分别对应每列的空缺位，这样的组合方法有$\\binom{k}{col_0}\\times\n\\binom{k-col_0}{col_1}\\times \\binom{k-col_0-col_1}{col_2}$种。\n\n完成上面这一步之后，相当于九宫格的每列对应的数集合是确定的。接下来遍历每一列，乘上在空缺位上的全排列数。\n\n\n代码#\n\n","routePath":"/posts/algorithm/nc25wd2","lang":"","toc":[{"text":"A 一起奏响历史之音！","id":"a-一起奏响历史之音","depth":2,"charIndex":-1},{"text":"题意","id":"题意","depth":3,"charIndex":14},{"text":"思路","id":"思路","depth":3,"charIndex":64},{"text":"代码","id":"代码","depth":3,"charIndex":80},{"text":"B 能去你家蹭口饭吃吗","id":"b-能去你家蹭口饭吃吗","depth":2,"charIndex":88},{"text":"题意","id":"题意-1","depth":3,"charIndex":103},{"text":"数据范围","id":"数据范围","depth":4,"charIndex":153},{"text":"思路","id":"思路-1","depth":3,"charIndex":206},{"text":"代码","id":"代码-1","depth":3,"charIndex":285},{"text":"D 字符串里串","id":"d-字符串里串","depth":2,"charIndex":293},{"text":"题意","id":"题意-2","depth":3,"charIndex":304},{"text":"数据范围","id":"数据范围-1","depth":4,"charIndex":385},{"text":"思路","id":"思路-2","depth":3,"charIndex":416},{"text":"代码","id":"代码-2","depth":3,"charIndex":511},{"text":"C 字符串外串","id":"c-字符串外串","depth":2,"charIndex":519},{"text":"题意","id":"题意-3","depth":3,"charIndex":530},{"text":"数据范围","id":"数据范围-2","depth":4,"charIndex":640},{"text":"思路","id":"思路-3","depth":3,"charIndex":682},{"text":"代码","id":"代码-3","depth":3,"charIndex":902},{"text":"E 一起走很长的路！","id":"e-一起走很长的路","depth":2,"charIndex":910},{"text":"题意","id":"题意-4","depth":3,"charIndex":924},{"text":"数据范围","id":"数据范围-3","depth":4,"charIndex":1095},{"text":"思路","id":"思路-4","depth":3,"charIndex":1175},{"text":"代码","id":"代码-4","depth":3,"charIndex":1480},{"text":"F 一起找神秘的数！","id":"f-一起找神秘的数","depth":2,"charIndex":1488},{"text":"题意","id":"题意-5","depth":3,"charIndex":1502},{"text":"数据范围","id":"数据范围-4","depth":4,"charIndex":1596},{"text":"思路","id":"思路-5","depth":3,"charIndex":1655},{"text":"代码","id":"代码-5","depth":3,"charIndex":1684},{"text":"G 一起铸最好的剑！","id":"g-一起铸最好的剑","depth":2,"charIndex":1692},{"text":"题意","id":"题意-6","depth":3,"charIndex":1706},{"text":"数据范围","id":"数据范围-5","depth":4,"charIndex":1732},{"text":"思路","id":"思路-6","depth":3,"charIndex":1786},{"text":"代码","id":"代码-6","depth":3,"charIndex":1797},{"text":"H 一起画很大的圆！","id":"h-一起画很大的圆","depth":2,"charIndex":1805},{"text":"题意","id":"题意-7","depth":3,"charIndex":1819},{"text":"数据范围","id":"数据范围-6","depth":4,"charIndex":1859},{"text":"思路","id":"思路-7","depth":3,"charIndex":1898},{"text":"代码","id":"代码-7","depth":3,"charIndex":1953},{"text":"I","id":"i","depth":2,"charIndex":1961},{"text":"题意","id":"题意-8","depth":3,"charIndex":1966},{"text":"数据范围","id":"数据范围-7","depth":4,"charIndex":1971},{"text":"思路","id":"思路-8","depth":3,"charIndex":1979},{"text":"代码","id":"代码-8","depth":3,"charIndex":1985},{"text":"J 数据时间？","id":"j-数据时间","depth":2,"charIndex":1991},{"text":"题意","id":"题意-9","depth":3,"charIndex":2002},{"text":"数据范围","id":"数据范围-8","depth":4,"charIndex":2273},{"text":"思路","id":"思路-9","depth":3,"charIndex":2394},{"text":"代码","id":"代码-9","depth":3,"charIndex":2408},{"text":"K 可以分开吗？","id":"k-可以分开吗","depth":2,"charIndex":2416},{"text":"题意","id":"题意-10","depth":3,"charIndex":2428},{"text":"数据范围","id":"数据范围-9","depth":4,"charIndex":2580},{"text":"思路","id":"思路-10","depth":3,"charIndex":2612},{"text":"代码","id":"代码-10","depth":3,"charIndex":2698},{"text":"L","id":"l","depth":2,"charIndex":2706},{"text":"题意","id":"题意-11","depth":3,"charIndex":2711},{"text":"数据范围","id":"数据范围-10","depth":4,"charIndex":2716},{"text":"思路","id":"思路-11","depth":3,"charIndex":2724},{"text":"代码","id":"代码-11","depth":3,"charIndex":2730},{"text":"M 那是我们的影子","id":"m-那是我们的影子","depth":2,"charIndex":2736},{"text":"题意","id":"题意-12","depth":3,"charIndex":2749},{"text":"数据范围","id":"数据范围-11","depth":4,"charIndex":2870},{"text":"思路","id":"思路-12","depth":3,"charIndex":2900},{"text":"代码","id":"代码-12","depth":3,"charIndex":3250}],"domain":"","frontmatter":{"title":"2025牛客暑寒假多校训练营Day2","subtitle":"","date":"2025-02-05T16:40:31.000Z","lastmod":"2025-02-05T16:40:31.000Z","draft":false,"authors":null,"description":"","tags":["2025寒假训练","算法","牛客","组合数学","计算几何","字符串","ST表"],"categories":["在学算法的日子里"],"series":["题解记录"],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"https://img.dodolalorc.cn/i/2025/02/06/67a3a57b557f6.jpg","featuredImagePreview":"https://img.dodolalorc.cn/i/2025/02/06/67a3a57b557f6.jpg","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":43,"title":"2025牛客暑寒假多校训练营Day3（完結）","content":"A 智乃的博弈游戏#\n\n\n题意#\n\n有一堆$n$个石子，每次可以拿走$x$个石子，要求$x$是一个不大于$n$且与$n$互质的数，当面对$1$时选手获胜，询问智乃（先手玩家）能否获胜。\n\n数据范围#\n\n * $1\\leq n\\leq 1e18$\n\n\n思路#\n\n必胜点是剩余 1，则 2 是必败点，两个选手都不希望对手面对 1，都希望对手面对 2。\n\n如果当前剩余$n$是奇数，则选手一定可以操作将剩余数量变成偶数（只拿一个）。面对偶数的选手，能选的互质的数一定是一个奇数，偶数减去奇数会变成奇数，下一轮回到奇数\n的情况，如果某一方保持偶数，一定会到剩余$2$的情况，也就是必败点。\n\n于是本题博弈和初始状态的奇偶性相关。\n\n\n代码#\n\n\n\n\nB 智乃的质数手串#\n\n\n题意#\n\n有一个环形的手串，第一个小球的编号是$0$，上面有一个数字$a_0$...第$n$个小球的编号是$n-1$，上面有一个数字$a_{n-1}$。\n\n遵循以下规则：\n\n * 手串上只有一个小球，则可以直接取下。\n * 若当前小球上的数字和其顺时针相邻的下一个小球的数字相加的和是一个质数，则可以拿下当前的小球。\n\n给出手串的结构，请问是否可以将小球全部取下来，取下来的合法序号顺序是什么？\n\n数据范围#\n\n * $1\\leq n\\leq 1e5$\n * $1\\leq a_i\\leq 1e5$\n\n\n思路#\n\n当手串是链状的时候，若要将第一个取下来，则需要将序号大于 1\n的第一个小球前的所有小球取下来，或者第二个小球前的所有小球取下来...很明显这是一个栈的结构，当将要入栈的小球可以和栈顶的数构成质数，则进行pop操作，知道栈为\n空或不能构成质数，才停止操作，将小球入栈。\n\n而在环状手串上，需要维护一个长度为$n$的区间，在这个区间上测试是否存在栈的大小只剩 1\n的情况，当栈底的小球的序号与栈顶的序号超过$n$的区间长度，需要将栈底的pop，这个数据结构需要支持两端的pop操作，应当使用deque模拟操作。\n\n\n代码#\n\n\n\n\nC 智乃的 Notepad(Easy version)#\n\n\n题意#\n\n有$n$个字符串，需要将它们都单独呈现在显示屏上，只能使用$26$个字母和退格键(\\b可以删去一个字符)，提问至少需要敲几下键盘？\n\n数据范围#\n\n * $1\\leq n\\leq 1e5$\n * $m=1$\n * $\\sum|s_i|\\leq 1e6$\n\n\n思路#\n\n当两个单词前缀相同时，对比分别打印两个单词，可以减少一个公共前缀的长度的次数，最后可以把最长的单词留在屏幕上。\n\n若建立字典树，答案就是字典树上边的数量的两倍减去最长单词的长度。\n\n也可以根据字典序排序，也可以把前缀相同的放在相邻的位置。\n\n\n代码：字典序排序#\n\n\n\n\n代码：字典树#\n\n\n\n\nD 智乃的 Notepad(Hard version)#\n\n\n题意#\n\n情景同 C 题，在此版本，需要支持$m$次查询，得到完成打印区间$[l,r]$内的单词需要的最少操作次数。\n\n数据范围#\n\n * $1\\leq n\\leq 1e5$\n * $1\\leq m\\leq 1e5$\n * $\\sum|s_i|\\leq 1e6$\n\n\n思路#\n\n离线处理查询的区间，范围$[l,r]$内的操作数是以$[l,r]$内的单词建立的字典树的边数\n×2-最长单词长度，考虑字典树的建树过程，每个单词会覆盖前若干个单词的部分前缀，在覆盖的过程中，前面的单词的贡献的点数部分转移到当前的单词上，将字符串的序号看作\n不同的颜色，在着色的过程中，更新各个颜色对应的贡献，在加入新的单词$i$时，可以计算所有以$i$为右端点的查询区间的答案。\n\n\n代码#\n\n\n\n\nE 智乃的小球#\n\n\n题意#\n\n在水平线上有$n$个小球，每个小球有一个初始速度，记向右为正，小球的初始速度要么为$1m/s$，要么为$-1m/s$，其质量都相同，坐标为$p_i$。询问在足够\n长的时间内，能否发生$k$次碰撞，以及第$k$次碰撞发生的时间。\n\n数据范围#\n\n * $1\\leq n\\leq 1e5$\n * $1\\leq k\\leq 1e9$\n * $0\\leq p_i\\leq 1e9,v_i\\in {-1,1}$\n\n保证一开始所有的小球位置不同。\n\n\n思路#\n\n根据高中物理常识，易得，当两个质量相同的小球相向碰撞，会交换彼此的速度。由于本题中所有小球的速度都是$1m/s$或$-1m/s$，可以把交换速度看作两个小球互相\n穿过对方，依然按照原来的速度向前运动。\n\n也就是说，本题询问若干向右的小球和向左的小球能相遇多少次，这个值可以枚举某个方向的小球的初始位置，再在另一个方向的小球中二分查找当前的小球会遇到多少相向的小球，\n再对时间进行二分。\n\n第$k$次碰撞的时刻的值大概率是浮点数，在二分时间的时候注意精度不要太小，容易超时。\n\n\n代码#\n\n\n\n\nF 智乃的捉迷藏#\n\n\n题意#\n\n在三角形的三个角和三条边着 6 个位置分别设计放多少人，人数总和是$n$，让 A、B、C 三个人分别能看到 a、b、c 数量的人。\n\n数据范围#\n\n * $1\\leq n\\leq 20$\n * $1\\leq a,b,c\\leq n$\n\n\n思路#\n\n赛时是直接冲了 6 重循环，暴力 for 遍历枚举 6 个位置的数量可以通过此题（注意边界）。\n\n也可以仅枚举 3 个顶点的位置，计算三边位置的值，判断成立条件。\n\n\n代码：枚举 6 位#\n\n\n\n\n代码：枚举 3 位#\n\n\n\n\nG 智乃与模数#\n\n\n题意#\n\n对一个正整数$n$，选择所有$1\\leq i\\leq n$的$i$作为模数，记录余数序列，再将余数序列降序排列，求前$k$大的数之和。\n\n数据范围#\n\n * $1\\leq k\\leq n\\leq 1e9$\n\n\n思路#\n\n分块，枚举商，在商比较小的时候，商是连续有值的，当商比较大的时候，可能会出现商和商之间不再连续，如$n=5$时，商为$1$的有${5,4,3}$，商为$2$的有\n${2}$，商为$3,4$的集合都是空的，商为$5$的集合是${1}$，对每个商相同的集合，可以发现其余数符合等差数列的规律，公差是商的值。商不连续的情况的数值\n范围比较小，可以通过打表记录这部分的余数。\n\n二分找出第$k$大的余数的值，再在每个按商分块的集合中，利用等差数列公式，计算余数大于等于$k$的余数之和，再减去多算的数量（这部分多算的数都是余数数值为$k$\n的数）。\n\n\n代码#\n\n\n\n类似题：因数个数和\n\n\nH 智乃与黑白树#\n\n\n题意#\n\n一棵节点数为$n$的黑白树，每个节点为黑色或白色，定义一棵黑白树的权值是树中所有黑色节点到白色节点的简单路径长度之和，路径长度是路径中经过边的数量。\n\n询问如果切掉第$i$条边，产生的两棵子树的权值分别是多少？\n\n数据范围#\n\n * $2\\leq n\\leq 1e5$\n\n\n思路#\n\n换根更新以$i$为根的子树的权值。\n\n{{< mermaid >}} flowchart TB c1((p))-.连接.->a1((v)) subgraph 子树v a1-->a2((s1))\na1-->a3((s2)) end subgraph 当前的树p c1-->c2((s1)) c1-->c3((s2)) end {{< /mermaid\n>}}\n\n如图，当前的操作是将子树$v$的信息更新到以$p$为根的树上，记以$i$为根的子树的黑/白色节点数是$num[i][0/1]$，子树$i$中的黑/白色节点到根$\ni$的距离之和是$g[i][0/1]$，$f[i]$为子树$i$的权值，那么在 dfs 递归更新的时候，转移是：\n\n\n\n而删边的时候转移是反过来：\n\n\n\n在切边的时候，按顺序换根，更新权值。\n\n\n代码#\n\n\n\n类似提：树学\n\n\nI 智乃的兔子跳#\n\n\n题意#\n\n在坐标${x_1,x_2,\\dots\n,x_n}$上各有一个胡萝卜，这$n$个胡萝卜的坐标各不重合，兔子要选择一个起始坐标$p$和一个跳跃步长$k$，以获得最多的胡萝卜个数。求出获得最多胡萝卜的$p\n$和$k$。\n\n数据范围#\n\n * $1\\leq n\\leq 1e5$\n * $1\\leq x_i\\leq 1e9$\n * $0\\leq p\\leq 1e9$\n * $2\\leq k\\leq 1e9$\n\n\n思路#\n\n随机化算法，如果每个坐标上都有胡萝卜，设计步长为 2，可以获得$\\max\n\\text{(奇数个数,偶数个数)}$个胡萝卜，任选两个胡萝卜，在最佳方案中的概率会大于$\\frac{1}{2}\\times\n\\frac{1}{2}$，随机选择两个胡萝卜，枚举其距离的质因数，更新最优的方案，随机的次数不超过可行的时间复杂度即可。\n\n\n代码#\n\n\n\n\nJ 智乃画二叉树#\n\n\n题意#\n\n使用\\、/、_画六边形二叉树，形似：\n\n\n\n要去掉不存在的节点，并用一圈*区分范围。\n\n数据范围#\n\n * $1\\leq n\\leq 99$\n * $1\\leq k\\leq 7$\n\n\n思路#\n\n先画出满二叉树，再根据树的结构填写序号和删去节点。\n\n\n代码#\n\n\n\n\nK 智乃的逆序数#\n\n\n题意#\n\n定义一个紧密排序数组：将数组元素按照从小到大排序后，相邻元素之间的差值是$1$。当两个数组没有任何相同元素，则这两个数组是不相交的。\n\n现在有$n$个互不相交的紧密数组，用这些数组中的元素组合成一个逆序数恰好为$k$的新数组，要求新数组中的数之间保持各自在原来数组中的相对顺序。\n\n数据范围#\n\n * $1\\leq n\\leq 1000$\n * $0\\leq k\\leq 1e6$\n * $1\\leq a_{i,j}\\leq 1e9$\n * 测试文件的数组长度之和不超过$10^3$\n\n\n思路#\n\n新数组中不改变数字之间在原数组中的相对顺序，且这些数组不会相交，那么每个数组是一个范围在$[l,r]$的数的排列，不管怎么改变他们在新数组中的位置，这个小排列中\n的数形成的逆序数对对数不会减少或增加，当按照最小值排序依次填入新数组时，就是逆序数最小的新数组。\n\n数组之间按照最小值为第一关键字升序排序，如果排序序号较大的数组中的元素放在序号小的数组中的数前面，会增加逆序数。最多的逆序数是数组按照逆序填入新数组时，从大到小\n枚举数组，计算元素需要向前移动几个位置能恰好满足$k$，也可以按组进行冒泡排序，合法的冒泡排序交换的次数就是增加的逆序数的数量。\n\n\n代码：枚举#\n\n\n\n\n代码：冒泡排序#\n\n\n\n\nL 智乃的三角遍历#\n\n\n题意#\n\n由三角形构成的平面图，给出层数，找出一条遍历所有边的欧拉回路。\n\n\n\n数据范围#\n\n\n思路#\n\n$n$比较小，可以打表存答案输出。\n\n法 2：要找出一种可以在任意层数上复刻的遍历思路，下图是一种思路，每次先向下遍历连到下层的点，再回复到右端点。\n\n\n\n法 3：递归搜索，类比汉诺塔，如果想完成 1→2→3→1 的顺序，需要先把以 2 为上顶点的三角形遍历完，指针回复到 2 号位置，继续完成 2→3，遍历 3\n为上顶点的三角形，最后回到 1。\n\n\n代码：某种顺序#\n\n\n\n\n代码：递归#\n\n\n\n\nM 智乃的牛题#\n\n\n题意#\n\n判断输入的长度为 8 的字符串能不能重组字符顺序组成nowcoder。\n\n数据范围#\n\n无\n\n\n思路#\n\n无\n\n\n代码#\n\n","routePath":"/posts/algorithm/nc25wd3","lang":"","toc":[{"text":"A 智乃的博弈游戏","id":"a-智乃的博弈游戏","depth":2,"charIndex":-1},{"text":"题意","id":"题意","depth":3,"charIndex":12},{"text":"数据范围","id":"数据范围","depth":4,"charIndex":93},{"text":"思路","id":"思路","depth":3,"charIndex":124},{"text":"代码","id":"代码","depth":3,"charIndex":312},{"text":"B 智乃的质数手串","id":"b-智乃的质数手串","depth":2,"charIndex":320},{"text":"题意","id":"题意-1","depth":3,"charIndex":333},{"text":"数据范围","id":"数据范围-1","depth":4,"charIndex":532},{"text":"思路","id":"思路-1","depth":3,"charIndex":585},{"text":"代码","id":"代码-1","depth":3,"charIndex":846},{"text":"C 智乃的 Notepad(Easy version)","id":"c-智乃的-notepadeasy-version","depth":2,"charIndex":854},{"text":"题意","id":"题意-2","depth":3,"charIndex":885},{"text":"数据范围","id":"数据范围-2","depth":4,"charIndex":957},{"text":"思路","id":"思路-2","depth":3,"charIndex":1019},{"text":"代码：字典序排序","id":"代码字典序排序","depth":3,"charIndex":1146},{"text":"代码：字典树","id":"代码字典树","depth":3,"charIndex":1160},{"text":"D 智乃的 Notepad(Hard version)","id":"d-智乃的-notepadhard-version","depth":2,"charIndex":1172},{"text":"题意","id":"题意-3","depth":3,"charIndex":1203},{"text":"数据范围","id":"数据范围-3","depth":4,"charIndex":1263},{"text":"思路","id":"思路-3","depth":3,"charIndex":1337},{"text":"代码","id":"代码-2","depth":3,"charIndex":1534},{"text":"E 智乃的小球","id":"e-智乃的小球","depth":2,"charIndex":1542},{"text":"题意","id":"题意-4","depth":3,"charIndex":1553},{"text":"数据范围","id":"数据范围-4","depth":4,"charIndex":1673},{"text":"思路","id":"思路-4","depth":3,"charIndex":1778},{"text":"代码","id":"代码-3","depth":3,"charIndex":2022},{"text":"F 智乃的捉迷藏","id":"f-智乃的捉迷藏","depth":2,"charIndex":2030},{"text":"题意","id":"题意-5","depth":3,"charIndex":2042},{"text":"数据范围","id":"数据范围-5","depth":4,"charIndex":2114},{"text":"思路","id":"思路-5","depth":3,"charIndex":2166},{"text":"代码：枚举 6 位","id":"代码枚举-6-位","depth":3,"charIndex":2255},{"text":"代码：枚举 3 位","id":"代码枚举-3-位","depth":3,"charIndex":2270},{"text":"G 智乃与模数","id":"g-智乃与模数","depth":2,"charIndex":2285},{"text":"题意","id":"题意-6","depth":3,"charIndex":2296},{"text":"数据范围","id":"数据范围-6","depth":4,"charIndex":2370},{"text":"思路","id":"思路-6","depth":3,"charIndex":2406},{"text":"代码","id":"代码-4","depth":3,"charIndex":2684},{"text":"H 智乃与黑白树","id":"h-智乃与黑白树","depth":2,"charIndex":2703},{"text":"题意","id":"题意-7","depth":3,"charIndex":2715},{"text":"数据范围","id":"数据范围-7","depth":4,"charIndex":2827},{"text":"思路","id":"思路-7","depth":3,"charIndex":2857},{"text":"代码","id":"代码-5","depth":3,"charIndex":3221},{"text":"I 智乃的兔子跳","id":"i-智乃的兔子跳","depth":2,"charIndex":3237},{"text":"题意","id":"题意-8","depth":3,"charIndex":3249},{"text":"数据范围","id":"数据范围-8","depth":4,"charIndex":3362},{"text":"思路","id":"思路-8","depth":3,"charIndex":3457},{"text":"代码","id":"代码-6","depth":3,"charIndex":3625},{"text":"J 智乃画二叉树","id":"j-智乃画二叉树","depth":2,"charIndex":3633},{"text":"题意","id":"题意-9","depth":3,"charIndex":3645},{"text":"数据范围","id":"数据范围-9","depth":4,"charIndex":3694},{"text":"思路","id":"思路-9","depth":3,"charIndex":3742},{"text":"代码","id":"代码-7","depth":3,"charIndex":3775},{"text":"K 智乃的逆序数","id":"k-智乃的逆序数","depth":2,"charIndex":3783},{"text":"题意","id":"题意-10","depth":3,"charIndex":3795},{"text":"数据范围","id":"数据范围-10","depth":4,"charIndex":3941},{"text":"思路","id":"思路-10","depth":3,"charIndex":4044},{"text":"代码：枚举","id":"代码枚举","depth":3,"charIndex":4328},{"text":"代码：冒泡排序","id":"代码冒泡排序","depth":3,"charIndex":4339},{"text":"L 智乃的三角遍历","id":"l-智乃的三角遍历","depth":2,"charIndex":4352},{"text":"题意","id":"题意-11","depth":3,"charIndex":4365},{"text":"数据范围","id":"数据范围-11","depth":4,"charIndex":4405},{"text":"思路","id":"思路-11","depth":3,"charIndex":4413},{"text":"代码：某种顺序","id":"代码某种顺序","depth":3,"charIndex":4594},{"text":"代码：递归","id":"代码递归","depth":3,"charIndex":4607},{"text":"M 智乃的牛题","id":"m-智乃的牛题","depth":2,"charIndex":4618},{"text":"题意","id":"题意-12","depth":3,"charIndex":4629},{"text":"数据范围","id":"数据范围-12","depth":4,"charIndex":4671},{"text":"思路","id":"思路-12","depth":3,"charIndex":4682},{"text":"代码","id":"代码-8","depth":3,"charIndex":4691}],"domain":"","frontmatter":{"title":"2025牛客暑寒假多校训练营Day3（完結）","subtitle":"","date":"2025-02-16T00:53:02.000Z","lastmod":"2025-02-16T00:53:02.000Z","draft":false,"authors":null,"description":"","tags":["2025寒假训练","字典树","数论分块","换根dp","随机化算法","模拟","ST表","算法"],"categories":["在学算法的日子里"],"series":["题解记录"],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"https://img.dodolalorc.cn/i/2025/02/16/67b17bacd70e1.jpg","featuredImagePreview":"https://img.dodolalorc.cn/i/2025/02/16/67b17bacd70e1.jpg","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":44,"title":"2025牛客暑寒假多校训练营Day4","content":"A#\n\n\n题意#\n\n数据范围#\n\n\n思路#\n\n\n代码#\n\n\nB Tokitsukaze and Balance String (easy)#\n\n\n题意#\n\n定义字符串是平衡的：字符串中01的连续子串的数量和10的连续子串的数量相同。\n\n定义字符串s的val(s)：\n\n * 将字符串s的某位置i的字符倒置（1变成0，0变成1）后，字符串是平衡的，这样的位置的总数\n\n现在有一个由1、0和?组成的字符串，?可以任意换成1或0，求所有的填写完成的字符串的val(s)的总和，模数是$10^9+7$。\n\n数据范围#\n\n * $1\\leq T\\leq 10^4$\n * $1\\leq n\\leq 10$\n * 保证单个测试文件的$2^n$之和不超过$10^5$\n\n\n思路#\n\nEasy版本的数据范围较小，直接dfs统计即可。\n\n\n代码#\n\n\n\n\nC#\n\n\n题意#\n\n数据范围#\n\n\n思路#\n\n\n代码#\n\n\nD Tokitsukaze and Concatenate‌ Palindrome#\n\n\n题意#\n\n有两个字符串a和b。\n\n第一步：对他们分别进行重新排列（也可以保持原状）；\n\n第二步：可以进行若干次替换；\n\n第三步：将a和b链接成一个新字符串s。\n\n求至少进行多少次第二步的替换，可以让s是一个回文串。\n\n数据范围#\n\n * $1\\leq n,m\\leq 2\\times 10^5$\n\n\n思路#\n\n如果a和b有共同拥有的字符，那么在回文串中要尽量将这些字符用作对称的位置，在组合串s的中线位置，尽量放满a或b中较长的串的剩余部分中的数量大于 1\n的字符，剩余的不对称的部分就是不得不替换的字符。\n\n\n代码#\n\n\n\n\nE Tokitsukaze and Dragon's Breath#\n\n\n题意#\n\n在$n\\times\nm$的表格中，每个位置$(i,j)$有一个数字$a_{i,j}$代表此地的怪物数量，当龙的位置在$(x,y)$时，火焰会打败坐标$(x,y)$的怪物，并向四个斜\n角方向（左上 ↖，右上 ↗，右下 ↘，左下 ↙）一直拓展，形成一个X形状。\n\n请在地图上选一个作为龙的坐标，并计算可以打败最多怪物的数量。\n\n数据范围#\n\n * $1\\leq T\\leq 1e4$\n * $1\\leq n,m\\leq 1e3$\n * $1\\leq a_{i,j}\\leq 1e9$\n * $n\\times m\\leq 1e6$\n\n\n思路#\n\n按题意枚举点，模拟攻击，注意需要记忆化算过的斜线，保证合适的复杂度。\n\n\n代码#\n\n\n\n\nI Tokitsukaze and Pajama Party#\n\n\n题意#\n\n歌词模式是u*uwawauwa，必须有一个u开头和一个uwawauwa结尾(连续的)，且中间的*至少匹配 1\n个任意字符，给出一个字符串，求字符串中有多少符合上述模式的子串。\n\n数据范围#\n\n * $1\\leq n\\leq 1e5$\n\n\n思路#\n\n寻找字符串中所有uwawauwa的位置，枚举u的位置，统计总数。\n\n\n代码#\n\n\n\n\nK Tokitsukaze and Shawarma#\n\n\n题意#\n\n客人需要$x$个沙威玛，$y$杯可乐，$z$包薯条。\n\n制作 $1$ 个沙威玛需要 $a$ 分钟；让饮料机倒可乐，每一杯可乐需要 $b$ 分钟；让炸锅自动炸薯条，每一包薯条需要 $c$ 分钟。这三件事可以同时进行。\n\n请问客人至少需要等待几分钟。\n\n数据范围#\n\n * $1\\leq x,y,z,a,b,c\\leq 100$\n\n\n思路#\n\n三者可以同时进行，取耗时最多的时间。\n\n\n代码#\n\n","routePath":"/posts/algorithm/nc25wd4","lang":"","toc":[{"text":"A","id":"a","depth":2,"charIndex":-1},{"text":"题意","id":"题意","depth":3,"charIndex":4},{"text":"数据范围","id":"数据范围","depth":4,"charIndex":9},{"text":"思路","id":"思路","depth":3,"charIndex":17},{"text":"代码","id":"代码","depth":3,"charIndex":23},{"text":"B Tokitsukaze and Balance String (easy)","id":"b-tokitsukaze-and-balance-string-easy","depth":2,"charIndex":29},{"text":"题意","id":"题意-1","depth":3,"charIndex":72},{"text":"数据范围","id":"数据范围-1","depth":4,"charIndex":248},{"text":"思路","id":"思路-1","depth":3,"charIndex":328},{"text":"代码","id":"代码-1","depth":3,"charIndex":360},{"text":"C","id":"c","depth":2,"charIndex":368},{"text":"题意","id":"题意-2","depth":3,"charIndex":373},{"text":"数据范围","id":"数据范围-2","depth":4,"charIndex":378},{"text":"思路","id":"思路-2","depth":3,"charIndex":386},{"text":"代码","id":"代码-2","depth":3,"charIndex":392},{"text":"D Tokitsukaze and Concatenate‌ Palindrome","id":"d-tokitsukaze-and-concatenate-palindrome","depth":2,"charIndex":398},{"text":"题意","id":"题意-3","depth":3,"charIndex":443},{"text":"数据范围","id":"数据范围-3","depth":4,"charIndex":552},{"text":"思路","id":"思路-3","depth":3,"charIndex":593},{"text":"代码","id":"代码-3","depth":3,"charIndex":699},{"text":"E Tokitsukaze and Dragon's Breath","id":"e-tokitsukaze-and-dragons-breath","depth":2,"charIndex":707},{"text":"题意","id":"题意-4","depth":3,"charIndex":744},{"text":"数据范围","id":"数据范围-4","depth":4,"charIndex":911},{"text":"思路","id":"思路-4","depth":3,"charIndex":1014},{"text":"代码","id":"代码-4","depth":3,"charIndex":1056},{"text":"I Tokitsukaze and Pajama Party","id":"i-tokitsukaze-and-pajama-party","depth":2,"charIndex":1064},{"text":"题意","id":"题意-5","depth":3,"charIndex":1098},{"text":"数据范围","id":"数据范围-5","depth":4,"charIndex":1192},{"text":"思路","id":"思路-5","depth":3,"charIndex":1222},{"text":"代码","id":"代码-5","depth":3,"charIndex":1262},{"text":"K Tokitsukaze and Shawarma","id":"k-tokitsukaze-and-shawarma","depth":2,"charIndex":1270},{"text":"题意","id":"题意-6","depth":3,"charIndex":1300},{"text":"数据范围","id":"数据范围-6","depth":4,"charIndex":1430},{"text":"思路","id":"思路-6","depth":3,"charIndex":1470},{"text":"代码","id":"代码-6","depth":3,"charIndex":1496}],"domain":"","frontmatter":{"title":"2025牛客暑寒假多校训练营Day4","subtitle":"","date":"2025-03-02T10:46:04.000Z","lastmod":"2025-03-02T10:46:04.000Z","draft":false,"authors":null,"description":"","tags":["2025寒假训练","算法","牛客"],"categories":["在学算法的日子里"],"series":["题解记录"],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"https://img.dodolalorc.cn/i/2025/03/02/67c461f0d8665.jpg","featuredImagePreview":"https://img.dodolalorc.cn/i/2025/03/02/67c461f0d8665.jpg","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":45,"title":"NENU2023学年算法2例题","content":"有的题还没写完）咕咕咕））\n\n\nNENU OJ算法2例题#\n\n这学期写算法2的思路并不都很详细，不过如果有想交流的也可以评论区或者私信，学校oj的题大多比较简单，这里的所有代码或许只保证通过学校的弱测试数据，因为其他地方O\nJ我还没有试过。\n\n\n算法2递归A#\n\n\n1241: A001 猴子吃桃#\n\n题目描述#\n\n猴子第1天摘下若干个桃子，当即吃了一半，还不过瘾，又多吃了一个。第2天又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下的一半另加一个。到第10\n天早上想再吃时，就只剩下一个桃子了。求第1天共摘了多少个桃子。\n\n输入\n\n输入第一行为正整数n，为测试数据组数。后面n行为测试数据，每组测试数据包括两个整数m，k，分别表示第m（m>1)天后剩余的桃子数k(k>=0)。\n\n输出\n\n输出猴子第一天摘的桃子数，每组数据占一行。\n\n样例输入\n\n\n\n样例输出\n\n\n\n参考代码#\n\n\n\n\n1242: A002 最大公约数#\n\n题目描述#\n\n输入两个正整数，求其最大公约数。 数论中有一个求最大公约数的算法称为辗转相除法，又称欧几里德算法。其基本思想及执行过程为（设m为两正整数中较大者，n为较小者）：\n（1）令u=m,v=n； （2）取u对v的余数，即r=u%v，如果r的值为0，则此时v的值就是m和n的最大公约数，否则执行第（3）步；\n（3）u=v，v=r，即u的值为v的值，而v的值为余数r。并转向第（2）步。\n\n输入\n\n第1行是测试数据的组数n，后面跟着n行输入。每组测试数据占1行，包括两个正整数m和n。\n\n输出\n\nn行，每行输出对应一个输入。输出应是一个正整数，为m和n的最大公约数。\n\n样例输入\n\n\n\n样例输出\n\n\n\n参考代码#\n\n\n\n\n1243: A003 经典的Hanoi(汉诺塔)问题#\n\n题目描述#\n\n有一个汉诺塔，塔内有A,B,C三个柱子。起初，A柱上有n个盘子，依次由大到小、从下往上堆放，要求将它们全部移到C柱上；在移动过程中可以利用B柱，但每次只能移到一\n个盘子，且必须使三个柱子上始终保持大盘在下，小盘在上的状态。要求编程输出移动的步骤。\n\n输入\n\n输入文件中包含多行，每行为一个整数n，代表初始A柱子上的盘子的个数。\n\n输出\n\n对输入文件中的每个整数n列出具体的汉诺塔移动步骤。两组输出之间有一空行。\n\n样例输入\n\n\n\n样例输出\n\n\n\n参考代码#\n\n\n\n\n1244: A004 菲波那契数列#\n\n题目描述#\n\n菲波那契数列是指这样的数列: 数列的第一个和第二个数都为1，接下来每个数都等于前面2个数之和。给出一个正整数a，要求菲波那契数列中第a个数是多少。\n\n输入\n\n第1行是测试数据的组数n，后面跟着n行输入。每组测试数据占1行，包括一个正整数a(1 <= a <= 20)。\n\n输出\n\n输出有n行，每行输出对应一个输入。输出应是一个正整数，为菲波那契数列中第a个数的大小。\n\n样例输入\n\n\n\n样例输出\n\n\n\n参考代码#\n\n\n\n\n1245: A005 另一个Fibonacci数列#\n\n题目描述#\n\n定义另外一个Fibonacci数列：F(0)=7,F(1)=11,F(n)=F(n-1)+F(n-2)，（n≥2）。\n\n输入\n\n输入文件中包含多行，每行为一个整数n，n<1000000。\n\n输出\n\n对输入文件中的每个整数n，如果F(n)能被3整除，输出yes，否则输出no。\n\n样例输入\n\n\n\n样例输出\n\n\n\n参考代码#\n\n\n\n\n1246: A006 分形（Fractal）#\n\n题目描述#\n\n分形是存在“自相似”的一个物体或一种量，从某种技术角度来说，这种“自相似”是全方位的。 盒形分形定义如下： 度数为1的分形很简单，为： X\n\n度数为2的分形为：\n\nX X\n\nX\n\nX X\n\n如果用B(n-1)代表度数为n-1的盒形分形，则度数为n的盒形分形可以递归地定义为：\n\nB(n-1) B(n-1)\n\nB(n-1)\n\nB(n-1) B(n-1)\n\n你的任务是输出度数为n的盒形分形。\n\n输入\n\n输入文件包含多个测试数据，每个测试数据占一行，包含一个正整数n，n ≤ 7。输入文件的最后一行为-1，代表输入结束。\n\n输出\n\n对每个测试数据，用符号“X”表示输出盒形分形。在每个测试数据对应的输出之后输出一个短划线符号“-”，在每行的末尾不要输出任何多余的空格，否则得到的是“格式错误”\n的结果。\n\n样例输入\n\n\n\n样例输出\n\n\n\n参考代码#\n\n\n\n\n1247: A007 二叉树#\n\n题目描述#\n\n如图所示，由正整数1, 2, 3, ...组成了一棵无限大的二叉树。从某一个结点到根结点（编号是1的结点）都有一条唯一的路径，比如从10到根结点的路径是(10,\n5, 2, 1)，从4到根结点的路径是(4, 2,\n1)，从根结点1到根结点的路径上只包含一个结点1，因此路径就是(1)。对于两个结点x和y，假设他们到根结点的路径分别是(x1, x2, ... ,1)和(y1,\ny2, ... ,1)（这里显然有x = x1，y = y1），那么必然存在两个正整数i和j，使得从xi 和 yj开始，有xi = yj , xi + 1 =\nyj + 1, xi + 2 = yj + 2,... 现在的问题就是，给定x和y，要求xi（也就是yj）。\n\n\n\n输入\n\n输入有多行，每行包括两个正整数x和y，这两个正整数都不大于1000。\n\n输出\n\n每行输出只有一个正整数xi。\n\n样例输入\n\n\n\n样例输出\n\n\n\n参考代码#\n\n\n\n\n1248: A008 波兰表达式#\n\n题目描述#\n\n波兰表达式是一种把运算符前置的算术表达式，例如普通的表达式2 + 3的波兰表示法为+ 2\n3。波兰表达式的优点是运算符之间不必有优先级关系，也不必用括号改变运算次序，例如(2 + 3) * 4的波兰表示法为* + 2 3\n4。本题求解波兰表达式的值，其中运算符包括+ - * /四个。\n\n输入\n\n输入第一行为一个整数n，然后是n行，每行为一组测试数据，其中运算符和运算数之间都用空格分隔，运算数是浮点数。\n\n输出\n\n输出n行，每行表达式的值，保留3位小数输出。\n\n样例输入\n\n\n\n样例输出\n\n\n\n参考代码#\n\n\n\n\n1249: A009 放苹果#\n\n题目描述#\n\n把M个同样的苹果放在N个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法（用K表示）？注意：5，1，1和1，5，1 是同一种分法。\n\n输入\n\n第一行是测试数据的数目t（0 <= t <= 20）。以下每行均包含二个整数M和N，以空格分开。1 <= M，N <= 10。\n\n输出\n\n对输入的每组数据M和N，用一行输出相应的K。\n\n样例输入\n\n\n\n样例输出\n\n\n\n参考代码#\n\n\n\n\n1250: A010 递归练习1#\n\n题目描述#\n\n有5个人坐在一起，问第5个人多少岁？他说比第4个人大两岁。问第4个人的岁数，他说比第3个人大两岁。问第3个人的岁数，又说比第2个人大两岁。问第2个人的岁数，说比\n第1个人大两岁。最后问第1个人的岁数，他说是10岁。请问第5个人多少岁？\n\n输入\n\n输入有多行，每行3个整数，依次为m,n,k。m表示一共有几个人，n表示大的岁数，k表示第一个人的岁数。\n\n输出\n\n输出第m个人的岁数，每个一行。\n\n样例输入\n\n\n\n样例输出\n\n\n\n参考代码#\n\n\n\n\n1251: A011 递归练习2#\n\n题目描述#\n\n根据递推式子C(m,n)=C(m-1,n)+C(m-1,n-1)，求组合数C(m,n)。注意递推的终止条件是C(m,1)=m；以及一些m和n取值的一些特殊情况，\n如m < 0或n < 0或m < n时，C(m,n)值为0，m和n相等时，C(m,n)=1等。\n\n输入\n\n第1行是测试数据的组数n，后面跟着n行输入。每组测试数据占1行，包括一个正整数m和一个正整数n。\n\n输出\n\n输出组合数C(m,n)。\n\n样例输入\n\n\n\n样例输出\n\n\n\n参考代码#\n\n\n\n\n1252: A012 递归练习3#\n\n题目描述#\n\n核反应堆中有α和β两种粒子。每秒钟内一个α粒子可以产生3个β粒子，而一个β粒子可以产生1个α粒子和2个β粒子。若在t=0时刻反应堆中有一个α粒子，求t时刻反应堆\n中分别有多少个α粒子和β粒子。\n\n输入\n\n输入有多个整数t，每个一行。\n\n输出\n\n输出t时刻反应堆里分别有多少个α粒子和β粒子。\n\n样例输入\n\n\n\n样例输出\n\n\n\n参考代码#\n\n\n\n插一句：这里用了pair数据类型，或许有同学并没有接触到...一般函数会返回1个值，有时候想返回两个或以上的时候可以试试自定义struct数据类型，再去定义一个\nstruct的函数，不过c++自有一个pair可以用，还是挺方便的。\n\n\n1253: A013 红与黑#\n\n题目描述#\n\n有一间长方形的房子，地上铺了红色、黑色两种颜色的正方形瓷砖。你站在其中一块黑色的瓷砖上，只能向相邻的黑色瓷砖移动。请写一个程序，计算你总共能够到达多少块黑色的瓷\n砖。\n\n输入\n\n包括多个数据集合。每个数据集合的第一行是两个整数W和H，分别表示x方向和y方向瓷砖的数量。W和H都不超过20。在接下来的H行中，每行包括W个字符。每个字符表示一\n块瓷砖的颜色，规则如下 1）‘.’：黑色的瓷砖； 2）‘#’：白色的瓷砖； 3）‘@’：黑色的瓷砖，并且你站在这块瓷砖上。该字符在每个数据集合中唯一出现一次。\n当在一行中读入的是两个零时，表示输入结束。\n\n输出\n\n对每个数据集合，分别输出一行，显示你从初始位置出发能到达的瓷砖数(记数时包括初始位置的瓷砖)。\n\n样例输入\n\n\n\n样例输出\n\n\n\n参考代码#\n\n\n\n\n1254: A014 城堡问题#\n\n题目描述#\n\n1 2 3 4 5 6 7 #############################\n\n1 # | # | # | | #\n\n#####---#####---#---#####---#\n\n2 # # | # # # # #\n\n#---#####---#####---#####---#\n\n3 # | | # # # # #\n\n#---#########---#####---#---#\n\n4 # # | | | | # #\n\n#############################\n\n(图 1)\n\n‘#’ = Wall ‘|’ = No wall '-' = No wall\n\n图1是一个城堡的地形图。请你编写一个程序，计算城堡一共有多少房间，最大的房间有多大。城堡被分割成m*n(m≤50，n≤50)个方块，每个方块可以有0~4面墙。\n\n输入\n\n程序从标准输入设备读入数据。第一行是两个整数，分别是南北向、东西向的方块数。在接下来的输入行里，每个方块用一个数字(0≤p≤50)描述。用一个数字表示方块周围的\n墙，1表示西墙，2表示北墙，4表示东墙，8表示南墙。每个方块用代表其周围墙的数字之和表示。城堡的内墙被计算两次，方块(1,1)的南墙同时也是方块(2,1)的北墙\n。输入的数据保证城堡至少有两个房间。\n\n输出\n\n城堡的房间数、城堡中最大房间所包括的方块数。\n\n样例输入\n\n\n\n样例输出\n\n\n\n参考代码#\n\n\n\n\n1255: A015 分解因式#\n\n题目描述#\n\n给出一个正整数a，要求分解成若干个正整数的乘积，即a = a1 * a2 * a3 * ... * an，并且1 < a1 <= a2 <= a3 <= ...\n<= an，问这样的分解的种数有多少。注意到a = a也是一种分解。\n\n输入\n\n第1行是测试数据的组数n，后面跟着n行输入。每组测试数据占1行，包括一个正整数a (1 < a < 32768)。\n\n输出\n\nn行，每行输出对应一个输入。输出应是一个正整数，指明满足要求的分解的种数。\n\n样例输入\n\n\n\n样例输出\n\n\n\n参考代码#\n\n\n\n\n1256: A016 数字拼凑#\n\n题目描述#\n\n现在给你这样一个任务，要求找出具有下列性质数的个数（包含输入的正整数 n）。 先输入一个正整数 n(n <= 500)，然后对此正整数按照如下方法进行处理：\n\n 1. 不作任何处理；\n 2. 在它的左边拼接一个正整数，但该正整数不能超过原数的一半或者是上一个被拼接数的一半；\n 3. 加上数后，继续按此规则进行处理，直到不能再加正整数为止。\n\n输入\n\n一个正整数n。\n\n输出\n\n一个正整数，表示具有该性质数的个数。\n\n样例输入\n\n\n\n样例输出\n\n\n\n参考代码#\n\n\n\n\n算法2排序B#\n\n\n1257: B001 快乐的蠕虫#\n\n题目描述#\n\n有一只快乐的蠕虫居住在一个m×n大小的网格中。在网格的某些位置放置了k块石头。网格中的每个位置要么是空的，要么放置了一块石头。当蠕虫睡觉时，它在水平方向或垂直方\n向上躺着，把身体尽可能伸展开来。蠕虫的身躯既不能进入到放有石块的方格中，也不能伸出网格外。而且蠕虫的长度不会短于2个方格的大小。\n本题的任务是给定网格，要计算蠕虫可以在多少个不同的位置躺下睡觉。\n\n输入\n\n输入文件的第1行是一个整数t，1<=t<=11,表示测试数据的个数。每个测试数据的第1行为3个整数：m,n和k(0<=m,n,k<=200000),接下来有k行\n，每行为2个整数，描述了一块石头的位置（行和列，最左上角位置为（1,1））。\n\n输出\n\n对每个测试数据，输出占一行，为一个整数，表示蠕虫可以躺着睡觉的不同位置的数目。\n\n样例输入\n\n\n\n样例输出\n\n\n\n参考代码#\n\n\n\n\n1258: B002 单词重组#\n\n题目描述#\n\n在美国数以百万计的报纸中，有一种单词游戏称为猜词。游戏的目标是猜谜，为了找出答案中缺少的字母，有必要对4个单词的字母顺序重新调整。在本题中，你的任务是编写程序实\n现对单词中的字母顺序重新调整。\n\n输入\n\n输入文件包含4部分： （1） 一部字典，包含至少1个单词，至多100个单词，每个单词占一行；\n\n（2） 字典后是一行字符串“XXXXXX”，表示字典结束；\n\n（3） 一个或多个被打乱字母顺序的“单词”，每个单词占一行，你必须整理这些字母的顺序；\n\n（4） 输入文件的最后一样为字符串“XXXXXX”，代表输入文件结束。\n\n所有单词，包括字典中的单词和被打乱字母顺序的单词，都只包含小写英文字母，并且至少包含一个字母，至多包含6个字母。字典中的单词不一定是按顺序排列的，但保证字典中的\n单词是唯一的。\n\n输出\n\n对输入文件中每个被打乱字母顺序的单词w，按字母顺序输出字典中所有满足以下条件的单词的列表：通过调整单词w中的字母顺序，可以变成字典中的单词。列表中的每个单词占一\n行。如果列表为空（即单词w不能转换成字典中的任何一个单词），则输出一行字符串“NOT A VALID\nWORD”。以上两种情形都在列表后，输出一行包含6个星号字符的字符串，表示列表结束。\n\n样例输入\n\n\n\n样例输出\n\n\n\n参考代码#\n\n\n\n\n算法2查找C#\n\n\n1264: C001 字符串计数#\n\n题目描述#\n\n给出m个字符串，要求输出重复n次的字符串有几个。\n\n输入\n\n先给定一个N，N≤100000，接着输入N个字符串。\n\n输出\n\n对于每组测试数据，输出若干行，每行两个正整数，第一个数表示重复的次数，第二个数表示在此重复次数下有几种不同的字符串。\n\n样例输入\n\n\n\n样例输出\n\n\n\n参考代码#\n\n\n\n\n1265: C002 赌徒#\n\n题目描述#\n\nN个赌徒一起决定玩一个游戏：\n游戏刚开始的时候，每个赌徒把赌注放在桌上并遮住，侍者要查看每个人的赌注并确保每个人的赌注都不一样。如果一个赌徒没钱了，则他要借一些筹码，因此他的赌注为负数。假定\n赌注都是整数。\n最后赌徒们揭开盖子，出示他们的赌注。如果谁下的赌注是其他赌徒中某3个人下的赌注之和，则他是胜利者。如果有多于一个胜利者，则下的赌注最大的赌徒才是最终的胜利者。\n例如，假定赌徒为：Tom、Bill、John、Roger和Bush，他们下的赌注分别为：2、3、5、7和12\n。因此最终获胜的是Bush（并且没有其他人是胜利者），因为他下的赌注为12，而其他的人下的赌注之和也等于12：2+3+7=12。\n\n输入\n\n输入文件中包含了多组赌徒下的赌注。每组赌注的数据第1行是一个整数n,1<=n<=1000,代表赌徒的个数，然后是他们下的赌注，每个人的赌注占一行，这些赌注各不相\n同，并且范围是[-536870912,+536870911]。输入文件的最后一行为0，代表输入结束。\n\n输出\n\n对每组赌注，输出胜利者下的赌注，如果没有解，则输出“no solution”。\n\n样例输入\n\n\n\n样例输出\n\n\n\n参考代码#\n\n\n\n\n1266: C003 半素数#\n\n题目描述#\n\n素数的定义：对于一个大于１的正整数，如果除了１和它本身没有其他的正约数了，那么这个数就称为素数。例如，2,11,67,89是素数，8,20,27不是素数。\n半素数的定义：对于一个大于1的正整数，如果它可以被分解成2个素数的乘积，则称该数为半素数，例如6是一个半素数，而12不是。 你的任务是判断一个数是否是半素数。\n\n输入\n\n输入文件中有多个测试数据，每个测试数据包含一个整数N，2<=N<=1,000,000。\n\n输出\n\n对每个测试数据，如果N是半素数，则输出YES，否则输出NO。\n\n样例输入\n\n\n\n样例输出\n\n\n\n参考代码#\n\n\n\n\n1267: C004 棍子的膨胀#\n\n题目描述#\n\n当一根长度为L的细长金属棍子加热n度后，它会膨胀到一个新的长度L’=(1+n*C)*L,其中C为该金属的热膨胀系数。\n当一根细长的金属棍子固定在两堵墙之间，然后加热，则棍子会变成圆弓形，棍子的原始位置为该圆弓形的弦，如图所示。\n\n![1699328671418](D:\\Tencent&&\\新建文件夹\\WeChat\nFiles\\wxid_j7esazuly79422\\FileStorage\\Temp\\1699328671418.png)\n\n图 膨胀的金属棍子（上为膨胀前，下为膨胀后） 你的任务是计算棍子中心的偏离距离。\n\n输入\n\n输入文件包含多个测试数据，每个测试数据占一行。每个测试数据包含3个非负整数：棍子的初始长度，单位为毫米；加热前后的温差，单位为度；该金属的热膨胀系数。输入数据保\n证膨胀的长度不超过棍子本身长度的一半。输入文件的最后一行为3个负数，代表输入结束，该测试数据不需处理。\n\n输出\n\n对每个测试数据，输出金属棍子中心加热后偏离的距离，单位为毫米，保留小数点后3位有效数字。\n\n样例输入\n\n\n\n样例输出\n\n\n\n参考代码#\n\n\n\n\n1268: C005 电缆主#\n\n题目描述#\n\n奶牛的居民决定举办一场编程区域赛。裁判委员会自告奋勇并宣称要举办有史以来最公正的比赛。队员们的电脑采用“星型”拓扑结构互连（也就是说要把所有电脑都连在一个中央集\n线器上）。为了让比赛尽可能公正，裁判委员会的头头们决定：将比赛队员们平均地安置在集线器周围，距离集线器有一个相同的距离。\n裁判委员会为了采买网络电缆，联系了一家当地的网络方案提供商，要求他们提供一些登等长的电缆。这些电缆应越长越好，从而使得队员们与其他队员的距离越大。\n这家公司的电缆工来办这件事。他知道仓库里每个电缆的长度（精确到厘米）。他每次切割电缆时的精度也是厘米。但他现在不知切多少，所以完全茫然中。\n你要写个程序计算出一条电缆最多多长使之可以提供一定能够数目的电缆，帮着这位电缆工完成任务。\n\n输入\n\n第一行是两个整数N和K，N（1<=N<=10000）是仓库里的电缆数，K（1<=K<=10000）是所需电缆数。接下来的N行每一行一个数，表示电缆的长度（单位是\n米）。电缆长度最小为1米，最大为100千米。每个表示长度的数均表示为带两位小数的浮点数（即精确到厘米）。\n\n输出\n\n所需的电缆一条最长有多少米（精确到厘米，即保留小数点两位）。如果不能提供K条大于等于1厘米的等长电缆就输出“0.00”。\n\n样例输入\n\n\n\n样例输出\n\n\n\n参考代码#\n\n\n\n\n1269: C006 宝贝鱼#\n\n题目描述#\n\n你刚刚从奶牛搬到一个大城市里。这里的人说一种让人理解不能的外文方言。万幸，你有本字典可以帮助你理解。\n\n输入\n\n输入包含多达100，000个字典词条，然后是一个空行，然后是一条消息，这条消息包含多达100，000个单词。每个词条占一行，先是一个英语单词，然后是一个空格，然\n后是一个外文方言词。一个方言词在字典中出现不超过一次。消息是一个外文方言词序列，一个词占一行。每个词是一个最长为10的小写字母序列。\n\n输出\n\n将消息的外文词翻译成英语，一个词一行。查不到的词应该翻译成“eh”。\n\n样例输入\n\n\n\n样例输出\n\n\n\n参考代码#\n\n\n\n\n1270: C007 星空#\n\n题目描述#\n\n将夜空抽象成二维平面，每个星星一个(X,Y)坐标。这些点可以形成多少正方形？\n\n输入\n\n多组输入。对于每组数据，第一行是n（1<=n<=1000）表示已知星星数，然后是n行，每行一个坐标值。坐标绝对值小于20000。n=0表示结束。\n\n输出\n\n对于每组数据输出形成正方形的个数。\n\n样例输入\n\n\n\n样例输出\n\n\n\n参考代码#\n\n\n\n\n算法2动态规划D#\n\n\n1272: D001 数字三角形#\n\n题目描述#\n\n7 3 8 8 1 0 2 7 4 4 4 5 2 6 5\n\n上图给出了一个数字三角形。从三角形的顶部到底部有很多条不同的路径。对于每条路径，把路径上面的数加起来可以得到一个和，你的任务就是找到最大的和。\n\n注意：路径上的每一步只能从一个数走到下一层上和它最近的左边的那个数或者右边的那个数。\n\n输入\n\n输入的第一行是一个整数N (1 < N <= 100)，给出三角形的行数。下面的N行给出数字三角形。数字三角形上的数的范围都在0和100之间。\n\n输出\n\n输出最大的和。\n\n样例输入\n\n\n\n样例输出\n\n\n\n参考代码#\n\n\n\n\n1273: D002 最长上升子序列#\n\n题目描述#\n\n一个数的序列bi，当b1 < b2 < ... < bS的时候，我们称这个序列是上升的。对于给定的一个序列(a1, a2, ...,\naN)，我们可以得到一些上升的子序列(ai1, ai2, ..., aiK)，这里1 <= i1 < i2 < ...\n\n你的任务，就是对于给定的序列，求出最长上升子序列的长度。\n\n输入\n\n输入有很多组，每组输入的第一行是序列的长度N (1 <= N <= 1000)。第二行给出序列中的N个整数，这些整数的取值范围都在0到10000。\n\n输出\n\n输出每组的最长上升子序列的长度。\n\n样例输入\n\n\n\n样例输出\n\n\n\n参考代码#\n\n\n\n\n1274: D003 Help Jimmy#\n\n题目描述#\n\n\"Help Jimmy\" 是在下图所示的场景上完成的游戏：\n\n\n\n场景中包括多个长度和高度各不相同的平台。地面是最低的平台，高度为零，长度无限。\nJimmy老鼠在时刻0从高于所有平台的某处开始下落，它的下落速度始终为1米/秒。当Jimmy落到某个平台上时，游戏者选择让它向左还是向右跑，它跑动的速度也是1米\n/秒。当Jimmy跑到平台的边缘时，开始继续下落。Jimmy每次下落的高度不能超过MAX米，不然就会摔死，游戏也会结束。\n设计一个程序，计算Jimmy到地面时可能的最早时间。\n\n输入\n\n第一行是测试数据的组数t（0 <= t <=\n20）。每组测试数据的第一行是四个整数N，X，Y，MAX，用空格分隔。N是平台的数目（不包括地面），X和Y是Jimmy开始下落的位置的横竖坐标，MAX是一次下落\n的最大高度。接下来的N行每行描述一个平台，包括三个整数，X1[i]，X2[i]和H[i]。H[i]表示平台的高度，X1[i]和X2[i]表示平台左右端点的横坐标\n。1<= N <= 1000，-20000 <= X, X1[i], X2[i] <= 20000，0 < H[i] < Y <= 20000（i =\n1..N）。所有坐标的单位都是米。 Jimmy 的大小和平台的厚度均忽略不计。如果Jimmy\n恰好落在某个平台的边缘，被视为落在平台上。所有的平台均不重叠或相连。测试数据保Jimmy一定能安全到达地面。\n\n输出\n\n对输入的每组测试数据，输出一个整数，Jimmy到地面时可能的最早时间。\n\n样例输入\n\n\n\n样例输出\n\n\n\n参考代码#\n\n\n\n\n1275: D004 最长公共子序列#\n\n题目描述#\n\n我们称序列Z = < z1, z2, ..., zk >是序列X = < x1, x2, ..., xm >的子序列当且仅当存在严格上升的序列< i1, i2,\n..., ik >，使得对j = 1, 2, ... ,k, 有xij = zj。比如Z = < a, b, f, c > 是X = < a, b,c, f,\nb, c >的子序列。 现在给出两个序列X和Y，你的任务是找到X和Y的最大公共子序列，也就是说要找到一个最长的序列Z，使得Z既是X的子序列也是Y的子序列。\n\n输入\n\n输入包括多组测试数据。每组数据包括一行，给出两个长度不超过200的字符串，表示两个序列。两个字符串之间由若干个空格隔开。\n\n输出\n\n输入包括多组测试数据。每组数据包括一行，给出两个长度不超过200的字符串，表示两个序列。两个字符串之间由若干个空格隔开。\n\n样例输入\n\n\n\n样例输出\n\n\n\n参考代码#\n\n\n\n\n1276: D005 陪审团的人选#\n\n题目描述#\n\n在遥远的国家佛罗布尼亚，嫌犯是否有罪，须由陪审团决定。陪审团是由法官从公众中挑选的。先随机挑选n个人作为陪审团的候选人，然后再从这n个人中选m人组成陪审团。选m\n人的办法是：\n控方和辩方会根据对候选人的喜欢程度，给所有候选人打分，分值从0到20。为了公平起见，法官选出陪审团的原则是：选出的m个人，必须满足辩方总分和控方总分的差的绝对值\n最小。如果有多种选择方案的辩方总分和控方总分的之差的绝对值相同，那么选辩控双方总分之和最大的方案即可。最终选出的方案称为陪审团方案。\n\n输入\n\n输入包含多组数据。每组数据的第一行是两个整数n和m，n是候选人数目，m是陪审团人数。注意，1<=n<=200,\n1<=m<=20而且m<=n。接下来的n行，每行表示一个候选人的信息，它包含2个整数，先后是控方和辩方对该候选人的打分。候选人按出现的先后从1开始编号。两组有效\n数据之间以空行分隔。最后一组数据n=m=0。\n\n输出\n\n对每组数据，先输出一行，表示答案所属的组号, 如 'Jury #1', 'Jury #2',\n等。接下来的一行要象例子那样输出陪审团的控方总分和辩方总分。再下来一行要以升序输出陪审团里每个成员的编号，两个成员编号之间用空格分隔。每组输出数据须以一个空行结\n束。\n\n样例输入\n\n\n\n样例输出\n\n\n\n参考代码#\n\n\n\n\n1277: D006 最大和#\n\n题目描述#\n\n给定一个n个整数的集合：A={a1, a2,..., an}，我们如下定义函数d(A)： $$ d(A)=\\max\\limits_{1\\leq s_1\\leq\nt_1\\leq s_2\\leq t_2\\leq n} \\begin{Bmatrix}\n\\sum_{i=s_1}^{t_1}a_i+\\sum_{j=s_2}^{t_2}a_j\\ \\end{Bmatrix} $$\n你的任务就是计算函数d(A)的函数值。 提示：对于样例，我们选择{2,2,3,-3,4} 和 {5}，进行想加得到函数d(A)的函数值。\n输入量大，建议使用scanf();\n\n输入\n\n输入包含 T(<=30)个样例，在输入的第一行即是整数T。每个样例包含两行，第一行是整数 n(2<=n<=50000)，第二行包含了n个整数： a1, a2,\n..., an. (|ai| <= 10000)。\n\n输出\n\n对于每个输入样例，输出一行，即如上定义函数d(A)的函数值。\n\n样例输入\n\n\n\n样例输出\n\n\n\n参考代码#\n\n\n\n\n1278: D007 最大子矩阵#\n\n题目描述#\n\n给你一个二维矩阵，元素是整数，有正有负。一个子矩阵就是最小1*1最大包含这个矩阵本身的矩阵。一个矩阵的和就是矩阵中所有元素求和，最大子矩阵就是所有子矩阵中和最大\n的那个字矩阵。下面是一个例子： 0 -2 -7 0 9 2 -6 2 -4 1 -4 1 -1 8 0 -2 最大子矩阵在左下角 9 2 -4 1 -1 8\n和值是15。\n\n输入\n\n输入的第一行是整数N，即表示要输入一个N * N的整数矩阵。接下来是N^2\n个整数，每个整数之间被空格或者空行分开，这些整数即为矩阵中的数，按照列优先的顺序排列，即第一行整数从左至右输入，第二行从左至右输入….\n第n行从左至右输入。N不会大于100，矩阵中的整数范围为 [-127,127]。\n\n输出\n\n输出最大矩阵的和。\n\n样例输入\n\n\n\n样例输出\n\n\n\n参考代码#\n\n\n\n\n算法2搜索E#\n\n\n1281: E001 数的划分#\n\n题目描述#\n\n将整数n分成k份，且每份不能为空，任意两种分法不能相同（不考虑顺序）。 例如：n=7，k=3，下面三种分法被认为是相同的。 1,1,5；1,5,1；5,1,1；\n问有多少种不同的分法。\n\n输入\n\n每组数据由一行上的2个整数n，k构成（6\n\n输出\n\n对每组测试数据，输出不同的分法整数。\n\n样例输入\n\n\n\n样例输出\n\n\n\n参考代码#\n\n\n\n\n1282: E002 闪避湖泊#\n\n题目描述#\n\n农夫约翰的农场在最近的一场暴风雨中被水淹没。但保险公司仅根据他得农场中最大的“湖泊”的大小赔偿一个数额。\n农场可表示为N行M列的长方形网格，（1≤N≤100,1≤M≤100）。网格中的每个单元或是干的或是被淹没的，且恰有K个单元被水淹没，（1≤K≤N*M）。正如人们\n所希望的，湖泊是一个中间单元，它与其他的单元共享一条长边（不是角落）。任何与中间单元共享一条长边或者与连通单元共享一条长边的单元是一个连通单元，是湖泊的一部分。\n\n输入\n\n有多组数据。每组的第1行有3个整数N，M和K。第2行到第K+1行，是整数R和C，表示被淹没的位置。\n\n输出\n\n对每组测试数据，输出有最大湖泊的单元的数目。\n\n样例输入\n\n\n\n样例输出\n\n\n\n参考代码#\n\n\n\n\n1283: E003 信道分配#\n\n题目描述#\n\n当无线电台在一个非常大的区域上传播信号时，为了每个接收器都能得到较强信号，使用转发器转发信号。然而，需要仔细地选择每个转发器使用的频道，以使附近的转发器不彼此干\n扰。如果邻近的转发器使用不同的频道，条件就得到满足。\n因为无线电波的频谱是宝贵的资源，转发器所需频道的数量应减到最少。编程任务：读取转发器网络的描述信息，并计算出所需频道的最小使用量。\n\n输入\n\n输入包含许多转发器网络图。每幅图的第一行是转发器数目（1~26）。转发器用连续的大写字母表示，从A开始。例如，10个转发器的名称分别是A，B，C，…，I和J。当\n转发器的个数是0时，表示输入结束。 转发器数目之后，是其邻近关系的列表。每行的格式为 A：BCDH\n表示转发器B、C、D和H与转发器A邻近。第一行描述与转发器A邻近的，第二行描述与B邻近的，直到描述完所有的转发器。如果某个转发器不与其他转发器相邻，它的形式为\nA： 转发器依字母顺序列出。 注意：相邻是对称的关系；如果A与B相邻，那么B与A也相邻。因为转发器位于水平面内，由相邻的转发器构成的网络图没有相交的线。\n\n输出\n\n对于每幅图（除了最后一个没有转发器），输出一行，是转发器不互相干扰所需的最少频道数。输出格式参考样例输出。注意：频道数为1的话，“channel”为单数。\n\n样例输入\n\n\n\n样例输出\n\n\n\n参考代码#\n\n\n\n\n1284: E004 移动的骑士#\n\n题目描述#\n\n你的一个朋友正在研究骑士旅行问题（TKP）。在一个有n个方格的棋盘上，你得找到一条最短的封闭骑士旅行的路径，使能够遍历每个方格一次。他认为问题的最困难部分在于，\n对两个给定的方格，确定骑士移动所需的最小步数。所以你帮助他编写一个程序，解决这个“困难的”部分。你的任务是：输入有两个方格a和b，确定骑士在最短路径上从a到b移\n动的次数。\n\n国际象棋中的骑士在棋盘上可移动的范围如下图：\n\n\n\n输入\n\n输入包含一组或多组测试例。每个测试例一行，是两个方格，用空格隔开。棋盘上的一个方格用一个字符串表示，字母（a-h）表示列，数字（1-8）表示行。\n\n输出\n\n对每个测试例，输出一行：“To get from xx to yy takes n knight moves.”。\n\n样例输入\n\n\n\n样例输出\n\n\n\n参考代码#\n\n\n\n\n1285: E005 图像周长#\n\n题目描述#\n\n病理学实验室的技术人员需要分析幻灯片的数字图像。幻灯片上有许多要分析的目标，由鼠标单击确定一个目标。目标边界的周长是一个有用的测量参数。编程任务：确定选中目标的\n在周长。 数字化的幻灯片是一个矩形的网格，里面有点’.’，表示空的地方；有大写字母‘X’，表示目标的一部分。简单网格如下所示\n\n\n\n方格中的一个X是指一个完整的网络方形区域，包括其边界和目标本身。网格中心的X与其边界上8个方向的X都是相邻的。任何两个相邻的X，其网格方形区域在边界或者拐角处是\n重叠的，所以他们的网格方形区域是相邻的。\n一个目标是由一系列相邻X的网格方形区域连接起来构成的。在网格1中，一个目标填充了全部网格；在网格2中有两个目标，其中一个目标只占左下角的一个网格方形区域，其余的\nX属于另一个目标。\n技术人员总是能单击到一个X，以选中包含该X的目标，记录单击时的坐标。行列号是从左上角开始，从1开始编号的。在网格1中，技术人员可以单击行2和列2选择目标；在网格\n2中，单击行2和列3就可以选中较大目标，单击行4和列3就不能选中任何目标。\n一个有用的统计参数是目标的周长。假定每个X的每条边上有一个方形的单元。在网格1中目标的周长是8（4个边，每个边上有2个方形的单元）；在网格2中，较大目标的周长是\n18，如下图所示。\n\n\n\n目标中不会包含任何完全封闭的孔，所以下面最左边的网格不会出现，应该是右边的网格样式。\n\n\n\n输入\n\n输入有多组网格。对每个网格，第一行是网格的行列数（rows，columns），鼠标单击的行列号（row，column），其整数范围都是1-20.接下来就是row\ns行，由字符‘.’和‘X’构成。 当一行是4个0时，标志输入结束。一行中的4个数字之间各有一个空格。网格数据的行之间没有空行。\n\n输出\n\n对每个网络输出一行，是选中目标的周长。\n\n样例输入\n\n\n\n样例输出\n\n\n\n参考代码#\n\n\n\n\n1286: E006 移动的骑士#\n\n题目描述#\n\nSomurolov先生是一个国际象棋高手，他声称在棋盘上将骑士棋子从一点移动到另外一点，没有人比他快，你敢挑战他吗？\n你的任务是编程计算出将一个骑士棋子从一点移动到另外一点，最少需要移动的步数。显而易见，这样你就有赢得Somurolov先生的机会。国际象棋中的骑士在棋盘上可移动\n的范围如下图：\n\n\n\n输入\n\n首先输入测试样例的个数n。接下来是n组输入数据，每组测试数据由三行整数组成：第一行是棋盘的边长l (4 <= l <= 300)，整个棋盘的面积也就是\nll；第二行和第三行分别是骑士棋子的初始位置和目标位置，表示为整数对形式{0, …, l-1}{0, …,\nl-1}。保证棋子的初始和目标位置是棋盘上的合法位置。\n\n输出\n\n对于每一个输入的测试样例，请你算出骑士从初始位置移动到目标位置最小移动步数。如果初始位置和目标位置相同，那么骑士移动的距离就是0。最后单独一行输出所求距离。\n\n样例输入\n\n\n\n样例输出\n\n\n\n参考代码#\n\n\n\n\n1287: E007 寻找M#\n\n题目描述#\n\n给出一个整数n，编程求出一个非零整数m，使得m是n的倍数，并且m的十进制表示中只有1和0。给出的n不大于200并且肯定存在对应的m，m是十进制数并且不大于100\n位。\n\n输入\n\n输入包含多组测试数据。每组测试数据只有一个整数n (1 <= n <= 200)。整数0标志输入的结束。\n\n输出\n\n对于每个n输出对应的整数m，m的十进制表示不多于100位。如果对于一个n存在多个合法的m，你只需输出一个即可。\n\n样例输入\n\n\n\n样例输出\n\n\n\n参考代码#\n\n\n\n\n1288: E008 红与黑#\n\n题目描述#\n\n有一个矩形的房间，房间铺着正方形的地砖。每个地砖被涂上红色或者黑色。初始时你站在房间里的某个黑色地砖上，你每次只能移动到相邻的四个地砖之一，即上下左右移动，并且\n你每次只能移动到黑色的地砖上，不能走到红色地砖。 编程计算出按照上述要求你能走到的黑色地砖的个数。\n\n输入\n\n输入包含多组测试数据。每组测试数据第一行包括2个整数W和H；W和H是房间的宽度和长度，分别表示为房间的x和y坐标轴。W和H不大于20。接下来是H行每行W个地砖的\n房间，每个地砖表示如下： ‘.’——黑色地砖 ‘#’——红色地砖 ‘@’ ——你在房间里的初始位置（房间只出现一次）。 输入的最后一行是两个整数0，不用处理。\n\n输出\n\n对每个测试样例，输出一行，即你能走到的黑色地砖的个数（包括你初始站在的黑色地砖）。\n\n样例输入\n\n\n\n样例输出\n\n\n\n参考代码#\n\n\n\n\n1289: E009 小木棒#\n\n题目描述#\n\nGeorge有一些长度相等的木棒，他随意的将这些木棒切成长度最多是50的小木棒。麻烦来了，他现在想将这些杂乱的小木棒恢复到原来的木棒，但是他忘记了原来到木棒的数\n量和长度。请你帮助他设计一个程序计算出原来木棒可能的最小长度，所有小木棒的长度均表示为大于0的整数。\n\n输入\n\n每组输入数据包括两行。第一行是George切后小木棒的个数，最多有64根小木棒；第二行是这些小木棒的长度，这些长度表示为空格分开的整数。输入样例以整数0表示结束\n。\n\n输出\n\n输出一行，即为原始木棒可能的最小长度。\n\n样例输入\n\n\n\n样例输出\n\n\n\n参考代码#\n\n\n\n\n算法2贪心F#\n\n\n1290: F001 木棒加工问题#\n\n题目描述#\n\n现有n根木棒，已知它们的长度和重量。要用一部木工机一根一根地加工这些木棒。该机器在加工过程中需要一定的准备时间，是用于清洗机器，调整工具和模板的。木工机需要的准\n备时间如下： （1） 第一根木棒需要1min的准备时间； （2）\n在加工了一根长为l，重为w的木棒之后，接着加工一根长为l’（l≤l’），重为w’（w≤w’）的木棒是不需要任何准备时间的。否则需要一分钟的准备时间。\n给定n根木棒，你要找到最少的准备时间。例如现在有长和重分别为（4,9），（5,2），（2,1），（3,5）和（1,4）的五根木棒，那么所需准备时间最少为2min\n，顺序为（1,4），（3,5），（4,9），（2,1），（5,2）。\n\n输入\n\n输入有多组测试例。输入数据的第一行是测试例的个数（T）。每个测试例两行：第一行是一个整数n（1≤n≤5000），表示有多少根木棒；第二行包括n*2个整数，表示l\n1,w1,l2,w2,l3,w3,…,ln,wn,全部不大于10000，其中li和wi表示第i根木棒的长度和重量。数据由一个或多个空格分隔。\n\n输出\n\n输出是以分钟为单位的最少准备时间，一行一个。\n\n样例输入\n\n\n\n样例输出\n\n\n\n参考代码#\n\n\n\n\n1291: F002 装箱#\n\n题目描述#\n\n一个工厂生产的产品形状都是长方体，高度都是h，主要有1x1，2x2，3x3，4x4，5x5，6x6等6种。这些产品在邮寄时被包装在一个6x6xh的长方体包裹中。\n由于邮费很贵，工厂希望减小每个订单的包裹数量以增加他们的利润。因此他们需要一个好的程序帮他们解决这个问题。你的任务就是设计这个程序。\n\n输入\n\n输入包括多组测试数据，每一行代表一个订单。每个订单里的一行包括六个整数，用空格隔开，从小到大分别为这6种产品的数量。6个0表示文件结束。\n\n输出\n\n针对每个订单输出一个整数，占一行，代表对应的订单所需的最小包裹数。没有多余的空行。\n\n样例输入\n\n\n\n样例输出\n\n\n\n参考代码#\n\n\n\n\n1292: F003 移动桌子#\n\n题目描述#\n\n著名的ACM（Advanced Computer Maker）公司租用了一层有400个房间的办公楼，结构如下。\n\n\n\n这层楼沿着走廊南北向的两边各有200个房间。最近，公司要做一次装修，需要在各个办公室之间搬运办公桌。由于走廊狭窄，办公桌都很大，走廊里一次只能通过一张办公桌。必\n须制定计划提高搬运效率。经理制定如下计划：一张办公桌从一个房间移动到另一个房间最多用十分钟。当从房间i移动一张办公桌到房间j，两个办公室之间的走廊都会被占用。所\n以，每10分钟内，只要不是同一段走廊，都可以在房间之间移动办公桌。为了说得更清楚一些，经理举例说明哪些情况可以同时移动，哪些情况不能同时移动。\n\n\n\n每个房间，只有一张办公桌进出。现在，经理想找到一种方案，使移动桌子的事情尽快完成。请编写程序解决经理的难题。\n\n输入\n\n输入数据有T组测试例，在第一行给出测试例个数（T）。每个测试例的第一行是一个整数N（1≤N≤200），表示要搬运办公桌的次数。接下来N行，每行两个正整数s和t，\n表示一张桌子，是从房间号码s移到房间号码t。有多组输入数据，输入第一行为一个表示输入数据总数的整数N，然后是N组输入数据。\n\n输出\n\n每组输入都有一行的输出数据，为一整数T，表示完成任务所花费的最少时间。\n\n样例输入\n\n\n\n样例输出\n\n\n\n参考代码#\n\n\n\n\n1293: F004 基因集合#\n\n题目描述#\n\n随着大量的基因组DNA序列数据被获得，它对于了解基因越来越重要（基因组DNA的一部分，是负责蛋白质合成的）。众所周知，在基因组序列中，由于存在垃圾的DNA中断基\n因的编码区，真核生物（相对于原核生物）的基因链更加复杂。也就是说，一个基因被分成几个编码片段（称为外显子）。虽然在蛋白质的合成过程中，外显子的顺序是固定的，但是\n外显子的数量和长度可以是任意的。\n大多数基因识别算法分为两步：第一步，寻找可能的外显子；第二步，通过寻找一条拥有尽可能多的外显子的基因链，尽可能大地拼接一个基因。这条链必须遵循外显子出现在基因组\n序列中的顺序。外显子i在外显子j的前面的条件是i的末尾必须在j开头的前面。 本题的目标是，给定一组可能的外显子，找出一条拥有尽可能多的外显子链，拼接成一个基因。\n\n输入\n\n给出几组输入实例。每个实例的开头是基因组序列中可能的外显子数n(0 < n <\n1000)。接着的n行，每行是一对整数，表示外显子在基因组序列中的起始和结束位置。假设基因组序列最长为50000。当一行是0时，表示输入结束。\n\n输出\n\n对于每个实例，找出最可能多的外显子链，输出链中的外显子，并占一行。假如有多条链，但外显子数相同，那么可以输出其中任意一条。\n\n样例输入\n\n\n\n样例输出\n\n\n\n参考代码#\n\n\n\n\n1294: F005 主框架#\n\n题目描述#\n\n多纳先生是ACM（Agent on Computing of\nMathematics，计算数学代理商）大型计算机的管理员。该代理商为一些公司承担在大型计算机上的计算工作，完成工作后获得报酬，因此大型计算机对这个代理商来说太\n重要了。多纳先生需要为这些在大型计算机上运行的作业安排顺序。一旦要运行某个作业，他就要检查运行该作业所需要的空闲资源。如果空闲资源足够的话，他就为该作业分配这些\n资源；否则就将该作业挂起，直至有足够的资源投入运行。 刚开始他并不熟悉这项工作，把事情搞得很乱。日积月累，他就胜任这项工作了。而且他还总结了一套规则：\n（1）大型计算机有M个CPU和N大小的内存空间可供分配。\n\n（2）对等待运行的作业有一个等待队列。可以假定这个队列足够长，能够存放所有等待运行的作业。\n\n（3）假定作业Ji需要Ai个CPU和Bi的内存空间，在时间Ti到达等待队列，需要在时间Ui之前完成。成功运行后，代理商可以获得Vi()的报酬；如果能在规定的时间\n之前完成，则每小时还可以额外获得Wi()的奖金；如果工期拖延，则每小时赔偿Xi()。例如，假定一个作业的报酬是10，时限8小时，每拖欠一小时罚2。如果该作业在1\n0小时完成，则代理商可以获得10-(10-8)*2=6。\n\n（4）当一个作业开始后，就独占了分配给它的CPU和内存空间，不能同时再分配给其他作业。当该作业运行结束后，这些资源被释放。如果资源足够多，同时可以运行多个作业。\n\n（5）为了最大限度地发挥大型计算机的计算能力，每个作业在开始运行后刚好一小时就完成。你可以假定每个作业的运行时间就是一小时。\n\n（6）没有作业运行时，机器空闲，一直到一个作业进入作业等待队列。\n\n（7）如果有多个作业进入作业等待队列，则报酬高的作业优先。可以假定这些作业的报酬都不相等。\n\n（8）如果某个作业的空闲CPU或内存空间不能满足，它就是被挂起一小时，也不占用任何资源。一小时后，再次为该作业检查资源，而不需要考虑等待队列里的其他作业。如果资\n源仍不满足要求，那就继续挂起一小时，把资源分配给其他在等待队列里的作业。否则，该作业将独占CPU和存储空间并投入运行。\n\n（9）当多个作业挂起时，采取先来先服务的原则。\n\n使用这些规则，多纳先生把事情安排得井井有条。现在除了日常公务外，代理商要求他根据作业列表计算收入。给定某个时间F，计算出已经完成的作业和应该被完成的作业。对作业\nJi，如果它的时限Ui>F并且仍未完成，就不需要统计收入。对已经完成的作业或Ui≤F的作业都要统计。如果工作没有完成，它不会给代理商带来报酬，但到这个时间F为止\n的罚款仍要计算。\n\n他不会程序设计，又不想手工做，现在你帮助他解决这个问题。\n\n输入\n\n有多组测试例。每个测试例描述大型计算机的资源和作业列表，第一行是整数F（0≤F≤10000），表示时限。接下来的一行是三个整数M，N和L（M，N，L≥0），M是\n机器CPU的数量，N是存储空间的大小，L是作业等待队列中作业的数量。最多有10000个作业。\n后面的L行是作业的信息。描述作业Ji的数据是7个整数：Ai，Bi，Ti，Ui，Vi，Wi，Xi。Ai和Bi（Ai，Bi≥0）指出了该作业对CPU和内存的需求。T\ni和Ui表示作业的到达时间和时限（0≤Ti≤Ui）。Vi，Wi，Xi分别是工作的报酬、奖励和罚款。 一个空的测试例（F=0）表示输入结束，该测试点无需处理。\n\n输出\n\n根据作业列表计算总收入。对每个测试例，输出测试例编号，一个冒号，一个空格，然后是收入。 测试例之间有一个空行。\n注意：对尚未投入运行的、且时限超过F的作业，不必统计。\n\n样例输入\n\n\n\n样例输出\n\n\n\n参考代码#\n\n\n\n\n1295: F006 整数区间#\n\n题目描述#\n\n一个整数区间[a,b] (a < b)，是一个从a到b连续整数的集合。\n现在给你n个整数区间，编程找出一个集合R，使得n个集合中的每个集合都有2个整数出现在R中，并且这个集合R包含的整数个数最少。\n\n输入\n\n输入有多组数据，每组第一行包含整数n(1 <= n <= 10000)，表示整数区间的个数。接下来n行，每行包含两个整数a和b(0 <= a < b <=\n10000, a < b)。\n\n输出\n\n输出符合条件的集合R中元素的个数。\n\n样例输入\n\n\n\n样例输出\n\n\n\n参考代码#\n\n\n\n\n1296: F007 安装雷达#\n\n题目描述#\n\n我们假设海岸线是一条无限直线：以海岸线为界，陆地和海洋被分开，在海边分布着很多小岛。现在，我们在海岸线上安装雷达，每个雷达有固定的通讯范围（以d为半径的圆形区域\n），这样，海边的小岛就可以被某个雷达信号覆盖。\n这里我们使用笛卡尔坐标系，定义海岸线为x轴，x轴上方是海洋，下方是陆地。给出分布在海边每个小岛的坐标位置和雷达信号能覆盖的范围d，你的任务是计算出最小需要安装的\n雷达数目，使得这些雷达信号能覆盖到所有海边的小岛。每个小岛的坐标格式为(x,y)。\n如下图所示，给出第一个输入样例的坐标表示，这样在(-2,0),(1,0)上分别安装雷达就可以覆盖所有的小岛（p点），所以我们只需要安装2个雷达。\n\n\n\n输入\n\n输入包含多组测试样例。每组测试第一行包含两个整数n(1<=n<=1000)和d，n表示小岛的数目，d表示雷达能覆盖的范围的半径。接下来n行，每行由整数x和y组成\n，表示n个小岛的坐标位置。每两组数据之间有一个空行。 输入0 0表示输入的结束。\n\n输出\n\n对于每一组输入，按照输出样例中的格式输出：包含输出序号和最少需要安装雷达的数目。如果找不到解决方案，即不能找到一种安装方案覆盖所有的小岛，输出”-1”。\n\n样例输入\n\n\n\n样例输出\n\n\n\n参考代码#\n\n\n\n\n1297: F008 排队买饭#\n\n题目描述#\n\n周晓晓吃完中午饭后又觉得没吃饱，因此想要再去食堂买点饭，当她走进食堂发现已经有n个人排队了，她知道每个人买饭需要的时间。她想帮助大家尽快的买到饭，即让n个人的平\n均等待时间最小，周晓晓已经饿的无法想出办法，只想知道他们最小的平均等待时间是多少，你能帮助她吗?\n\n输入\n\n输入可能有多组，每组第一行为一个整数n。 第二行 n 个整数，第 i 个整数 Ti 表示第i个人的等待时间Ti。\n\n输出\n\n每组输出占一行，为每组最小的平均等待时间（输出结果精确到小数点后两位）。\n\n样例输入\n\n\n\n样例输出\n\n\n\n参考代码#\n\n\n\n\n1298: F009 放书#\n\n题目描述#\n\n周小小最近想为自己的图书室添置一个巨型书架，尽管它是如此的大，但它还是几乎瞬间就被各种各样的书塞满了。现在，只有书架的顶上还留有一点空间。\n所有N(1<=N<=2000)把椅子都有一个确定的高度Hi（1<=Hi<=1000）。为了够到书架顶，周小小想像演杂技一般，将椅子一个一个的叠在一起，并上去把书\n架的空间补上。 显然，椅子叠的越多，就越不稳定，于是小小希望在够到书架顶的前提下，让椅子数量尽量少，作为聪明的你，一定能帮助他计算出这个最小数量吧。\n\n输入\n\n第1行: 2个用空格隔开的整数：N和B，表示有N把椅子和书架的高度； 第2行到N+1行: 第i+1行是1个整数：Hi，表示椅子的高度。 可能存在多组输入数据。\n\n输出\n\n输出1个整数，即最少要多少把椅子。（如果到不了顶端，输出-1）\n\n样例输入\n\n\n\n样例输出\n\n\n\n参考代码#\n\n","routePath":"/posts/algorithm/nenuoj","lang":"","toc":[{"text":"**算法2递归A**","id":"算法2递归a","depth":2,"charIndex":-1},{"text":"1241: A001 猴子吃桃","id":"1241-a001-猴子吃桃","depth":3,"charIndex":132},{"text":"题目描述","id":"题目描述","depth":4,"charIndex":150},{"text":"参考代码","id":"参考代码","depth":4,"charIndex":392},{"text":"1242: A002 最大公约数","id":"1242-a002-最大公约数","depth":3,"charIndex":402},{"text":"题目描述","id":"题目描述-1","depth":4,"charIndex":421},{"text":"参考代码","id":"参考代码-1","depth":4,"charIndex":723},{"text":"1243: A003 经典的Hanoi(汉诺塔)问题","id":"1243-a003-经典的hanoi汉诺塔问题","depth":3,"charIndex":733},{"text":"题目描述","id":"题目描述-2","depth":4,"charIndex":762},{"text":"参考代码","id":"参考代码-2","depth":4,"charIndex":992},{"text":"1244: A004 菲波那契数列","id":"1244-a004-菲波那契数列","depth":3,"charIndex":1002},{"text":"题目描述","id":"题目描述-3","depth":4,"charIndex":1022},{"text":"参考代码","id":"参考代码-3","depth":4,"charIndex":1230},{"text":"1245: A005 另一个Fibonacci数列","id":"1245-a005-另一个fibonacci数列","depth":3,"charIndex":1240},{"text":"题目描述","id":"题目描述-4","depth":4,"charIndex":1268},{"text":"参考代码","id":"参考代码-4","depth":4,"charIndex":1430},{"text":"1246: A006 分形（Fractal）","id":"1246-a006-分形fractal","depth":3,"charIndex":1440},{"text":"题目描述","id":"题目描述-5","depth":4,"charIndex":1465},{"text":"参考代码","id":"参考代码-5","depth":4,"charIndex":1839},{"text":"1247: A007 二叉树","id":"1247-a007-二叉树","depth":3,"charIndex":1849},{"text":"题目描述","id":"题目描述-6","depth":4,"charIndex":1866},{"text":"参考代码","id":"参考代码-6","depth":4,"charIndex":2275},{"text":"1248: A008 波兰表达式","id":"1248-a008-波兰表达式","depth":3,"charIndex":2285},{"text":"题目描述","id":"题目描述-7","depth":4,"charIndex":2304},{"text":"参考代码","id":"参考代码-7","depth":4,"charIndex":2559},{"text":"1249: A009 放苹果","id":"1249-a009-放苹果","depth":3,"charIndex":2569},{"text":"题目描述","id":"题目描述-8","depth":4,"charIndex":2586},{"text":"参考代码","id":"参考代码-8","depth":4,"charIndex":2778},{"text":"1250: A010 递归练习1","id":"1250-a010-递归练习1","depth":3,"charIndex":2788},{"text":"题目描述","id":"题目描述-9","depth":4,"charIndex":2807},{"text":"参考代码","id":"参考代码-9","depth":4,"charIndex":3027},{"text":"1251: A011 递归练习2","id":"1251-a011-递归练习2","depth":3,"charIndex":3037},{"text":"题目描述","id":"题目描述-10","depth":4,"charIndex":3056},{"text":"参考代码","id":"参考代码-10","depth":4,"charIndex":3281},{"text":"1252: A012 递归练习3","id":"1252-a012-递归练习3","depth":3,"charIndex":3291},{"text":"题目描述","id":"题目描述-11","depth":4,"charIndex":3310},{"text":"参考代码","id":"参考代码-11","depth":4,"charIndex":3480},{"text":"1253: A013 红与黑","id":"1253-a013-红与黑","depth":3,"charIndex":3607},{"text":"题目描述","id":"题目描述-12","depth":4,"charIndex":3624},{"text":"参考代码","id":"参考代码-12","depth":4,"charIndex":3973},{"text":"1254: A014 城堡问题","id":"1254-a014-城堡问题","depth":3,"charIndex":3983},{"text":"题目描述","id":"题目描述-13","depth":4,"charIndex":4001},{"text":"参考代码","id":"参考代码-13","depth":4,"charIndex":4611},{"text":"1255: A015 分解因式","id":"1255-a015-分解因式","depth":3,"charIndex":4621},{"text":"题目描述","id":"题目描述-14","depth":4,"charIndex":4639},{"text":"参考代码","id":"参考代码-14","depth":4,"charIndex":4885},{"text":"1256: A016 数字拼凑","id":"1256-a016-数字拼凑","depth":3,"charIndex":4895},{"text":"题目描述","id":"题目描述-15","depth":4,"charIndex":4913},{"text":"参考代码","id":"参考代码-15","depth":4,"charIndex":5145},{"text":"**算法2排序B**","id":"算法2排序b","depth":2,"charIndex":-1},{"text":"1257: B001 快乐的蠕虫","id":"1257-b001-快乐的蠕虫","depth":3,"charIndex":5165},{"text":"题目描述","id":"题目描述-16","depth":4,"charIndex":5184},{"text":"参考代码","id":"参考代码-16","depth":4,"charIndex":5557},{"text":"1258: B002 单词重组","id":"1258-b002-单词重组","depth":3,"charIndex":5567},{"text":"题目描述","id":"题目描述-17","depth":4,"charIndex":5585},{"text":"参考代码","id":"参考代码-17","depth":4,"charIndex":6141},{"text":"**算法2查找C**","id":"算法2查找c","depth":2,"charIndex":-1},{"text":"1264: C001 字符串计数","id":"1264-c001-字符串计数","depth":3,"charIndex":6161},{"text":"题目描述","id":"题目描述-18","depth":4,"charIndex":6180},{"text":"参考代码","id":"参考代码-18","depth":4,"charIndex":6325},{"text":"1265: C002 赌徒","id":"1265-c002-赌徒","depth":3,"charIndex":6335},{"text":"题目描述","id":"题目描述-19","depth":4,"charIndex":6351},{"text":"参考代码","id":"参考代码-19","depth":4,"charIndex":6861},{"text":"1266: C003 半素数","id":"1266-c003-半素数","depth":3,"charIndex":6871},{"text":"题目描述","id":"题目描述-20","depth":4,"charIndex":6888},{"text":"参考代码","id":"参考代码-20","depth":4,"charIndex":7155},{"text":"1267: C004 棍子的膨胀","id":"1267-c004-棍子的膨胀","depth":3,"charIndex":7165},{"text":"题目描述","id":"题目描述-21","depth":4,"charIndex":7184},{"text":"参考代码","id":"参考代码-21","depth":4,"charIndex":7658},{"text":"1268: C005 电缆主","id":"1268-c005-电缆主","depth":3,"charIndex":7668},{"text":"题目描述","id":"题目描述-22","depth":4,"charIndex":7685},{"text":"参考代码","id":"参考代码-22","depth":4,"charIndex":8246},{"text":"1269: C006 宝贝鱼","id":"1269-c006-宝贝鱼","depth":3,"charIndex":8256},{"text":"题目描述","id":"题目描述-23","depth":4,"charIndex":8273},{"text":"参考代码","id":"参考代码-23","depth":4,"charIndex":8541},{"text":"1270: C007 星空","id":"1270-c007-星空","depth":3,"charIndex":8551},{"text":"题目描述","id":"题目描述-24","depth":4,"charIndex":8567},{"text":"参考代码","id":"参考代码-24","depth":4,"charIndex":8731},{"text":"**算法2动态规划D**","id":"算法2动态规划d","depth":2,"charIndex":-1},{"text":"1272: D001 数字三角形","id":"1272-d001-数字三角形","depth":3,"charIndex":8753},{"text":"题目描述","id":"题目描述-25","depth":4,"charIndex":8772},{"text":"参考代码","id":"参考代码-25","depth":4,"charIndex":9033},{"text":"1273: D002 最长上升子序列","id":"1273-d002-最长上升子序列","depth":3,"charIndex":9043},{"text":"题目描述","id":"题目描述-26","depth":4,"charIndex":9064},{"text":"参考代码","id":"参考代码-26","depth":4,"charIndex":9346},{"text":"1274: D003 Help Jimmy","id":"1274-d003-help-jimmy","depth":3,"charIndex":9356},{"text":"题目描述","id":"题目描述-27","depth":4,"charIndex":9380},{"text":"参考代码","id":"参考代码-27","depth":4,"charIndex":10055},{"text":"1275: D004 最长公共子序列","id":"1275-d004-最长公共子序列","depth":3,"charIndex":10065},{"text":"题目描述","id":"题目描述-28","depth":4,"charIndex":10086},{"text":"参考代码","id":"参考代码-28","depth":4,"charIndex":10481},{"text":"1276: D005 陪审团的人选","id":"1276-d005-陪审团的人选","depth":3,"charIndex":10491},{"text":"题目描述","id":"题目描述-29","depth":4,"charIndex":10511},{"text":"参考代码","id":"参考代码-29","depth":4,"charIndex":11072},{"text":"1277: D006 最大和","id":"1277-d006-最大和","depth":3,"charIndex":11082},{"text":"题目描述","id":"题目描述-30","depth":4,"charIndex":11099},{"text":"参考代码","id":"参考代码-30","depth":4,"charIndex":11542},{"text":"1278: D007 最大子矩阵","id":"1278-d007-最大子矩阵","depth":3,"charIndex":11552},{"text":"题目描述","id":"题目描述-31","depth":4,"charIndex":11571},{"text":"参考代码","id":"参考代码-31","depth":4,"charIndex":11929},{"text":"**算法2搜索E**","id":"算法2搜索e","depth":2,"charIndex":-1},{"text":"1281: E001 数的划分","id":"1281-e001-数的划分","depth":3,"charIndex":11949},{"text":"题目描述","id":"题目描述-32","depth":4,"charIndex":11967},{"text":"参考代码","id":"参考代码-32","depth":4,"charIndex":12134},{"text":"1282: E002 闪避湖泊","id":"1282-e002-闪避湖泊","depth":3,"charIndex":12144},{"text":"题目描述","id":"题目描述-33","depth":4,"charIndex":12162},{"text":"参考代码","id":"参考代码-33","depth":4,"charIndex":12484},{"text":"1283: E003 信道分配","id":"1283-e003-信道分配","depth":3,"charIndex":12494},{"text":"题目描述","id":"题目描述-34","depth":4,"charIndex":12512},{"text":"参考代码","id":"参考代码-34","depth":4,"charIndex":13086},{"text":"1284: E004 移动的骑士","id":"1284-e004-移动的骑士","depth":3,"charIndex":13096},{"text":"题目描述","id":"题目描述-35","depth":4,"charIndex":13115},{"text":"参考代码","id":"参考代码-35","depth":4,"charIndex":13474},{"text":"1285: E005 图像周长","id":"1285-e005-图像周长","depth":3,"charIndex":13484},{"text":"题目描述","id":"题目描述-36","depth":4,"charIndex":13502},{"text":"参考代码","id":"参考代码-36","depth":4,"charIndex":14299},{"text":"1286: E006 移动的骑士","id":"1286-e006-移动的骑士","depth":3,"charIndex":14309},{"text":"题目描述","id":"题目描述-37","depth":4,"charIndex":14328},{"text":"参考代码","id":"参考代码-37","depth":4,"charIndex":14749},{"text":"1287: E007 寻找M","id":"1287-e007-寻找m","depth":3,"charIndex":14759},{"text":"题目描述","id":"题目描述-38","depth":4,"charIndex":14776},{"text":"参考代码","id":"参考代码-38","depth":4,"charIndex":15003},{"text":"1288: E008 红与黑","id":"1288-e008-红与黑","depth":3,"charIndex":15013},{"text":"题目描述","id":"题目描述-39","depth":4,"charIndex":15030},{"text":"参考代码","id":"参考代码-39","depth":4,"charIndex":15398},{"text":"1289: E009 小木棒","id":"1289-e009-小木棒","depth":3,"charIndex":15408},{"text":"题目描述","id":"题目描述-40","depth":4,"charIndex":15425},{"text":"参考代码","id":"参考代码-40","depth":4,"charIndex":15694},{"text":"**算法2贪心F**","id":"算法2贪心f","depth":2,"charIndex":-1},{"text":"1290: F001 木棒加工问题","id":"1290-f001-木棒加工问题","depth":3,"charIndex":15714},{"text":"题目描述","id":"题目描述-41","depth":4,"charIndex":15734},{"text":"参考代码","id":"参考代码-41","depth":4,"charIndex":16248},{"text":"1291: F002 装箱","id":"1291-f002-装箱","depth":3,"charIndex":16258},{"text":"题目描述","id":"题目描述-42","depth":4,"charIndex":16274},{"text":"参考代码","id":"参考代码-42","depth":4,"charIndex":16567},{"text":"1292: F003 移动桌子","id":"1292-f003-移动桌子","depth":3,"charIndex":16577},{"text":"题目描述","id":"题目描述-43","depth":4,"charIndex":16595},{"text":"参考代码","id":"参考代码-43","depth":4,"charIndex":17159},{"text":"1293: F004 基因集合","id":"1293-f004-基因集合","depth":3,"charIndex":17169},{"text":"题目描述","id":"题目描述-44","depth":4,"charIndex":17187},{"text":"参考代码","id":"参考代码-44","depth":4,"charIndex":17736},{"text":"1294: F005 主框架","id":"1294-f005-主框架","depth":3,"charIndex":17746},{"text":"题目描述","id":"题目描述-45","depth":4,"charIndex":17763},{"text":"参考代码","id":"参考代码-45","depth":4,"charIndex":19302},{"text":"1295: F006 整数区间","id":"1295-f006-整数区间","depth":3,"charIndex":19312},{"text":"题目描述","id":"题目描述-46","depth":4,"charIndex":19330},{"text":"参考代码","id":"参考代码-46","depth":4,"charIndex":19574},{"text":"1296: F007 安装雷达","id":"1296-f007-安装雷达","depth":3,"charIndex":19584},{"text":"题目描述","id":"题目描述-47","depth":4,"charIndex":19602},{"text":"参考代码","id":"参考代码-47","depth":4,"charIndex":20138},{"text":"1297: F008 排队买饭","id":"1297-f008-排队买饭","depth":3,"charIndex":20148},{"text":"题目描述","id":"题目描述-48","depth":4,"charIndex":20166},{"text":"参考代码","id":"参考代码-48","depth":4,"charIndex":20424},{"text":"1298: F009 放书","id":"1298-f009-放书","depth":3,"charIndex":20434},{"text":"题目描述","id":"题目描述-49","depth":4,"charIndex":20450},{"text":"参考代码","id":"参考代码-49","depth":4,"charIndex":20822}],"domain":"","frontmatter":{"title":"NENU2023学年算法2例题","date":"2023-12-19T14:02:50.000Z","draft":false,"authors":[],"description":"","tags":["算法","NENUOJ"],"categories":["在学算法的日子里"],"series":["题解记录"],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"","featuredImagePreview":"","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":46,"title":"线段树模板","content":"线段树(segment tree)#\n\n线段树主要用于维护区间信息，与传统的树状数组相比，可以实现O(log n)的区间修改，还可以同时支持多种操作(加、乘)，更具通用性。\n\n还是一样，为了方便测试，我们引入一个例题中的数据来演示。\n\n【模板】线段树#\n\n题目链接：[线段树 1](#P3372 【模板】线段树 1 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn))\n\n> ==题目描述==\n> \n> 如题，已知一个数列，你需要进行下面两种操作：\n> \n>  1. 将某区间每一个数加上 $k$。\n>  2. 求出某区间每一个数的和。\n> \n> ==输入格式==\n> \n> 第一行包含两个整数 $n, m$，分别表示该数列数字的个数和操作的总个数。\n> \n> 第二行包含 $n$ 个用空格分隔的整数，其中第 $i$ 个数字表示数列第 $i$ 项的初始值。\n> \n> 接下来 $m$ 行每行包含 $3$ 或 $4$ 个整数，表示一个操作，具体如下：\n> \n>  1. 1 x y k：将区间 $[x, y]$ 内每个数加上 $k$。\n>  2. 2 x y：输出区间 $[x, y]$ 内每个数的和。\n> \n> ==输出格式==\n> \n> 输出包含若干行整数，即为所有操作 2 的结果。\n> \n> ==样例 #1==\n> \n> 样例输入 #1\n> \n> \n> \n> 样例输出 #1\n> \n> \n> \n> ==提示==\n> \n> 对于 $30%$ 的数据：$n \\le 8$，$m \\le 10$。 对于 $70%$ 的数据：$n \\le {10}^3$，$m \\le {10}^4$。\n> 对于 $100%$ 的数据：$1 \\le n, m \\le {10}^5$。\n> \n> 保证任意时刻数列中所有元素的绝对值之和 $\\le {10}^{18}$。\n> \n> 【样例解释】\n\n线段树的建立#\n\n线段树的每个节点对应一个区间，最小的区间(最底下的叶子)只包含1个数，从node=1(根节点)往下逐渐二分，且每一层的区间并不重合。\n\n我们如此设置节点（简单概念）：\n\n每个节点p的左右子节点分别是2p和2p+1，假如节点p储存的是[l, r]的和，我们取mid=(l+r)/2\n（一般就是向下取整啦，数组从索引0开始）则其子节点恰是分别储存[l, mid]和[mid+1,\nr]的和，可以发现这样可以使得做节点对应的区间长度恰好与右节点对应的区间长度相同或恰好多1。\n\n草履虫都会的递归建图：\n\n\n\n如何更新数据？#\n\n朴素的想法或许是在改变数组中的某值之后再次递归来同步线段树，就像建树过程一样，但可以预见的是，这样做的时间复杂度比较高，因为当数组中的某值改变，我们需要upda\nte的节点是叶子节点，修改一个点会需要连锁修改上方所有包含该点的父节点、祖节点...etc，所以我们引入==懒标记法==进行线段树的区间修改。\n\n懒标记（延迟标记）#\n\n这是线段树的精髓所在qwq，递归的复杂度主要在于一层套一层然后再一层一层出来，有没有一种可能，我们给我们要修改的区间(将会对应一个唯一的节点)做上标记，只需要在\n将来用到某个节点的时候将变化传递下去就行。这样将会大大减少我们的时间。\n\n相当于啊，本来某个变化是变动整个树来更新的，现在我们懒一懒，把工作做到确定哪些区间是全部变化了的，给它标记上（带上变化的内容），只有等到需要找它的子区间的时候才\n把变化落实下去。\n\n还是看代码来理解吧：\n\n\n\n整个过程看着还是有递归，但是并不像建树时一样递归到底层才结束，我们在中间随时可以结束，只要找到一个可以代表它下面的所有小弟的大哥，然后告诉大哥要这样...那样.\n..然后我们的任务就完成了，意思已经传达到了。\n\n那么如何把我们的标记翻译下去呢，这个就更简单了，我们上面使用了一个mark[]数组记录变化，我们只需要吧mark里的指令传递到目标即可。\n\n\n\n接下来，我们如果想要更新到所有叶子结点，只要调用这个落实函数就好。\n\n查询区间#\n\n上面我们已经有了修改区间的方法，其实查询已经讲进去了吧，不会查怎么做修改\n\n简单的写一个模板函数：\n\n\n\n最后给上例题的参考代码：\n\n","routePath":"/posts/algorithm/seg_tree","lang":"","toc":[{"text":"线段树(segment tree)","id":"线段树segment-tree","depth":3,"charIndex":-1},{"text":"【模板】线段树","id":"模板线段树","depth":4,"charIndex":117},{"text":"线段树的建立","id":"线段树的建立","depth":4,"charIndex":795},{"text":"如何更新数据？","id":"如何更新数据","depth":4,"charIndex":1055},{"text":"查询区间","id":"查询区间","depth":4,"charIndex":1667}],"domain":"","frontmatter":{"title":"线段树模板","date":"2024-01-06T13:53:21.000Z","draft":false,"authors":[],"description":"","tags":["算法","线段树","数据结构","算法模板"],"categories":["在学算法的日子里"],"series":["算法模板笔记"],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"","featuredImagePreview":"","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":47,"title":"线段树专题练习","content":"{{< admonition abstract \"前言\" true>}}\n\n痛定思痛练习线段树QAQ。\n\n{{< /admonition >}}\n\n此篇包含尚未写完的题，事实上是一个TODO List。\n\n\nTODO List#\n\n * Atlantis\n\n * P5490 【模板】扫描线 & 矩形面积并 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n\n * I Hate It\n\n * 覆盖的面积\n\n * 敌兵布阵\n\n * P4588 TJOI2018 数学计算 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n\n * 单峰数列 ✅ 2024-09-26\n\n * 树上询问\n\n * P1502 窗口的星星 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n\n * P2471 SCOI2007 降雨量 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n\n\nAtlantis & P5490 扫描线矩形面积并#\n\nProblem - 1542 (hdu.edu.cn)\n\n\n题意#\n\n给出$x_1,y_1,x_2,y_2$，标志平面内的矩形的左上角坐标$(x_1,y_1)$和右下角坐标$(x_2,y_2)$ ，求这些矩形覆盖的总面积。\n\n输出格式参照样例。\n\n数据范围#\n\n * $0\\leq n\\leq 100$\n * $0\\leq x_1\\lt x_2\\leq 10^5$\n * $0\\leq y_1\\lt y_2\\leq 10^5$\n\n\n思路#\n\n记录每个矩阵的上下边，并给下边沿标记$1$，上边沿标记$-1$，扫描线从下向上扫描。\n\n记录每条线的左右端点的$x$坐标，去重后进行离散化，用$X[]$数组记录出现过的$x$坐标，并做去重。\n\n在去重之后的$X[]$数组上建立线段树（不包含最右侧端点），线段树中的每个节点记录该段节点代表的线段的左右端点在$X[]$中的下标，之后若该线段被覆盖，该节点代\n表的长度就是$X[posr+1]- X[posl]$，初始时每个节点记录的长度都是$0$（初始时均未被覆盖）。\n\n扫描线从下到上扫描，每次都是先遇到某个矩阵的下边沿（标记为$1$的边），然后再遇到上边沿（标记为$-1$的边）。对于每次加边，更新线段树上的节点，当前被覆盖的长\n度$\\times$当前扫描线与下一条扫描线的高度差即为这一部分的面积。\n\n\n代码#\n\n\n\n稍微修改一下上一题的代码就能过这个题：P5490 【模板】扫描线 & 矩形面积并 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n\n代码：\n\n\n\n\nI Hate It#\n\nI Hate It\n\n\n题意#\n\n老师想询问学生中从某某到某某分数最高的是多少，并支持修改单个学生的成绩。\n\n数据范围#\n\n$0\\lt n\\leq 200000$\n\n$0\\lt m\\leq 5000$\n\n\n思路#\n\n建树，节点记录最大值，单点修改。注意多组读入\n\n\n代码#\n\n\n\n\n覆盖的面积#\n\n覆盖的面积\n\n\n题意#\n\n给定平面上的矩阵，求出被这些矩阵覆盖至少两次的区域面积。\n\n数据范围#\n\n$1\\leq N\\leq 1000$\n\n$0\\leq x_i,y_i\\leq 100000$\n\n\n思路#\n\n扫描线求矩形并，在求并时统计更新被覆盖的次数，在pushup的时候，当父节点已有一次覆盖，而子区间已经被包含一次，则子区间已经被包含了2次。\n\n\n代码#\n\n\n\n\n敌兵布阵#\n\n敌兵布阵\n\n\n题意#\n\n有$N$个营地，初始第$i$个营地有$a_i$个人，有$4$种命令。\n\n 1. Add i j，表示第$i$个营地增加$j$人。\n 2. Sub i j，表示第$i$个营地减少$j$人。\n 3. Query i j，查询第$i$到第$j$个营地一共有多少人。\n 4. End，表示结束。\n\n数据范围#\n\n * $N\\leq 50000$\n * $1\\leq a_i\\leq 50$\n\n\n思路#\n\n很模板的一个题。\n\n\n代码#\n\n\n\n\n单峰数列#\n\n单峰数列\n\n\n题意#\n\n给定长度为$n$的数列$a$，支持以下操作：\n\n 1. 1 l r x：给区间$[l,r]$的所有数加上$x$\n 2. 2 l r：查询区间$[l,r]$中的元素是否全都相同\n 3. 3 l r：查询区间$[l,r]$中的元素是否严格上升，当$l==r$时认为是严格上升的\n 4. 4 l r：查询区间$[l,r]$中的元素是否严格下降，当$l==r$时认为是严格下降的\n 5. 5 l r：查询区间$[l,r]$是否是单峰数列，单峰数列符合右侧严格递增，左侧严格递减，并且左右侧的区间不为空，保证$r-l+1\\geq 3$。\n\n数据范围#\n\n * $3\\leq n \\leq 10^5$\n * $0\\leq a_i\\leq 10^9$\n * $1\\leq q \\leq 2\\times 10^5$\n\n对于第一类操作，保证$-10^9\\leq x\\leq 10^9$\n\n\n思路#\n\n用三个变量记录区间左值、右值和懒标记。\n\n用三个布尔值变量记录当前区间是否是相同、上升、下降、单峰。在判断合并后是否是单峰时，主要满足单峰的区间必须大于等于3，当左右两个区间分别是上升、下降，且某个区间\n只有一个数时，要注意比较左右值。\n\n\n代码#\n\n","routePath":"/posts/algorithm/segtree_practice","lang":"","toc":[{"text":"TODO List","id":"todo-list","depth":3,"charIndex":103},{"text":"Atlantis & P5490 扫描线矩形面积并","id":"atlantis--p5490-扫描线矩形面积并","depth":2,"charIndex":414},{"text":"题意","id":"题意","depth":3,"charIndex":472},{"text":"数据范围","id":"数据范围","depth":4,"charIndex":566},{"text":"思路","id":"思路","depth":3,"charIndex":658},{"text":"代码","id":"代码","depth":3,"charIndex":1017},{"text":"I Hate It","id":"i-hate-it","depth":2,"charIndex":1107},{"text":"题意","id":"题意-1","depth":3,"charIndex":1131},{"text":"数据范围","id":"数据范围-1","depth":4,"charIndex":1174},{"text":"思路","id":"思路-1","depth":3,"charIndex":1222},{"text":"代码","id":"代码-1","depth":3,"charIndex":1252},{"text":"覆盖的面积","id":"覆盖的面积","depth":2,"charIndex":1260},{"text":"题意","id":"题意-2","depth":3,"charIndex":1276},{"text":"数据范围","id":"数据范围-2","depth":4,"charIndex":1311},{"text":"思路","id":"思路-2","depth":3,"charIndex":1367},{"text":"代码","id":"代码-2","depth":3,"charIndex":1445},{"text":"敌兵布阵","id":"敌兵布阵","depth":2,"charIndex":1453},{"text":"题意","id":"题意-3","depth":3,"charIndex":1467},{"text":"数据范围","id":"数据范围-3","depth":4,"charIndex":1617},{"text":"思路","id":"思路-3","depth":3,"charIndex":1665},{"text":"代码","id":"代码-3","depth":3,"charIndex":1681},{"text":"单峰数列","id":"单峰数列","depth":2,"charIndex":1689},{"text":"题意","id":"题意-4","depth":3,"charIndex":1703},{"text":"数据范围","id":"数据范围-4","depth":4,"charIndex":1973},{"text":"思路","id":"思路-4","depth":3,"charIndex":2094},{"text":"代码","id":"代码-4","depth":3,"charIndex":2220}],"domain":"","frontmatter":{"title":"线段树专题练习","date":"2024-08-16T14:43:59.000Z","lastmod":"2024-08-16T14:43:59.000Z","draft":false,"authors":[],"description":"","tags":["算法","线段树","数据结构","算法模板"],"categories":["在学算法的日子里"],"series":["题解记录"],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"https://img.dodolalorc.cn/i/2024/12/10/67580e58b035a.png","featuredImagePreview":"https://img.dodolalorc.cn/i/2024/12/10/67580e58b035a.png","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":48,"title":"线段树讲义||寒假","content":"线段树介绍#\n\n * 线段树是一棵二叉树，每个节点维护一个区间内$[l,r]$的信息\n * 左子树区间维护$[l,\\lfloor \\frac{l+r}{2} \\rfloor]$的信息，右子树维护$[\\lfloor \\frac{l+r}{2}\n   \\rfloor+1,r]$的信息\n * 节点信息可以由两个子节点合并得到\n * 任意一个区间会被分为线段树上$O(\\log n)$个节点\n\n线段树可以在$O(\\log N)$的时间复杂度内实现单点修改、区间修改、**区间查询（区间求和/区间最大值/区间最小值）**等操作。\n\n线段树一般解决类似这样的问题：\n\n> 已知一个数列，你需要进行下面几种操作：\n> \n>  1. 将某区间每一个数加上 $k$。（修改）\n>  2. 求出某区间每一个数的和。（查询）\n>  3. 将某区间的每个数修改为$x$。（修改）\n>  4. 求某区间的最大值/最小值。（查询）\n\n\n建树#\n\n\n\n实现#\n\n递归实现\n\n\n\n\n查询&修改&求值#\n\n\n区间查询#\n\n进行区间查询的时候，区间和节点区间的关系有三种可能：\n\n 1. 当前要查询的区间与正在询问的区间没有交集，返回空\n 2. 当前要查询的区间被某个节点的区间完全包含，直接取该点记录的值\n 3. 当前要查询的区间被某个节点部分包含，则将这个节点往下传递一层，直到符合上面两种情况\n\n实现#\n\n\n\n\n区间修改（懒标记）#\n\n区间修改和区间查询的思路是一样的，判断当前节点区间与被修改的区间的关系，对其数据进行修改。\n\n假如我们在修改区间$[l,r]$时，把所有与$[l,r]$有交集的节点都遍历并修改一边，时间复杂度将过高，所以我们引入懒标记。\n\n思考：\n\n当我们要修改$[l,r]$，有一个节点（或者是一些节点的并集）恰好是$[l,r]$，我们选择节点数最少的那个集合进行修改，并对这些集合进行标记，只有当某次访问需\n要这些节点的子节点时，才把变化传递下去，这样可以大大减少对更深处的节点的修改次数，降低时间复杂度。\n\n实现#\n\n\n\n相应的，引入懒区间之后，我们在区间查询的时候要考虑懒标记是否下达，如果没有下达则要将懒标记传递下去。\n\n\n\n例题指路：\n\n区间求和：P3372 【模板】线段树 1 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n\n参考#\n\n\n\n思考#\n\n相似的，如果是将某个区间内的值都修改为某个值，应该如何操作？\n\n\n例题 1（两种懒标记）#\n\nP3373 【模板】线段树 2 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n\n> 操作 1： 格式：1 x y k 含义：将区间$[x,y]$内每个数乘上 k\n> \n> 操作 2： 格式：2 x y k 含义：将区间$[x,y]$ 内每个数加上 k\n> \n> 操作 3： 格式：3 x y 含义：输出区间 $[x,y]$ 内每个数的和对 m 取模所得的结果\n> \n> 这题需要考虑两种修改值的操作之间的相互影响。\n> \n>  * 每次对节点加/乘之前，要判断是否需要将当前节点的两种懒标记向下传递\n>  * 判断时应该先乘后加\n\n参考#\n\n\n\n\n动态开点#\n\n一般来说，线段树处理的范围在$[1,n]$，$n$一般是$1e5$的大小。\n\n如果我们想处理负数的范围，或者是$n$达到$1e9$的数量级时，我们就需要可以动态开点的线段树。\n\n线段树我们一般开到$4n$的大小是充足的，为了节省空间以及直接建立全树的时间，我们也可以对线段树动态开点，也就是只有当我们需要用到某些节点的时候，才去创造它。\n\n比如，我们已经一个节点表示$[11,16]$的相关数据，我们需要修改$[13,15]$上的信息，我们就创造$[11,13]$和$[14,16]$的节点，并继续递\n归创建节点，直到这个线段树可以完全表示到已被修改的信息。\n\n\n实现#\n\n\n\n\n线段树合并与分裂#\n\n\n线段树合并#\n\n线段树合并通过递归实现，需要有合并操作的线段树需要使用动态开点的技巧。\n\n将线段树 a 和 b 合并，从 1 号点开始递归，若递归到某个节点为空，直接返回另一个树上的对应节点；若递归到叶子节点，我们合并两棵树上的对应节点。\n\n\n\n模板题：[P4556 Vani 有约会] 雨天的尾巴 /【模板】线段树合并 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n\n\n线段树分裂#\n\n线段树分裂是线段树合并的逆过程。\n\n线段树分裂只适用于有序的序列，无序的序列是没有意义的，常用在动态开点的权值线段树上。\n\n当分裂和合并都存在时，要注意回收节点，以免分裂时会出现节点重复/占用的问题。\n\n 1. 当$[s,t]$与$[l,r]$有交集时开新节点\n 2. 当$[s,t]$包含于$[l,r]$时，直接将当前节点接到新的树下面，把旧边断开。\n\n\n\n模板题：P5494 【模板】线段树分裂 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n\n\n练习题一览#\n\n一些模板题/测测你的板子(!\n\nP3372 【模板】线段树 1 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n\nP3373 【模板】线段树 2 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n\nProblem - 5306 (hdu.edu.cn)\n\n[P4556 Vani 有约会] 雨天的尾巴 /【模板】线段树合并 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n\nP5494 【模板】线段树分裂 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n\n[P4097 【模板】李超线段树 / HEOI2013] Segment - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n\nP3369 【模板】普通平衡树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n\nP3391 【模板】文艺平衡树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)","routePath":"/posts/algorithm/segtreelecnote","lang":"","toc":[{"text":"线段树介绍","id":"线段树介绍","depth":2,"charIndex":-1},{"text":"建树","id":"建树","depth":3,"charIndex":404},{"text":"实现","id":"实现","depth":4,"charIndex":411},{"text":"查询&修改&求值","id":"查询修改求值","depth":2,"charIndex":425},{"text":"区间查询","id":"区间查询","depth":3,"charIndex":437},{"text":"实现","id":"实现-1","depth":4,"charIndex":583},{"text":"区间修改（懒标记）","id":"区间修改懒标记","depth":3,"charIndex":591},{"text":"实现","id":"实现-2","depth":4,"charIndex":852},{"text":"参考","id":"参考","depth":4,"charIndex":975},{"text":"思考","id":"思考","depth":4,"charIndex":982},{"text":"例题 1（两种懒标记）","id":"例题-1两种懒标记","depth":3,"charIndex":1020},{"text":"参考","id":"参考-1","depth":4,"charIndex":1310},{"text":"动态开点","id":"动态开点","depth":2,"charIndex":1318},{"text":"实现","id":"实现-3","depth":3,"charIndex":1607},{"text":"线段树合并与分裂","id":"线段树合并与分裂","depth":2,"charIndex":1615},{"text":"线段树合并","id":"线段树合并","depth":3,"charIndex":1627},{"text":"线段树分裂","id":"线段树分裂","depth":3,"charIndex":1823},{"text":"练习题一览","id":"练习题一览","depth":2,"charIndex":2066}],"domain":"","frontmatter":{"title":"线段树讲义||寒假","date":"2024-03-13T05:29:07.000Z","draft":false,"authors":[],"description":"","tags":["算法","线段树","数据结构","算法模板"],"categories":["在学算法的日子里"],"series":["算法模板笔记"],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"","featuredImagePreview":"","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":49,"title":"最短路问题（Dijkstra + SPFA + Floyd）","content":"思维先行#\n\n我们要找某点到某点的最短路径(记为点u到点v)，这样的路径只能从两种路径中选择——\n\n 1. u和v之间有边连接时，存在边(u, v)，不存在的话可以视作这两点的距离无限大\n 2. u和v可以通过某些点中转相连，这个(最短的)中转路径\n\n很明显，我们选最短路径肯定是在这两种路径当中选最短的来作为u和v的最短距离，而路径选择2又可以不断拆分，比如我们有u -> P ->\nv我们再去寻找这条路径的最短时，可以分为u -> P最短+P -> v最短，再去寻找中转点...而且每次取最小值最小的+最小的肯定得最小的（有一点贪心的感觉）。\n\n那么思维布置到这，我们来看看这个寻找最短路径的几种算法：\n\n\nFloyd算法&Bellman-Ford算法#\n\n * ==Floyd算法==\n\n这个算法就是刚刚思维里的算法的朴素实现了，动态规划思维，不断去尝试增加节点来找最小值。伪代码如下：\n\n\n\n很明显，这个算法有O(n^3)的复杂度，并不好，而且开的dist[maxn][maxn]数组空间也大，和之前学习存储图时一样，如果图比较稀疏，浪费的空间也大。\n\n如何优化呢？\n\n先看算法上，我们在选择中间点p的时候，我们很容易想到——并不是所有的点1~点n和u都有边，所以假如我们按边存储成为邻接表(前向星/链式前向星)，我们在搜索边的时\n候就能直接在已有的<u, p>边上进行选择。\n\nTIP：Floyd算法可以获得所有点之间的最短距离，所以在需要处理多源最短路且数据规模比较小的时候会选择它。\n\n我们更关心单源最短路问题，接下来我们的问题就假定为：找到以点v~1~为起点的最短路。\n\n由于是确定起点的单源最短路，我们接下来记录距离的数组只用开一维就行。\n\n初始化：dist[1]=0, dist[v]=distance[1][v], 其他的置INF。\n\n在Bellman-Ford算法中，我们假设不存在负权环（有负权环我们就会发现每绕一次dist都在变小，而我们取min（dist[v],weight(p->v)+\ndist[v]）肯定会把路径上的这个负权环走超过n遍），那么从v~1~到任何点的路径上点的个数都不会大于总点数n，所以Bellman-Ford算法就直接暴力搜n\n次来找最短路,到这里我们先代码实现一下这样的思路：\n\n给出一个图例like this：\n\n\n\n样例：\n\n\n\n参考代码like this：\n\n\n\nIDEA：我们在这个算法中可以发现，我们选边的时候对于它终点于何处并不关心，相反，我们会关心它的起点的信息（我们要算的源起点到该边的起点的距离），所以直接在存边\n的时候添加起点(from)的记录会方便我们确定起点。\n\n虽然上文提到我们不考虑负权环的存在，但是我们可以想象，如果存在负权环，该图进入Bellman-Ford算法之后会有神奇的数据产生，我们试试看：\n\n给我们的测试数据添加一个负权边：\n\n\n\n\n\n\n\n思考：不管有没有负权环，我们得到的其实都是合理的最短路径，但是存在负权环会使得到某些点的最短距离一定会减少（加上一个负数肯定变小，而我们选择的是较小的那个路径）\n，所以有负权环时，最短路径(假设路径上的点的数量没有限制)其实可以无限短，我们先前用暴力循环所有的点来保证所有的dist数组能够更新到最佳，那么假如有负权环在其\n中，dist数组没有最佳状态，所以我们简单的多循环一边，假如没有负权环，再多循环一边并不会改变dist数组里的值，如果有负权环，dist数组里一定有值改变。我们\n试试看：\n\n\n\n符合我们的想法。\n\n不过啊这个算法还是有暴力的成分，我们先前提到的只要遍历那些起点可直接到达的点等等想法还没实现，Bellman-Ford算法的时间复杂度有O(nm)，我们讨论算法\n的对于这样的复杂度肯定还是不满意的。\n\n我们再回忆一下整个搜索过程：其实我们关系的只是可以拓展的可能当中最小的是哪个，为了找到最小的那个，我们上面用了搜索全部的边、点的方法。那么我们的目的还是还是：有\n没有一种可以维护数据结构的方式，让我们更容易找到最小的那个可能？\n\n于是队列优化进入思维\n\n\nSPFA算法#\n\n我们找u -> p -> v路径时，p点的选择方法会实际影响我们的复杂度。我们的目的肯定是去更新u可以直接到达的点，而下一次就是p可以直接到达的点...\n\nSPFA算法使用一个队列去记录这些可以直接到达的点(也就是答案可能在的路径上)。\n\nSPFA是如何做到“只更新可能更新的点”的？\n\n 1. 只让当前点能到达的点入队\n 2. 如果一个点已经在队列里，便不重复入队\n 3. 如果一条边的起点还没被更新，那么它的终点不入队\n\n也就是说：当一个点入队了，代表它还在等待更新，当一个点出队了，那么它一定在当前经过最好的更新了。\n\n会有一个点入队了更新之后再次入队的情况吗？会有这种可能。\n\n来看看代码实现吧：\n\n\n\nSPFA算法的时间复杂度并不稳定，可以预想，在极端的情况下，SPFA算法的复杂度可以和Bellman-Ford算法一样是O(nm)（不过随机数据模拟的算法复杂度\n大概是O(m + nlogn)）\n\nSPFA算法也可以判断负权环的存在：若一个点入队次数超过n次，接下来无论怎么更新队列都不会为空，可以据此判断是否有负权环。\n\nemmm优化了一点的BellmanFord算法？(思考)\n\n接下来介绍复杂度稳定的贪心算法：==Dijstra算法==\n\n\n☆☆☆Dijstra算法#\n\nDij假设没有负边\n\n因为没有负边，我们可以确定，离起点最近的那个顶点的dist一定是那个顶点的最终结果。\n\n思路：起点u可以直接到达的点中，最近的点p对应的e一定是dist[p]的最佳值。假如它已经是最佳值了，我们在后面就可以把它当做起点u一样的点。由此我们只需要不断\n取出待更新队列里dist最小的点，并向后更新一层，直到没有需要再更新的点为止。\n\n\n\n当然了用pair也行，反正只有id和dist两个数据，多个其实也没关系你也可以pair套pair\n\n(另外两种简单的写法在STL.md里面写了，这里不写了)\n\n-如何记录路径？#\n\n把在更新点更新path数组就行。也就是dist[pos]>dist[u]+w(u->pos)的时候把这个更新的来源放在path数组里就行（记录到达某点的最好的路\n径的上一个来源点）。像这样：\n\n\n\n\n模板题#\n\n> 模板题指路：\n> \n> P3371 【模板】单源最短路径（弱化版） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n> \n> P4779 【模板】单源最短路径（标准版） - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n> \n> P3371【模板】单源最短路径（弱化版）\n> \n> ==题目背景==\n> \n> 本题测试数据为随机数据，在考试中可能会出现构造数据让SPFA不通过，如有需要请移步 P4779。\n> \n> 题目描述\n> \n> 如题，给出一个有向图，请输出从某一点出发到所有点的最短路径长度。\n> \n> ==输入格式==\n> \n> 第一行包含三个整数 $n,m,s$，分别表示点的个数、有向边的个数、出发点的编号。\n> \n> 接下来 $m$ 行每行包含三个整数 $u,v,w$，表示一条 $u \\to v$ 的，长度为 $w$ 的边。\n> \n> ==输出格式==\n> \n> 输出一行 $n$ 个整数，第 $i$ 个表示 $s$ 到第 $i$ 个点的最短路径，若不能到达则输出 $2^{31}-1$。\n> \n> ==样例==\n> \n> 样例输入 #1\n> \n> \n> \n> 样例输出 #1\n> \n> \n> \n> ==提示==\n> \n> 【数据范围】\n> \n> 对于 $20%$ 的数据：$1\\le n \\le 5$，$1\\le m \\le 15$；\n> \n> 对于 $40%$ 的数据：$1\\le n \\le 100$，$1\\le m \\le 10^4$；\n> \n> 对于 $70%$ 的数据：$1\\le n \\le 1000$，$1\\le m \\le 10^5$；\n> \n> 对于 $100%$ 的数据：$1 \\le n \\le 10^4$，$1\\le m \\le 5\\times 10^5$，$1\\le u,v\\le\n> n$，$w\\ge 0$，$\\sum w< 2^{31}$，保证数据随机。\n> \n> Update 2022/07/29：两个点之间可能有多条边，敬请注意。\n> \n> 对于真正 $100%$ 的数据，请移步 P4779。请注意，该题与本题数据范围略有不同。\n> \n> 样例说明：\n> \n> \n> \n> 图片1到3和1到4的文字位置调换\n\nAC代码\n\n\n\n这个...没有卡SPFA。看另一个卡SPFA的题：\n\n> P4779【模板】单源最短路径（标准版）\n> \n> ==题目背景==\n> \n> 2018 年 7 月 19 日，某位同学在 NOI Day 1 T1 归程 一题里非常熟练地使用了一个广为人知的算法求最短路。\n> \n> 然后呢？\n> \n> $100 \\rightarrow 60$；\n> \n> $\\text{Ag} \\rightarrow \\text{Cu}$；\n> \n> 最终，他因此没能与理想的大学达成契约。\n> \n> 小 F 衷心祝愿大家不再重蹈覆辙。\n> \n> ==题目描述==\n> \n> 给定一个 $n$ 个点，$m$ 条有向边的带非负权图，请你计算从 $s$ 出发，到每个点的距离。\n> \n> 数据保证你能从 $s$ 出发到任意点。\n> \n> ==输入格式==\n> \n> 第一行为三个正整数 $n, m, s$。 第二行起 $m$ 行，每行三个非负整数 $u_i, v_i, w_i$，表示从 $u_i$ 到 $v_i$\n> 有一条权值为 $w_i$ 的有向边。\n> \n> ==输出格式==\n> \n> 输出一行 $n$ 个空格分隔的非负整数，表示 $s$ 到每个点的距离。\n> \n> ==样例==\n> \n> 样例输入 #1\n> \n> \n> \n> 样例输出 #1\n> \n> \n> \n> ==提示==\n> \n> 样例解释请参考 数据随机的模板题。\n> \n> $1 \\leq n \\leq 10^5$；\n> \n> $1 \\leq m \\leq 2\\times 10^5$；\n> \n> $s = 1$；\n> \n> $1 \\leq u_i, v_i\\leq n$；\n> \n> $0 \\leq w_i \\leq 10 ^ 9$,\n> \n> $0 \\leq \\sum w_i \\leq 10 ^ 9$。\n> \n> 本题数据可能会持续更新，但不会重测，望周知。\n> \n> 2018.09.04 数据更新 from @zzq\n\nAC代码\n\n\n\n啊总算绕完最短路这几个算法了，时候想通了感觉还挺明白的，不过由于某人的码力好差，老是达不到想要的效果[可恶]，还得多写代码而不是只注重想法。写出来了才算是初步会\n了！","routePath":"/posts/algorithm/shortest_path","lang":"","toc":[{"text":"思维先行","id":"思维先行","depth":3,"charIndex":-1},{"text":"Floyd算法&Bellman-Ford算法","id":"floyd算法bellman-ford算法","depth":3,"charIndex":305},{"text":"SPFA算法","id":"spfa算法","depth":3,"charIndex":1708},{"text":"☆☆☆Dijstra算法","id":"dijstra算法","depth":3,"charIndex":2247},{"text":"-如何记录路径？","id":"-如何记录路径","depth":4,"charIndex":2521},{"text":"模板题","id":"模板题","depth":3,"charIndex":2632}],"domain":"","frontmatter":{"title":"最短路问题（Dijkstra + SPFA + Floyd）","date":"2023-12-23T08:08:47.000Z","draft":false,"authors":[],"description":"","tags":["图论","最短路"],"categories":["在学算法的日子里"],"series":["算法模板笔记"],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"","featuredImagePreview":"","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":50,"title":"字符串匹配问题||前缀函数+KMP+字符串哈希","content":"字符串匹配算法#\n\n\n暴力做法(BF)#\n\n简称BF(Brute Force)算法。\n\n没什么好说的，就是看到描述直接能想到的朴素做法。\n\n\n\nBF算法的时间复杂度不稳定。匹配成功时，最好为O(n)，最差为O(mn)；匹配失败时，最好为最好为O(n)，最差为O(mn)。平均时间复杂度为O(n)。\n\n\n前缀函数#\n\n定义#\n\n定义字符串$S$的前缀函数：$\\pi\n[i]$为其子串$s[0...i]$的最长相等真前缀与真后缀的长度。例如对于S=aabaaab，它的前缀函数是[0,1,0,1,2,2,3]。\n\n计算#\n\n朴素算法枚举子串的长度（其中$\\pi\n[0]=0$），然后从大到小尝试枚举子串中真前缀的长度，并与同样长度的真后缀进行匹配，直到找到符合相等条件的最大长度或者长度为$0$，时间复杂度是$O(n^3)\n$ 。\n\n\n\n考虑优化#\n\n容易考虑到，假设有一个长度为i的子串t的前缀函数是$\\pi [i]=k$，则表示t1 = t[0...k-1]与t2 =\nt[n-k...n-1]是相同的，那么当他们同时去掉后一位字符，得到的t1' = t[0....k-2]与t2' =\nt[n-k+1...n-2]也是匹配的。换句话说，当$s[k-1]=s[i]$时，有$\\pi[i-1]+1=\\pi[i]$，并且当$s[k-1]≠s[i]$时，\n$\\pi[i]$将变为$0$或保持一个不大于$s[i-1]$的数。前缀函数只能在前一个匹配的状态下进行拓展，每次拓展最多只能增加1，否则维持不变或减少。\n\n其实这时候应该能发现，这是一个动态规划，每次向后拓展一位时，我们需要与拓展前的状态相对比，判断新加的一位是当前状态（当前匹配的前缀/后缀串）的后继（$s[\\pi\n[i]]=s[i+1]$）或者是之前的状态$\\pi[p]$的后继（空匹配$\\pi[p]=0$也算一种状态）。\n\n加入这个优化，我们就能优化掉每次匹配前后缀最大长度的枚举。\n\n\n\n复杂度#\n\n考虑某一次匹配，在若$s[i+1]=s[\\pi[i]]$，则只需要进行一次比较就能成功，而这次成功也是在$s[i]=s[\\pi[i-1]]$的基础上的累加。考虑\n：在$i=n$时，从$j=\\pi[n-1]+1$到$j=1$都是不匹配的，那么字符串比较累计了$\\pi[n-1]+1$次（j=0时是空字符串比较）。若$\\pi[\nn-1]$是最大的$n-2$，则在计算$\\pi[n]$时进行了$n-1$次字符串比较。同时代表$\\pi[n-1]=\\pi[n-2]+1=\\pi[n-3]+1+1\n=...=\\pi[1]+n-2$都是成立的，这里进行了$n-2$次加1，也就是说从$\\pi[1]$累计到$\\pi[n-1]$每次都进行$1$次比较，总比较次数共\n是$n-2$次匹配。总的字符串比较次数为n-1 + n-2。再考虑字符串比较复杂度是$O(s.length)$。优化之后的时间复杂度为$O(n^2)$\n\n再次优化#\n\n上一步我们将整个计算前缀函数的字符串比较次数优化到$O(n)$的大小，在上一步的基础上，我们优化当$s[i+1]\\neq\ns[\\pi[i]]$时，如何转移到上一个符合$s[i+1]=s[\\pi[k]]$的状态。\n\n失配时，我们希望找到长度$j=\\pi[k]$使得$s[i+1]=s[\\pi[k]]$成立，也就是将$i+1$的状态直接从$k$ 的状态进行继承。\n\n当$s[j]\\neq\ns[i]$时，若存在仅次于$j$的第二长度$k$，使得$s[0...k-1]=s[i-k+1...i]$成立，则$\\pi[i]=k$，对于这样的子串，符合以下性\n质： $$ s[0...k-1]=s[i-k+1...i]=s[\\pi[i]-k...\\pi[i]-1]=s[0...\\pi[i]-1] $$\n$s[0...\\pi[i]-1]$的长度$\\pi[i]=k$，也就是说，$k$等价于$s[0...\\pi[i]-1]$的前缀函数值，也就是$\\pi[\\pi[i]\n-1]$。\n\n利用这个性质，每次失配之后，只需要将$j$更新为$\\pi[j-1]$即可。\n\n\n\n\nKMP算法#\n\n观察朴素的BF算法，造成复杂度上升的主要原因在于模式串T中指针的回溯（即匹配失败时j再次从0开始匹配，KMP算法主要优化了回溯这一步，我们为减少回溯的距离，引入\n了next数组来指示匹配之后回溯的位置。next数组减少回溯的想法正好是结合上面关于生成前缀函数的想法，换句话说，KMP中的next数组就是一个前缀表。\n\n前缀函数匹配的是前缀和后缀，当我们把待匹配串$t$拼接到模式串$s$的后面（用一个不在$s$和$t$中的字符分隔），即可按照相同的做法去生成前缀函数。考虑组合出\n的新字符串的前缀函数，前$n+1$个函数值是只和主串自身字符有关的一部分前缀函数。接下来，依次在前缀函数中加入$t$中的一个字符，计算当前位置的前缀函数值，若在\n某一位置有$\\pi[i]=n$成立，则代表字符串$s$在字符串$t$中的位置$i-(n-1)-(n+1)=i-2*n$出现（在组合串的$i-(n-1)$的位置出\n现，减去前面$s$和分隔符的长度即为在$t$中的位置）。\n\n\n\nKMP模板题#\n\n题面：P3375 【模板】KMP - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n\n代码#\n\n\n\n另一个关于KMP的题：[P4824 USACO15FEB] Censoring S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n\n代码#\n\n\n\n自动机#\n\n在KMP中生成s + '#' + t前缀函数时，前s + '#'的状态于t没有关系，而s + '#' + t可以由s +\n'#'的状态转移而来，如果t中包含的字符是一定的，比如约定都是小写字母，则可以根据s +\n'#'来构建一个关于下一位字符的有限状态机，逐个添加字符就是逐建更新状态。\n\n\n\n数组aut[i][c]表示在前$i$个字符匹配上的情况下，第$i+1$的字符是c时要跳转的状态，这样的跳转是$O(1)$ 的。\n\n试手例题：Problem - 808G - Codeforces\n\n参考代码\n\n\n\n\n统计所有前缀次数#\n\n统计待匹配串$s$的所有前缀在$t$中出现的次数。\n\n考虑$\\pi[i]$的生成，依然是参照这里的推导思路，对于位置$i$的前缀函数值$\\pi[i]$，可知长度小于$\\pi[i]$的最长的以$s[i]$结尾的前缀长\n度是$\\pi[\\pi[i]-1]$，之后是$\\pi[\\pi[\\pi[i]-1]-1]$......，直到长度为$0$，因此$s[0...i]$的每个前缀在$t$\n中出现的次数可以统计这样的传递的次数。\n\n\n\n\n不同本质子串计数#\n\n给长度为$n$的字符串$s$后添加一个新字符$c$，给原来的$s$的所有不同子串后加$c$后，会出现一些以这个字符$c$结尾的之前没出现过的子串，我们的目的是计\n数每次在末尾添加新字符之后的字符串的不同本质子串数目。\n\n举例，原串$S$是aba，原来的子串集合是：$[S]=\\{a,b,ab,ba\\}$，添加字符x之后的新串是abax，由于添加x后没有再之前的子串集合里的任何两个\n子串$s_1,s_2$中出现$s_1+x=s_2$的情况，那么新出现的子串数目就是原集合$[S]$的元素数目。假如添加的字符是b，新串是abab，那么就会发现，\n在原子串集合添加含有新加的b出现的新增加的元素集合$[S']=\\{b,ab,bab\\}$ 中$\\{b,ab\\}$与原有元素出现了重复。\n\n思路#\n\n考虑原串cbbcb添加了新字符后是cbbcbx，考虑x加入后cbx是否与cbb相同，我们可以将字符串cbbcbx翻转为xbcbbc，对翻转后的字符串计算前缀函数\n，记该字符串前缀函数的最大值是$\\pi_{max}$，假设$\\pi_{max}=3$，则该最大值对应的前缀是xbc，也就是说xbc=bbc，这是包含x的最长的匹\n配长度，显然，xbc的子串x、xb、xbc在bbc中对应b、bb、bbc，复原为没有翻转前，正好就是添加新字符之后的包含新字符的元素集合中，与未加新字符前的字符\n串的子串集合中重复的元素。于是在添加新字符之后，新出现的子串数目即为$(|s_{原}|+1)-\\pi_{max}$ 。\n\n\n字符串压缩#\n\n字符串压缩指的是找到最短的长度$k$使得所有$s[0...k-1]=s[k...2*k-1]=...=s[n-k...n-1]$成立（$n\\bmod k=0$\n）。\n\n举例字符串abcabc可以被压缩为abc、abababab可以被压缩为ab。显然，假设字符串$s$可以被压缩至长度$k$，则该字符串的前缀函数的最后一个值$\\p\ni[n]$一定是$n-k$，（注意前后缀是真子串），$\\pi[n]$与$n$相差的长度应当正好是一个最短压缩串的长度。因此，由$n-\\pi[n]$得到$k$，若\n$n\\bmod k=0$成立，则$k$即为压缩后的长度。\n\n\n字符串Hash#\n\n字符串哈希的主要难点是构造哈希函数。\n\n哈希的性质：\n\n * Hash函数值不一样的时候，两个字符串一定不一样。\n * Hash函数值一样的时候，两个字符串大概率一样。\n\n第二条主要是哈希碰撞引起的，可以尝试用双哈希降低哈希碰撞的概率。\n\n构造哈希函数#\n\n通常是多项式哈希，对于一个长度为$l$的字符串$s$，可以定义它的多项式哈希函数为这样： $$ f(s)=\\sum_{i=1}^ls[i]\\times\nb^{l-i}(\\bmod M) $$\n比如字符串$xyz$，它的哈希函数值就是$xb^2+yb+z$，就像一个$b$进制的数一样。当然也可以反过来，将哈希函数定义为： $$\nf(s)=\\sum_{i=1}^l s[i]\\times b^{i-1}(\\bmod M) $$ 相应的，$xyz$的哈希函数值就是$x+yb+cb^2$\n。实际使用的时候不要混淆。\n\n哈希碰撞不想算了我要咕咕咕。\n\n参考代码（及其朴素）：\n\n\n\n考虑到更多时候需要配合字符串子串的哈希值，所以我们需要预处理出每个前缀的哈希值，这样就能快速求得子串的哈希值了。\n\n\n\n还是这个题：[P4824 USACO15FEB] Censoring S - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)\n\n利用哈希解决：\n\n代码#\n\n","routePath":"/posts/algorithm/string_match","lang":"","toc":[{"text":"字符串匹配算法","id":"字符串匹配算法","depth":2,"charIndex":-1},{"text":"暴力做法(BF)","id":"暴力做法bf","depth":3,"charIndex":10},{"text":"前缀函数","id":"前缀函数","depth":3,"charIndex":150},{"text":"定义","id":"定义","depth":4,"charIndex":157},{"text":"计算","id":"计算","depth":4,"charIndex":254},{"text":"KMP算法","id":"kmp算法","depth":3,"charIndex":1711},{"text":"KMP模板题","id":"kmp模板题","depth":4,"charIndex":2153},{"text":"自动机","id":"自动机","depth":4,"charIndex":2303},{"text":"统计所有前缀次数","id":"统计所有前缀次数","depth":3,"charIndex":2564},{"text":"不同本质子串计数","id":"不同本质子串计数","depth":3,"charIndex":2788},{"text":"思路","id":"思路","depth":4,"charIndex":3140},{"text":"字符串压缩","id":"字符串压缩","depth":3,"charIndex":3450},{"text":"字符串Hash","id":"字符串hash","depth":3,"charIndex":3735},{"text":"构造哈希函数","id":"构造哈希函数","depth":4,"charIndex":3865}],"domain":"","frontmatter":{"title":"字符串匹配问题||前缀函数+KMP+字符串哈希","date":"2024-01-05T06:11:58.000Z","draft":false,"authors":[],"description":"","tags":["KMP","字符串","算法","哈希"],"categories":["在学算法的日子里"],"series":["算法模板笔记","字符串笔记"],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"","featuredImagePreview":"","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":51,"title":"思维题刷题合集","content":"#","routePath":"/posts/algorithm/thinking","lang":"","toc":[{"text":"","id":"","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"title":"思维题刷题合集","subtitle":"","date":"2024-10-18T15:07:39.000Z","lastmod":"2024-10-18T15:07:39.000Z","draft":true,"authors":null,"description":"记录题源CodeForces的一些思维题","tags":["算法","思维题"],"categories":["在学算法的日子里"],"series":["题解记录"],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"https://img.dodolalorc.cn/i/2024/10/18/67127ce55c5aa.jpg","featuredImagePreview":null,"toc":{"enable":true},"math":{"enable":false},"lightgallery":false,"license":""},"version":""},{"id":52,"title":"拓扑排序","content":"拓扑排序#\n\n前提：拓扑排序是对有向无环图来说的，无向图、有环图都不存在拓扑排序。\n\n拓扑排序是将图G中的所有顶点排成一个线性序列，使得对于任意一堆有边顶点，在线性序列中，u都出现在v之前。\n\n拓扑排序可以反应某种方案是否是切实可行的。\n\n一般一个图是否是有向图我们分析题意要求就能知道，但是究竟有没有环存在，就不是瞄一眼就能发现的了，所以，虽然拓扑排序是针对有向无环图而言的一种性质，但是反过来，一\n个有向图是否有拓扑排序，也可以反过来解决该图是否存在环、以及存在多少环等等问题，也就是某种方案可不可行。\n\n接下来我们通过代码学习如何获得一个有向图的拓扑排序：\n\n\n算法思路#\n\n拓扑排序一定是从入度为0的顶点开始的（假如入度不为0不就是有点要排在它的前面了嘛qwq），所以，我们通过删除点(及由该点出发的所有边)的方法可以不断更新制作拓扑\n排序时当前图的状态，这样的步骤不断执行，直到图中能删的点(入度为0的点)都删光了，我们的程序就执行到了终点。\n\n\n程序实现#\n\n我们还是用链式前向星来存储图\n\n使用队列来记录我们的拓扑序列（说是队列不过其实还是个每次只读末尾的数组啦，也没用到queue容器qwq）\n\n寻找拓扑序列样例代码：\n\n\n\n这时候我们得到了一个序列，其实这个序列无论如何都能得到（空序列也是序列！），所以接下来需要判断一下是否是拓扑序列，同时也就判断出当前的图是不是有向无环图啦。\n\n判断样例代码：\n\n\n\n前面的输入样例是个有向有环图，这里添加一组有向无环图的样例用于学习：\n\n\n\n\n\n完整代码：\n\n\n\n该算法在O(m)的时间内对indegree数组进行初始化，在O(n)时间内对queue进行初始化，后面的部分虽然看起来是两层循环，但实际上是m条边各遍历一次，所\n以时间复杂度只有O(m)而已，所以一共也就O(m+n)的复杂度。还是很友好滴。","routePath":"/posts/algorithm/topo","lang":"","toc":[{"text":"拓扑排序","id":"拓扑排序","depth":2,"charIndex":-1},{"text":"算法思路","id":"算法思路","depth":3,"charIndex":283},{"text":"程序实现","id":"程序实现","depth":3,"charIndex":428}],"domain":"","frontmatter":{"title":"拓扑排序","date":"2024-01-05T06:20:41.000Z","draft":false,"authors":[],"description":"","tags":["图论","拓扑排序"],"categories":["在学算法的日子里"],"series":["算法模板笔记"],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"","featuredImagePreview":"","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":53,"title":"","content":"前言点评：本次题目难度不高\n\n\nA 跳石头#\n\n\n> [NOIP2015 提高组] 跳石头\n> \n> \n> 题目背景\n> \n> NOIP2015 Day2T1\n> \n> \n> 题目描述\n> \n> 一年一度的“跳石头”比赛又要开始了！\n> \n> 这项比赛将在一条笔直的河道中进行，河道中分布着一些巨大岩石。组委会已经选择好了两块岩石作为比赛起点和终点。在起点和终点之间，有 $N$\n> 块岩石（不含起点和终点的岩石）。在比赛过程中，选手们将从起点出发，每一步跳向相邻的岩石，直至到达终点。\n> \n> 为了提高比赛难度，组委会计划移走一些岩石，使得选手们在比赛过程中的最短跳跃距离尽可能长。由于预算限制，组委会至多从起点和终点之间移走 $M$\n> 块岩石（不能移走起点和终点的岩石）。\n> \n> \n> 输入格式\n> \n> 第一行包含三个整数 $L,N,M$，分别表示起点到终点的距离，起点和终点之间的岩石数，以及组委会至多移走的岩石数。保证 $L \\geq 1$ 且 $N\n> \\geq M \\geq 0$。\n> \n> 接下来 $N$ 行，每行一个整数，第 $i$ 行的整数 $D_i,( 0 < D_i < L)$， 表示第 $i$\n> 块岩石与起点的距离。这些岩石按与起点距离从小到大的顺序给出，且不会有两个岩石出现在同一个位置。\n> \n> \n> 输出格式\n> \n> 一个整数，即最短跳跃距离的最大值。\n> \n> \n> 样例 #1\n> \n> \n> 样例输入 #1\n> \n> \n> \n> \n> 样例输出 #1\n> \n> \n> \n> \n> 提示\n> \n> \n> 输入输出样例 1 说明\n> \n> 将与起点距离为 $2$ 和 $14$ 的两个岩石移走后，最短的跳跃距离为 $4$（从与起点距离 $17$ 的岩石跳到距离 $21$ 的岩石，或者从距离\n> $21$ 的岩石跳到终点）。\n> \n> \n> 数据规模与约定\n> \n> 对于 $20%$的数据，$0 \\le M \\le N \\le 10$。\n> \n> 对于 $50%$ 的数据，$0 \\le M \\le N \\le 100$。\n> \n> 对于 $100%$ 的数据，$0 \\le M \\le N \\le 50000,1 \\le L \\le 10^9$。\n\n\n分析#\n\n\n参考代码#\n\n\n\n\nB Secret Sport#\n\n\n> Secret Sport\n> \n> \n> 题面翻译\n> \n> \n> 题目大意\n> \n> A,B 两人玩游戏，游戏规则如下： 整场游戏有多轮，每轮游戏先胜 $X$ 局的人获胜，每场游戏先胜 $Y$ 局的人获胜。\n> \n> 你在场边观看了比赛，但是你忘记了 $X$ 和 $Y$ ，只记得总共比了 $1 \\le n \\le 20$ 局，和每局获胜的人，请判断谁获胜了。如果 A\n> 获胜，输出 A ，如果 B 获胜，输出 B ，如果都有可能，输出 ? 。\n> \n> \n> 题目描述\n> \n> Let's consider a game in which two players, A and B, participate. This game is\n> characterized by two positive integers, $ X $ and $ Y $ .\n> \n> The game consists of sets, and each set consists of plays. In each play,\n> exactly one of the players, either A or B, wins. A set ends exactly when one\n> of the players reaches $ X $ wins in the plays of that set. This player is\n> declared the winner of the set. The players play sets until one of them\n> reaches $ Y $ wins in the sets. After that, the game ends, and this player is\n> declared the winner of the entire game.\n> \n> You have just watched a game but didn't notice who was declared the winner.\n> You remember that during the game, $ n $ plays were played, and you know which\n> player won each play. However, you do not know the values of $ X $ and $ Y $ .\n> Based on the available information, determine who won the entire game — A or\n> B. If there is not enough information to determine the winner, you should also\n> report it.\n> \n> \n> 输入格式\n> \n> Each test contains multiple test cases. The first line contains a single\n> integer $ t $ $ (1 \\leq t \\leq 10^4) $ - the number of test cases. The\n> description of the test cases follows.\n> \n> The first line of each test case contains an integer $ n $ $ (1 \\leq n \\leq\n> 20) $ - the number of plays played during the game.\n> \n> The second line of each test case contains a string $ s $ of length $ n $ ,\n> consisting of characters $ \\texttt{A} $ and $ \\texttt{B} $ . If $ s_i =\n> \\texttt{A} $ , it means that player A won the $ i $ -th play. If $ s_i =\n> \\texttt{B} $ , it means that player B won the $ i $ -th play.\n> \n> It is guaranteed that the given sequence of plays corresponds to at least one\n> valid game scenario, for some values of $ X $ and $ Y $ .\n> \n> \n> 输出格式\n> \n> For each test case, output:\n> \n>  * $ \\texttt{A} $ — if player A is guaranteed to be the winner of the game.\n>  * $ \\texttt{B} $ — if player B is guaranteed to be the winner of the game.\n>  * $ \\texttt{?} $ — if it is impossible to determine the winner of the game.\n> \n> \n> 样例 #1\n> \n> \n> 样例输入 #1\n> \n> \n> \n> \n> 样例输出 #1\n> \n> \n> \n> \n> 提示\n> \n> In the first test case, the game could have been played with parameters $ X =\n> 3 $ , $ Y = 1 $ . The game consisted of $ 1 $ set, in which player A won, as\n> they won the first $ 3 $ plays. In this scenario, player A is the winner. The\n> game could also have been played with parameters $ X = 1 $ , $ Y = 3 $ . It\n> can be shown that there are no such $ X $ and $ Y $ values for which player B\n> would be the winner.\n> \n> In the second test case, player B won all the plays. It can be easily shown\n> that in this case, player B is guaranteed to be the winner of the game.\n> \n> In the fourth test case, the game could have been played with parameters $ X =\n> 3 $ , $ Y = 3 $ :\n> \n>  * In the first set, $ 3 $ plays were played: AAA. Player A is declared the\n>    winner of the set.\n>  * In the second set, $ 3 $ plays were played: AAA. Player A is declared the\n>    winner of the set.\n>  * In the third set, $ 5 $ plays were played: AABBB. Player B is declared the\n>    winner of the set.\n>  * In the fourth set, $ 5 $ plays were played: AABBB. Player B is declared the\n>    winner of the set.\n>  * In the fifth set, $ 4 $ plays were played: BBAB. Player B is declared the\n>    winner of the set.\n> \n> In total, player B was the first player to win $ 3 $ sets. They are declared\n> the winner of the game.\n\n\n分析#\n\n根据题意，其实每次都是赛到出现结果了才结束，所以每次的最后一局的胜负其实就是整场游戏的胜负。\n\n\n参考代码#\n\n\n\n\nC 众数#\n\n\n> [THUPC 2023 初赛] 众数\n> \n> \n> 题目描述\n> \n> 你有若干个 $[1,n]$ 内的正整数：对于 $1 \\le i \\le n$，你有 $a_i$ 个整数 $i$。设 $S = \\sum_{i=1}^n\n> a_i$。\n> \n> 对于一个序列 $p_1,p_2,\\cdots,p_l$，定义其众数 $\\text{maj}(p_1,p_2,\\cdots,p_l)$\n> 为出现次数最多的数。若有多个数出现次数最多，则其中最大的数为其众数。\n> \n> 现在你需要把这 $S$ 个数排成一个序列 $b_1,b_2,\\cdots,b_S$，使得 $\\sum_{i=1}^S\n> \\text{maj}(b_1,b_2,\\cdots,b_i)$ 最大。输出该最大值。\n> \n> \n> 输入格式\n> \n> 第一行一个整数 $n$，表示值域。\n> \n> 接下来一行 $n$ 个正整数 $a_1,a_2,\\cdots,a_n$，表示每种数的个数。\n> \n> \n> 输出格式\n> \n> 输出一行一个正整数表示 $\\sum_{i=1}^S \\text{maj}(b_1,b_2,\\cdots,b_i)$ 的最大值。\n> \n> \n> 样例 #1\n> \n> \n> 样例输入 #1\n> \n> \n> \n> \n> 样例输出 #1\n> \n> \n> \n> \n> 提示\n> \n> 样例解释 1\n> \n> 一个达到最大值的序列为 $(3,2,3,1,2,2)$。\n> \n> 数据范围\n> \n> 对于所有测试数据，$1 \\le n \\leq 10^5$，$1 \\le a_1,a_2,\\cdots,a_n \\le 10^5$。\n> \n> 题目来源\n> \n> 来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）初赛。\n> \n> 题解等资源可在 https://github.com/THUSAAC/THUPC2023-Pre 查看。\n\n\n分析#\n\n贪心，要让较大的数作为众数的次数最多。\n\n构造排列时按照 n~1 的顺序排下去，每次先排列尽量满足上述想法的数。\n\n\n参考代码#\n\n\n\n\nD 大纲#\n\n\n> [THUPC 2023 决赛] 大纲\n> \n> \n> 题目描述\n> \n> 小 I、小 O 和小 N 是 ION 大纲的编写者，小 I 负责给每个知识点定难度。\n> \n> ION 大纲计划列入 $n$ 个知识点，其中小 I 按照自己的认识给其中部分知识点定好了难度，还有部分知识点没有定难度。\n> \n> 知识点之间有依赖关系，这个依赖关系恰好构成了一棵以 $1$ 为根的外向树，知识点 $x$ 指向知识点 $y$ 表示 $x$ 依赖\n> $y$。依赖关系不具有传递性。\n> \n> 你需要告诉小 I 目前确定下来的难度是否合理。我们认为确定下来的难度是合理的当且仅当存在一个给所有未确定难度的知识点确定难度的方式，使得以下所有条件成立：\n> \n>  * 每个知识点的难度都是非负整数；\n>  * 对于每个依赖其他知识点的知识点 $x$，设 $\\max_x$ 为 $x$ 依赖的知识点中难度的最大值，则如果 $x$ 恰依赖一个难度为\n>    $\\max_x$ 的知识点，那么知识点 $x$ 的难度为 $\\max_x$，否则为 $\\max_x+1$。对于不依赖其他知识点的知识点，没有其他限制。\n> \n> \n> 输入格式\n> \n> 本题有多组测试数据。第一行一个整数 $T$ 表示测试数据组数，接下来依次读入每组测试数据。\n> \n> 对于每组测试数据，\n> \n>  * 第一行一个整数 $n$ 表示知识点数量。\n>  * 第二行 $n$ 个整数 $a_1,a_2,\\cdots,a_n$，描述每个知识点的难度。若 $a_i = -1$ 表示知识点 $i$\n>    未确定难度，否则知识点 $i$ 的难度确定为 $a_i$。\n>  * 接下来 $n-1$ 行每行两个整数 $u,v$，表示依赖关系构成的外向树中的一条有向边。\n> \n> \n> 输出格式\n> \n> 对于每组测试数据输出一行：若难度是合理的，输出 Reasonable，否则输出 Unreasonable。\n> \n> \n> 样例 #1\n> \n> \n> 样例输入 #1\n> \n> \n> \n> \n> 样例输出 #1\n> \n> \n> \n> \n> 提示\n> \n> \n> 样例 1 解释\n> \n> 对于第一组测试数据，将知识点 $2$ 的难度定为 $0$ 即满足条件。\n> \n> 对于第二组测试数据，无论如何指定知识点 $2$ 的难度，知识点 $1$ 的难度会产生矛盾。\n> \n> \n> 数据规模与约定\n> \n> 对于所有测试数据，$1 \\le T \\le 10^5$，$2 \\le n \\le 10^5$，$-1 \\le a_i \\le 10^9$，$1 \\le\n> u,v \\le n$。\n> \n> 保证单个测试点中所有测试数据的 $n$ 的和不超过 $2 \\times 10^5$，每组测试数据输入的所有边构成一棵以 $1$ 为根的外向树。\n> \n> \n> 后记\n> \n> 大纲发表了。若干天后，小 I 给 ION 比赛投题，却发现有人偷偷改了一笔难度表，导致他的题目超纲。于是小 I 只能把题投给 CPUHT。\n> \n> \n> 题目来源\n> \n> 来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）决赛。\n> \n> 题解等资源可在 https://github.com/THUSAAC/THUPC2023 查看。\n\n\n分析#\n\n\n参考代码#\n\n\n\n\nE Chip and Ribbon#\n\n\n> Chip and Ribbon\n> \n> \n> 题面翻译\n> \n> 每次可以在一段长度为 $n$，初始值都为 $0$ 的序列中选取一段连续区间，并将区间内所有元素加\n> $1$，求最少操作数使得该序列与题目所给的序列所有元素相同，输出最少操作数减 $1$。\n> \n> \n> 题目描述\n> \n> There is a ribbon divided into $ n $ cells, numbered from $ 1 $ to $ n $ from\n> left to right. Initially, an integer $ 0 $ is written in each cell.\n> \n> Monocarp plays a game with a chip. The game consists of several turns. During\n> the first turn, Monocarp places the chip in the $ 1 $ -st cell of the ribbon.\n> During each turn except for the first turn, Monocarp does exactly one of the\n> two following actions:\n> \n>  * move the chip to the next cell (i. e. if the chip is in the cell $ i $ , it\n>    is moved to the cell $ i+1 $ ). This action is impossible if the chip is in\n>    the last cell;\n>  * choose any cell $ x $ and teleport the chip into that cell. It is possible\n>    to choose the cell where the chip is currently located.\n> \n> At the end of each turn, the integer written in the cell with the chip is\n> increased by $ 1 $ .\n> \n> Monocarp's goal is to make some turns so that the $ 1 $ -st cell contains the\n> integer $ c_1 $ , the $ 2 $ -nd cell contains the integer $ c_2 $ , ..., the $\n> n $ -th cell contains the integer $ c_n $ . He wants to teleport the chip as\n> few times as possible.\n> \n> Help Monocarp calculate the minimum number of times he has to teleport the\n> chip.\n> \n> \n> 输入格式\n> \n> The first line contains one integer $ t $ ( $ 1 \\le t \\le 10^4 $ ) — the\n> number of test cases.\n> \n> Each test case consists of two lines:\n> \n>  * the first line contains one integer $ n $ ( $ 1 \\le n \\le 2 \\cdot 10^5 $ );\n>  * the second line contains $ n $ integers $ c_1, c_2, \\dots, c_n $ ( $ 0 \\le\n>    c_i \\le 10^9 $ ; $ c_1 \\ge 1 $ ).\n> \n> It can be shown that under these constraints, it is always possible to make a\n> finite amount of turns so that the integers in the cells match the sequence $\n> c_1, c_2, \\dots, c_n $ .\n> \n> Additional constraint on the input: the sum of values of $ n $ over all test\n> cases does not exceed $ 2 \\cdot 10^5 $ .\n> \n> \n> 输出格式\n> \n> For each test case, print one integer — the minimum number of times Monocarp\n> has to teleport the chip.\n> \n> \n> 样例 #1\n> \n> \n> 样例输入 #1\n> \n> \n> \n> \n> 样例输出 #1\n> \n> \n> \n> \n> 提示\n> \n> In the first test case of the example, Monocarp can perform the turns as\n> follows:\n> \n>  * place the chip in the $ 1 $ -st cell; the numbers in the cells are $ [1, 0,\n>    0, 0] $ ;\n>  * move the chip to the next ( $ 2 $ -nd) cell; the numbers in the cells are $\n>    [1, 1, 0, 0] $ ;\n>  * move the chip to the next ( $ 3 $ -rd) cell; the numbers in the cells are $\n>    [1, 1, 1, 0] $ ;\n>  * teleport the chip to the $ 2 $ -nd cell; the numbers in the cells are $ [1,\n>    2, 1, 0] $ ;\n>  * move the chip to the next ( $ 3 $ -rd) cell; the numbers in the cells are $\n>    [1, 2, 2, 0] $ ;\n>  * move the chip to the next ( $ 4 $ -th) cell; the numbers in the cells are $\n>    [1, 2, 2, 1] $ .\n\n\n分析#\n\n令连续的下一 cell 内数字加一的操作数是不限的，那么我们的目的就变成了画多少条这样的连续的“线”，能达到最终的目的，示意图如下：\n\n\n\n在代码实现的时候，只要后一位的高度高于前一位，那么就需要增加：后一位高度-前一位高度 这么多的线，参考代码如下：\n\n\n参考代码#\n\n\n\n\nF 着色#\n\n\n> [THUPC 2023 决赛] 着色\n> \n> \n> 题目背景\n> \n> 远古的笔迹，远古的乐音，远古的历史，远古的 $K_{1000}$，若无人问津，便悄然褪色……\n> \n> \n> 题目描述\n> \n> 给出一个 $n$ 个节点的无向完全图，你需要给每条边标上一个 $0 \\sim 9$ 的数字，使得图上不存在一个三元环或五元环满足：其上所有边的数字相同。\n> \n> \n> 输入格式\n> \n> 输入仅一行一个整数 $n$ 表示图的节点数。\n> \n> \n> 输出格式\n> \n> 如果不存在方案，输出一行一个整数 -1。否则输出 $(n-1)$ 行，第 $i$ 行 $(n-i)$ 个字符，第 $i$ 行的第 $j$ 个字符表示\n> $(i,i+j)$ 的标号。若有多个方案，输出任意一个即可。\n> \n> \n> 样例 #1\n> \n> \n> 样例输入 #1\n> \n> \n> \n> \n> 样例输出 #1\n> \n> \n> \n> \n> 提示\n> \n> \n> 数据规模与约定\n> \n> 对于所有测试数据，$2 \\le n \\le 1000$。\n> \n> \n> 题目来源\n> \n> 来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）决赛。\n> \n> 题解等资源可在 https://github.com/THUSAAC/THUPC2023 查看。\n\n\n分析#\n\n\n参考代码#\n\n\n\n\nG Treasure Chest#\n\n\n> Treasure Chest\n> \n> \n> 题面翻译\n> \n> \n> 题目描述\n> \n> 给你一个数轴，一开始你的位置为 $0$，箱子在 $x$ 处，钥匙在 $y$ 处，$x\\neq y$。你需要通过一些操作打开宝箱。\n> \n> 当位置为 $i$ 时，你能执行以下操作：\n> \n>  * 花费 $1$ 秒，走向 $i+1$ 或 $i-1$；\n>  * 花费 $0$ 秒，拿起 $i$ 处的钥匙或箱子，如果此处有的话；\n>  * 花费 $0$ 秒，在 $i$ 处放下箱子；\n>  * 花费 $0$ 秒，打开宝箱，如果箱子在 $i$ 处且你拿着钥匙的话。\n> \n> 另外给出限制：因为箱子很重，所以在整个过程中，扛着箱子的时间不得超过 $k$ 秒（放下再拿起箱子不会使其重置）。\n> \n> 现在给定 $x,y,k$，请问你打开箱子的最短用时为多少？ 每个测试点采用多组数据测试。\n> \n> \n> 输入格式\n> \n> 第一行一个整数 $t\\space(1\\le t\\le 100)$，表示数据组数。\n> \n> 对于每组数据：唯一一行三个整数 $x,y,k\\space(1\\le x,y\\le 100,x\\neq y,0\\le k\\le\n> 100)$，分别表示初始时箱子的位置，钥匙的位置和你扛着箱子的最大时长。\n> \n> \n> 输出格式\n> \n> 共 $t$ 行，第 $i$ 行一个整数表示第 $i$ 组数据的答案。\n> \n> \n> 说明/提示\n> \n> 数据范围与约定\n> \n> $1\\le t\\le 100;\\1\\le x,y\\le 100,x\\neq y;\\1\\le k\\le 100.$\n> \n> 样例解释\n> \n> 对于样例的第 $1$ 组数据，可以通过以下一系列动作在第 $7$ 秒打开箱子。\n> \n>  * 花费 $5$ 秒走到 $5$,\n>  * 花费 $0$ 秒拿起箱子，\n>  * 花费 $2$ 秒走到 $7$，\n>  * 拿起钥匙、放下箱子并打开箱子，共花费 $0$ 秒。\n> \n> 全过程共花费 $7$ 秒，拿着箱子的时间仅有 $2$ 秒，不超过给定的限制 $k=2$。可以证明不存在更优解。\n> \n> 对于样例的第 $2$ 组数据，你可以花费 $5$ 秒走到 $5$ 并捡起钥匙，再花费 $5$ 秒走到 $10$ 并打开箱子。共花费 $10$\n> 秒，其中没有扛过箱子，不超过给定的限制 $k=0$。可以证明不存在更优解。\n> \n> 对于样例的第 $3$ 组数据，你无法像数据 $1$ 那样将箱子直接搬到钥匙处，而必须：\n> \n>  * 花费 $5$ 秒走到 $5$ 并扛起箱子；\n>  * 花费 $2$ 秒走到 $7$；\n>  * 此时你已经力竭，达到了限制 $k=2$，所以必须花费 $0$ 秒在 $7$ 处放下箱子；\n>  * 花费 $1$ 秒走到 $8$ 并捡起钥匙；\n>  * 花费 $1$ 秒再走到 $7$ 并打开箱子。\n> \n> 全过程共花费 $9$ 秒且刚好没有超过限制。可以证明不存在更优解。\n> \n> \n> 题目描述\n> \n> Monocarp has found a treasure map. The map represents the treasure location as\n> an OX axis. Monocarp is at $ 0 $ , the treasure chest is at $ x $ , the key to\n> the chest is at $ y $ .\n> \n> Obviously, Monocarp wants to open the chest. He can perform the following\n> actions:\n> \n>  * go $ 1 $ to the left or $ 1 $ to the right (spending $ 1 $ second);\n>  * pick the key or the chest up if he is in the same point as that object\n>    (spending $ 0 $ seconds);\n>  * put the chest down in his current point (spending $ 0 $ seconds);\n>  * open the chest if he's in the same point as the chest and has picked the\n>    key up (spending $ 0 $ seconds).\n> \n> Monocarp can carry the chest, but the chest is pretty heavy. He knows that he\n> can carry it for at most $ k $ seconds in total (putting it down and picking\n> it back up doesn't reset his stamina).\n> \n> What's the smallest time required for Monocarp to open the chest?\n> \n> \n> 输入格式\n> \n> The first line contains a single integer $ t $ ( $ 1 \\le t \\le 100 $ ) — the\n> number of testcases.\n> \n> The only line of each testcase contains three integers $ x, y $ and $ k $ ( $\n> 1 \\le x, y \\le 100 $ ; $ x \\neq y $ ; $ 0 \\le k \\le 100 $ ) — the initial\n> point of the chest, the point where the key is located, and the maximum time\n> Monocarp can carry the chest for.\n> \n> \n> 输出格式\n> \n> For each testcase, print a single integer — the smallest time required for\n> Monocarp to open the chest.\n> \n> \n> 样例 #1\n> \n> \n> 样例输入 #1\n> \n> \n> \n> \n> 样例输出 #1\n> \n> \n> \n> \n> 提示\n> \n> In the first testcase, Monocarp can open the chest in $ 7 $ seconds with the\n> following sequence of moves:\n> \n>  * go $ 5 $ times to the right ( $ 5 $ seconds);\n>  * pick up the chest ( $ 0 $ seconds);\n>  * go $ 2 $ times to the right ( $ 2 $ seconds);\n>  * pick up the key ( $ 0 $ seconds);\n>  * put the chest down ( $ 0 $ seconds);\n>  * open the chest ( $ 0 $ seconds).\n> \n> He only carries the chest for $ 2 $ seconds, which he has the stamina for.\n> \n> In the second testcase, Monocarp can pick up the key on his way to the chest.\n> \n> In the third testcase, Monocarp can't use the strategy from the first testcase\n> because he would have to carry the chest for $ 3 $ seconds, while he only has\n> the stamina for $ 2 $ seconds. Thus, he carries the chest to $ 7 $ , puts it\n> down, moves $ 1 $ to the right to pick up the key and returns $ 1 $ left to\n> open the chest.\n\n\n分析#\n\n分类讨论，要么在向右移动的时候就能把 key 带到 chest 的位置或者把 chest 带到 key 的位置，要么就把 chest 向右移动 k 个位置(离\nkey 最近)，然后拿 key 再折返回到 chest 位置。\n\n\n参考代码#\n\n\n\n\nH 烂柯杯#\n\n\n> [THUPC 2023 决赛] 烂柯杯\n> \n> \n> 题目背景\n> \n> 却说庞统迤逦前进，抬头见两山逼窄，树木丛杂；又值夏末秋初，枝叶茂盛。庞统心下甚疑，勒住马问：“此处是何地？”数内有新降军士，指道：“此处地名落凤坡。”庞统惊\n> 曰：“吾道号凤雏，此处名落凤坡，不利于吾。”令后军疾退。只听山坡前一声炮响，箭如飞蝗，只望骑白马者射来。可怜庞统竟死于乱箭之下。时年止三十六岁。后人有诗叹曰\n> ：“古岘相连紫翠堆，士元有宅傍山隈。儿童惯识呼鸠曲，闾巷曾闻展骥才。预计三分平刻削，长驱万里独徘徊。谁知天狗流星坠，不使将军衣锦回。”先是东南有童谣云：“一\n> 凤并一龙，相将到蜀中。才到半路里，凤死落坡东。风送雨，雨随风，隆汉兴时蜀道通，蜀道通时只有龙。”\n> \n> ——《三国演义》第六十三回：诸葛亮痛哭庞统 张翼德义释严颜\n> \n> \n> 题目描述\n> \n> $2023$ 年 $5$ 月 $4$ 日 $ \\sim 9$\n> 日，第一届“衢州烂柯杯”世界围棋公开赛本赛第一阶段的赛程在衢州顺利进行。作为疫情后第一场全程线下进行的世界围棋大赛，也是目前中国主办的唯一一项每年一届的世界\n> 围棋大赛，无疑引起了国内外广大围棋爱好者的广泛关注。\n> \n> “羽客一枰无复见，青山留得烂柯名。”衢州是围棋圣地，流传着“王质遇仙”的故事，境内的烂柯山也因此闻名于天下。正因为此，“烂柯”也是围棋的别称之一，从古至今的\n> 许多围棋故事、书籍、弈谱等，也有不少化用了“烂柯”的典故，或以“烂柯”定名。\n> \n> 此次“烂柯杯”世界围棋大赛，是在保留原有的“烂柯杯”中国围棋冠军赛的基础上，创办的一项崭新的世界性围棋赛事，吸引了全世界围棋高手前来参加。其中，中国队派出了\n> 柯洁、辜梓豪、王星昊、丁浩、李钦诚等 $15$ 员大将参赛，韩国队 $8$ 人，日本队 $5$ 人，还有 $2$ 位棋手来自中国台湾、 $2$\n> 位棋手来自欧美地区。可以说，全世界最顶尖的围棋高手悉数相聚于此。\n> \n> 随着科技的发展，人工智能的巨大技术进步和网络传媒的全面普及，围棋这项来自中国的传统运动正在焕发出新的活力。在网络上，人们随时可以看到最新的赛事直播，以及人工\n> 智能的精准分析和各大围棋高手的细致解读。资源获取的便捷性使得人们对围棋的关注度空前上升，围棋不再是只有少部分懂棋的爱好者才能欣赏的“小众游戏”；围棋高手也不\n> 再只是一个神秘的身份，越来越多的围棋高手开始在网络上与棋迷近距离互动，普及围棋知识，讲解最新对局，赢得了一致好评。正如这次参赛的选手中，有一位棋手同时也是粉\n> 丝数达 $150$ 多万的网红主播，甚至还有一位棋手是一家网红餐厅的老板。\n> \n> 我们今天故事的主角正是这样一位有着传奇色彩的人物。作为一名清华大学本科在读的学生，同时也是一名顶尖围棋高手，他的一举一动无疑都会引起巨大的关注。此次他参加“\n> 烂柯杯”比赛，众人无一例外看好他的比赛前景，尤其是现在韩国围棋”第一人“申真谞九段的巅峰时期，他也被无数中国棋迷寄托以”狙击‘小申’“的重任。$5$ 月\n> $4$ 日抽签过后，没有任何人会怀疑他能不能赢下 $5$ 日的第一轮比赛，一些围棋高手更是直接放出了”大胜，不可能失败“的预言。\n> \n> 然而，$5$ 月 $5$ 日的比赛还是爆出了惊天大冷门。他在已经胜券在握，AI 胜率达到 $99%$\n> 的关头，接连选择了“弹幕最多的下法”，最终因为几招致命的失误葬送好局，落败于中国台湾棋手赖均辅八段。赛后，人们在震惊的同时，纷纷猜测本局失利的原因。有人说，\n> 他的状态低迷在前些年早已有所体现，“当你在 XX 的时候，小申在下棋”成了调侃他与申真谞战绩差距的一句名言；有人说，他在比赛之前的 $12$\n> 连胜战绩反而使他心态紧张，从而犯了优势下容易大意的老毛病；也有人拿出了“落凤坡”的典故，以证明他或许命中注定与“烂柯杯”八字不合……但或许，这样的变幻莫测和\n> 不可预料性，正是围棋的魅力所在。\n> \n> 请你根据以上所有信息，猜测本文的主角是谁。\n> \n> \n> 输入格式\n> \n> 无输入。\n> \n> \n> 输出格式\n> \n> 输出一个由小写字母组成的字符串，表示上文中提到的主角的名字全拼。如若答案是马云，应当输出 mayun。\n> \n> \n> 提示\n> \n> \n> 提示\n> \n> 主角的名字在题面中已经有所提及。\n> \n> 题面中一些看似无厘头的信息实际上是有价值的。\n> \n> \n> 题目来源\n> \n> 来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）决赛。\n> \n> 题解等资源可在 https://github.com/THUSAAC/THUPC2023 查看。\n\n\n分析#\n\n是签到题，输出\"kejie\"即可。\n\n\n参考代码#\n\n\n\n\nI 总投票数#\n\n\n> [THUPC 2023 决赛] 总投票数\n> \n> \n> 题目背景\n> \n> 各位亲爱的《La Lumière: Scarlet Intense Flame - Adventurous Scarlet -》玩家：\n> \n> 非常荣幸能与您携手度过了这四年的美好时光，衷心感谢大家的支持与陪伴！\n> \n> 现在，我们非常遗憾的宣布，《La Lumière: Scarlet Intense Flame - Adventurous Scarlet -》将于\n> 2023 年 5 月 28 日 15:00 停止运营服务。\n> \n> 停止运营相关时间表如下：\n> \n> ……\n> \n> \n> 题目描述\n> \n> 在关服前，运营发起了一系列投票，调查哪些游戏内容给玩家带来了更深的印象。\n> \n> 作为系列的忠实玩家，你想知道有多少人参加了关服前的投票，但是运营只公开了最终的投票结果：对于一项包含 $N$ 个选项的投票，选择第 $i$\n> 个选项的玩家比例为 $P_i$（$1\\le i\\le N$）。运营在公布结果时进行了四舍五入，所有的 $P_i$ 仅保留到小数点后第 $L$ 位。假设实际有\n> $K$ 位玩家参加了投票，其中有 $D_i$ 位玩家选择了第 $i$ 个选项，则应该有\n> \n> $$ P_i-\\frac{1}{2}\\times 10^{-L}\\le\\frac{D_i}{K}< P_i+\\frac{1}{2}\\times\n> 10^{-L} $$\n> \n> 显然，所有的 $D_i$ 必须是非负整数，而 $K=\\sum_{i=1}^N D_i$ 则必须是正整数。现在，给定 $N$ 和 $P_i$，请你求出满足\n> $D_i$ 有非负整数解的最小的总投票数 $K$。\n> \n> \n> 输入格式\n> \n> 输入的第一行包含一个正整数 $N$，表示投票的选项总数。保证 $1\\le N\\le 100$。\n> \n> 接下来 $N$ 行，每行包括一个 $[0, 1]$ 中的实数 $P_i$，表示选择第 $i$ 个选项的玩家比例。保证 $\\sum_{i=1}^N P_i\n> =1$，所有 $P_i$ 均保留到小数点后第 $L$ 位，且 $1\\le L\\le 6$。\n> \n> \n> 输出格式\n> \n> 输出一个正整数，表示满足要求的最小总投票数 $K$。\n> \n> \n> 样例 #1\n> \n> \n> 样例输入 #1\n> \n> \n> \n> \n> 样例输出 #1\n> \n> \n> \n> \n> 样例 #2\n> \n> \n> 样例输入 #2\n> \n> \n> \n> \n> 样例输出 #2\n> \n> \n> \n> \n> 样例 #3\n> \n> \n> 样例输入 #3\n> \n> \n> \n> \n> 样例输出 #3\n> \n> \n> \n> \n> 提示\n> \n> 【样例解释 #1】\n> \n> 最小的总投票数为 $6$，对应每个选项的投票数为 $1, 2, 3$。\n> \n> 【样例解释 #2】\n> \n> 最小的总投票数为 $73$，对应每个选项的投票数为 $3, 8, 8, 12, 22, 5, 15$。\n> \n> 【样例解释 #3】\n> \n> 最小的总投票数为 $7766$，对应每个选项的投票数为 $12, 301, 123, 403, 629, 530, 1216, 808, 205,\n> 1113, 1005, 1206, 215$。\n> \n> 【数据范围】\n> \n> 对于所有测试数据，$1\\le N\\le 100$，$0\\le P_i\\le 1$，$\\sum_{i=1}^N P_i=1$，且 $P_i$\n> 最多统一保留到小数点后 $6$ 位。\n> \n> 【题目来源】\n> \n> 来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）决赛。\n> \n> 题解等资源可在 https://github.com/THUSAAC/THUPC2023 查看。\n\n\n分析#\n\n\n参考代码#\n\n\n\n\nJ Points and Minimum Distance#\n\n\n> Points and Minimum Distance\n> \n> \n> 题面翻译\n> \n> 给定长度为 $2n$ 的序列 $a$，你需要把这些数分为 $n$ 对，得到 $n$ 个坐标轴上的点。$a$ 中的每个数都要是某一个点的 $x$ 或 $y$\n> 坐标。注意有些点可能会重合。\n> \n> 之后，你可以选择从一个点出发，选择一条路径走过所有 $n$ 个点至少一次，在某个点处停下。\n> \n> 你需要求出路径总长度的最小值。本题中两点间距离为曼哈顿距离，即 $(x_1,y_1)$ 和 $(x_2,y_2)$ 间距离为\n> $|x_1-x_2|+|y_1-y_2|$。\n> \n> \n> 题目描述\n> \n> You are given a sequence of integers $ a $ of length $ 2n $ . You have to\n> split these $ 2n $ integers into $ n $ pairs; each pair will represent the\n> coordinates of a point on a plane. Each number from the sequence $ a $ should\n> become the $ x $ or $ y $ coordinate of exactly one point. Note that some\n> points can be equal.\n> \n> After the points are formed, you have to choose a path $ s $ that starts from\n> one of these points, ends at one of these points, and visits all $ n $ points\n> at least once.\n> \n> The length of path $ s $ is the sum of distances between all adjacent points\n> on the path. In this problem, the distance between two points $ (x_1, y_1) $\n> and $ (x_2, y_2) $ is defined as $ |x_1-x_2| + |y_1-y_2| $ .\n> \n> Your task is to form $ n $ points and choose a path $ s $ in such a way that\n> the length of path $ s $ is minimized.\n> \n> \n> 输入格式\n> \n> The first line contains a single integer $ t $ ( $ 1 \\le t \\le 100 $ ) — the\n> number of testcases.\n> \n> The first line of each testcase contains a single integer $ n $ ( $ 2 \\le n\n> \\le 100 $ ) — the number of points to be formed.\n> \n> The next line contains $ 2n $ integers $ a1, a_2, \\dots, a{2n} $ ( $ 0 \\le a_i\n> \\le 1,000 $ ) — the description of the sequence $ a $ .\n> \n> \n> 输出格式\n> \n> For each testcase, print the minimum possible length of path $ s $ in the\n> first line.\n> \n> In the $ i $ -th of the following $ n $ lines, print two integers $ x_i $ and\n> $ y_i $ — the coordinates of the point that needs to be visited at the $ i $\n> -th position.\n> \n> If there are multiple answers, print any of them.\n> \n> \n> 样例 #1\n> \n> \n> 样例输入 #1\n> \n> \n> \n> \n> 样例输出 #1\n> \n> \n> \n> \n> 提示\n> \n> In the first testcase, for instance, you can form points $ (10, 1) $ and $\n> (15, 5) $ and start the path $ s $ from the first point and end it at the\n> second point. Then the length of the path will be $ |10 - 15| + |1 - 5| = 5 +\n> 4 = 9 $ .\n> \n> In the second testcase, you can form points $ (20, 20) $ , $ (10, 30) $ , and\n> $ (10, 30) $ , and visit them in that exact order. Then the length of the path\n> will be $ |20 - 10| + |20 - 30| + |10 - 10| + |30 - 30| = 10 + 10 + 0 + 0 = 20\n> $ .\n\n\n分析#\n\n构造题，根据题意可以推断，ans 只分别与 x 集合的差值和、y 集合差值和有关。显然，（大数-小数）+（大数-小数）的结果劣于（大数-大数）+（小数-小数）。\n\n故此题，在进行排列后按序先分配 x 再分配 y，直接统计 x 有序集合与 y 有序集合的差值即可（注意结果除去 x，y 交界的一对差）。\n\n\n参考代码#\n\n\n\n\nK 速战速决#\n\n\n> [THUPC 2023 初赛] 速战速决\n> \n> \n> 题目描述\n> \n> 小 I 与小 J 正在玩一个叫做“开火车”，又称作“拖板车”和“小猫钓鱼”的扑克游戏。游戏规则如下，注意其与一般玩法可能有不同：\n> \n>  * 有 $2n$ 张牌，其中对于整数 $1 \\le i \\le n$，牌面为 $i$ 的牌恰好有 $2$ 张。\n>  * 游戏开始时，小 I 和小 J 各拿其中 $n$ 张牌组成双方的初始手牌。\n>  * 维护一个公共牌堆（可以将其看作一个栈），初始没有牌。小 I 与小 J 依次行动，小 I 先手。一次行动时，行动方依次进行以下操作：\n>    1. 将手牌中的一张牌放在公共牌堆顶；\n>    2. 若此时公共牌堆中有两张相同的牌，则这两张相同的牌以及在这两张牌之间的所有牌从公共牌堆移到当前行动方手牌中；\n>    3. 若此时当前行动方没有手牌，则当前行动方失败，另一方胜利。\n> \n> 小 J 是扑克萌新，所以会按照以下策略行动：\n> \n>  * 维护一个队列，初始将 $n$ 张手牌按照一定顺序放入队列中；\n>  * 每次行动时，将队列开头的牌放在公共牌堆顶；\n>  * 若小 J 放入某张牌后公共牌堆中有两张相同的牌，则按照在公共牌堆中自顶到底的顺序将获得的牌放入队列尾。\n> \n> 小 I 通过偷看得到了小 J 的策略以及队列中牌的顺序。现在小 I 不仅想获胜，还想速战速决，用最少的行动次数获胜，但他也是扑克萌新。所以给定小 J\n> 队列中的 $n$ 张牌以及它们的顺序，你需要给出小 I 的策略，使得小 I 能够获胜，同时行动次数最少，或者告诉他这是不可能的。\n> \n> \n> 输入格式\n> \n> 每组数据的第一行一个整数 $n$ 表示牌面的种数。\n> \n> 第二行 $n$ 个整数 $a_1,a_2,\\cdots,a_n$，从队头到队尾的顺序依次描述小 J 队列中的牌。\n> \n> 得到小 J 的 $n$ 张手牌也就得到了小 I 的 $n$ 张手牌，因此不会输入小 I 的手牌。\n> \n> \n> 输出格式\n> \n> 如果小 I 不可能获胜，只需要输出一个整数 -1；否则第一行输出一个整数 $s$，表示你给出的策略中小 I 的行动次数。接下来一行 $s$\n> 个整数，依次描述每次行动时小 I 从手牌中放入公共牌堆的牌的牌面，两个数之间以一个空格分隔。注意你给出的策略要满足 $s$ 最小。\n> \n> \n> 样例 #1\n> \n> \n> 样例输入 #1\n> \n> \n> \n> \n> 样例输出 #1\n> \n> \n> \n> \n> 样例 #2\n> \n> \n> 样例输入 #2\n> \n> \n> \n> \n> 样例输出 #2\n> \n> \n> \n> \n> 提示\n> \n> 样例解释 1\n> \n> \n> \n> \n> \n> 子任务\n> \n> 对于所有测试数据，$1 \\le n \\le 3 \\times 10^5$，$1 \\le a_1,a_2,\\cdots, a_n \\le\n> n$，且每个整数在序列 $a$ 中至多出现两次。\n> \n> 题目来源\n> \n> 来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）初赛。\n> \n> 题解等资源可在 https://github.com/THUSAAC/THUPC2023-Pre 查看。\n\n\n分析#\n\n\n参考代码#\n\n\n\n\nL 滑雪#\n\n\n> [SHOI2002] 滑雪\n> \n> \n> 题目描述\n> \n> Michael\n> 喜欢滑雪。这并不奇怪，因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael\n> 想知道在一个区域中最长的滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子：\n> \n> \n> \n> 一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度会减小。在上面的例子中，一条可行的滑坡为 $24-17-16-1$（从 $24$ 开始，在 $1$\n> 结束）。当然 $25$－$24$－$23$－$\\ldots$－$3$－$2$－$1$ 更长。事实上，这是最长的一条。\n> \n> \n> 输入格式\n> \n> 输入的第一行为表示区域的二维数组的行数 $R$ 和列数 $C$。下面是 $R$ 行，每行有 $C$ 个数，代表高度(两个数字之间用 $1$ 个空格间隔)。\n> \n> \n> 输出格式\n> \n> 输出区域中最长滑坡的长度。\n> \n> \n> 样例 #1\n> \n> \n> 样例输入 #1\n> \n> \n> \n> \n> 样例输出 #1\n> \n> \n> \n> \n> 提示\n> \n> 对于 $100%$ 的数据，$1\\leq R,C\\leq 100$。\n\n\n分析#\n\n优先队列+线性 dp\n\n优先队列内排序按照高度从小到大，依次取出队首的点（高度最低的点），记为 pos，更新从低处到 pos 的最长路径。\n\n状态转移：\n\n$$ dp[xi][yi]=max(dp[xi][yi],dp[xi+1][yi]+1) $$\n\n同时记录最长的路径即可。\n\n\n参考代码#\n\n\n\n\nM Two Out of Three#\n\n\n> Two Out of Three\n> \n> \n> 题面翻译\n> \n> \n> 题目描述\n> \n> 给定一个数组 $a_1, a_2, ..., a_n$。你需要找到一个数组 $b_1$, $b_2$, ..., $b_n$，其中包含数字 $1, 2,\n> 3$，使得以下三个条件中恰好有两个条件被满足：\n> \n>  * 存在 $1\\le i, j\\le n$，使得 $a_i=a_j,b_i=1,b_j=2$。\n>  * 存在 $1\\le i, j\\le n$，使得 $a_i=a_j,b_i=1,b_j=3$。\n>  * 存在 $1\\le i, j\\le n$，使得 $a_i=a_j,b_i=2,b_j=3$。\n> \n> 如果不存在这样的数组 $b$，请报告不可以。\n> \n> \n> 输入格式\n> \n> 每个测试点多测。第一行输入一个整数 $t$，表示数据组数。对于每一组数据：\n> \n> 第一行输入一个整数 $n$ $(1\\le n\\le 100)$，表示数组 $a$ 的长度。\n> \n> 第二行读入 $n$ 个整数 $a_1,a_2,...,a_n$ $(1\\le a_i\\le 100)$，代表数组 $a$。\n> \n> \n> 输出格式\n> \n> 对于每组数据输出一行。若无解，则输出 -1。否则输出一个由 $1,2,3$ 组成的数组 $b$，恰好满足两条性质。如果有多个合法数组，输出任一即可。\n> \n> \n> 说明/提示\n> \n> 第一个数组 $a$，合法数组可以是 $b=[1,2,3,1,1,1]$。当 $i = 4,j = 2$ 时，满足性质一。当$i = 6,j = 3$\n> 时满足性质二。数组 $b$ 无法满足性质三，所以恰好满足两条，合法。\n> \n> \n> 题目描述\n> \n> You are given an array $ a_1, a_2, \\ldots, a_n $ . You need to find an array $\n> b_1, b_2, \\ldots, b_n $ consisting of numbers $ 1 $ , $ 2 $ , $ 3 $ such that\n> exactly two out of the following three conditions are satisfied:\n> \n>  1. There exist indices $ 1 \\leq i, j \\leq n $ such that $ a_i = a_j $ , $ b_i\n>     = 1 $ , $ b_j = 2 $ .\n>  2. There exist indices $ 1 \\leq i, j \\leq n $ such that $ a_i = a_j $ , $ b_i\n>     = 1 $ , $ b_j = 3 $ .\n>  3. There exist indices $ 1 \\leq i, j \\leq n $ such that $ a_i = a_j $ , $ b_i\n>     = 2 $ , $ b_j = 3 $ .\n> \n> If such an array does not exist, you should report it.\n> \n> \n> 输入格式\n> \n> Each test contains multiple test cases. The first line contains a single\n> integer $ t $ $ (1 \\leq t \\leq 500) $ — the number of test cases. Each test\n> case is described as follows.\n> \n> The first line of each test case contains an integer $ n $ $ (1 \\leq n \\leq\n> 100) $ — the length of the array $ a $ .\n> \n> The second line of each test case contains $ n $ integers $ a_1, a_2, \\ldots,\n> a_n $ $ (1 \\leq a_i \\leq 100) $ — the elements of the array $ a $ .\n> \n> \n> 输出格式\n> \n> For each test case, print -1 if there is no solution. Otherwise, print $ b_1,\n> b_2, \\ldots, b_n $ — an array consisting of numbers $ 1 $ , $ 2 $ , $ 3 $ that\n> satisfies exactly two out of three conditions. If there are multiple possible\n> answers, you can print any of them.\n> \n> \n> 样例 #1\n> \n> \n> 样例输入 #1\n> \n> \n> \n> \n> 样例输出 #1\n> \n> \n> \n> \n> 提示\n> \n> In the first test case, $ b = [1, 2, 3, 1, 1, 1] $ satisfies condition $ 1 $\n> because for $ i = 4 $ , $ j = 2 $ : $ a_i = a_j $ , $ b_i = 1 $ , and $ b_j =\n> 2 $ . It also satisfies condition $ 2 $ because for $ i = 6 $ , $ j = 3 $ : $\n> a_i = a_j $ , $ b_i = 1 $ , and $ b_j = 3 $ . However, it does not satisfy\n> condition $ 3 $ . In total, exactly two out of three conditions are satisfied.\n\n\n分析#\n\n构造题，根据分析，只有当数量超过 2 个的数的种数大于等于 2，才有可能构造出符合要求的 b 数组。\n\n\n参考代码#\n\n","routePath":"/posts/algorithm/training0","lang":"","toc":[{"text":"A 跳石头","id":"a-跳石头","depth":2,"charIndex":15},{"text":"分析","id":"分析","depth":3,"charIndex":953},{"text":"参考代码","id":"参考代码","depth":3,"charIndex":959},{"text":"B Secret Sport","id":"b-secret-sport","depth":2,"charIndex":969},{"text":"分析","id":"分析-1","depth":3,"charIndex":4659},{"text":"参考代码","id":"参考代码-1","depth":3,"charIndex":4713},{"text":"C 众数","id":"c-众数","depth":2,"charIndex":4723},{"text":"分析","id":"分析-2","depth":3,"charIndex":5553},{"text":"参考代码","id":"参考代码-2","depth":3,"charIndex":5617},{"text":"D 大纲","id":"d-大纲","depth":2,"charIndex":5627},{"text":"分析","id":"分析-3","depth":3,"charIndex":7035},{"text":"参考代码","id":"参考代码-3","depth":3,"charIndex":7041},{"text":"E Chip and Ribbon","id":"e-chip-and-ribbon","depth":2,"charIndex":7051},{"text":"分析","id":"分析-4","depth":3,"charIndex":9989},{"text":"参考代码","id":"参考代码-4","depth":3,"charIndex":10123},{"text":"F 着色","id":"f-着色","depth":2,"charIndex":10133},{"text":"分析","id":"分析-5","depth":3,"charIndex":10723},{"text":"参考代码","id":"参考代码-5","depth":3,"charIndex":10729},{"text":"G Treasure Chest","id":"g-treasure-chest","depth":2,"charIndex":10739},{"text":"分析","id":"分析-6","depth":3,"charIndex":14433},{"text":"参考代码","id":"参考代码-6","depth":3,"charIndex":14552},{"text":"H 烂柯杯","id":"h-烂柯杯","depth":2,"charIndex":14562},{"text":"分析","id":"分析-7","depth":3,"charIndex":16548},{"text":"参考代码","id":"参考代码-7","depth":3,"charIndex":16573},{"text":"I 总投票数","id":"i-总投票数","depth":2,"charIndex":16583},{"text":"分析","id":"分析-8","depth":3,"charIndex":18233},{"text":"参考代码","id":"参考代码-8","depth":3,"charIndex":18239},{"text":"J Points and Minimum Distance","id":"j-points-and-minimum-distance","depth":2,"charIndex":18249},{"text":"分析","id":"分析-9","depth":3,"charIndex":20745},{"text":"参考代码","id":"参考代码-9","depth":3,"charIndex":20903},{"text":"K 速战速决","id":"k-速战速决","depth":2,"charIndex":20913},{"text":"分析","id":"分析-10","depth":3,"charIndex":22318},{"text":"参考代码","id":"参考代码-10","depth":3,"charIndex":22324},{"text":"L 滑雪","id":"l-滑雪","depth":2,"charIndex":22334},{"text":"分析","id":"分析-11","depth":3,"charIndex":22906},{"text":"参考代码","id":"参考代码-11","depth":3,"charIndex":23053},{"text":"M Two Out of Three","id":"m-two-out-of-three","depth":2,"charIndex":23063},{"text":"分析","id":"分析-12","depth":3,"charIndex":25698},{"text":"参考代码","id":"参考代码-12","depth":3,"charIndex":25756}],"domain":"","frontmatter":{},"version":""},{"id":54,"title":"","content":"👾树形动态规划#\n\n==树形动态规划，即在树上进行的动态规划。==\n\n==因为树的递归性质，树形动态规划一般都是递归求解的。==\n\n\n🫐[P1352]没有上司的舞会#\n\n\n> 没有上司的舞会\n> \n> \n> 题目描述\n> \n> 某大学有 $n$ 个职员，编号为 $1\\ldots n$。\n> \n> 他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树，父结点就是子结点的直接上司。\n> \n> 现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数\n> $r_i$，但是呢，如果某个职员的直接上司来参加舞会了，那么这个职员就无论如何也不肯来参加舞会了。\n> \n> 所以，请你编程计算，邀请哪些职员可以使快乐指数最大，求最大的快乐指数。\n> \n> \n> 输入格式\n> \n> 输入的第一行是一个整数 $n$。\n> \n> 第 $2$ 到第 $(n + 1)$ 行，每行一个整数，第 $(i+1)$ 行的整数表示 $i$ 号职员的快乐指数 $r_i$。\n> \n> 第 $(n + 2)$ 到第 $2n$ 行，每行输入一对整数 $l, k$，代表 $k$ 是 $l$ 的直接上司。\n> \n> \n> 输出格式\n> \n> 输出一行一个整数代表最大的快乐指数。\n> \n> \n> 样例 #1\n> \n> \n> 样例输入 #1\n> \n> \n> \n> \n> 样例输出 #1\n> \n> \n> \n> \n> 提示\n> \n> 数据规模与约定\n> \n> 对于 $100%$ 的数据，保证 $1\\leq n \\leq 6 \\times 10^3$，$-128 \\leq r_i\\leq 127$，$1 \\leq\n> l, k \\leq n$，且给出的关系一定是一棵树。\n\n\n🫐[P1040]加分二叉树#\n\n\n> [NOIP2003 提高组] 加分二叉树\n> \n> \n> 题目描述\n> \n> 设一个 $n$ 个节点的二叉树 $\\text{tree}$ 的中序遍历为$(1,2,3,\\ldots,n)$，其中数字 $1,2,3,\\ldots,n$\n> 为节点编号。每个节点都有一个分数（均为正整数），记第 $i$ 个节点的分数为 $d_i$，$\\text{tree}$ 及它的每个子树都有一个加分，任一棵子树\n> $\\text{subtree}$（也包含 $\\text{tree}$ 本身）的加分计算方法如下：\n> \n> $\\text{subtree}$ 的左子树的加分 $\\times$ $\\text{subtree}$ 的右子树的加分 $+$\n> $\\text{subtree}$ 的根的分数。\n> \n> 若某个子树为空，规定其加分为 $1$，叶子的加分就是叶节点本身的分数。不考虑它的空子树。\n> \n> 试求一棵符合中序遍历为 $(1,2,3,\\ldots,n)$ 且加分最高的二叉树 $\\text{tree}$。要求输出\n> \n>  1. $\\text{tree}$ 的最高加分。\n> \n>  2. $\\text{tree}$ 的前序遍历。\n> \n> \n> 输入格式\n> \n> 第 $1$ 行 $1$ 个整数 $n$，为节点个数。\n> \n> 第 $2$ 行 $n$ 个用空格隔开的整数，为每个节点的分数\n> \n> \n> 输出格式\n> \n> 第 $1$ 行 $1$ 个整数，为最高加分（$ Ans \\le 4,000,000,000$）。\n> \n> 第 $2$ 行 $n$ 个用空格隔开的整数，为该树的前序遍历。\n> \n> \n> 样例 #1\n> \n> \n> 样例输入 #1\n> \n> \n> \n> \n> 样例输出 #1\n> \n> \n> \n> \n> 提示\n> \n> \n> 数据规模与约定\n> \n> 对于全部的测试点，保证 $1 \\leq n< 30$，节点的分数是小于 $100$ 的正整数，答案不超过 $4 \\times 10^9$。\n\n\n🫐[P1122]最大子树和#\n\n\n> 最大子树和\n> \n> \n> 题目描述\n> \n> 小明对数学饱有兴趣，并且是个勤奋好学的学生，总是在课后留在教室向老师请教一些问题。一天他早晨骑车去上课，路上见到一个老伯正在修剪花花草草，顿时想到了一个有关\n> 修剪花卉的问题。于是当日课后，小明就向老师提出了这个问题：\n> \n> 一株奇怪的花卉，上面共连有 $N$ 朵花，共有 $N-1$\n> 条枝干将花儿连在一起，并且未修剪时每朵花都不是孤立的。每朵花都有一个“美丽指数”，该数越大说明这朵花越漂亮，也有“美丽指数”为负数的，说明这朵花看着都让人恶\n> 心。所谓“修剪”，意为：去掉其中的一条枝条，这样一株花就成了两株，扔掉其中一株。经过一系列“修剪“之后，还剩下最后一株花（也可能是一朵）。老师的任务就是：通\n> 过一系列“修剪”（也可以什么“修剪”都不进行），使剩下的那株（那朵）花卉上所有花朵的“美丽指数”之和最大。\n> \n> 老师想了一会儿，给出了正解。小明见问题被轻易攻破，相当不爽，于是又拿来问你。\n> \n> \n> 输入格式\n> \n> 第一行一个整数 $n\\ (1\\le N\\le 16000)$。表示原始的那株花卉上共 $n$ 朵花。\n> \n> 第二行有 $n$ 个整数，第 $i$ 个整数表示第 $i$ 朵花的美丽指数。\n> \n> 接下来 $n-1$ 行每行两个整数 $a,b$，表示存在一条连接第 $a$ 朵花和第 $b$ 朵花的枝条。\n> \n> \n> 输出格式\n> \n> 一个数，表示一系列“修剪”之后所能得到的“美丽指数”之和的最大值。保证绝对值不超过 $2147483647$。\n> \n> \n> 样例 #1\n> \n> \n> 样例输入 #1\n> \n> \n> \n> \n> 样例输出 #1\n> \n> \n> \n> \n> 提示\n> \n> \n> 数据范围及约定\n> \n>  * 对于 $60%$ 的数据，有 $1\\le N\\le 1000$；\n>  * 对于 $100%$ 的数据，有 $1\\le N\\le 16000$。\n\n\n🫐[P1273]有线电视网#\n\n\n> 有线电视网\n> \n> \n> 题目描述\n> \n> 某收费有线电视网计划转播一场重要的足球比赛。他们的转播网和用户终端构成一棵树状结构，这棵树的根结点位于足球比赛的现场，树叶为各个用户终端，其他中转站为该树的\n> 内部节点。\n> \n> 从转播站到转播站以及从转播站到所有用户终端的信号传输费用都是已知的，一场转播的总费用等于传输信号的费用总和。\n> \n> 现在每个用户都准备了一笔费用想观看这场精彩的足球比赛，有线电视网有权决定给哪些用户提供信号而不给哪些用户提供信号。\n> \n> 写一个程序找出一个方案使得有线电视网在不亏本的情况下使观看转播的用户尽可能多。\n> \n> \n> 输入格式\n> \n> 输入文件的第一行包含两个用空格隔开的整数 $N$ 和 $M$，其中 $2 \\le N \\le 3000$，$1 \\le M \\le N-1$，$N$\n> 为整个有线电视网的结点总数，$M$ 为用户终端的数量。\n> \n> 第一个转播站即树的根结点编号为 $1$，其他的转播站编号为 $2$ 到 $N-M$，用户终端编号为 $N-M+1$ 到 $N$。\n> \n> 接下来的 $N-M$ 行每行表示—个转播站的数据，第 $i+1$ 行表示第 $i$ 个转播站的数据，其格式如下：\n> \n> $K \\ \\ A_1 \\ \\ C_1 \\ \\ A_2 \\ \\ C_2 \\ \\ \\ldots \\ \\ A_k \\ \\ C_k$\n> \n> $K$ 表示该转播站下接 $K$ 个结点（转播站或用户），每个结点对应一对整数 $A$ 与 $C$ ，$A$ 表示结点编号，$C$\n> 表示从当前转播站传输信号到结点 $A$ 的费用。最后一行依次表示所有用户为观看比赛而准备支付的钱数。单次传输成本和用户愿意交的费用均不超过 10。\n> \n> \n> \n> \n> 输出格式\n> \n> 输出文件仅一行，包含一个整数，表示上述问题所要求的最大用户数。\n> \n> \n> 样例 #1\n> \n> \n> 样例输入 #1\n> \n> \n> \n> \n> 样例输出 #1\n> \n> \n> \n> \n> 提示\n> \n> 样例解释\n> \n> \n> \n> 如图所示，共有五个结点。结点 ① 为根结点，即现场直播站，② 为一个中转站，③④⑤ 为用户端，共 $M$ 个，编号从 $N-M+1$ 到\n> $N$，他们为观看比赛分别准备的钱数为 $3$、$4$、$2$。\n> \n> 从结点 ① 可以传送信号到结点 ②，费用为 $2$；\n> \n> 也可以传送信号到结点 ⑤，费用为 $3$（第二行数据所示）；\n> \n> 从结点 ② 可以传输信号到结点 ③，费用为$2$；\n> \n> 也可传输信号到结点 ④，费用为 $3$（第三行数据所示）。\n> \n> 如果要让所有用户（③④⑤）都能看上比赛，则信号传输的总费用为：$2+3+2+3=10$，大于用户愿意支付的总费用\n> $3+4+2=9$，有线电视网就亏本了，而只让 ③④ 两个用户看比赛就不亏本了。\n\n\n🫐[P2014]选课#\n\n\n> [CTSC1997] 选课\n> \n> \n> 题目描述\n> \n> 在大学里每个学生，为了达到一定的学分，必须从很多课程里选择一些课程来学习，在课程里有些课程必须在某些课程之前学习，如高等数学总是在其它课程之前学习。现在有\n> $N$ 门功课，每门课有个学分，每门课有一门或没有直接先修课（若课程 a 是课程 b 的先修课即只有学完了课程 a，才能学习课程\n> b）。一个学生要从这些课程里选择 $M$ 门课程学习，问他能获得的最大学分是多少？\n> \n> \n> 输入格式\n> \n> 第一行有两个整数 $N$ , $M$ 用空格隔开。( $1 \\leq N \\leq 300$ , $1 \\leq M \\leq 300$ )\n> \n> 接下来的 $N$ 行,第 $I+1$ 行包含两个整数 $k_i $和 $s_i$, $k_i$ 表示第I门课的直接先修课，$s_i$ 表示第I门课的学分。若\n> $k_i=0$ 表示没有直接先修课（$1 \\leq {k_i} \\leq N$ , $1 \\leq {s_i} \\leq 20$）。\n> \n> \n> 输出格式\n> \n> 只有一行，选 $M$ 门课程的最大得分。\n> \n> \n> 样例 #1\n> \n> \n> 样例输入 #1\n> \n> \n> \n> \n> 样例输出 #1\n\n\n🫐[P2585]三色二叉树#\n\n\n> [ZJOI2006] 三色二叉树\n> \n> \n> 题目描述\n> \n> 一棵二叉树可以按照如下规则表示成一个由 $0$、$1$、$2$ 组成的字符序列，我们称之为“二叉树序列 $S$”：\n> \n> $$S= \\begin{cases} 0& \\text{表示该树没有子节点}\\ 1S_1& \\text{表示该树有一个节点，}S_1\n> \\text{为其子树的二叉树序列}\\ 2S_1S_2& \\text{表示该树由两个子节点，}S_1 \\text{和} S_2\n> \\text{分别表示其两个子树的二叉树序列} \\end{cases}$$\n> \n> 例如，下图所表示的二叉树可以用二叉树序列 $S=\\texttt{21200110}$ 来表示。\n> \n> \n> \n> 你的任务是要对一棵二叉树的节点进行染色。每个节点可以被染成红色、绿色或蓝色。并且，一个节点与其子节点的颜色必须不同，如果该节点有两个子节点，那么这两个子节点\n> 的颜色也必须不同。给定一颗二叉树的二叉树序列，请求出这棵树中最多和最少有多少个点能够被染成绿色。\n> \n> \n> 输入格式\n> \n> 输入只有一行一个字符串 $s$，表示二叉树序列。\n> \n> \n> 输出格式\n> \n> 输出只有一行，包含两个数，依次表示最多和最少有多少个点能够被染成绿色。\n> \n> \n> 样例 #1\n> \n> \n> 样例输入 #1\n> \n> \n> \n> \n> 样例输出 #1\n> \n> \n> \n> \n> 提示\n> \n> 数据规模与约定\n> \n> 对于全部的测试点，保证 $1 \\leq |s| \\leq 5 \\times 10^5$，$s$ 中只含字符 0 1 2。\n\n\n🫐[P3047 ]Nearby Cows#\n\n\n> [USACO12FEB] Nearby Cows G\n> \n> \n> 题目描述\n> \n> Farmer John has noticed that his cows often move between nearby fields. Taking\n> this into account, he wants to plant enough grass in each of his fields not\n> only for the cows situated initially in that field, but also for cows visiting\n> from nearby fields.\n> \n> Specifically, FJ's farm consists of N fields (1 <= N <= 100,000), where some\n> pairs of fields are connected with bi-directional trails (N-1 of them in\n> total). FJ has designed the farm so that between any two fields i and j, there\n> is a unique path made up of trails connecting between i and j. Field i is home\n> to C(i) cows, although cows sometimes move to a different field by crossing up\n> to K trails (1 <= K <= 20).\n> \n> FJ wants to plant enough grass in each field i to feed the maximum number of\n> cows, M(i), that could possibly end up in that field -- that is, the number of\n> cows that can potentially reach field i by following at most K trails. Given\n> the structure of FJ's farm and the value of C(i) for each field i, please help\n> FJ compute M(i) for every field i.\n> \n> 给你一棵 $n$ 个点的树，点带权，对于每个节点求出距离它不超过 $k$ 的所有节点权值和 $m_i$。\n> \n> \n> 输入格式\n> \n> * Line 1: Two space-separated integers, N and K.\n> \n> * Lines 2..N: Each line contains two space-separated integers, i and j (1 <=\n> i,j <= N) indicating that fields i and j are directly connected by a trail.\n> \n> * Lines N+1..2N: Line N+i contains the integer C(i). (0 <= C(i) <= 1000)\n> \n> 第一行两个正整数 $n,k$。\n> \n> 接下来 $n-1$ 行，每行两个正整数 $u,v$，表示 $u,v$ 之间有一条边。\n> \n> 最后 $n$ 行，每行一个非负整数 $c_i$，表示点权。\n> \n> \n> 输出格式\n> \n> * Lines 1..N: Line i should contain the value of M(i).\n> \n> 输出 $n$ 行，第 $i$ 行一个整数表示 $m_i$。\n> \n> \n> 样例 #1\n> \n> \n> 样例输入 #1\n> \n> \n> \n> \n> 样例输出 #1\n> \n> \n> \n> \n> 提示\n> \n> There are 6 fields, with trails connecting (5,1), (3,6), (2,4), (2,1), and\n> (3,2). Field i has C(i) = i cows.\n> \n> Field 1 has M(1) = 15 cows within a distance of 2 trails, etc.\n> \n> 【数据范围】\n> \n> 对于 $100%$ 的数据：$1 \\le n \\le 10^5$，$1 \\le k \\le 20$，$0 \\le c_i \\le 1000$\n\n\n🫐[P3698]小Q的棋盘#\n\n\n> [CQOI2017] 小Q的棋盘\n> \n> \n> 题目描述\n> \n> 小 Q 正在设计一种棋类游戏。\n> \n> 在小 Q 设计的游戏中，棋子可以放在棋盘上的格点中。某些格点之间有连线，棋子只能在有连线的格点之间移动。整个棋盘上共有 $V$ 个格点，编号为\n> $0,1,2,\\cdots, V- 1$，它们是连通的，也就是说棋子从任意格点出发，总能到达所有的格点。小 Q\n> 在设计棋盘时，还保证棋子从一个格点移动到另外任一格点的路径是唯一的。\n> \n> 小 Q 现在想知道，当棋子从格点 $0$ 出发，移动 $N$ 步最多能经过多少格点。格点可以重复经过多次，但不重复计数。\n> \n> \n> 输入格式\n> \n> 第一行包含2个正整数 $V, N$，其中 $V$ 表示格点总数，$N$ 表示移动步数。\n> \n> 接下来 $V-1$ 行，每行两个数 $a_i,b_i$，表示编号为$a_i,b_i$ 的两个格点之间有连线。\n> \n> \n> 输出格式\n> \n> 输出一行一个整数，表示最多经过的格点数量。\n> \n> \n> 样例 #1\n> \n> \n> 样例输入 #1\n> \n> \n> \n> \n> 样例输出 #1\n> \n> \n> \n> \n> 样例 #2\n> \n> \n> 样例输入 #2\n> \n> \n> \n> \n> 样例输出 #2\n> \n> \n> \n> \n> 提示\n> \n> 【输入输出样例 1 说明】\n> \n> 从格点 $0$ 出发移动 $2$ 步。经过 $0, 1, 2$ 这 $3$ 个格点。\n> \n> 【输入输出样例 2 说明】\n> \n> 一种可行的移动路径为 $0 \\to 1 \\to 3 \\to 5 \\to 3 \\to 7$，经过 $0, 1, 3, 5, 7$ 这 $5$ 个格点。\n> \n> 【数据规模与约定】\n> \n> 对于 $100%$ 的测试点，$1\\le N,V ≤ 100$，$0 ≤a_i,b_i< V$。\n\n\n🫐[P5658]括号树#\n\n\n> [CSP-S2019] 括号树\n> \n> \n> 题目背景\n> \n> 本题中合法括号串的定义如下：\n> \n>  1. () 是合法括号串。\n>  2. 如果 A 是合法括号串，则 (A) 是合法括号串。\n>  3. 如果 A，B 是合法括号串，则 AB 是合法括号串。\n> \n> 本题中子串与不同的子串的定义如下：\n> \n>  1. 字符串 S 的子串是 S 中连续的任意个字符组成的字符串。S 的子串可用起始位置 $l$ 与终止位置 $r$ 来表示，记为 $S (l,\n>     r)$（$1 \\leq l \\leq r \\leq |S |$，$|S |$ 表示 S 的长度）。\n>  2. S 的两个子串视作不同当且仅当它们在 S 中的位置不同，即 $l$ 不同或 $r$ 不同。\n> \n> \n> 题目描述\n> \n> 一个大小为 $n$ 的树包含 $n$ 个结点和 $n - 1$ 条边，每条边连接两个结点，且任意两个结点间有且仅有一条简单路径互相可达。\n> \n> 小 Q 是一个充满好奇心的小朋友，有一天他在上学的路上碰见了一个大小为 $n$ 的树，树上结点从 $1 \\sim n$ 编号，$1$ 号结点为树的根。除\n> $1$ 号结点外，每个结点有一个父亲结点，$u$（$2 \\leq u \\leq n$）号结点的父亲为 $f_u$（$1 ≤ f_u < u$）号结点。\n> \n> 小 Q 发现这个树的每个结点上恰有一个括号，可能是( 或)。小 Q 定义 $s_i$ 为：将根结点到 $i$\n> 号结点的简单路径上的括号，按结点经过顺序依次排列组成的字符串。\n> \n> 显然 $s_i$ 是个括号串，但不一定是合法括号串，因此现在小 Q 想对所有的 $i$（$1\\leq i\\leq n$）求出，$s_i$\n> 中有多少个互不相同的子串是合法括号串。\n> \n> 这个问题难倒了小 Q，他只好向你求助。设 $s_i$ 共有 $k_i$ 个不同子串是合法括号串， 你只需要告诉小 Q 所有 $i \\times k_i$\n> 的异或和，即： $$ (1 \\times k_1)\\ \\text{xor}\\ (2 \\times k_2)\\ \\text{xor}\\ (3 \\times\n> k_3)\\ \\text{xor}\\ \\cdots\\ \\text{xor}\\ (n \\times k_n) $$ 其中 $xor$ 是位异或运算。\n> \n> \n> 输入格式\n> \n> 第一行一个整数 $n$，表示树的大小。\n> \n> 第二行一个长为 $n$ 的由( 与) 组成的括号串，第 $i$ 个括号表示 $i$ 号结点上的括号。\n> \n> 第三行包含 $n − 1$ 个整数，第 $i$（$1 \\leq i \\lt n$）个整数表示 $i + 1$ 号结点的父亲编号 $f_{i+1}$。\n> \n> \n> 输出格式\n> \n> 仅一行一个整数表示答案。\n> \n> \n> 样例 #1\n> \n> \n> 样例输入 #1\n> \n> \n> \n> \n> 样例输出 #1\n> \n> \n> \n> \n> 提示\n> \n> 【样例解释1】\n> \n> 树的形态如下图：\n> \n> \n> \n> 将根到 1 号结点的简单路径上的括号，按经过顺序排列所组成的字符串为 (，子串是合法括号串的个数为 $0$。\n> \n> 将根到 2 号结点的字符串为 ((，子串是合法括号串的个数为 $0$。\n> \n> 将根到 3 号结点的字符串为 ()，子串是合法括号串的个数为 $1$。\n> \n> 将根到 4 号结点的字符串为 (((，子串是合法括号串的个数为 $0$。\n> \n> 将根到 5 号结点的字符串为 (()，子串是合法括号串的个数为 $1$。\n> \n> 【数据范围】\n\n\n🫐[P2607]骑士#\n\n\n> [ZJOI2008] 骑士\n> \n> \n> 题目描述\n> \n> Z 国的骑士团是一个很有势力的组织，帮会中汇聚了来自各地的精英。他们劫富济贫，惩恶扬善，受到社会各界的赞扬。\n> \n> 最近发生了一件可怕的事情，邪恶的 Y 国发动了一场针对 Z 国的侵略战争。战火绵延五百里，在和平环境中安逸了数百年的 Z 国又怎能抵挡的住 Y\n> 国的军队。于是人们把所有的希望都寄托在了骑士团的身上，就像期待有一个真龙天子的降生，带领正义打败邪恶。\n> \n> 骑士团是肯定具有打败邪恶势力的能力的，但是骑士们互相之间往往有一些矛盾。每个骑士都有且仅有一个自己最厌恶的骑士（当然不是他自己），他是绝对不会与自己最厌恶的\n> 人一同出征的。\n> \n> 战火绵延，人民生灵涂炭，组织起一个骑士军团加入战斗刻不容缓！国王交给了你一个艰巨的任务，从所有的骑士中选出一个骑士军团，使得军团内没有矛盾的两人（不存在一个\n> 骑士与他最痛恨的人一同被选入骑士军团的情况），并且，使得这支骑士军团最具有战斗力。\n> \n> 为了描述战斗力，我们将骑士按照 $1$ 至 $n$ 编号，给每名骑士一个战斗力的估计，一个军团的战斗力为所有骑士的战斗力总和。\n> \n> \n> 输入格式\n> \n> 第一行包含一个整数 $n$，描述骑士团的人数。\n> \n> 接下来 $n$ 行，每行两个整数，按顺序描述每一名骑士的战斗力和他最痛恨的骑士。\n> \n> \n> 输出格式\n> \n> 应输出一行，包含一个整数，表示你所选出的骑士军团的战斗力。\n> \n> \n> 样例 #1\n> \n> \n> 样例输入 #1\n> \n> \n> \n> \n> 样例输出 #1\n> \n> \n> \n> \n> 提示\n> \n> 数据规模与约定\n> \n> 对于 $30%$ 的测试数据，满足 $n \\le 10$；\n> \n> 对于 $60%$ 的测试数据，满足 $n \\le 100$；\n> \n> 对于 $80%$ 的测试数据，满足 $n \\le 10 ^4$。\n> \n> 对于 $100%$ 的测试数据，满足 $1\\le n \\le 10^6$，每名骑士的战斗力都是不大于 $10^6$ 的正整数。\n\n\n🫐[P3177]树上染色#\n\n\n> [HAOI2015] 树上染色\n> \n> \n> 题目描述\n> \n> 有一棵点数为 $n$ 的树，树边有边权。给你一个在 $0 \\sim n$ 之内的正整数 $k$ ，你要在这棵树中选择 $k$ 个点，将其染成黑色，并将其他的\n> $n-k$ 个点染成白色。将所有点染色后，你会获得黑点两两之间的距离加上白点两两之间的距离的和的收益。问收益最大值是多少。\n> \n> \n> 输入格式\n> \n> 第一行包含两个整数 $n,k$。\n> \n> 第二到 $n$ 行每行三个正整数 $u, v, w$，表示该树中存在一条长度为 $w$ 的边 $(u, v)$。输入保证所有点之间是联通的。\n> \n> \n> 输出格式\n> \n> 输出一个正整数，表示收益的最大值。\n> \n> \n> 样例 #1\n> \n> \n> 样例输入 #1\n> \n> \n> \n> \n> 样例输出 #1\n> \n> \n> \n> \n> 提示\n> \n> 对于 $100%$ 的数据，$0 \\leq n,k \\leq 2000$。\n\n\n🫐[P4395]Gem#\n\n\n> [BOI2003] Gem 气垫车\n> \n> \n> 题目描述\n> \n> 给出一棵树，要求你为树上的结点标上权值，权值可以是任意的正整数\n> \n> 唯一的限制条件是相临的两个结点不能标上相同的权值，要求一种方案，使得整棵树的总价值最小。\n> \n> \n> 输入格式\n> \n> 先给出一个数字N,代表树上有N个点,N<=10000\n> \n> 下面N-1行,代表两个点相连\n> \n> \n> 输出格式\n> \n> 最小的总权值\n> \n> \n> 样例 #1\n> \n> \n> 样例输入 #1\n> \n> \n> \n> \n> 样例输出 #1\n> \n> \n> \n> \n> 提示\n> \n> 本题已经添加数据，但考虑到题目年代较为久远（毕竟是2003年的BOI了）以及洛谷神速评测姬，将此题时限修改为500ms。\n\n\n🫐[P4516]潜入行动#\n\n\n> [JSOI2018] 潜入行动\n> \n> \n> 题目描述\n> \n> 外星人又双叒叕要攻打地球了，外星母舰已经向地球航行！这一次，JYY 已经联系好了黄金舰队，打算联合所有 JSOIer 抵御外星人的进攻。\n> \n> 在黄金舰队就位之前，JYY 打算事先了解外星人的进攻计划。现在，携带了监听设备的特工已经秘密潜入了外星人的母舰，准备对外星人的通信实施监听。\n> \n> 外星人的母舰可以看成是一棵 $n$ 个节点、 $n-1$ 条边的无向树，树上的节点用 $1,2,\\cdots,n$ 编号。JYY\n> 的特工已经装备了隐形模块，可以在外星人母舰中不受限制地活动，可以神不知鬼不觉地在节点上安装监听设备。\n> \n> 如果在节点 $u$ 上安装监听设备，则 JYY 能够监听与 $u$ 直接相邻所有的节点的通信。换言之，如果在节点 $u$ 安装监听设备，则对于树中每一条边\n> $(u,v)$ ，节点 $v$ 都会被监听。特别注意放置在节点 $u$ 的监听设备并不监听 $u$ 本身的通信，这是 JYY\n> 特别为了防止外星人察觉部署的战术。\n> \n> JYY 的特工一共携带了 $k$ 个监听设备，现在 JYY\n> 想知道，有多少种不同的放置监听设备的方法，能够使得母舰上所有节点的通信都被监听？为了避免浪费，每个节点至多只能安装一个监听设备，且监听设备必须被用完。\n> \n> \n> 输入格式\n> \n> 输入第一行包含两个整数 $n,k$ ，表示母舰节点的数量 $n$ 和监听设备的数量 $k$ 。 接下来 $n-1$ 行，每行两个整数 $u,v$\n> $(1\\le u,v\\le n)$，表示树中的一条边。\n> \n> \n> 输出格式\n> \n> 输出一行，表示满足条件的方案数。因为答案可能很大，你只需要输出答案 $\\text{mod 1,000,000,007}$ 的余数即可。\n> \n> \n> 样例 #1\n> \n> \n> 样例输入 #1\n> \n> \n> \n> \n> 样例输出 #1\n> \n> \n> \n> \n> 提示\n> \n> 样例 1 解释\n> \n> 样例数据是一条链 $1-2-3-4-5$ 。首先，节点 $2$ 和 $4$ 必须放置监听设备，否则 $1,5$\n> 将无法被监听（放置的监听设备无法监听它所在的节点）。剩下一个设备必须放置在 $3$ 号节点以同时监听 $2,4$ 。因此在 $2,3,4$\n> 节点放置监听设备是唯一合法的方案。\n> \n> 数据范围\n> \n> 存在 $10%$ 的数据，$1 \\le n \\le 20$ ；\n> \n> 存在另外 $10%$ 的数据，$1 \\le n \\le 100$ ；\n> \n> 存在另外 $10%$ 的数据，$1 \\le k \\le 10$ ；\n> \n> 存在另外 $10%$ 的数据，输入的树保证是一条链；\n> \n> 对于所有数据，$1\\le n\\le 10^5$ ，$1\\le k\\le \\min{n,100}$ 。","routePath":"/posts/algorithm/treedp","lang":"","toc":[{"text":"**👾树形动态规划**","id":"树形动态规划","depth":2,"charIndex":-1},{"text":"🫐[P1352]没有上司的舞会","id":"p1352没有上司的舞会","depth":3,"charIndex":67},{"text":"🫐[P1040]加分二叉树","id":"p1040加分二叉树","depth":3,"charIndex":727},{"text":"🫐[P1122]最大子树和","id":"p1122最大子树和","depth":3,"charIndex":1611},{"text":"🫐[P1273]有线电视网","id":"p1273有线电视网","depth":3,"charIndex":2477},{"text":"🫐[P2014]选课","id":"p2014选课","depth":3,"charIndex":3737},{"text":"🫐[P2585]三色二叉树","id":"p2585三色二叉树","depth":3,"charIndex":4310},{"text":"🫐[P3047 ]Nearby Cows","id":"p3047-nearby-cows","depth":3,"charIndex":5040},{"text":"🫐[P3698]小Q的棋盘","id":"p3698小q的棋盘","depth":3,"charIndex":7080},{"text":"🫐[P5658]括号树","id":"p5658括号树","depth":3,"charIndex":7915},{"text":"🫐[P2607]骑士","id":"p2607骑士","depth":3,"charIndex":9496},{"text":"🫐[P3177]树上染色","id":"p3177树上染色","depth":3,"charIndex":10420},{"text":"🫐[P4395]Gem","id":"p4395gem","depth":3,"charIndex":10877},{"text":"🫐[P4516]潜入行动","id":"p4516潜入行动","depth":3,"charIndex":11240}],"domain":"","frontmatter":{},"version":""},{"id":55,"title":"CS-APP Datalab","content":"0. before start#\n\n实验需要的材料在这里：CSAPP Datalab\n\nCSAPP原书在线阅读\n\n将datalab-handout.tar下载复制到计划用来实验的目录下，解压：\n\n\n\n解压之后，文件中bit.c是包含13个编程题中每个题的骨架。实验要求是使用没有任何循环或条件语句，以及有限的c算术和逻辑运算符来完成其中每个函数的内容，只能使用\n如下8个运算符：\n\n\n\n\n测评#\n\n在btest文件夹中，包含了一个测试程序，可以用来测试我们的实现是否正确。我们可以通过make命令编译btest，然后运行：\n\n\n\ndlc：用于检查我们的实现是否符合实验要求：\n\n\n\n接下来，按照难度从易到难，我们依次完成实验\n\n\n1. bitXor#\n\n异或等价于不是同0且不是同1。\n\n\n代码#\n\n\n\n\n2. tmin#\n\n获得对2补码的最小int值。在C中，int是32位的，所以补码的最小值就是符号位为1，其余位为0的值，对0x1左移31位即可。\n\n\n代码#\n\n\n\n\n3. isTmax#\n\n判断$x$是否是int的最大整数。最大整数tmax应该为0x7fffffff。\n\n题目提示不允许使用移位操作。\n\n注意到： $$ Tmax=0x7fffffff,Tmin=0x80000000\\ so,that:Tmax=\\sim Tmin,Tmax+1 = Tmin\\\n-Tmin = \\sim Tmin + 1 = Tmax + 1 = Tmin\\ so,that:\\ -(\\sim Tmax) = Tmax + 1 =\n\\sim Tmax\\ $$ 也就是说，假如~x的相反数与~x相等，则满足x=Tmax。\n\n注意除了Tmax拥有这个性质，当x=-1时： $$ x=0xffffffff\\ \\sim x=0x00000000\\ -(\\sim x)=\\sim (\\sim\nx)+1 = x+1 = 0x00000000 $$ 也满足这个上述特点，需要排除。\n\n\n代码#\n\n\n\n{{< admonition tip \"提示\" true>}}\n\n注意返回值是int型的，所以需要使用!!将结果转换为0或1。\n\n{{< /admonition >}}\n\n\n4. allOddBits#\n\n当$x$中所有奇数位都为$1$时返回true。\n\n奇数位都为$1$的数形如： $$ x=0b1x_{30}1x_{28}1...1x_{2}1x_{0} $$\n思路是构造偶数位都为$1$的掩码0x55555555，再与$x$按位取或，若能构造出0xffffffff则复合要求。\n\n由于实验要求不允许使用长度超过8位的常量，所以通过移位操作来构造掩码。\n\n\n代码#\n\n\n\n\n5. negate#\n\n返回$x$的相反数。\n\n这个操作在第三个实验里其实已经使用过了。 $$ -x=\\sim x + 1 $$\n\n\n代码#\n\n\n\n\n6. isAsciDigit#\n\n判断$x$是否是ASCII码0~9中的某一个，即判断$0x30\\leq x\\leq 0x39$。\n\n注意到$0x30\\sim 0x39$的低4位从$0000\\sim 1001$，低5~8位为$0011$，可以分别判断。\n\n在满足低5~8位为$0011$的前提下，若倒数第4位为0则符合要求，若倒数第4位为1则需判断是否为$1000$或$1001$，即中间2位是否是0。\n\n\n代码#\n\n\n\n\n7. conditional#\n\n实现出w =( x ? y : z)的条件判断。\n\n感觉在上个题就实现了，上题相当于对一个二进制数$x=x_4 x_3 x_2 x_1$，是否满足$(x_4 == 1)?(x & 6 == 0):1$。\n\n判断$x$通过!!x获得0/1，再通过按位取反+1分别获得0x00000000和0xffffffff，再与$y$和$z$按位或并相加，获得结果。\n\n\n代码#\n\n\n\n\n8. isLessOrEqual#\n\n判断是否符合$x\\leq y$的关系。\n\n首先比较符号位，若符号位相同，则判断$x-y\\leq 0$是否成立。减号可以由按位取反+1获得相反数，再相加实现。\n\n\n代码#\n\n\n\n\n9. logicalNeg#\n\n实现逻辑取反，$x$非0返回0，$x$为0返回1。\n\n通过取反+1获得相反数，如果x是0，其相反数与x拥有相同的符号位0，否则在x和其相反数两个数之间一定会有至少一个符号位为1。\n\n在Tmin = 0x80000000中也一致，-Tmin = ~Tmin + 1 = 0x7fffffff + 1 = 0x80000000。\n\n\n代码#\n\n\n\n\n10. howManyBits#\n\n计算出表示$x$ 需要的最少补码位数。 $$ 0=0b0,1bit\\ 1=0b01,2bits\\ -1=0b1,1bit\\ 2=0b010,3bits\\\n-2=0b10,2bits\\ 3=0b011,3bits\\ -3=0b101,3bits $$\n如果是正数的话x补码形如：0x00001...，所需补码位数是从左向右第一个1的位置在+1（符号位），负数的话x补码形如：0x11110...，取反之后是0x0\n0001...，所需位数是从左向右第一个1的位置+1。\n\n不能通过循环来从左向右找，尝试二分找第一个1的位置。\n\nint型有32位，逐渐二分为16、8、4、2、1位。 $$ \\begin{aligned} &x =\n0b0001,1...,....,....,....,....,....,....\\ loop1:& !!(x>>16)=1,b16=16\\\n&\\text{高16位存在1，则可以舍去低16位，将x右移16位}\\ &x = x>>16=0b0001,1...,...,...\\ loop2:&...\n\\end{aligned} $$ 最后统计完毕之后要+1符号位。\n\n\n代码#\n\n\n\n\n11. floatScale2#\n\n求一个float浮点数乘2之后的值。\n\nfloat的各位：\n\n符号    指数(EXP)        尾数\n1     8              23\n0/1   0x01111111+e   小数部分\n\n通过定义先按指数是否为0x00000000或0x11111111、≠0 & ≠255分类。\n\n * 对规格化数进行指数+1（若+1后为255则返回无穷大）\n\n * 非规格化数保持符号位不变，左移一位（注意：若尾数最左边一位为1时，乘2后恰好是规格化数，故保留符号位整体左移即可）\n\n * 无穷大保持不变\n\n * NaN保持不变。\n\n\n代码#\n\n\n\n\n12. floatFloat2Int#\n\n将float浮点数转化为int类型。\n\n算出真实的Exp：Exp + 0b0111111 = e，\n\n再给尾数最左侧补一位1，整体右移|Exp-23|位（舍位），再通过正负性取补码。\n\n注意，若溢出或是NaN返回0x80000000u\n\n\n代码#\n\n\n\n\n13. floatPower2#\n\n求浮点表示下的$2.0$的$x$次。\n\nemmm其实就是exp + x，那就处理好$0b000000$和$0b11111111$的情况就好了。\n\n\n代码#\n\n\n\n写完哩~最后一个样例似乎跑了好久（。\n\n\n总结碎碎念#\n\n做完实验第一次感觉到!f和~f的区别（迫真。\n\n下个实验再见(∪.∪ )...zzz","routePath":"/posts/csapp/datalab","lang":"","toc":[{"text":"0. before start","id":"0-before-start","depth":2,"charIndex":-1},{"text":"测评","id":"测评","depth":3,"charIndex":193},{"text":"1. bitXor","id":"1-bitxor","depth":2,"charIndex":314},{"text":"代码","id":"代码","depth":3,"charIndex":344},{"text":"2. tmin","id":"2-tmin","depth":2,"charIndex":352},{"text":"代码","id":"代码-1","depth":3,"charIndex":428},{"text":"3. isTmax","id":"3-istmax","depth":2,"charIndex":436},{"text":"代码","id":"代码-2","depth":3,"charIndex":831},{"text":"4. allOddBits","id":"4-alloddbits","depth":2,"charIndex":925},{"text":"代码","id":"代码-3","depth":3,"charIndex":1119},{"text":"5. negate","id":"5-negate","depth":2,"charIndex":1127},{"text":"代码","id":"代码-4","depth":3,"charIndex":1194},{"text":"6. isAsciDigit","id":"6-isascidigit","depth":2,"charIndex":1202},{"text":"代码","id":"代码-5","depth":3,"charIndex":1406},{"text":"7. conditional","id":"7-conditional","depth":2,"charIndex":1414},{"text":"代码","id":"代码-6","depth":3,"charIndex":1609},{"text":"8. isLessOrEqual","id":"8-islessorequal","depth":2,"charIndex":1617},{"text":"代码","id":"代码-7","depth":3,"charIndex":1717},{"text":"9. logicalNeg","id":"9-logicalneg","depth":2,"charIndex":1725},{"text":"代码","id":"代码-8","depth":3,"charIndex":1906},{"text":"10. howManyBits","id":"10-howmanybits","depth":2,"charIndex":1914},{"text":"代码","id":"代码-9","depth":3,"charIndex":2430},{"text":"11. floatScale2","id":"11-floatscale2","depth":2,"charIndex":2438},{"text":"代码","id":"代码-10","depth":3,"charIndex":2729},{"text":"12. floatFloat2Int","id":"12-floatfloat2int","depth":2,"charIndex":2737},{"text":"代码","id":"代码-11","depth":3,"charIndex":2878},{"text":"13. floatPower2","id":"13-floatpower2","depth":2,"charIndex":2886},{"text":"代码","id":"代码-12","depth":3,"charIndex":2978},{"text":"总结碎碎念","id":"总结碎碎念","depth":2,"charIndex":3006}],"domain":"","frontmatter":{"title":"CS-APP Datalab","subtitle":"实验记录","date":"2024-07-04T12:49:31.000Z","lastmod":"2024-07-04T12:49:31.000Z","draft":false,"authors":[],"description":"记录CS-APP Datalab实验过程","tags":["CSAPP"],"categories":["在学习计算机系统的日子里"],"series":["CS:APP实验记录"],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"","featuredImagePreview":"","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":56,"title":"Electron 构建记录","content":"> System：Windows 11\n> \n> Python：Python 3.13.3\n> \n> node：v22.14.0\n> \n> npm：10.9.2\n> \n> yarn：1.22.22\n> \n> 足够的磁盘空间和流量\n\n\n初始化环境#\n\nElectron  是嵌入  Chromium  和  Node.js  到 二进制进行开发，所以在构建Electron时显然也要准备这两者的开发环境。\n\n\nChromium 开发工具#\n\n参考Chromium 此页拉取depot_tools。\n\n拉取完毕之后，将depot_tools的路径加入到系统变量path中，并将变量位置上移到至少git变量之前。\n\ndepot_tools需要本机安装了Git for Windows，以及python 3.8。\n\n识别不到安装的git#\n\n报错信息：\n\n\n\n本机使用Scoop安装大部分的软件，难过的是通过这样下载的git无法被depot_tools工具识别，只能卸载本机当前的git后在git重新下载一遍，之后的gc\nlient。\n\n\nElectron build-tools#\n\n本篇使用的脚本是Electron build-tools。\n\n按照 readme 的提示安装：\n\n\n\n在本机找好存放源码的位置后，进行：\n\n\n\n--root=~/electron是拉取的时候想要存源码的位置，如果留空则在当前路径下，建议选择合适的磁盘，至少光是源码已经占据 20 多个 G\n了，考虑到之后还有依赖包。\n\n识别不到命令#\n\n在e init ...命令执行到一半，发现中断在某处，重新进行e sync -f后，出现找不到 npm 命令的反馈。\n\n\n\n进行拉取时，脚本在执行到大约python script/lib/npx.py yarn@1.15.2 install\n--frozen-lockfile的时候发生了报错，称FileNotFoundError: [WinError 2]，导致ERROR gclient sync\nfailed失败。\n\n仔细阅读日志之后，先在命令行直接执行上述脚本语句，发现运行是正常的，同时想的本机在平时开发使用 python、node.js\n均没有出现找不到命令的问题，且实验当时在命令行测试node -v、yarn --version和npm -v都有版本返回，排错查看环境变量path也有正确设置。\n\n本机使用了 node.js 版本管理工具fnm，继而想到或许需要激活 node 环境，于是先运行了fnm use\nv22，发现继续的拉取依然有问题，想到或许是通过fnm设置的临时环境会不被识别，于是选择直接在 node.js\n官网下载一个合适的版本，这样操作之后能成功运行完毕。\n\n不太确定nvm会不会也有这样的问题，但是插个眼，解决方法还是比较简单的。\n\n\n构建#\n\n附一张成功拉取的截图(嘻嘻)\n\n\n\n在进行e build之后，初次构建需要鉴权，点击命令行提示的网址操作一下就好啦~\n\n然后就是继续泡 n 杯咖啡等待构建。\n\n构建成功之后的结果会存在./src/out/..目录下，在命令行执行：\n\n\n\n可以在命令行看到当前构建出的Electron信息，以及弹出的窗口。\n\n\n\n根据提示的命令启动本地的 electron demo\n\n\n\n合影😗","routePath":"/posts/electronjs/build_electron","lang":"","toc":[{"text":"初始化环境","id":"初始化环境","depth":2,"charIndex":116},{"text":"Chromium 开发工具","id":"chromium-开发工具","depth":3,"charIndex":203},{"text":"识别不到安装的`git`","id":"识别不到安装的git","depth":4,"charIndex":-1},{"text":"Electron build-tools","id":"electron-build-tools","depth":3,"charIndex":465},{"text":"识别不到命令","id":"识别不到命令","depth":4,"charIndex":648},{"text":"构建","id":"构建","depth":2,"charIndex":1194}],"domain":"","frontmatter":{"title":"Electron 构建记录","subtitle":null,"date":"2025-04-25T05:27:50.000Z","lastmod":"2025-04-25T05:27:50.000Z","draft":false,"authors":null,"description":"Electron 构建记录，排错记录流水账","tags":["Electron","Chromium"],"categories":["在前端搬砖的日子里"],"series":["Electron学习笔记"],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"https://img.dodolalorc.cn/i/2025/04/26/680c60755e10f.png","featuredImagePreview":"https://img.dodolalorc.cn/i/2025/04/26/680c60755e10f.png","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":57,"title":"自定义Electron.exe的使用","content":"初始化环境可以阅读这篇。\n\n上接之前的构建过程，经过第一次构建之后，后续修改源码添加 api 等都不会再构建那么久了。\n\n\n添加简单的 API#\n\n当前目录在构建时相同的目录下，其下包含src、.gclient、node_modules等。\n\n找到src/electron目录，在lib/browser/api/app.ts添加：\n\n\n\n再到electron.d.ts中更新添加：\n\n\n\n然后在命令行重新构建一遍：\n\n\n\n这样就准备好了测试用的自定义 electron 啦\n\n\n测试 demo#\n\n找到一个测试用的小 electron demo，可以参考Electron 教程。\n\n\n修改启动命令#\n\n在package.json中修改启动脚本start的部分，原来是electron .启动，将electron改为构建的electron.exe路径：\n\n\n\n{{< admonition type=info title=\"不重要的小说明\" open=false >}} chcp\n65001只是为了在命令行中能够正常显示中文字符用的 {{< /admonition >}}\n\n\n调用 Api#\n\n在main.js中添加 console.log 语句：\n\n\n\n之后正常启动测试的项目即可：\n\n\n\n可以看到命令行对应的输出：\n\n\n\n\n小 demo 的代码#\n\n\nmain.js#\n\n\n\n\npreload.js#\n\n\n\n\nrenderer.js#\n\n\n\n\nindex.html#\n\n","routePath":"/posts/electronjs/custom_electron_demo","lang":"","toc":[{"text":"添加简单的 API","id":"添加简单的-api","depth":2,"charIndex":61},{"text":"测试 demo","id":"测试-demo","depth":2,"charIndex":238},{"text":"修改启动命令","id":"修改启动命令","depth":3,"charIndex":291},{"text":"调用 Api","id":"调用-api","depth":3,"charIndex":488},{"text":"小 demo 的代码","id":"小-demo-的代码","depth":2,"charIndex":564},{"text":"`main.js`","id":"mainjs","depth":3,"charIndex":-1},{"text":"`preload.js`","id":"preloadjs","depth":3,"charIndex":-1},{"text":"`renderer.js`","id":"rendererjs","depth":3,"charIndex":-1},{"text":"`index.html`","id":"indexhtml","depth":3,"charIndex":-1}],"domain":"","frontmatter":{"title":"自定义Electron.exe的使用","subtitle":"","date":"2025-04-27T08:51:01.000Z","lastmod":"2025-04-27T08:51:01.000Z","draft":false,"authors":null,"description":"只是一个本地测试的小流程记录","tags":["前端","Electron","Chromium"],"categories":["在前端搬砖的日子里"],"series":["Electron学习笔记"],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"https://img.dodolalorc.cn/i/2025/04/26/680c601796399.png","featuredImagePreview":"https://img.dodolalorc.cn/i/2025/04/26/680c601796399.png","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":58,"title":"Github Action实践","content":"前言#\n\n本篇记录利用 github action 实现自动化构建和部署的过程。\n\n本站除了部署在 github page 上，还部署在本人的服务器上，懒惰的 ddl 直到现在才去上手实验，因此利用在 github action\n中实现两种部署方式。\n\n\nGithub Action#\n\nGithub Action 是 Github 提供的持续集成服务，可以在代码仓库中配置 workflow，实现自动化构建、测试、部署等功能。\n\n有一些术语需要了解：\n\n * Workflow：一个 workflow 由一个或多个 job 组成，可以在不同的操作系统环境中运行。\n * Job：一个 job 由一系列 step 组成，可以在同一个 runner 上运行。\n * Step：一个 step 由一个或多个 action 组成，可以在同一个 runner 上运行。\n * Action：一个 action 是一个独立的任务，可以在不同的 runner 上运行。\n\n\n配置#\n\n这里我使用的是 github action 自带的SSH Deploy action，使用 ssh 链接远程服务器，将代码部署到服务器上。使用方法可以参考这里。\n\n\n1. 创建 SSH Key 并添加到 github secrets#\n\n首先需要在服务器上生成一个 SSH Key，用于 github action 登录服务器。\n\n\n\nkey\n的生成过程中会提示输入密码，可以不输入，直接回车，默认保存在/root/.ssh目录下（这个可能不同的服务器环境会有区别，具体的默认位置在生成ssh-key的时\n候命令行有提示。\n\n生成的 key\n包含一个私钥id_rsa和一个公钥id_rsa.pub，私钥保存在本地，我们需要将公钥添加到服务器的/root/.ssh/authorized_keys文件中。\n\n\n\n考虑到我们并不想把私钥暴露在 github 公开仓库上，我们需要将私钥id_rsa添加到 github 的 secrets 中。\n\n在仓库的Settings->Security->Secrets and variables->Actions中，选择New repository\nsecret，添加一个SSH_PRIVATE_KEY，将私钥内容粘贴进去。\n\n再新建三个 secrets，分别是REMOTE_HOST、REMOTE_USER、REMOTE_TARGET，分别对应服务器的地址、用户名、目标路径。\n\n\n2. 创建 workflow#\n\n在代码仓库的.github/workflows目录下创建一个.yml文件，文件名可以自定义，如deploy.yml。\n\n一个库可以有多个 workflow，github 只要发现.github/workflows目录下有.yml文件，就会自动运行 workflow。\n\n内容可以参考如下：\n\n\n\n向 github 仓库 push 代码之后，我们在Actions选项卡中可以看到 workflow\n的运行情况。假如运行失败，可以点进去查看具体的错误信息，进行调试。\n\n之后每次 push 到 main 分支或者手动触发 workflow，github action 就会自动运行 workflow，将代码部署到服务器上。\n\n\n更新 2024-09-22#\n\n之前部署的时候只上传了public/文件夹，最近有同步源码的需求，但是源码包含一些隐私信息，并不适合上传到 github 的公开仓库，所以现在的需求是：\n\n * 将源码上传到一个私有仓库\n * 从私有仓库中将public/文件夹同步到<username>.github.io公开仓库中，并部署到github page\n\n因此新增了一个在源码仓库根目录下的 workflow，将源码上传到私有仓库，通过 hugo 官方提供的\naction，将生产的站点文件同步到<username>.github.io公开仓库中。\n\n\n创建私有仓库#\n\n首先在 github 上创建一个私有仓库，用于存放源码。\n\n\n创建 personal access token#\n\n在 github 的Settings->Developer settings->Personal access tokens中，点击Generate new\ntoken，勾选repo权限，生成一个 token，将 token 复制下来。\n\n\n添加 secrets#\n\n在源码仓库的Settings->Security->Secrets and\nvariables->Actions中，添加一个ACTION_ACCESS_TOKEN，将刚刚生成的 token 粘贴进去，这个命名要和 workflow\n文件中的一致。\n\n\n创建 workflow#\n\n在私有仓库的.github/workflows目录下创建一个gh-page.yml文件。\n\n文件内容如下：\n\n\n\n由于现在的xxx.github.io对应的仓库是在 GitHub action 中构建站点后直接 commit 同步的，故原来在公开仓库中的 workflows\n并不方便添加到这个 commit 里，我这里的解决思路是将原来 ssh 连接云服务器进行 deploy 的代码进行修改，添加自动构建内容，再直接用 ssh\n连接到云服务器，完成云服务器的内容更新。修改后的remote-deploy.yml参考如下：\n\n","routePath":"/posts/fool/github_action","lang":"","toc":[{"text":"前言","id":"前言","depth":2,"charIndex":-1},{"text":"Github Action","id":"github-action","depth":2,"charIndex":127},{"text":"配置","id":"配置","depth":2,"charIndex":430},{"text":"1. 创建 SSH Key 并添加到 github secrets","id":"1-创建-ssh-key-并添加到-github-secrets","depth":3,"charIndex":518},{"text":"2. 创建 workflow","id":"2-创建-workflow","depth":3,"charIndex":1046},{"text":"更新 2024-09-22","id":"更新-2024-09-22","depth":2,"charIndex":1375},{"text":"创建私有仓库","id":"创建私有仓库","depth":3,"charIndex":1650},{"text":"创建 personal access token","id":"创建-personal-access-token","depth":3,"charIndex":1690},{"text":"添加 secrets","id":"添加-secrets","depth":3,"charIndex":1838},{"text":"创建 workflow","id":"创建-workflow","depth":3,"charIndex":1977}],"domain":"","frontmatter":{"title":"Github Action实践","subtitle":"","date":"2024-07-05T15:11:39.000Z","lastmod":"2024-09-22T14:11:39.000Z","draft":false,"authors":[],"description":"","tags":["Github Action","自动化部署"],"categories":["我们需要更多的鱼"],"series":[],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"","featuredImagePreview":"","toc":{"enable":true},"math":{"enable":false},"lightgallery":false,"license":""},"version":""},{"id":59,"title":"前端八股文小题集合","content":"Vue2 和 Vue3 区别#\n\n性能优化\n\n * Vue 3：通过重写虚拟 DOM 和优化编译器，性能显著提升，渲染速度更快，内存占用更少。\n\n * Vue 2：性能较好，但不如 Vue 3。\n   \n   Composition API\n\n * Vue 3：引入了 Composition API，允许开发者按逻辑组织代码，提升复杂组件的可维护性。\n\n * Vue 2：主要使用 Options API，代码组织方式相对固定。\n   \n   响应式系统\n\n * Vue 3：使用 Proxy 实现响应式系统，支持更多数据类型，性能更好。\n\n * Vue 2：使用 Object.defineProperty，存在一些局限性，如无法检测数组和对象的变化。\n   \n   TypeScript 支持\n\n * Vue 3：内置 TypeScript 支持，类型推断更完善。\n\n * Vue 2：对 TypeScript 的支持较弱，类型推断不够完善。\n   \n   Fragment 和 Teleport\n\n * Vue 3：支持 Fragment（多根节点组件）和 Teleport（将组件渲染到 DOM 其他位置）。\n\n * Vue 2：不支持这些特性。\n\n全局 API 更改\n\n * Vue 3：全局 API 改为按需导入，减少打包体积。\n * Vue 2：全局 API 通过 Vue 对象访问。\n\n生命周期钩子\n\n * Vue 3：部分生命周期钩子更名（如 beforeDestroy 改为 beforeUnmount），并新增了 setup 函数。\n\n * Vue 2：使用传统的生命周期钩子。\n   \n   自定义渲染器\n\n * Vue 3：支持自定义渲染器，适用于非 DOM 环境（如小程序、Canvas）。\n\n * Vue 2：不支持自定义渲染器。\n   \n   Suspense\n\n * Vue 3：支持 Suspense，用于处理异步组件加载。\n\n * Vue 2：不支持 Suspense。\n\n打包体积\n\n * Vue 3：通过 Tree-shaking 优化，打包体积更小。\n * Vue 2：打包体积相对较大。\n\nVue 3 在性能、开发体验和灵活性上都有显著提升，尤其是 Composition API 和响应式系统的改进。对于新项目，推荐使用 Vue 3；对于现有\nVue 2 项目，可以根据需求逐步迁移。\n\n\nJavaScript 和 TypeScript#\n\nTypeScript 和 JavaScript 是两种常用的编程语言，它们的主要区别和优点如下：\n\n对比项    JAVASCRIPT                             TYPESCRIPT\n类型系统   动态类型语言，变量在运行时确定                        静态类型语言，支持类型注解，类型检查在编译时进行。\n编译     直接由浏览器或 Node.js 执行，无需编译。               需要编译为 JavaScript 后才能运行。\n工具支持   工具支持较少，尤其在大型项目中。                       提供更好的开发工具支持，如代码补全、类型检查、重构等。\n兼容性    所有 JavaScript 代码都可在 TypeScript 中运行。    编译后的代码与 JavaScript 完全兼容。\n学习曲线   学习曲线较平缓，适合初学者。                         需要掌握类型系统等额外概念，学习曲线稍陡。\n社区生态   社区庞大，资源丰富。                             社区增长迅速，尤其在大型项目中应用广泛。\n适用场景   适合小型项目或快速原型开发。                         适合大型项目，尤其是需要长期维护的复杂应用。\n优点     无需编译，开发流程简单。学习门槛低，适合初学者。社区资源丰富，生态成熟。   静态类型检查减少运行时错误。更好的工具支持提升开发效率。增强代码可读性和可维护性。支持最新的 JavaScript\n                                              特性。\n总结     适合大型项目，提供更强的类型检查和工具支持。                 适合小型项目或快速开发，学习成本低。\n\n\n代码：千分位逗号#\n\n\n\n\n代码：手写深浅拷贝#\n\n浅拷贝只会复制对象的顶层属性和值，如果属性值是对象或数组，那么它实际上只是复制了引用，而不是真正的对象。\n\n而深拷贝则会递归地复制对象的所有层级，确保所有的对象或数组都被真正复制，而不是仅复制引用。\n\n浅拷贝#\n\n\n\n深拷贝#\n\n\n\n\n代码：手写 New 方法#\n\n\n\n\n代码：手写函数柯里化#\n\n\n\n\n代码：实现 AJAX 请求，使用 Promise 封装 AJAX 请求#\n\n","routePath":"/posts/front_end/8part_essay","lang":"","toc":[{"text":"Vue2 和 Vue3 区别","id":"vue2-和-vue3-区别","depth":3,"charIndex":-1},{"text":"JavaScript 和 TypeScript","id":"javascript-和-typescript","depth":3,"charIndex":1019},{"text":"代码：千分位逗号","id":"代码千分位逗号","depth":3,"charIndex":1864},{"text":"代码：手写深浅拷贝","id":"代码手写深浅拷贝","depth":3,"charIndex":1878},{"text":"浅拷贝","id":"浅拷贝","depth":4,"charIndex":1991},{"text":"深拷贝","id":"深拷贝","depth":4,"charIndex":1999},{"text":"代码：手写 New 方法","id":"代码手写-new-方法","depth":3,"charIndex":2008},{"text":"代码：手写函数柯里化","id":"代码手写函数柯里化","depth":3,"charIndex":2026},{"text":"代码：实现 AJAX 请求，使用 Promise 封装 AJAX 请求","id":"代码实现-ajax-请求使用-promise-封装-ajax-请求","depth":3,"charIndex":2042}],"domain":"","frontmatter":{"title":"前端八股文小题集合","subtitle":"","date":"2025-03-13T06:08:19.000Z","lastmod":"2025-03-13T06:08:19.000Z","draft":true,"authors":null,"description":"","tags":null,"categories":null,"series":null,"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"","featuredImagePreview":"","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":60,"title":"【划水】Canacitor构建基于Vue/React的移动端应用","content":"最近工作需要开发一个移动端应用，考虑到我们团队前端已经有Vue/React的开发经验，所以决定使用Canacitor来构建。\n\n{{< admonition abstract \"Canacitor简介\" false>}}\n\nCanacitor是一个基于Vue/React的移动端应用开发框架，它提供了一套完整的开发工具和组件库，可以帮助开发者快速构建移动端应用。\n\n{{< /admonition >}}\n\n\n安装&创建项目#\n\n根据官方文档的指示，我选择在VSCode中使用Ionic插件来安装Canacitor。\n\n根据提示，我构建了一个如下配置的应用：\n\n\n\n点击Create Project，创建项目。\n\n项目结构像这样：\n\n\n\n\n构建项目#\n\n除了通过网页预览项目，capacitor项目还可以构建为Android应用和IOS应用，在Project中依次Build、Sync即可。\n\n\n\n\nBugs#\n\n假如发现运行Android失败，同时感觉控制台输出的信息有点难懂，可以时候Open in Android Studio，在Android\nStudio中运行，再根据提示信息去debug（比如一些环境配置或者版本支持等导致的问题...\n\n所以还是推荐多平台开发的时候能够同时利用各个平台的开发工具(●'◡'●)","routePath":"/posts/front_end/canacitor_init","lang":"","toc":[{"text":"安装&创建项目","id":"安装创建项目","depth":2,"charIndex":204},{"text":"构建项目","id":"构建项目","depth":2,"charIndex":319},{"text":"Bugs","id":"bugs","depth":2,"charIndex":399}],"domain":"","frontmatter":{"title":"【划水】Canacitor构建基于Vue/React的移动端应用","subtitle":"","date":"2024-07-11T18:04:49.000Z","lastmod":"2024-07-11T18:04:49.000Z","draft":true,"authors":[],"description":"","tags":["前端","移动端","Canacitor"],"categories":["在前端搬砖的日子里"],"series":[],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"","featuredImagePreview":"","toc":{"enable":true},"math":{"enable":false},"lightgallery":false,"license":""},"version":""},{"id":61,"title":"购物车页面制作教程（包含分页设计）","content":"{{< admonition abstract \"前言\" true>}}\n\n这篇文章用于2024年蓝旭暑期项目前的培训作业教学，目的是从零开始构建一个购物车页面，以此来熟悉原生前端三件套。o((>ω< ))o\n\n{{< /admonition >}}\n\n\n需求分析#\n\n功能要求：\n\n * 全选、单选联动逻辑（包括依次选中所有物品时自动勾选全选按钮、勾选全选时勾选所 有单选、取消全选后取消所有选中等）、结算小项总价以及整体总价。\n\n * 展示商品图片、名称、价格、数量等基础信息。\n\n * 体现分页展示购物车内商品内容。\n\n * 可以对购物车内商品进行增删改，即改变数量、结算商品、删除商品（结合分页显示数 目合理调整）等。\n\n * 美观的页面效果。\n\n加分功能\n\n * 实现在购物车页面查找商品的功能。\n\n * 自己写一个弹出提示框，在删除商品、结算商品等行为后与用户进行确认交互。\n\n\n页面布局#\n\n\n整体布局#\n\n整个购物车页面有三个主要功能：列表、结算、分页。\n\n购物车页面的布局主要分为两部分：购物车列表和结算栏。\n\n购物车列表是购物车页面的主体部分，用于展示用户购物车中的商品信息，我们将整个列表设计在整个页面的中部，在顶部设计一个nav用于展示购物车的标题，以及作为之后的路\n由跳转的位置，这个nav设计成吸顶。\n\n中间主体部分是购物车列表，用于展示用户购物车中的商品信息。\n\n底部我设计为结算栏，用于展示用户当前选中的总价，以及结算按钮。\n\n分页的位置我设计在购物车列表之上，并且把它设计成向下滑动时吸顶的设计，这样用户在浏览商品时可以随时翻页。\n\n于是整体的设计如下：\n\n\n\n{{< admonition tip \"关于吸顶和吸底的设计\" false >}}\n\n设计吸顶和吸底的时候，我们可以使用position: sticky属性，这个属性可以让元素在滚动到特定位置时固定在页面上，这样可以让用户在浏览页面时更加方便。\n\n{{< /admonition >}}\n\n\n购物车列表设计#\n\n购物车列表的设计主要是展示购物车内的商品信息，我们需要展示商品的图片、名称、价格、数量等基础信息，我们把每个商品信息设计成一个卡片，之后我们可以通过js动态生成\n这些卡片。\n\n这是我设计的一个商品卡片的结构：\n\n\n\n这是我的CSS样式：\n\n\n\nCSS解释#\n\n像上面这样直接甩出一堆代码，感觉会看起来有点懵，不过一条条的讲CSS会有点枯燥，这里稍微解释一下整体的设计想法。\n\n我比较习惯使用flex布局，所以整个卡片的设计都是基于flex布局的，首先整个卡片是一个flex容器，里面有四个部分：单选按钮、商品图片、商品信息、删除按钮。按\n照这个顺序，我将他们横向排列，分别占据不同的比例。\n\n{{< admonition tip \"在flex布局中让内部元素水平垂直居中，并且间隔合适的技巧\" false >}}\n\n在flex布局中，我们可以通过justify-content和align-items来控制元素的水平和垂直居中，通过margin来控制元素之间的间隔。\n\n其中justify-content用于控制元素在主轴上的排列方式，align-items用于控制元素在交叉轴上的排列方式。\n\n\n\njustify-content除了center之外还有flex-start、flex-end、space-between、space-around等属性，ali\ngn-items除了center之外还有flex-start、flex-end、baseline、stretch等属性，是很方便的布局方式，可以节省大量之前需要\n通过不断调整margin来实现的布局。具体区别可以在这里和这里在线演示。\n\n{{< /admonition >}}\n\n我固定了单选按钮、商品图片、删除按钮的大小，商品信息部分占据了剩下的空间。\n\n商品信息部分又分为两个部分：商品描述和商品价格，我将他们分别占据了不同的比例，使得整个卡片看起来比较美观。\n\n{{< admonition tip \"在flex布局中让内部元素占据不同的比例\" false >}}\n\n上面的justify-content和align-items更倾向于把元素均匀排列，有时候我们也需要让元素分别占据不同的比例，这时候我们可以试试通过flex属性\n来控制元素。\n\n例如上面的代码中，我通过flex: 3和flex:\n1来控制商品描述和商品价格分别占据了3:1的比例。这样的写法相比较于width属性更加灵活，可以根据不同的屏幕大小自动调整。就像下面这样：\n\n\n\n{{< /admonition >}}\n\n图标库#\n\n相信大家看完图片之后发现，我在价格和数量的部分的加号减号按钮，以及￥符号看起来不像原生的按钮和字符，这里我使用了font-awesome图标库，这是一个很好用的\n图标库，在美化页面的时候我们其实会尝试使用很多图标，我比较喜欢的两个图标库是Font\nawesome和iconfont，大家可以尝试使用，使用方法大家可以自行学习，这里我就不再赘述了。\n\n在线工具推荐#\n\n有些同学可能不太擅长调整出好看的盒子，这里我推荐一个好用的前端工具在线网站：{{https://lingdaima.com/\">}}\n，可以帮助你快速调整出好看的CSS样式。\n\n当然了，在线工具只是起到一个辅助作用，调整CSS的时候还是需要自己多尝试，多调整，多看看效果。大家不要过分依赖哦(‾◡◝)\n\n这里是整体设计完Html结构和CSS之后的效果：\n\n\n\n这个页面的效果是我自己设计的，大家可以根据自己的喜好进行调整，这里只是提供一个参考，相应的源码我也会公开放在我的gitee上，大家可以自行下载，仓库的地址在文末\n。\n\n\nJavaScript逻辑#\n\n我比较习惯在设计完页面之后再写JavaScript逻辑，这样可以更好的理清思路，而且不需要总是再次调整Html和CSS。在设计完页面之后，我们通过让这个页面不再\n是一个静态的页面，而是一个可以动态交互的页面。\n\n{{< admonition tip \"通过本地json来获得数据和渲染数据\" false >}}\n\n由于这个只是用于前端学习的小项目，我们没有接口，不过在生成应用中，页面的数据是来自后端传递而来的（往往是一个json），所以在这个项目中，我们可以通过本地的js\non文件来模拟后端返回的数据，这样可以更好的模拟真实的购物车页面，同时也可以更好的理解前后端的交互。\n\n引入json文件的方法是通过fetch方法，这是一个异步方法，我们可以通过这个方法来获取json文件，然后通过json()方法来解析json文件。\n\n就像这样：\n\n\n\n{{< /admonition >}}\n\n\nJS逻辑#\n\n为了方便管理数据，我将数据保存在一个全局变量中，这样可以更好的操作数据，下文的代码中，我会使用这些全局变量来操作数据。\n\n\n\n\n数据获取与渲染#\n\n首先我们需要通过fetch方法来获取json文件，然后通过json()方法来解析json文件，这样我们就可以得到一个json对象，这个对象就是我们的商品信息。\n\n\n\n获取数据之后，我们设置全局变量来保存当前的数据状态，然后将数据渲染到页面上，就像这样：\n\n\n\n注意到，在上述代码中，我为每一个cart-item添加了一个唯一的id属性，这个属性是用于标识每一个商品的，这样我们在之后的操作中可以通过这个id属性来找到对应\n的商品。\n\n{{< admonition tip \"关于唯一标识符\" true >}}\n\n在实际的项目中，我们往往需要为每一个商品添加一个唯一的标识符，这个标识符可以是商品的id，也可以是其他的唯一标识符，这样可以更好的操作商品，例如删除商品、修改商\n品数量等。\n\n{{< /admonition >}}\n\n{{< admonition attension \"过滤错误数据\" true >}}\n\n在实际的项目中，我们往往会遇到一些错误的数据，例如商品数量为负数或者小数、商品价格为负数等，这些数据是不符合实际的，我们需要在获取数据之后对这些数据进行过滤，这\n样可以保证数据的正确性。\n\n如果数据量比较大，我们也会选择使用filter方法来过滤数据。\n\n{{< /admonition >}}\n\n{{< admonition bug \"图片加载失败时\" true >}}\n\n在实际的项目中，我们往往会遇到一些图片加载失败的情况，这时候我们可以通过onerror事件来监听图片加载失败的情况，然后通过一些方法来处理这种情况，例如显示一个\n默认图片、显示一个提示信息等。\n\n{{< /admonition >}}\n\n\n改变商品数量#\n\n修改商品数量是通过点击+和-按钮来实现的，我们可以通过onClick事件来监听这两个按钮的点击事件，然后通过changeQuantity函数来改变商品的数量。\n\n在修改商品数量的时候，我们需要注意一些边界条件，例如商品数量不能为负数，商品数量不能超过库存（本篇的demo没有考虑这个库存上限）等，考虑到加操作和减操作的逻辑\n是一样的，我们可以通过传入一个参数来判断是加还是减，以减少代码的重复。\n\n以下是我的changeQuantity函数：\n\n\n\n\n删除商品#\n\n删除商品是通过点击删除按钮来实现的，我们可以通过onClick事件来监听删除按钮的点击事件，然后通过delItem函数来删除商品。\n\n在删除商品的时候，我们需要注意一些边界条件，例如删除商品后本页购物车为空，或者删除商品后购物车的商品数量减少等。\n\n以下是我的delItem函数：\n\n\n\n\n选中商品#\n\n选中商品可以分为两种情况：全选和单选。全选的状态会影响到单选的状态，单选的状态也会影响到全选的状态，在考虑全选和单选的逻辑的时候，我们需要多角度考虑。\n\n在对单个商品进行选中的时候，我们可以通过onClick事件来监听单选按钮的点击事件，然后通过selectGood函数来选中商品，选中商品时，我们要考虑的有：选中\n商品的总价、选中商品的数量、全选按钮的状态等。\n\n以下是我的selectGood函数：\n\n\n\n在全选的时候，我们可以通过通过selectAll函数来全选商品，全选商品时，我们要考虑的有：选中商品的总价、选中商品的数量、单选按钮的状态等。\n\n以下是我的selectAll函数：\n\n\n\n\n更新总价#\n\n我们在结算的时候需要计算当前选中的商品的总价，这个总价依赖于选中的商品数量和价格，我们可以通过updateTotalCount函数来更新总价，并在需要的时候调用\n这个函数。\n\n以下是我的updateTotalCount函数：\n\n\n\n\n分页设计#\n\n分页是通过点击页码来切换商品列表的，我们可以通过onClick事件来监听页码的点击事件，然后通过changePage函数来切换商品列表。\n\n标准的分页设计中，每次点击页码时，我们都会重新请求数据，然后重新渲染页面，这样可以保证数据的实时性，这里我只是模拟了这个过程，实际的项目中，我们会通过后端来获取\n数据。\n\n由于总页数是不确定的，所以我们依然是通过全局变量来保存当前的页码和总页数，并且在切换页码的时候，我们需要考虑一些边界条件，例如页码不能为负数，页码不能超过总页数\n等。\n\n以下是我的initPagnation和changePagnation函数：\n\n\n\n我这里的分页设计的比较简单，一共只根据json数据设计了5页，在实际项目中，分页的数目是不确定，而且有可能非常多，在设计分页功能的时候，最好的方法是增加一个..\n.按钮，点击这个按钮可以展开更多的页码，以及增加一个跳转按钮，可以跳转到指定的页码，方便用户查找。\n\n\n结算#\n\n结算逻辑比较简单，依然是考虑为空等边界条件。\n\n以下是我的setPay函数：\n\n\n\n\n消息提示框#\n\n在删除商品、结算商品等行为后，我们可以通过一个弹出提示框来与用户进行确认交互，并且可以自定义消息弹出框的类型，这样可以提高用户体验。\n\n以下是我的alert函数：\n\n\n\n\n查找功能#\n\n在本项目中，一页只有6个商品，感觉查找功能不是很必要，不过假如在一些项目中，一页有很多商品，比如不是基于分页获取数据，而是一次性获取所有数据或者是利用瀑布流加载\n数据，这时候查找功能就显得很重要了。\n\n查找功能的实现其实就是一个filter，我们设计一个简单的搜索功能：\n\n\n\n搜索框的设计\n\n\n\n\n\n这样我们就可以通过输入关键字来查找商品了。\n\n\n仓库地址#\n\n这个项目的源码我已经上传到我的gitee上，大家可以自行下载，地址在这里：{{https://gitee.com/florae00/bluemsun2024\">\n}}。","routePath":"/posts/front_end/cart_page_sample","lang":"","toc":[{"text":"整体布局","id":"整体布局","depth":2,"charIndex":403},{"text":"购物车列表设计","id":"购物车列表设计","depth":3,"charIndex":843},{"text":"CSS解释","id":"css解释","depth":4,"charIndex":975},{"text":"图标库","id":"图标库","depth":4,"charIndex":1930},{"text":"在线工具推荐","id":"在线工具推荐","depth":4,"charIndex":2111},{"text":"JS逻辑","id":"js逻辑","depth":2,"charIndex":2796},{"text":"数据获取与渲染","id":"数据获取与渲染","depth":3,"charIndex":2867},{"text":"改变商品数量","id":"改变商品数量","depth":3,"charIndex":3594},{"text":"删除商品","id":"删除商品","depth":3,"charIndex":3829},{"text":"选中商品","id":"选中商品","depth":3,"charIndex":3981},{"text":"更新总价","id":"更新总价","depth":3,"charIndex":4288},{"text":"分页设计","id":"分页设计","depth":3,"charIndex":4412},{"text":"结算","id":"结算","depth":3,"charIndex":4834},{"text":"消息提示框","id":"消息提示框","depth":2,"charIndex":4882},{"text":"查找功能","id":"查找功能","depth":2,"charIndex":4976},{"text":"仓库地址","id":"仓库地址","depth":2,"charIndex":5158}],"domain":"","frontmatter":{"title":"购物车页面制作教程（包含分页设计）","subtitle":"","date":"2024-07-06T11:16:27.000Z","lastmod":"2024-07-06T11:16:27.000Z","draft":false,"authors":null,"description":"一篇用于从零开始，基于原生H5C3JS制作的购物车页面","tags":["前端"],"categories":["在前端搬砖的日子里"],"series":null,"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"https://img.dodolalorc.cn/i/2025/03/03/67c558f57d10e.png","featuredImagePreview":"https://img.dodolalorc.cn/i/2025/03/03/67c558f57d10e.png","toc":{"enable":true},"math":{"enable":false},"lightgallery":false,"license":""},"version":""},{"id":62,"title":"前端流量控制常用手段","content":"{{< admonition abstract \"问题预设\" true>}}\n\n如何解决页面请求接口的大规模并发问题？\n\n{{< /admonition >}}\n\n在需要处理大规模请求的情境中，做好流量控制可以提升系统稳定性和性能。\n\n\n防抖/节流#\n\n\n防抖（Debounce）#\n\n在事件触发后，延迟执行函数，若在延迟期间再次出发，则重新计时，如在搜索框输入、调整窗口大小时。\n\n实现#\n\n\n\n为什么在  debounce  函数中使用  let？#\n\n在  debounce  函数中，timeout  变量需要满足以下条件：\n\n 1. 块级作用域：timeout  只需要在  debounce  函数内部有效，不需要泄漏到外部作用域。\n 2. 可重新赋值：每次调用返回的函数时，timeout  需要被重新赋值（通过  clearTimeout  和  setTimeout）。\n 3. 不需要提升：timeout  不需要在声明前访问，因此不需要  var  的提升行为。\n\nlet  完美符合这些需求：\n\n * 它提供了块级作用域，避免变量泄漏。\n * 它允许重新赋值，适合存储定时器 ID。\n * 它不会提升，避免了潜在的逻辑错误。\n\n如果使用  var：\n\n * timeout  会泄漏到外部作用域，可能导致意外行为。\n * 虽然可以重新赋值，但作用域规则不如  let  清晰。\n\n如果使用  const：\n\n * timeout  不能被重新赋值，无法满足  debounce  的逻辑需求。\n\n{{< admonition tip \"var、let和const\" true>}}\n\n作用域区别：var是函数作用域，let和const是块级作用域。\n\n变量升级：var可以升级（初始值是undefined），let和const不能变量升级，是暂时性死区。\n\n变量提升指的是在代码执行前，js 引擎将变量和函数的声明提示到作用域的顶部，也就是说可以在声明之前使用变量或函数，但赋值操作会保留在原位置。\n\nExample：变量\n\n\n\n实际执行顺序：\n\n\n\nExample：函数\n\n\n\n实际执行顺序：\n\n\n\n重新赋值：var和let可以重新赋值，const不可以。\n\n适用场景：\n\nvar：旧代码、全局变量\n\nlet：块级作用域、需要重新赋值\n\nconst：常量、不需要重新赋值\n\n{{< /admonition >}}\n\n\n节流（Throttle）#\n\n在规定时间内，函数只执行一次，多余触发被忽略，适用于滚动事件、按钮点击等情景。\n\n实现#\n\n\n\n\n注意事项#\n\n * 这两个函数都返回一个新的函数，这个新函数会包装传入的原始函数，并根据防抖或节流的逻辑来调用它。\n * 防抖和节流的区别在于，防抖是在事件触发后等待一段时间再执行，而节流是确保事件触发后的一段时间内只执行一次。\n * 这两个函数都可以接受任意数量的参数，并将它们传递给原始函数。\n\n\n请求队列#\n\n所用算法：滑动窗口\n\n每次只处理长度为maxConcurrent的窗口内的事件。\n\n\n实现#\n\n\n\n\n分页加载#\n\n分批加载数据，减少单次请求量，应用于长列表、分页数据。\n\n\n示例#\n\n\n\n\n懒加载（lazy Load）#\n\n延迟加载非关键资源，减少初始负载，如图片、视频、长列表。\n\n\n实现#\n\n\n\n\n请求重试#\n\n请求失败后，按策略重试，应用于网络不稳定、服务端错误等情景。\n\n\n实现#\n\n\n\n\n缓存#\n\n缓存请求结果，减少重复请求，应用于静态资源、频繁请求的数据。\n\n\n实现#\n\n\n\n\n限流#\n\n限制单位时间内的请求次数，应用于 API 调用、资源加载等场景。\n\n\n实现#\n\n\n\n\n反思#\n\n封装请求队列属于前端开发主导的限制请求行为。\n\n防抖、节流属于用户交互层面上的设计。可以查阅Lodash的实现思路。\n\n此外还有分页、滚动加载、可视区绘制等措施。\n\n再再此外还可以从服务器端有一些限制流量的措施，缓解高并发压力，如 Nginx 分流等。","routePath":"/posts/front_end/flow_control","lang":"","toc":[{"text":"防抖/节流","id":"防抖节流","depth":2,"charIndex":118},{"text":"防抖（Debounce）","id":"防抖debounce","depth":3,"charIndex":127},{"text":"实现","id":"实现","depth":4,"charIndex":191},{"text":"为什么在  `debounce`  函数中使用  `let`？","id":"为什么在-debounce-函数中使用-let","depth":4,"charIndex":-1},{"text":"节流（Throttle）","id":"节流throttle","depth":3,"charIndex":1021},{"text":"实现","id":"实现-1","depth":4,"charIndex":1077},{"text":"注意事项","id":"注意事项","depth":3,"charIndex":1085},{"text":"请求队列","id":"请求队列","depth":2,"charIndex":1236},{"text":"实现","id":"实现-2","depth":3,"charIndex":1286},{"text":"分页加载","id":"分页加载","depth":2,"charIndex":1294},{"text":"示例","id":"示例","depth":3,"charIndex":1331},{"text":"懒加载（lazy Load）","id":"懒加载lazy-load","depth":2,"charIndex":1339},{"text":"实现","id":"实现-3","depth":3,"charIndex":1387},{"text":"请求重试","id":"请求重试","depth":2,"charIndex":1395},{"text":"实现","id":"实现-4","depth":3,"charIndex":1435},{"text":"缓存","id":"缓存","depth":2,"charIndex":1443},{"text":"实现","id":"实现-5","depth":3,"charIndex":1481},{"text":"限流","id":"限流","depth":2,"charIndex":1489},{"text":"实现","id":"实现-6","depth":3,"charIndex":1529},{"text":"反思","id":"反思","depth":2,"charIndex":1537}],"domain":"","frontmatter":{"title":"前端流量控制常用手段","subtitle":"","date":"2025-03-17T03:40:19.000Z","lastmod":"2025-03-17T03:40:19.000Z","draft":false,"authors":null,"description":null,"tags":["前端","JavaScript"],"categories":["在前端搬砖的日子里"],"series":["前端八股文基础"],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"https://img.dodolalorc.cn/i/2025/03/03/67c5599367fe0.jpg","featuredImagePreview":"https://img.dodolalorc.cn/i/2025/03/03/67c5599367fe0.jpg","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":63,"title":"大文件上传和下载问题","content":"{{< admonition abstract \"问题预设\" true>}}\n\n网络断开之后，之前上传的部分没了？\n\n传着传着，网络波动了，结果没有了。\n\n关机后可不可以接着传，怎么做到？\n\n{{< /admonition >}}\n\n\n术语#\n\n * 断点续传\n * 断开重连重传\n * 切片上传\n\n\n切片上传#\n\n步骤\n\n 1. 前端切片 chunk 5MB\n 2. 将切片传递给后端，切片要去名：hash、index\n 3. 后端组合切片\n\n\n代码示例#\n\n\n\n\n优化#\n\n压缩文件#\n\n上传前对文件进行压缩，减少传输的数据量。\n\ncanvas或第三方库压缩图片、pako压缩其他文件类型。\n\n并发上传#\n\n使用Promise.all并发上传多个分片。\n\n注意控制并发数，避免请求过多。\n\n\n\n显示上传进度#\n\nwebsocket实时通知上传情况，以及请求序列的控制。\n\n通过XMLHttpRequest或fetch的 API 显示上传进度，提升用户体验。\n\n\n\n主进程卡顿？#\n\n尝试使用web-worker，实现多线程切片，处理完之后交给主进程发送\n\n实现用户关闭浏览器后重新打开，继续上传#\n\n将 Blob 存储到IndexedDB，下次打开浏览器后嗅探一下是否存在未完成的切片，如果有就尝试继续上传。\n\n记录已上传的分片信息。\n\n上传前检查服务器上已上传的分片，跳过已上传部分。\n\n\n下载#\n\n\n合并分片的文件#\n\n将大文件分成多个小块下载，减少单次请求的压力，并支持断点续传。\n\n步骤\n\n * 服务器将文件分片，前端通过多个请求下载分片。\n * 使用  Range  请求头指定下载范围。\n * 前端将分片合并为完整文件。\n\n代码示例#\n\n\n\n\n流式下载#\n\n使用流式 API（如  ReadableStream）逐步下载文件，避免内存占用过高。\n\n实现步骤：\n\n * 使用  fetch  获取响应流。\n * 通过  ReadableStream  逐步读取数据并写入文件。\n\n代码示例#\n\n\n\n\n断点续传（Resumable Download）#\n\n在网络中断后，从中断处继续下载，避免重新下载。\n\n实现步骤：\n\n * 记录已下载的字节范围。\n * 使用  Range  请求头从断点处继续下载。\n\n代码示例#\n\n\n\n\n其他优化#\n\n 1. Service Worker 缓存：通过 Service Worker 缓存大文件，提升后续加载速度。。\n 2. 显示下载进度：提升用户体验。","routePath":"/posts/front_end/large_file_upload","lang":"","toc":[{"text":"术语","id":"术语","depth":3,"charIndex":117},{"text":"切片上传","id":"切片上传","depth":2,"charIndex":150},{"text":"代码示例","id":"代码示例","depth":3,"charIndex":223},{"text":"优化","id":"优化","depth":3,"charIndex":233},{"text":"压缩文件","id":"压缩文件","depth":4,"charIndex":238},{"text":"并发上传","id":"并发上传","depth":4,"charIndex":298},{"text":"显示上传进度","id":"显示上传进度","depth":4,"charIndex":348},{"text":"主进程卡顿？","id":"主进程卡顿","depth":4,"charIndex":433},{"text":"实现用户关闭浏览器后重新打开，继续上传","id":"实现用户关闭浏览器后重新打开继续上传","depth":4,"charIndex":479},{"text":"下载","id":"下载","depth":2,"charIndex":597},{"text":"合并分片的文件","id":"合并分片的文件","depth":3,"charIndex":603},{"text":"代码示例","id":"代码示例-1","depth":4,"charIndex":719},{"text":"流式下载","id":"流式下载","depth":3,"charIndex":729},{"text":"代码示例","id":"代码示例-2","depth":4,"charIndex":846},{"text":"断点续传（Resumable Download）","id":"断点续传resumable-download","depth":3,"charIndex":856},{"text":"代码示例","id":"代码示例-3","depth":4,"charIndex":958},{"text":"其他优化","id":"其他优化","depth":3,"charIndex":968}],"domain":"","frontmatter":{"title":"大文件上传和下载问题","subtitle":"","date":"2025-03-17T05:17:45.000Z","lastmod":"2025-03-17T05:17:45.000Z","draft":false,"authors":null,"description":"","tags":["前端","大文件上传","JavaScript"],"categories":["在前端搬砖的日子里"],"series":["前端八股文基础"],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"https://img.dodolalorc.cn/i/2025/03/03/67c558f57d10e.png","featuredImagePreview":"https://img.dodolalorc.cn/i/2025/03/03/67c558f57d10e.png","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":64,"title":"JavaScript 链式调用 | 设计模式 笔记","content":"Vue :从 createApp 开始的链式调用#\n\n\n代码示例#\n\n\n\n\n解释#\n\ncreateApp:创建一个 Vue 应用实例。传入一个根组件配置对象，包含 data 和 methods。\n\n链式调用\n\n * .component(): 注册一个全局组件 MyButton，组件中定义了一个按钮，点击按钮时会触发 custom-click 事件。\n * .directive(): 注册一个全局指令 highlight，当元素挂载时，背景颜色会变为黄色。\n * .mixin(): 添加一个全局混入，在组件的 created 生命周期钩子中输出日志。\n * .mount(): 将应用挂载到 DOM 中，挂载点为 #app。\n\n事件绑定\n\n在 MyButton 组件中，通过 @click 绑定了一个点击事件，触发时会调用 handleClick 方法，并通过 $emit 触发\ncustom-click 事件。\n\n在父组件中，可以通过监听 custom-click 事件来处理按钮点击逻辑。\n\n\nuse 方法#\n\nuse  方法是 Vue 应用实例的一个方法，用于安装插件。插件可以是一个对象（必须提供  install  方法），也可以是一个函数（会被直接调用）。Vue\n会调用插件的  install  方法，并将 Vue 应用实例作为参数传递给它。\n\n语法#\n\n\n\n * plugin: 要安装的插件，可以是一个对象或函数。\n * options: 可选的配置对象，传递给插件的  install  方法。\n\n实现 use#\n\n 1. use 的逻辑\n\n\n\n 2. 使用\n\n\n\n\nPromise 中的链式调用#\n\n\n手写 Promise 方法#\n\nPromise A+规范#\n\nPromiseA+规范详细描述了 JavaScript 中 Promise 的行为标准，确保不同的 Promise 实现可以相互兼容。\n\n术语#\n\npromise：先是一个对象或函数，其具有，然后是方法，其行为符合本规范。 thenable：先用一个具有，再用方法的对象或函数。\nvalue：任何合法的脚本值(包括未定义，一个已启用，或一个 Promise)。 exception：一个使用抛出语句抛出的值。 reason：一个表示\nPromise 被拒绝的原因\n\n要求#\n\nPromise 状态\n\n一个 promise 必须处于以下三种状态之一：pending(等待态），fulfilled(执行态)，或 rejected(拒绝态)。\n\npending：可以迁移到 fulfilled 或 rejected 状态。 fulfilled：不可迁移到其他状态，必须有一个 value。\nrejected：不可迁移到其他状态，必须有一个 reason。\n\nthen 方法 一个 promise 必须提供一个 then 方法来访问其当前或最终的 value 或 reason。\npromise.then(onFulfilled, onRejected)\n\n * onFulfilled 和 onRejected 都是可选参数。\n * 如果 onFulfilled 不是函数，必须忽略它。\n * 如果 onRejected 不是函数，必须忽略它。\n\nonFulfilled 的执行\n\n * onFulfilled 必须在 promise 完成后被调用，且 promise 的 value 作为其第一个参数。\n * onFulfilled 不得在 promise 完成前被调用。\n * onFulfilled 必须只被调用一次。\n\nonRejected 的执行\n\n * onRejected 必须在 promise 被拒绝后被调用，且 promise 的 reason 作为其第一个参数。\n * onRejected 不得在 promise 被拒绝前被调用。\n * onRejected 必须只被调用一次。\n\nthen 方法必须返回一个 promise\n\n\n\npromise2 必须是一个新的 promise。\n\n处理返回的值\n\n * 如果 onFulfilled 或 onRejected 返回一个值，则运行 Promise 解决程序Resolve(promise2, x)。\n * 如果 onFulfilled 或 onRejected 抛出一个异常，则 promise2 必须以作为拒绝原因。\n * 如果 onFulfilled 不是一个函数且 promise1 完成，promise2 必须以 promise1 的 value 作为其 value。\n * 如果 onRejected 不是一个函数且 promise1 被拒绝，promise2 必须以 promise1 的 reason 作为其 reason。\n\n代码示例#\n\n\n\n\n实现链式调用#\n\n\n例题#\n\n限制用 JavaScript 实现：\n\n\n\n\n代码#\n\n\n\n\n发布订阅模式 vs 观察者模式#\n\n发布-订阅模式（Pub-Sub）和观察者模式（Observer）是两种常见的设计模式，它们都用于处理对象之间的通信和事件处理。\n\n\n观察者模式（Observer Pattern）#\n\n观察者模式定义了一种一对多的依赖关系，当一个对象（称为Subject，主题）的状态发生变化时，所有依赖于它的对象（称为Observers，观察者）都会收到通知并\n自动更新。\n\nSubject\n\n * 维护一个观察者列表。\n * 提供注册（attach）和注销（detach）观察者的方法。\n * 在状态变化时通知所有观察者（notify）。\n\nObserver（观察者）\n\n * 定义一个更新接口（update），用于接收主题的通知。\n\n代码示例#\n\n\n\n\n发布-订阅模式（Pub-Sub Pattern）#\n\n发布-订阅模式通过一个事件中心（Event\nBus）来解耦发布者和订阅者。发布者将消息发布到事件中心，订阅者从事件中心订阅感兴趣的消息。发布者和订阅者之间没有直接的依赖关系。\n\n关键角色#\n\nPublisher（发布者）： 负责发布消息到事件中心。\n\nSubscriber（订阅者）： 向事件中心订阅感兴趣的消息。\n\nEvent Bus（事件中心）：维护一个消息队列和订阅者列表；负责将消息分发给订阅者。\n\n代码示例#\n\n\n\n\n主要区别#\n\n特性      观察者模式                       发布-订阅模式\n通信方式    直接通信（主题直接通知观察者）             间接通信（通过事件中心）\n耦合度     强耦合（观察者和主题直接关联）             松耦合（发布者和订阅者解耦）\n角色      主题（Subject）和观察者（Observer）   发布者（Publisher）、订阅者（Subscriber）、事件中心（Event Bus）\n适用场景    简单的对象间通信                    复杂的系统，需要解耦的场景\n实现复杂度   简单                          相对复杂\n同步/异步   通常是同步的                      可以是异步的\n\n应用#\n\n观察者模式#\n\n * GUI 框架中的事件处理（如按钮点击事件）。\n * 数据模型和视图之间的绑定（如 MVC 模式）。\n * 简单的对象间通信场景。\n\n发布-订阅模式#\n\n * 消息队列系统（如 RabbitMQ、Kafka）。\n * 事件驱动架构（如 Node.js 的 EventEmitter）。\n * 需要解耦的复杂系统（如微服务之间的通信）。","routePath":"/posts/front_end/method_chaining","lang":"","toc":[{"text":"Vue :从 createApp 开始的链式调用","id":"vue-从-createapp-开始的链式调用","depth":2,"charIndex":-1},{"text":"代码示例","id":"代码示例","depth":3,"charIndex":27},{"text":"解释","id":"解释","depth":3,"charIndex":37},{"text":"use 方法","id":"use-方法","depth":3,"charIndex":451},{"text":"语法","id":"语法","depth":4,"charIndex":582},{"text":"实现 use","id":"实现-use","depth":4,"charIndex":661},{"text":"Promise 中的链式调用","id":"promise-中的链式调用","depth":2,"charIndex":696},{"text":"手写 Promise 方法","id":"手写-promise-方法","depth":3,"charIndex":714},{"text":"Promise A+规范","id":"promise-a规范","depth":4,"charIndex":730},{"text":"代码示例","id":"代码示例-1","depth":4,"charIndex":2001},{"text":"实现链式调用","id":"实现链式调用","depth":2,"charIndex":2011},{"text":"例题","id":"例题","depth":3,"charIndex":2021},{"text":"代码","id":"代码","depth":3,"charIndex":2049},{"text":"发布订阅模式 vs 观察者模式","id":"发布订阅模式-vs-观察者模式","depth":2,"charIndex":2057},{"text":"**观察者模式（Observer Pattern）**","id":"观察者模式observer-pattern","depth":3,"charIndex":-1},{"text":"代码示例","id":"代码示例-2","depth":4,"charIndex":2386},{"text":"**发布-订阅模式（Pub-Sub Pattern）**","id":"发布-订阅模式pub-sub-pattern","depth":3,"charIndex":-1},{"text":"关键角色","id":"关键角色","depth":4,"charIndex":2512},{"text":"代码示例","id":"代码示例-3","depth":4,"charIndex":2627},{"text":"主要区别","id":"主要区别","depth":3,"charIndex":2637},{"text":"应用","id":"应用","depth":4,"charIndex":3006}],"domain":"","frontmatter":{"title":"JavaScript 链式调用 | 设计模式 笔记","subtitle":"","date":"2025-03-17T01:26:02.000Z","lastmod":"2025-03-17T01:26:02.000Z","draft":false,"authors":null,"description":null,"tags":["前端","链式调用","JavaScript"],"categories":["在前端搬砖的日子里"],"series":["前端八股文基础"],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"https://img.dodolalorc.cn/i/2025/03/03/67c55994138f8.jpg","featuredImagePreview":"https://img.dodolalorc.cn/i/2025/03/03/67c55994138f8.jpg","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":65,"title":"MutationObserver学习+实践","content":"> 一篇学习 MutationObserver 的文章\n\n\n背景#\n\n今天调整新主题的时候，在重新设计友链样式的时候想保留原本的随机背景颜色，之前数量少的时候似乎不太明显，现在本地测试发觉加载太慢了。于是上网寻找解决思路，找到了\nMutationObserver 这个 API，于是就学习了一下//此处记录一下学习过程。\n\n\n需求分析#\n\n我有不知数量的div元素，每个div元素都有一个class名为friend-link-div，我需要在每个单个的div元素被加载完成的同时，对它设置一个随机的背\n景颜色。而不是等待整个页面或窗口加载完毕\n\n\n想法分析#\n\n\nwindow.onload和'DOMContentLoaded'的问题#\n\n原本的实现代码：\n\n\n\n原本的思路就是简单的在页面加载完成后，获取所有的友链元素，然后给每个元素设置一个随机的背景颜色。但是这样的实现方式有一个问题，就是当友链数量较多的时候，会导致页\n面加载变慢，因为每次都要重新计算随机颜色，并且在等待本页面加载的时候，友链的背景颜色是白色的，这样会导致页面的视觉体验不好。\n\n在网上询问得到的另一个思路是用document.addEventListener('DOMContentLoaded', function()\n{})，但是这个方法也是等待整个页面加载完毕后才会执行，观察发现还是挺慢的...所以也不适合。\n\n\n仅利用CSS实现随机色彩的思路#\n\n还有一个仅利用CSS实现随机色彩的思路，该思路是在CSS中定义一个颜色数组，然后通过nth-child选择器来实现，但是这样的实现方式有一个问题，就是颜色的数量\n是固定的，而且颜色的选择是有规律的，不是真正的随机颜色。\n\n不过还是展示一下如何伪随机实现：\n\n\n\n搭配scss的话可以这样写：\n\n\n\n于是放弃window.onload和'DOMContentLoaded'，以及CSS的伪随机实现方法。改用 MutationObserver 来实现。\n\n\n解决思路#\n\n使用MutationObserver\nAPI来观察DOM的变化，并在新的盒子被添加到DOM中时应用背景色更改。这样，每当有新的盒子被添加到页面上时，你就可以立即更改它的背景，而不需要等待其他内容加载\n完成。\n\n\n代码#\n\n\n\n\n关于用于hugo主题的一些Tips#\n\n有的时候DOM初始化时已经存在一些盒子，因此我们需要在初始化时为这些盒子设置随机背景色。然后，我们创建一个MutationObserver实例，并配置它以观察D\nOM树中的子节点添加。最后，我们选择要观察变化的DOM节点（在这个例子中是body，但你可以根据需要更改），并启动观察。\n\n假如直接将js插入到friend.html中，打开控制台会发现该段js被渲染了好多次，这是因为hugo的模板渲染机制导致的，所以我们需要将js放在整个大页面的j\ns中，这样就不会出现重复渲染的问题了。\n\n一个合适的地方是在layouts/partials/footer.html中，这样就可以保证在整个页面加载完毯后再执行这段js。\n\n不过直接放在footer.html中也会有一个问题，就是我们只需要在友链页面加载这段js，而不是每个页面都加载，所以我们可以在footer.html中加入一个判\n断条件，判断当前页面是否是友链页面，如果是则加载这段js。\n\n可以在content/links.md中加入一个isLink字段，然后在footer.html中判断是否为友链页面，如果是则加载这段js。\n\n\n\n假如不想每次都把新增的js直接写在footer.html等地方中，可以在static/js/文件夹下新建一个js文件，然后在footer.html中引入这个js\n文件。\n\n\n\n另注：githubPage是jekyll模板似乎不能识别下划线开头的文件，所以有需要的话可以把_extended改成其他名字。\n\n完成！现在，每当新的friend-link-div盒子被添加到DOM中时，它的背景颜色将立即更改为随机颜色。 可以在本站的友链页面查看效果：友链","routePath":"/posts/front_end/mutationObserver","lang":"","toc":[{"text":"背景","id":"背景","depth":2,"charIndex":29},{"text":"需求分析","id":"需求分析","depth":2,"charIndex":162},{"text":"想法分析","id":"想法分析","depth":2,"charIndex":273},{"text":"`window.onload`和`'DOMContentLoaded'`的问题","id":"windowonload和domcontentloaded的问题","depth":3,"charIndex":-1},{"text":"仅利用CSS实现随机色彩的思路","id":"仅利用css实现随机色彩的思路","depth":3,"charIndex":598},{"text":"解决思路","id":"解决思路","depth":2,"charIndex":843},{"text":"代码","id":"代码","depth":3,"charIndex":956},{"text":"关于用于hugo主题的一些Tips","id":"关于用于hugo主题的一些tips","depth":3,"charIndex":964}],"domain":"","frontmatter":{"title":"MutationObserver学习+实践","subtitle":"","date":"2024-07-04T08:31:24.000Z","lastmod":"2024-07-04T08:31:24.000Z","draft":false,"authors":[],"description":"","tags":["前端","JavaScript"],"categories":["在前端搬砖的日子里","关于Hugo的一些设置"],"series":[],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"","featuredImagePreview":"","toc":{"enable":true},"math":{"enable":false},"lightgallery":false,"license":""},"version":""},{"id":66,"title":"怎么做一个准确的倒计时 | Javascript 单线程","content":"TODO","routePath":"/posts/front_end/timeout","lang":"","toc":[],"domain":"","frontmatter":{"title":"怎么做一个准确的倒计时 | Javascript 单线程","subtitle":"","date":"2025-03-17T06:26:20.000Z","lastmod":"2025-03-17T06:26:20.000Z","draft":true,"authors":null,"description":"","tags":null,"categories":null,"series":null,"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"","featuredImagePreview":"","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":67,"title":"Vue3封装一个SVG组件","content":"Vue3+Vite+Svg#\n\n以前使用Svg的时候会图简单直接将内容巨长的Svg代码粘贴在项目中，结果导致需要用Svg图标的部分代码巨长，今天写项目又需要使用Svg了，于是想着对其进行封装。\n\n\n插件安装#\n\n使用vite-plugin-svg-icons插件。\n\n安装：\n\n\n\n在src/assets/下新建icon文件夹，这个文件夹下存放我们以后要用的.svg文件。\n\n\n配置vite.config.ts#\n\n\n\n\n在main.ts中加入：#\n\n\n\n\n封装SvgIcon组件#\n\n在src/components/新建SvgIcon文件夹，在其中新建index.vue，内容：\n\n\n\n之后就能在页面使用svg啦。\n\n","routePath":"/posts/front_end/vue_svgicon","lang":"","toc":[{"text":"插件安装","id":"插件安装","depth":2,"charIndex":98},{"text":"配置`vite.config.ts`","id":"配置viteconfigts","depth":3,"charIndex":-1},{"text":"在`main.ts`中加入：","id":"在maints中加入","depth":3,"charIndex":-1},{"text":"封装`SvgIcon`组件","id":"封装svgicon组件","depth":3,"charIndex":-1}],"domain":"","frontmatter":{"title":"Vue3封装一个SVG组件","subtitle":"","date":"2024-03-23T07:24:28.000Z","lastmod":"2024-03-23T07:24:28.000Z","draft":true,"authors":null,"description":"","tags":["Vue","Vite","Svg","组件","前端"],"categories":"在前端搬砖的日子里","series":null,"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"","featuredImagePreview":"","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":68,"title":"一个Vue项目的基础模板 PC端+移动端适配","content":"创建项目#\n\n\n\n转到根目录下后\n\n\n规范目录#\n\n\n\n\npath 模板+代理#\n\n在vite.config.ts中，设置@指向src、服务器启动端口、打包路径、代理等等设置\n\n先进行 path 模板的安装：\n\n\n\n如果需要使用代理的话，可以先下载：\n\n\n\n或者这个：\n\n\n\n这两个二选一即可\n\n\n集成工具#\n\n\nVue Router 4.x#\n\n\n\n\n集成状态管理工具 Pinia#\n\n\n\n\nAxios#\n\n\n\n\nCSS 预编译器 Stylus/Sass/Less#\n\n使用 CSS 预编译器 Stylus\n\n安装(按序选择就好)\n\n\n\n\n自动引入插件#\n\n通过插件 unplugin-vue-components 和 unplugin-auto-import 实现组件自动按需导入（推荐！）\n\n\n\n\n移动端适配#\n\n\npostcss 插件#\n\n\n\npostcss.config.ts\n\n\n\n组件库设计基于 375px 宽度设计稿，推荐使用 postcss 插件将 px 单位转换成 vmin 单位从而实现移动端适配。 在 webpack/vite\n项目根路径下创建 postcss.config.js 并做如下配置之后 375px -> 100vmin。\n\n\n桌面端适配#\n\n\n\n\n组件库#\n\n\nElement Plus#\n\n\n\n\nvarlet#\n\n\n\nVsCode 插件市场搜索： varlet-vscode-extension。\n\n\nArco.design#\n\n\n\n\nNaive UI#\n\n\n\n\n配置文件示例#\n\ntsconfig.json#\n\n\n\ntsconfig.node.json#\n\n\n\nvite.config.ts#\n\n\n\npostcss.config.ts#\n\n\n\npackage.json#\n\n\n\nvite-env.d.ts#\n\n\n\nmain.ts#\n\n","routePath":"/posts/front_end/vuemod","lang":"","toc":[{"text":"创建项目","id":"创建项目","depth":2,"charIndex":-1},{"text":"规范目录","id":"规范目录","depth":3,"charIndex":18},{"text":"path 模板+代理","id":"path-模板代理","depth":2,"charIndex":28},{"text":"集成工具","id":"集成工具","depth":2,"charIndex":148},{"text":"Vue Router 4.x","id":"vue-router-4x","depth":3,"charIndex":156},{"text":"集成状态管理工具 Pinia","id":"集成状态管理工具-pinia","depth":3,"charIndex":176},{"text":"Axios","id":"axios","depth":2,"charIndex":196},{"text":"CSS 预编译器 Stylus/Sass/Less","id":"css-预编译器-stylussassless","depth":3,"charIndex":207},{"text":"自动引入插件","id":"自动引入插件","depth":2,"charIndex":270},{"text":"移动端适配","id":"移动端适配","depth":2,"charIndex":351},{"text":"postcss 插件","id":"postcss-插件","depth":3,"charIndex":360},{"text":"桌面端适配","id":"桌面端适配","depth":2,"charIndex":531},{"text":"组件库","id":"组件库","depth":2,"charIndex":542},{"text":"Element Plus","id":"element-plus","depth":3,"charIndex":549},{"text":"varlet","id":"varlet","depth":3,"charIndex":567},{"text":"Arco.design","id":"arcodesign","depth":3,"charIndex":620},{"text":"Naive UI","id":"naive-ui","depth":3,"charIndex":637},{"text":"配置文件示例","id":"配置文件示例","depth":2,"charIndex":651},{"text":"tsconfig.json","id":"tsconfigjson","depth":4,"charIndex":660},{"text":"tsconfig.node.json","id":"tsconfignodejson","depth":4,"charIndex":678},{"text":"vite.config.ts","id":"viteconfigts","depth":4,"charIndex":701},{"text":"postcss.config.ts","id":"postcssconfigts","depth":4,"charIndex":720},{"text":"package.json","id":"packagejson","depth":4,"charIndex":742},{"text":"vite-env.d.ts","id":"vite-envdts","depth":4,"charIndex":759},{"text":"main.ts","id":"maints","depth":4,"charIndex":777}],"domain":"","frontmatter":{"title":"一个Vue项目的基础模板 PC端+移动端适配","subtitle":"","date":"2024-03-10T09:14:08.000Z","lastmod":"2024-03-10T09:14:08.000Z","draft":true,"authors":null,"description":"","tags":["Vue","前端","Vite","CSS","JavaScript","组件"],"categories":"在前端搬砖的日子里","series":null,"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"","featuredImagePreview":"","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":69,"title":"所有文章","content":"记录一些学习笔记和技术文章。","routePath":"/posts/","lang":"","toc":[],"domain":"","frontmatter":{"overview":true,"title":"所有文章"},"version":""},{"id":70,"title":"Rust编程区块链项目 BlockChain in Rust","content":"一、产品方案#\n\n\n项目目标#\n\n实现一个轻量的简单高效的区块链系统项目，用于学习和研究。\n\n * 学习区块链的相关知识，实现一个由 Rust 实现的简单区块链系统。\n * 能够生成创世区块，支持区块的创建、验证和链式储存，实现工作量证明算法。\n * 利用本机端口构建服务系统，实现交易的广播、挖矿功能、简单的交易校验功能。\n\n\n用户需求分析#\n\n * 用户可以通过命令行启动本地服务，在main.rs中配置路由，参考下方的使用手册，进行创建交易、挖矿、查看信息等。\n * 通过时间戳、lock_time、签名校验等完成简单的对交易信息的核对。\n * 系统具有一定的可扩展性，用户可以通过调整 API 接口快速调试。\n\n\n主要功能#\n\n本产品主要由src/下的.rs文件实现主要功能。\n\n设计了区块链和区块的数据结构，并完成了简单的新建区块、新建区块链以及设置创世区块、添加交易到交易池、挖矿打包交易、交易广播、计算 Merkle 树根哈希等功能。\n\n设计了一条交易信息的各种数据结构，包括其交易输入、交易输出、锁定时间，还实现了签名交易和广播行为。\n\n\n二、技术方案#\n\n\n技术选型#\n\n * 编程语言：Rust（高性能、内存安全、适合区块链开发）。\n * 数据序列化：使用  serde  和  serde_json  进行完成序列化。\n * 时间戳：使用chrono获取当前时间。\n * 哈希算法：通过sha2库的 SHA-256 计算哈希值。\n * 加密算法：使用 Rust 的加密库ring实现哈希、签名等功能。\n * 共识算法：实现 PoW（工作量证明）共识机制。\n * 网络通信：使用 Rust 的异步网络库Tokio实现 P2P 通信。\n\n\n模块划分#\n\n * 区块模块：区块的创建、验证和链式存储。\n * 交易模块：交易的创建、签名和验证。\n * 网络模块：节点发现、消息广播和数据同步。\n * 共识模块：实现共识算法。\n * 存储模块：数据持久化存储。\n\nmain.rs：定义了创建节点、消息广播等功能的网络模块。\n\nblock_chain.rs：定义了区块链和区块的数据结构，并完成了简单的新建区块、新建区块链以及设置创世区块、添加交易到交易池、挖矿打包交易、交易广播、计算\nMerkle 树根哈希等功能。\n\nhash_function.rs：主要定义了常用的哈希函数。\n\nserialization.rs：定义了序列化和反序列化的方法。\n\ntransaction.rs：定义了一条交易信息的各种数据结构，包括其交易输入、交易输出、锁定时间，还实现了签名交易和广播行为。\n\n\n系统结构#\n\n区块链结构#\n\n区块链的核心是由一系列按顺序链接的区块组成的链式结构。每个区块包含以下关键信息：\n\n * 时间戳（timestamp）：区块创建的时间。\n * 哈希值（merkle_root）：当前区块的唯一标识，通过加密算法生成。\n * 前一区块哈希（prev_block_hash）：指向前一个区块的哈希值，用于维护链的连续性。\n\n在实现中，区块链可以通过一个动态数组（ Vec<Block>）来存储所有区块，确保区块的顺序和完整性。\n\n创世区块#\n\n创世区块是区块链中的第一个区块，它的生成标志着区块链的初始化。创世区块的特点包括：\n\n * 前一区块哈希为空：由于没有前驱区块，其前一区块哈希值通常设置为空或特定标识（如 \"0\"）。\n * 哈希值计算：根据区块的内容（索引、时间戳、前一区块哈希和数据）生成唯一的哈希值，并存储到区块中。\n\n创世区块的生成是区块链启动的必要步骤，为后续区块的添加奠定基础。\n\n挖矿算法#\n\n挖矿是区块链中生成新区块的关键过程，其核心是通过计算找到一个满足特定条件的哈希值。具体实现如下：\n\n 1. 难度目标：设定一个哈希值的难度条件（例如，哈希值的前几位必须为 \"0\"）。\n 2. 随机数（Nonce）：通过不断尝试不同的随机数，结合区块的其他信息（索引、时间戳、前一区块哈希和数据），计算哈希值。\n 3. 哈希验证：检查生成的哈希值是否满足难度条件。如果满足，则挖矿成功；否则，继续尝试新的随机数。\n\n挖矿算法的实现确保了区块链的安全性和去中心化特性，同时也为新区块的生成提供了动力。\n\n以上设计使得区块链系统能够实现基础的区块的创建、链接和验证，同时通过挖矿算法保证网络的共识和安全。\n\n\n三、使用手册#\n\n拉取本项目\n\n\n\n启动项目，开启本地服务器\n\n\n\n本地服务器接口使用：\n\n * 添加交易\n\n\n\n * 查看交易池\n\n\n\n * 查看区块链区块部分\n\n\n\n * 挖矿\n\n\n\n\n实验截图#\n\n建立交易及交易池状态\n\n\n\n挖矿\n\n\n\n\n四、项目要求#\n\n一：计划\n\n 1. 完成概念学习：区块链\n 2. 完成需求设计：产品方案、技术方案\n 3. 完成项目实现：Rust 实现，至少输出创世区块\n\n二：要求\n\n 1. 结合下面给的和自己搜索到的参考资料、书籍、视频等学习区块链基础知识\n 2. 结合个人兴趣和所学内容，自己确定一个区块链领域的项目目标（如，实现基本的挖矿）\n 3. 有了目标，自己学习怎么写产品方案、技术方案、可以多人组队研究\n 4. 基于产品方案和技术方案实现你的需求，要结合之前讲的数据结构和算法内容\n\n注意：至少是实现一个简单的区块链，运行并输出创世区块\n\n三：参考资料\n\n 1. 区块链教程 https://liaoxuefeng.com/books/blockchain/introduction/index.html\n 2. 区块链学习路线 https://zjubca.github.io/roadmap/\n 3. go 实现的 demo https://github.com/Jeiwan/blockchain_go\n 4. B 站区块链项目实战\n    https://www.bilibili.com/video/BV145411t7qp/?vd_source=ca616b8d8161186b30bdd\n    62e4e044e42\n\n","routePath":"/posts/rust/block_chain","lang":"","toc":[{"text":"一、产品方案","id":"一产品方案","depth":2,"charIndex":-1},{"text":"项目目标","id":"项目目标","depth":3,"charIndex":9},{"text":"用户需求分析","id":"用户需求分析","depth":3,"charIndex":164},{"text":"主要功能","id":"主要功能","depth":3,"charIndex":310},{"text":"二、技术方案","id":"二技术方案","depth":2,"charIndex":477},{"text":"技术选型","id":"技术选型","depth":3,"charIndex":487},{"text":"模块划分","id":"模块划分","depth":3,"charIndex":728},{"text":"系统结构","id":"系统结构","depth":3,"charIndex":1098},{"text":"区块链结构","id":"区块链结构","depth":4,"charIndex":1105},{"text":"创世区块","id":"创世区块","depth":4,"charIndex":1326},{"text":"挖矿算法","id":"挖矿算法","depth":4,"charIndex":1512},{"text":"三、使用手册","id":"三使用手册","depth":2,"charIndex":1821},{"text":"实验截图","id":"实验截图","depth":3,"charIndex":1916},{"text":"四、项目要求","id":"四项目要求","depth":2,"charIndex":1944}],"domain":"","frontmatter":{"title":"Rust编程区块链项目 BlockChain in Rust","subtitle":"","date":"2025-03-03T07:20:51.000Z","lastmod":"2025-03-03T07:20:51.000Z","draft":false,"authors":null,"description":null,"tags":["Rust","区块链"],"categories":["Rust 低手的垃圾桶"],"series":["Rust 学习中"],"hiddenFromHomePage":false,"hiddenFromSearch":false,"featuredImage":"https://img.dodolalorc.cn/i/2025/03/03/67c559ab9df13.jpg","featuredImagePreview":"https://img.dodolalorc.cn/i/2025/03/03/67c559ab9df13.jpg","toc":{"enable":true},"math":{"enable":true},"lightgallery":false,"license":""},"version":""},{"id":71,"title":"引入js文件","content":"今天摸鱼把网站的点击特效做了QwQ，选用的效果是烟花（/逆飞的流星🎆🎆，主要摸索了如何在Hugo里添加JavaScript代码\n\n\n添加js文件#\n\n这次用到的两个js文件在这里：\n\nanime.min.js\n\nfireworks.js\n\n在./static/下新建一个js文件夹，文件夹下新建两个js文件，命名为anime.min.js和fireworks.js，然后将上面两个文件的内容粘贴进去。\n\n\n引入js文件#\n\n在./layouts/partials/extend_head.html中添加如下代码：\n\n","routePath":"/posts/startsite/beautify_site_click","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":72,"title":"`css`文件：","content":"增加了一个鼠标追尾的效果 QwQ\n\n添加文件的方式参考上一篇~指路这篇\n\n\njs文件：#\n\npointerfollow.js\n\njs 原文件来源：Canva's Magic Mouse Effect (codepen.io)\n\n（我有稍微改了一些样式 qwq，写在代码里了。\n\n\ncss文件：#\n\n","routePath":"/posts/startsite/beautify_site_clickfollow","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":73,"title":"","content":"简单设计#\n\nassets/css/common/terms.css添加：\n\n\n\n\n添加权重#\n\n在./layouts/_default/terms.html中，找到这段代码并在a标签插入data-weight属性\n\n\n\n\n字体大小按权重显示#\n\nassets/css/common/terms.css中设计：\n\n\n\n\ncss伪随机字体色彩#\n\nassets/css/common/terms.css中\n\n\n\n当然了也可以在js里搓qwq，可以参考这篇","routePath":"/posts/startsite/beautify_site_tags","lang":"","toc":[{"text":"简单设计","id":"简单设计","depth":2,"charIndex":-1},{"text":"添加权重","id":"添加权重","depth":2,"charIndex":41},{"text":"字体大小按权重显示","id":"字体大小按权重显示","depth":2,"charIndex":111},{"text":"css伪随机字体色彩","id":"css伪随机字体色彩","depth":2,"charIndex":159}],"domain":"","frontmatter":{},"version":""},{"id":74,"title":"","content":"> 一篇私有配置图床，给 twikoo 评论插件添加图片功能的文章。\n\n\n背景#\n\n背景：最近回想起来本站的 twikoo 评论尚未配置过图床，所以此前评论区不能上传图片，这篇就记录一下 twikoo 官方推荐的 lsky-pro\n私有部署图床。\n\n选用的图床是兰空图床 👉lsky-org/lsky-pro: ☁️ 兰空图床(Lsky Pro) - Your photo album on the\ncloud. (github.com)\n\n文档：Lsky Pro\n\n服务器环境：\n\n * 宝塔面板 8.0.6\n * PHP 8.0.26\n * MySQL 5.7.43\n * Nginx 1.22.1\n\n要注意版本哦(\n\n\n添加站点#\n\n进入宝塔后，在左侧网站导航页内点击添加站点，新建一个网站，配置如图：\n\n\n\n\n配置站点#\n\n在Releases · lsky-org/lsky-pro\n(github.com)选择Assets中的第一个.zip下载下来。定位到上述创建的站点的根目录(/www/wwwroot/img.dodolalorc.cn)\n下，将解压后的文件放在该目录下。\n\n将程序所在目录的所有文件夹、子文件夹、文件的权限，用户组和所有者改为 www，权限改为 0755\n\n回到网站导航页，点击刚刚创建的站点，进行如下修改：\n\n * 网站目录下，将网站目录中的路径后添加/public，并保存\n\n * Nginx 需要设置伪静态，点击伪静态，添加如下代码并保存：\n   \n   \n\n * 在 SSL 中，申请Let's Encrypt证书，申请成功并安装保存之后，在证书页开启强制HTTPS\n\n\nPHP 扩展+禁用函数#\n\n根据文档所提示的安装要求，我们需要添加两个扩展：Fileinfo PHP 扩展和Imagick 拓展。\n\n在宝塔软件商店内搜索使用的 PHP，点击管理，在安装扩展中选择下载 fileinfo 和 imagemagick 扩展。\n\n在禁用函数页面，删除 exec、shell_exec、readlink、symlink、putenv、getenv、chmod、chown、fileperms\n函数。\n\n若由于可用内存小于 1G，没有安装上 fileinfo，可以在软件商店搜索找到 Linux 工具箱，在工具箱中的Swap/虚拟内存中添加 Swap，设置为\n1024MB 并确定，重试即可。\n\n\n安装程序#\n\n在完成上述内容后，访问站点，显示符合要求之后，点击下一步，填写配置后进行安装。\n\n\n获取 token#\n\n在站点的仪表盘页，点击接口，复制接口 URL。\n\n在这个网站Getman.cn，按照这个格式填写：\n\n\n\n\n\n\n配置 Twikoo#\n\n获取到 token 后，在 twikoo 管理页，IMAGE_CDN 配置图床首页 URL\n地址（注意不要加尾随斜杠），IMAGE_CDN_TOKEN填入刚刚获取的 token。\n\n保存后，即可上传图片。","routePath":"/posts/startsite/twikoo_with_imgs","lang":"","toc":[{"text":"背景","id":"背景","depth":2,"charIndex":36},{"text":"添加站点","id":"添加站点","depth":2,"charIndex":313},{"text":"配置站点","id":"配置站点","depth":2,"charIndex":359},{"text":"PHP 扩展+禁用函数","id":"php-扩展禁用函数","depth":2,"charIndex":706},{"text":"安装程序","id":"安装程序","depth":2,"charIndex":1017},{"text":"获取 token","id":"获取-token","depth":2,"charIndex":1066},{"text":"配置 Twikoo","id":"配置-twikoo","depth":2,"charIndex":1133}],"domain":"","frontmatter":{},"version":""},{"id":75,"title":"友链制作","content":"使用场景：\n\n\n\n效果：","routePath":"/projects/friendlink","lang":"","toc":[],"domain":"","frontmatter":{"title":"友链制作"},"version":""},{"id":76,"title":"","content":"","routePath":"/projects/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""}]